(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function() {
  //Do not do anything if there is no support of ECMAScript 5
  if (typeof [].forEach !== 'function') {
    require("es5-shim");
    require("es5-shim/es5-sham");
  }

	var metrics = require("tick42-metrics");
	var agm = require("tick42-agm");
	var gatewayConnection = require("tick42-gateway-connection");
	var logger = require("tick42-logger");
	var appconfig = require("tick42-appconfig/src/js/appconfig");
	var windows = require("tick42-windows");
	var appManager = require("tick42-app-manager");
	var activity = require("tick42-activity");

  //Do not do anything if the user turned off the auto initialization
	if (window.glue_auto_initialize === false) {
		return;
	}

  //Init the GLUE namespace
	var glue = {};
	glue.version = "2.3.0";
	//Base configurations. Later they are updated depending on the runtime.
	var loggerConfiguration = {identity: {system: "Tick42"}};
	var metricsConfiguration = {identity: {system: "Tick42"}};
	var agmConfiguration = {instance: {}, server: {presence_interval: 3000}};

	//Here we will store a reference to the connection with the Service Provider
	glue.connection = undefined;
	var app_name;

	//If we are running in an HTML Container, use the HTML Container environment variables
	if (window.htmlContainer !== undefined) {
		//Generate AGM app name
		app_name = window.agm_application || window.htmlContainer.containerName + "." + window.htmlContainer.browserWindowName;

		//Fill logger configurations with custom properties
		agmConfiguration.instance.application = app_name;
		loggerConfiguration.identity.system = "HtmlContainer." + window.htmlContainer.containerName;
		loggerConfiguration.identity.service = "JS." + window.htmlContainer.browserWindowName;
		loggerConfiguration.identity.instance = "~" + window.htmlContainer.machineName;

		if (window.htmlContainer.appConfigFacade !== undefined && window.htmlContainer.appConfigFacade.config !== undefined) {
			// Initialize AppConfig
			glue.appconfig = appconfig();
			glue.appconfig.init(function () {
				function supplant(template) {
					return template.replace(/\{([^{}]*)\}/g, function (match, key) {
						var value = this;
						key.split('.').forEach(function (part) {
							if (value) {
								value = value[part];
							}
						});
						return typeof value === 'string' || typeof value === 'number' ? value : match;
					});
				}

				var settings = window.htmlContainer.appConfigFacade.config;
				var identity = {};
				Object.keys(settings.identity).forEach(function (key) {
					var value = supplant(settings.identity[key]);
					identity[key] = value;
				});
				settings.identity = identity;
				return settings;
			}());
		}

		//Init the Connection
		glue.connection = gatewayConnection();

		//If we are running in normal browser, connect via Websocket
	} else {
    var connection_config = {};
    var uid_prefix;

    if (typeof window.WebSocket !== 'function') {
      // if no support for WebSocket use HTTP
      uid_prefix = "HTTP";
      // don't make insecure requests from secure env
      var default_http_url = window.location.protocol === 'http:' ? "http://localhost:22037" : "https://localhost:22037";
      connection_config.http_url = window.glue_http_url || default_http_url;
    } else {
      uid_prefix = "WS";
      //Websocket URL (this is the default that is used in the demo WS server)
      var default_ws_url = window.location.protocol === 'http:' ? "ws://localhost:22037" : "wss://localhost:22037";
      connection_config.websocket_url = window.glue_ws_url || default_ws_url;
    }

    //Generate application UID to allow for the same application to be called multiple times.
    var uid = uid_prefix + Math.floor(1e10 * Math.random());

    //Generate AGM app name
		app_name = window.agm_application || document.title + uid;

		//Fill configurations with custom properties
		agmConfiguration.instance.application = app_name;
		loggerConfiguration.identity.system = "Browser";
		loggerConfiguration.identity.service = document.title || 'unknown';
		loggerConfiguration.identity.instance = "~" + uid;

		// Init the Connection and specify the URL of the Web Socket server that we are connecting to.
		glue.connection = gatewayConnection(connection_config);
	}

	//Place the Connection, as part of the components' configuration
	loggerConfiguration.connection = glue.connection;
	metricsConfiguration.connection = glue.connection;
	agmConfiguration.connection = glue.connection;

	//Override some props with environment variables, if provided
	loggerConfiguration.identity.system = window.glue_metric_system || loggerConfiguration.identity.system;
	loggerConfiguration.identity.service = window.glue_metric_service || loggerConfiguration.identity.service;
	loggerConfiguration.identity.instance = window.glue_metric_instance || loggerConfiguration.identity.instance;

	//Initialize Logger (uses the same configuration as Metrics)
	glue.logger = logger(loggerConfiguration);

	//Fill metrics configuration with the same properties as metrics configurations
	metricsConfiguration.identity = loggerConfiguration.identity;
	metricsConfiguration.logger = glue.logger.subLogger("metrics");

	//Initialize Metrics and save into the 'glue' global variable
	glue.metrics = metrics(metricsConfiguration).subSystem("App");

	//Initialize the metrics system in the logger's "metrics_level" method
	glue.logger.metricsLevel("warn", glue.metrics.parent.subSystem("LogEvents"));

	agmConfiguration.instance.application = window.glue_agm_application || agmConfiguration.instance.application;

	//Include the metric repo in the AGM configuration (so that AGM can broadcast metrics)
	agmConfiguration.metrics = glue.metrics.subSystem("AGM");

	//Initialize AGM save into the 'glue' global variable
	glue.agm = agm(agmConfiguration);

	// Add activity in the container only
	var activitiesFacade = window.htmlContainer ? window.htmlContainer.activityFacade : undefined;
	if (typeof activitiesFacade !== "undefined"){
		var activityLogger = glue.logger.subLogger("activity");
		activityLogger.publishLevel("debug");
		activityLogger.consoleLevel("info");
    activityLogger.metricsLevel("off");
		glue.activities = activity({agm: glue.agm, logger: activityLogger});
	}

	glue.windows = windows(glue.agm);

	// camel case for App Manager
	glue.appManager = appManager(glue.agm, glue.windows);

  glue.info = {
    glueVersion : '2.3.0',
    activities : glue.activities ? glue.activities.version : 'unknown', 
    metrics: glue.metrics.repo.version,
    agm: glue.agm.version,
    windows: glue.windows.version,
    logger: glue.logger.version,
    appManager: glue.appManager.version,
    connection: glue.connection.version    
  };
  
	// no conflict function
	var originalGlue = window.glue;
	glue.noConflict = function(){
		window.glue = originalGlue;
		return glue;
	};

	//Export GLUE
	window.glue = glue;
	module.exports = glue;
}());
},{"es5-shim":5,"es5-shim/es5-sham":4,"tick42-activity":12,"tick42-agm":30,"tick42-app-manager":39,"tick42-appconfig/src/js/appconfig":44,"tick42-gateway-connection":50,"tick42-logger":57,"tick42-metrics":72,"tick42-windows":73}],2:[function(require,module,exports){
/**
 * (c) 2013 Beau Sorensen
 * MIT Licensed
 * For all details and documentation:
 * https://github.com/sorensen/ascii-table
 */

;(function() {
'use strict';

/*!
 * Module dependencies
 */

var slice = Array.prototype.slice
  , toString = Object.prototype.toString

/**
 * AsciiTable constructor
 *
 * @param {String|Object} title or JSON table
 * @param {Object} table options
 *  - `prefix` - string prefix added to each line on render
 * @constructor
 * @api public
 */

function AsciiTable(name, options) {
  this.options = options || {}
  this.reset(name)
}

/*!
 * Current library version, should match `package.json`
 */

AsciiTable.VERSION = '0.0.8'

/*!
 * Alignment constants
 */

AsciiTable.LEFT = 0
AsciiTable.CENTER = 1
AsciiTable.RIGHT = 2

/*!
 * Static methods
 */

/**
 * Create a new table instance
 *
 * @param {String|Object} title or JSON table
 * @param {Object} table options
 * @api public
 */

AsciiTable.factory = function(name, options) {
  return new AsciiTable(name, options)
}

/**
 * Align the a string at the given length
 *
 * @param {Number} direction
 * @param {String} string input
 * @param {Number} string length
 * @param {Number} padding character
 * @api public
 */

AsciiTable.align = function(dir, str, len, pad) {
  if (dir === AsciiTable.LEFT) return AsciiTable.alignLeft(str, len, pad)
  if (dir === AsciiTable.RIGHT) return AsciiTable.alignRight(str, len, pad)
  if (dir === AsciiTable.CENTER) return AsciiTable.alignCenter(str, len, pad)
  return AsciiTable.alignAuto(str, len, pad)
}

/**
 * Left align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignLeft = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var alen = len + 1 - str.length
  if (alen <= 0) return str
  return str + Array(len + 1 - str.length).join(pad)
}

/**
 * Center align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignCenter = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var nLen = str.length
    , half = Math.floor(len / 2 - nLen / 2)
    , odds = Math.abs((nLen % 2) - (len % 2))
    , len = str.length

  return AsciiTable.alignRight('', half, pad) 
    + str
    + AsciiTable.alignLeft('', half + odds, pad)
}

/**
 * Right align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignRight = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var alen = len + 1 - str.length
  if (alen <= 0) return str
  return Array(len + 1 - str.length).join(pad) + str
}

/**
 * Auto align string value based on object type
 *
 * @param {Any} object to string
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignAuto = function(str, len, pad) {
  if (str === undefined || str === null) str = ''
  var type = toString.call(str)
  pad || (pad = ' ')
  len = +len
  if (type !== '[object String]') {
    str = str.toString()
  }
  if (str.length < len) {
    switch(type) {
      case '[object Number]': return AsciiTable.alignRight(str, len, pad)
      default: return AsciiTable.alignLeft(str, len, pad)
    }
  }
  return str
}

/**
 * Fill an array at a given size with the given value
 *
 * @param {Number} array size
 * @param {Any} fill value
 * @return {Array} filled array
 * @api public
 */

AsciiTable.arrayFill = function(len, fill) {
  var arr = new Array(len)
  for (var i = 0; i !== len; i++) {
    arr[i] = fill;
  }
  return arr
}

/*!
 * Instance methods
 */

/**
 * Reset the table state back to defaults
 *
 * @param {String|Object} title or JSON table
 * @api public
 */

AsciiTable.prototype.reset = 
AsciiTable.prototype.clear = function(name) {
  this.__name = ''
  this.__nameAlign = AsciiTable.CENTER
  this.__rows = []
  this.__maxCells = 0
  this.__aligns = []
  this.__colMaxes = []
  this.__spacing = 1
  this.__heading = null
  this.__headingAlign = AsciiTable.CENTER
  this.setBorder()

  if (toString.call(name) === '[object String]') {
    this.__name = name
  } else if (toString.call(name) === '[object Object]') {
    this.fromJSON(name)
  }
  return this
}

/**
 * Set the table border
 *
 * @param {String} horizontal edges (optional, default `|`)
 * @param {String} vertical edges (optional, default `-`)
 * @param {String} top corners (optional, default `.`)
 * @param {String} bottom corners (optional, default `'`)
 * @api public
 */

AsciiTable.prototype.setBorder = function(edge, fill, top, bottom) {
  this.__border = true
  if (arguments.length === 1) {
    fill = top = bottom = edge
  }
  this.__edge = edge || '|'
  this.__fill = fill || '-'
  this.__top = top || '.'
  this.__bottom = bottom || "'"
  return this
}

/**
 * Remove all table borders
 *
 * @api public
 */

AsciiTable.prototype.removeBorder = function() {
  this.__border = false
  this.__edge = ' '
  this.__fill = ' '
  return this
}

/**
 * Set the column alignment at a given index
 *
 * @param {Number} column index
 * @param {Number} alignment direction
 * @api public
 */

AsciiTable.prototype.setAlign = function(idx, dir) {
  this.__aligns[idx] = dir
  return this
}

/**
 * Set the title of the table
 *
 * @param {String} title
 * @api public
 */

AsciiTable.prototype.setTitle = function(name) {
  this.__name = name
  return this
}

/**
 * Get the title of the table
 *
 * @return {String} title
 * @api public
 */

AsciiTable.prototype.getTitle = function() {
  return this.__name
}

/**
 * Set table title alignment
 *
 * @param {Number} direction
 * @api public
 */

AsciiTable.prototype.setTitleAlign = function(dir) {
  this.__nameAlign = dir
  return this
}

/**
 * AsciiTable sorting shortcut to sort rows
 *
 * @param {Function} sorting method
 * @api public
 */

AsciiTable.prototype.sort = function(method) {
  this.__rows.sort(method)
  return this
}

/**
 * Sort rows based on sort method for given column
 *
 * @param {Number} column index
 * @param {Function} sorting method
 * @api public
 */

AsciiTable.prototype.sortColumn = function(idx, method) {
  this.__rows.sort(function(a, b) {
    return method(a[idx], b[idx])
  })
  return this
}

/**
 * Set table heading for columns
 *
 * @api public
 */

AsciiTable.prototype.setHeading = function(row) {
  if (arguments.length > 1 || toString.call(row) !== '[object Array]') {
    row = slice.call(arguments)
  }
  this.__heading = row
  return this
}

/**
 * Get table heading for columns
 *
 * @return {Array} copy of headings
 * @api public
 */

AsciiTable.prototype.getHeading = function() {
  return this.__heading.slice()
}

/**
 * Set heading alignment
 *
 * @param {Number} direction
 * @api public
 */

AsciiTable.prototype.setHeadingAlign = function(dir) {
  this.__headingAlign = dir
  return this
}

/**
 * Add a row of information to the table
 * 
 * @param {...|Array} argument values in order of columns
 * @api public
 */

AsciiTable.prototype.addRow = function(row) {
  if (arguments.length > 1 || toString.call(row) !== '[object Array]') {
    row = slice.call(arguments)
  }
  this.__maxCells = Math.max(this.__maxCells, row.length)
  this.__rows.push(row)
  return this
}

/**
 * Get a copy of all rows of the table
 *
 * @return {Array} copy of rows
 * @api public
 */

AsciiTable.prototype.getRows = function() {
  return this.__rows.slice().map(function(row) {
    return row.slice()
  })
}

/**
 * Add rows in the format of a row matrix
 *
 * @param {Array} row matrix
 * @api public
 */

AsciiTable.prototype.addRowMatrix = function(rows) {
  for (var i = 0; i < rows.length; i++) {
    this.addRow(rows[i])
  }
  return this
}

/**
 * Add rows from the given data array, processed by the callback function rowCallback.
 *
 * @param {Array} data
 * @param (Function) rowCallback
 * @param (Boolean) asMatrix - controls if the row created by rowCallback should be assigned as row matrix
 * @api public
 */

AsciiTable.prototype.addData = function(data, rowCallback, asMatrix) {
  if (toString.call(data) !== '[object Array]') {
    return this;
  }
  for (var index = 0, limit = data.length; index < limit; index++) {
    var row = rowCallback(data[index]);
    if(asMatrix) {
      this.addRowMatrix(row);
    } else {
      this.addRow(row);
    }
  }
  return this
}

  /**
 * Reset the current row state
 *
 * @api public
 */

AsciiTable.prototype.clearRows = function() {
  this.__rows = []
  this.__maxCells = 0
  this.__colMaxes = []
  return this
}

/**
 * Apply an even spaced column justification
 *
 * @param {Boolean} on / off
 * @api public
 */

AsciiTable.prototype.setJustify = function(val) {
  arguments.length === 0 && (val = true)
  this.__justify = !!val
  return this
}

/**
 * Convert the current instance to a JSON structure
 *
 * @return {Object} json representation
 * @api public
 */

AsciiTable.prototype.toJSON = function() {
  return {
    title: this.getTitle()
  , heading: this.getHeading()
  , rows: this.getRows()
  }
}

/**
 * Populate the table from a JSON object
 *
 * @param {Object} json representation
 * @api public
 */

AsciiTable.prototype.parse = 
AsciiTable.prototype.fromJSON = function(obj) {
  return this
    .clear()
    .setTitle(obj.title)
    .setHeading(obj.heading)
    .addRowMatrix(obj.rows)
}

/**
 * Render the table with the current information
 *
 * @return {String} formatted table
 * @api public
 */

AsciiTable.prototype.render =
AsciiTable.prototype.valueOf =
AsciiTable.prototype.toString = function() {
  var self = this
    , body = []
    , mLen = this.__maxCells
    , max = AsciiTable.arrayFill(mLen, 0)
    , total = mLen * 3
    , rows = this.__rows
    , justify
    , border = this.__border
    , all = this.__heading 
        ? [this.__heading].concat(rows)
        : rows

  // Calculate max table cell lengths across all rows
  for (var i = 0; i < all.length; i++) {
    var row = all[i]
    for (var k = 0; k < mLen; k++) {
      var cell = row[k]
      max[k] = Math.max(max[k], cell ? cell.toString().length : 0)
    }
  }
  this.__colMaxes = max
  justify = this.__justify ? Math.max.apply(null, max) : 0

  // Get 
  max.forEach(function(x) {
    total += justify ? justify : x + self.__spacing
  })
  justify && (total += max.length)
  total -= this.__spacing

  // Heading
  border && body.push(this._seperator(total - mLen + 1, this.__top))
  if (this.__name) {
    body.push(this._renderTitle(total - mLen + 1))
    border && body.push(this._seperator(total - mLen + 1))
  }
  if (this.__heading) {
    body.push(this._renderRow(this.__heading, ' ', this.__headingAlign))
    body.push(this._rowSeperator(mLen, this.__fill))
  }
  for (var i = 0; i < this.__rows.length; i++) {
    body.push(this._renderRow(this.__rows[i], ' '))
  }
  border && body.push(this._seperator(total - mLen + 1, this.__bottom))

  var prefix = this.options.prefix || ''
  return prefix + body.join('\n' + prefix)
}

/**
 * Create a line seperator
 *
 * @param {Number} string size
 * @param {String} side values (default '|')
 * @api private
 */

AsciiTable.prototype._seperator = function(len, sep) {
  sep || (sep = this.__edge)
  return sep + AsciiTable.alignRight(sep, len, this.__fill)
}

/**
 * Create a row seperator
 *
 * @return {String} seperator
 * @api private
 */

AsciiTable.prototype._rowSeperator = function() {
  var blanks = AsciiTable.arrayFill(this.__maxCells, this.__fill)
  return this._renderRow(blanks, this.__fill)
}

/**
 * Render the table title in a centered box
 *
 * @param {Number} string size
 * @return {String} formatted title
 * @api private
 */

AsciiTable.prototype._renderTitle = function(len) {
  var name = ' ' + this.__name + ' '
    , str = AsciiTable.align(this.__nameAlign, name, len - 1, ' ')
  return this.__edge + str + this.__edge
}

/**
 * Render an invdividual row
 *
 * @param {Array} row
 * @param {String} column seperator
 * @param {Number} total row alignment (optional, default `auto`)
 * @return {String} formatted row
 * @api private
 */

AsciiTable.prototype._renderRow = function(row, str, align) {
  var tmp = ['']
    , max = this.__colMaxes

  for (var k = 0; k < this.__maxCells; k++) {
    var cell = row[k]
      , just = this.__justify ? Math.max.apply(null, max) : max[k]
      // , pad = k === this.__maxCells - 1 ? just : just + this.__spacing
      , pad = just
      , cAlign = this.__aligns[k]
      , use = align
      , method = 'alignAuto'
  
    if (typeof align === 'undefined') use = cAlign

    if (use === AsciiTable.LEFT) method = 'alignLeft'
    if (use === AsciiTable.CENTER) method = 'alignCenter'
    if (use === AsciiTable.RIGHT) method = 'alignRight'

    tmp.push(AsciiTable[method](cell, pad, str))
  }
  var front = tmp.join(str + this.__edge + str)
  front = front.substr(1, front.length)
  return front + str + this.__edge
}

/*!
 * Aliases
 */

// Create method shortcuts to all alignment methods for each direction
;['Left', 'Right', 'Center'].forEach(function(dir) {
  var constant = AsciiTable[dir.toUpperCase()]

  ;['setAlign', 'setTitleAlign', 'setHeadingAlign'].forEach(function(method) {
    // Call the base method with the direction constant as the last argument
    AsciiTable.prototype[method + dir] = function() {
      var args = slice.call(arguments).concat(constant)
      return this[method].apply(this, args)
    }
  })
})

/*!
 * Module exports.
 */

if (typeof exports !== 'undefined') {
  module.exports = AsciiTable
} else {
  this.AsciiTable = AsciiTable
}

}).call(this);

},{}],3:[function(require,module,exports){
module.exports = require('./ascii-table')
},{"./ascii-table":2}],4:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
  }
}(this, function () {

var call = Function.call;
var prototypeOfObject = Object.prototype;
var owns = call.bind(prototypeOfObject.hasOwnProperty);
var isEnumerable = call.bind(prototypeOfObject.propertyIsEnumerable);
var toStr = call.bind(prototypeOfObject.toString);

// If JS engine supports accessors creating shortcuts.
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
if (supportsAccessors) {
    /* eslint-disable no-underscore-dangle */
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
    /* eslint-enable no-underscore-dangle */
}

// ES5 15.2.3.2
// http://es5.github.com/#x15.2.3.2
if (!Object.getPrototypeOf) {
    // https://github.com/es-shims/es5-shim/issues#issue/2
    // http://ejohn.org/blog/objectgetprototypeof/
    // recommended by fschaefer on github
    //
    // sure, and webreflection says ^_^
    // ... this will nerever possibly return null
    // ... Opera Mini breaks here with infinite loops
    Object.getPrototypeOf = function getPrototypeOf(object) {
        /* eslint-disable no-proto */
        var proto = object.__proto__;
        /* eslint-enable no-proto */
        if (proto || proto === null) {
            return proto;
        } else if (toStr(object.constructor) === '[object Function]') {
            return object.constructor.prototype;
        } else if (object instanceof Object) {
          return prototypeOfObject;
        } else {
          // Correctly return null for Objects created with `Object.create(null)`
          // (shammed or native) or `{ __proto__: null}`.  Also returns null for
          // cross-realm objects on browsers that lack `__proto__` support (like
          // IE <11), but that's the best we can do.
          return null;
        }
    };
}

// ES5 15.2.3.3
// http://es5.github.com/#x15.2.3.3

var doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {
    try {
        object.sentinel = 0;
        return Object.getOwnPropertyDescriptor(object, 'sentinel').value === 0;
    } catch (exception) {
        return false;
    }
};

// check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
if (Object.defineProperty) {
    var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
    var getOwnPropertyDescriptorWorksOnDom = typeof document === 'undefined' ||
    doesGetOwnPropertyDescriptorWork(document.createElement('div'));
    if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
        var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
    }
}

if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
    var ERR_NON_OBJECT = 'Object.getOwnPropertyDescriptor called on a non-object: ';

    /* eslint-disable no-proto */
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object !== 'object' && typeof object !== 'function') || object === null) {
            throw new TypeError(ERR_NON_OBJECT + object);
        }

        // make a valiant attempt to use the real getOwnPropertyDescriptor
        // for I8's DOM elements.
        if (getOwnPropertyDescriptorFallback) {
            try {
                return getOwnPropertyDescriptorFallback.call(Object, object, property);
            } catch (exception) {
                // try the shim if the real one doesn't work
            }
        }

        var descriptor;

        // If object does not owns property return undefined immediately.
        if (!owns(object, property)) {
            return descriptor;
        }

        // If object has a property then it's for sure `configurable`, and
        // probably `enumerable`. Detect enumerability though.
        descriptor = {
            enumerable: isEnumerable(object, property),
            configurable: true
        };

        // If JS engine supports accessor properties then property may be a
        // getter or setter.
        if (supportsAccessors) {
            // Unfortunately `__lookupGetter__` will return a getter even
            // if object has own non getter property along with a same named
            // inherited getter. To avoid misbehavior we temporary remove
            // `__proto__` so that `__lookupGetter__` will return getter only
            // if it's owned by an object.
            var prototype = object.__proto__;
            var notPrototypeOfObject = object !== prototypeOfObject;
            // avoid recursion problem, breaking in Opera Mini when
            // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
            // or any other Object.prototype accessor
            if (notPrototypeOfObject) {
                object.__proto__ = prototypeOfObject;
            }

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);

            if (notPrototypeOfObject) {
                // Once we have getter and setter we can put values back.
                object.__proto__ = prototype;
            }

            if (getter || setter) {
                if (getter) {
                    descriptor.get = getter;
                }
                if (setter) {
                    descriptor.set = setter;
                }
                // If it was accessor property we're done and return here
                // in order to avoid adding `value` to the descriptor.
                return descriptor;
            }
        }

        // If we got this far we know that object has an own property that is
        // not an accessor so we set it as a value and return descriptor.
        descriptor.value = object[property];
        descriptor.writable = true;
        return descriptor;
    };
    /* eslint-enable no-proto */
}

// ES5 15.2.3.4
// http://es5.github.com/#x15.2.3.4
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}

// ES5 15.2.3.5
// http://es5.github.com/#x15.2.3.5
if (!Object.create) {

    // Contributed by Brandon Benvie, October, 2012
    var createEmpty;
    var supportsProto = !({ __proto__: null } instanceof Object);
                        // the following produces false positives
                        // in Opera Mini => not a reliable check
                        // Object.prototype.__proto__ === null

    // Check for document.domain and active x support
    // No need to use active x approach when document.domain is not set
    // see https://github.com/es-shims/es5-shim/issues/150
    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
    /* global ActiveXObject */
    var shouldUseActiveX = function shouldUseActiveX() {
        // return early if document.domain not set
        if (!document.domain) {
            return false;
        }

        try {
            return !!new ActiveXObject('htmlfile');
        } catch (exception) {
            return false;
        }
    };

    // This supports IE8 when document.domain is used
    // see https://github.com/es-shims/es5-shim/issues/150
    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
    var getEmptyViaActiveX = function getEmptyViaActiveX() {
        var empty;
        var xDoc;

        xDoc = new ActiveXObject('htmlfile');

        xDoc.write('<script><\/script>');
        xDoc.close();

        empty = xDoc.parentWindow.Object.prototype;
        xDoc = null;

        return empty;
    };

    // The original implementation using an iframe
    // before the activex approach was added
    // see https://github.com/es-shims/es5-shim/issues/150
    var getEmptyViaIFrame = function getEmptyViaIFrame() {
        var iframe = document.createElement('iframe');
        var parent = document.body || document.documentElement;
        var empty;

        iframe.style.display = 'none';
        parent.appendChild(iframe);
        /* eslint-disable no-script-url */
        iframe.src = 'javascript:';
        /* eslint-enable no-script-url */

        empty = iframe.contentWindow.Object.prototype;
        parent.removeChild(iframe);
        iframe = null;

        return empty;
    };

    /* global document */
    if (supportsProto || typeof document === 'undefined') {
        createEmpty = function () {
            return { __proto__: null };
        };
    } else {
        // In old IE __proto__ can't be used to manually set `null`, nor does
        // any other method exist to make an object that inherits from nothing,
        // aside from Object.prototype itself. Instead, create a new global
        // object and *steal* its Object.prototype and strip it bare. This is
        // used as the prototype to create nullary objects.
        createEmpty = function () {
            // Determine which approach to use
            // see https://github.com/es-shims/es5-shim/issues/150
            var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();

            delete empty.constructor;
            delete empty.hasOwnProperty;
            delete empty.propertyIsEnumerable;
            delete empty.isPrototypeOf;
            delete empty.toLocaleString;
            delete empty.toString;
            delete empty.valueOf;

            var Empty = function Empty() {};
            Empty.prototype = empty;
            // short-circuit future calls
            createEmpty = function () {
                return new Empty();
            };
            return new Empty();
        };
    }

    Object.create = function create(prototype, properties) {

        var object;
        var Type = function Type() {}; // An empty constructor.

        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype !== 'object' && typeof prototype !== 'function') {
                // In the native implementation `parent` can be `null`
                // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)
                // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`
                // like they are in modern browsers. Using `Object.create` on DOM elements
                // is...err...probably inappropriate, but the native version allows for it.
                throw new TypeError('Object prototype may only be an Object or null'); // same msg as Chrome
            }
            Type.prototype = prototype;
            object = new Type();
            // IE has no built-in implementation of `Object.getPrototypeOf`
            // neither `__proto__`, but this manually setting `__proto__` will
            // guarantee that `Object.getPrototypeOf` will work as expected with
            // objects created using `Object.create`
            /* eslint-disable no-proto */
            object.__proto__ = prototype;
            /* eslint-enable no-proto */
        }

        if (properties !== void 0) {
            Object.defineProperties(object, properties);
        }

        return object;
    };
}

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, 'sentinel', {});
        return 'sentinel' in object;
    } catch (exception) {
        return false;
    }
};

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document === 'undefined' ||
        doesDefinePropertyWork(document.createElement('div'));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty,
            definePropertiesFallback = Object.defineProperties;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
    var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
    var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object !== 'object' && typeof object !== 'function') || object === null) {
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        }
        if ((typeof descriptor !== 'object' && typeof descriptor !== 'function') || descriptor === null) {
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
        }
        // make a valiant attempt to use the real defineProperty
        // for I8's DOM elements.
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
                // try the shim if the real one doesn't work
            }
        }

        // If it's a data property.
        if ('value' in descriptor) {
            // fail silently if 'writable', 'enumerable', or 'configurable'
            // are requested but not supported
            /*
            // alternate approach:
            if ( // can't implement these features; allow false but not true
                ('writable' in descriptor && !descriptor.writable) ||
                ('enumerable' in descriptor && !descriptor.enumerable) ||
                ('configurable' in descriptor && !descriptor.configurable)
            ))
                throw new RangeError(
                    'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
                );
            */

            if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
                // As accessors are supported only on engines implementing
                // `__proto__` we can safely override `__proto__` while defining
                // a property to make sure that we don't hit an inherited
                // accessor.
                /* eslint-disable no-proto */
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                // Deleting a property anyway since getter / setter may be
                // defined on object itself.
                delete object[property];
                object[property] = descriptor.value;
                // Setting original `__proto__` back now.
                object.__proto__ = prototype;
                /* eslint-enable no-proto */
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors && (('get' in descriptor) || ('set' in descriptor))) {
                 return;
            }
            // If we got that far then getters and setters can be defined !!
            if ('get' in descriptor) {
                defineGetter(object, property, descriptor.get);
            }
            if ('set' in descriptor) {
                defineSetter(object, property, descriptor.set);
            }
        }
        return object;
    };
}

// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
if (!Object.defineProperties || definePropertiesFallback) {
    Object.defineProperties = function defineProperties(object, properties) {
        // make a valiant attempt to use the real defineProperties
        if (definePropertiesFallback) {
            try {
                return definePropertiesFallback.call(Object, object, properties);
            } catch (exception) {
                // try the shim if the real one doesn't work
            }
        }

        Object.keys(properties).forEach(function (property) {
            if (property !== '__proto__') {
                Object.defineProperty(object, property, properties[property]);
            }
        });
        return object;
    };
}

// ES5 15.2.3.8
// http://es5.github.com/#x15.2.3.8
if (!Object.seal) {
    Object.seal = function seal(object) {
        if (Object(object) !== object) {
            throw new TypeError('Object.seal can only be called on Objects.');
        }
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// ES5 15.2.3.9
// http://es5.github.com/#x15.2.3.9
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        if (Object(object) !== object) {
            throw new TypeError('Object.freeze can only be called on Objects.');
        }
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// detect a Rhino bug and patch it
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function (freezeObject) {
        return function freeze(object) {
            if (typeof object === 'function') {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    }(Object.freeze));
}

// ES5 15.2.3.10
// http://es5.github.com/#x15.2.3.10
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        if (Object(object) !== object) {
            throw new TypeError('Object.preventExtensions can only be called on Objects.');
        }
        // this is misleading and breaks feature-detection, but
        // allows "securable" code to "gracefully" degrade to working
        // but insecure code.
        return object;
    };
}

// ES5 15.2.3.11
// http://es5.github.com/#x15.2.3.11
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        if (Object(object) !== object) {
            throw new TypeError('Object.isSealed can only be called on Objects.');
        }
        return false;
    };
}

// ES5 15.2.3.12
// http://es5.github.com/#x15.2.3.12
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        if (Object(object) !== object) {
            throw new TypeError('Object.isFrozen can only be called on Objects.');
        }
        return false;
    };
}

// ES5 15.2.3.13
// http://es5.github.com/#x15.2.3.13
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        // 1. If Type(O) is not Object throw a TypeError exception.
        if (Object(object) !== object) {
            throw new TypeError('Object.isExtensible can only be called on Objects.');
        }
        // 2. Return the Boolean value of the [[Extensible]] internal property of O.
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}

}));

},{}],5:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
    }
}(this, function () {

/**
 * Brings an environment as close to ECMAScript 5 compliance
 * as is possible with the facilities of erstwhile engines.
 *
 * Annotated ES5: http://es5.github.com/ (specific links below)
 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
 */

// Shortcut to an often accessed properties, in order to avoid multiple
// dereference that costs universally. This also holds a reference to known-good
// functions.
var $Array = Array;
var ArrayPrototype = $Array.prototype;
var $Object = Object;
var ObjectPrototype = $Object.prototype;
var $Function = Function;
var FunctionPrototype = $Function.prototype;
var $String = String;
var StringPrototype = $String.prototype;
var $Number = Number;
var NumberPrototype = $Number.prototype;
var array_slice = ArrayPrototype.slice;
var array_splice = ArrayPrototype.splice;
var array_push = ArrayPrototype.push;
var array_unshift = ArrayPrototype.unshift;
var array_concat = ArrayPrototype.concat;
var array_join = ArrayPrototype.join;
var call = FunctionPrototype.call;
var apply = FunctionPrototype.apply;
var max = Math.max;
var min = Math.min;

// Having a toString local variable name breaks in Opera so use to_string.
var to_string = ObjectPrototype.toString;

/* global Symbol */
/* eslint-disable one-var-declaration-per-line */
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, tryFunctionObject = function tryFunctionObject(value) { try { fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]'; isCallable = function isCallable(value) { if (typeof value !== 'function') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };
var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
/* eslint-enable one-var-declaration-per-line */

/* inlined from http://npmjs.com/define-properties */
var supportsDescriptors = $Object.defineProperty && (function () {
    try {
        var obj = {};
        $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        for (var _ in obj) { return false; }
        return obj.x === obj;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());
var defineProperties = (function (has) {
  // Define configurable, writable, and non-enumerable props
  // if they don't exist.
  var defineProperty;
  if (supportsDescriptors) {
      defineProperty = function (object, name, method, forceAssign) {
          if (!forceAssign && (name in object)) { return; }
          $Object.defineProperty(object, name, {
              configurable: true,
              enumerable: false,
              writable: true,
              value: method
          });
      };
  } else {
      defineProperty = function (object, name, method, forceAssign) {
          if (!forceAssign && (name in object)) { return; }
          object[name] = method;
      };
  }
  return function defineProperties(object, map, forceAssign) {
      for (var name in map) {
          if (has.call(map, name)) {
            defineProperty(object, name, map[name], forceAssign);
          }
      }
  };
}(ObjectPrototype.hasOwnProperty));

//
// Util
// ======
//

/* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
var isPrimitive = function isPrimitive(input) {
    var type = typeof input;
    return input === null || (type !== 'object' && type !== 'function');
};

var isActualNaN = $Number.isNaN || function (x) { return x !== x; };

var ES = {
    // ES5 9.4
    // http://es5.github.com/#x9.4
    // http://jsperf.com/to-integer
    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
    ToInteger: function ToInteger(num) {
        var n = +num;
        if (isActualNaN(n)) {
            n = 0;
        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
            n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
        return n;
    },

    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
    ToPrimitive: function ToPrimitive(input) {
        var val, valueOf, toStr;
        if (isPrimitive(input)) {
            return input;
        }
        valueOf = input.valueOf;
        if (isCallable(valueOf)) {
            val = valueOf.call(input);
            if (isPrimitive(val)) {
                return val;
            }
        }
        toStr = input.toString;
        if (isCallable(toStr)) {
            val = toStr.call(input);
            if (isPrimitive(val)) {
                return val;
            }
        }
        throw new TypeError();
    },

    // ES5 9.9
    // http://es5.github.com/#x9.9
    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
    ToObject: function (o) {
        if (o == null) { // this matches both null and undefined
            throw new TypeError("can't convert " + o + ' to object');
        }
        return $Object(o);
    },

    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
    ToUint32: function ToUint32(x) {
        return x >>> 0;
    }
};

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

var Empty = function Empty() {};

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isCallable(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var bound;
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = apply.call(
                    target,
                    this,
                    array_concat.call(args, array_slice.call(arguments))
                );
                if ($Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return apply.call(
                    target,
                    that,
                    array_concat.call(args, array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            array_push.call(boundArgs, '$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
// use it in defining shortcuts.
var owns = call.bind(ObjectPrototype.hasOwnProperty);
var toStr = call.bind(ObjectPrototype.toString);
var arraySlice = call.bind(array_slice);
var arraySliceApply = apply.bind(array_slice);
var strSlice = call.bind(StringPrototype.slice);
var strSplit = call.bind(StringPrototype.split);
var strIndexOf = call.bind(StringPrototype.indexOf);
var pushCall = call.bind(array_push);
var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
var arraySort = call.bind(ArrayPrototype.sort);

//
// Array
// =====
//

var isArray = $Array.isArray || function isArray(obj) {
    return toStr(obj) === '[object Array]';
};

// ES5 15.4.4.12
// http://es5.github.com/#x15.4.4.13
// Return len+argCount.
// [bugfix, ielt8]
// IE < 8 bug: [].unshift(0) === undefined but should be "1"
var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
defineProperties(ArrayPrototype, {
    unshift: function () {
        array_unshift.apply(this, arguments);
        return this.length;
    }
}, hasUnshiftReturnValueBug);

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties($Array, { isArray: isArray });

// The IsCallable() check in the Array functions
// has been replaced with a strict check on the
// internal class of the object to trap cases where
// the provided function was actually a regular
// expression literal, which in V8 and
// JavaScriptCore is a typeof "function".  Only in
// V8 are regular expression literals permitted as
// reduce parameters, so it is desirable in the
// general case for the shim to match the more
// strict and common behavior of rejecting regular
// expressions.

// ES5 15.4.4.18
// http://es5.github.com/#x15.4.4.18
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

// Check failure of by-index access of string characters (IE < 9)
// and failure of `0 in boxedString` (Rhino)
var boxedString = $Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    var threwException = false;
    if (method) {
        try {
            method.call('foo', function (_, __, context) {
                if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
            });

            method.call([1], function () {
                'use strict';

                properlyBoxesStrict = typeof this === 'string';
            }, 'x');
        } catch (e) {
            threwException = true;
        }
    }
    return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(callbackfn/*, thisArg*/) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, '') : object;
        var i = -1;
        var length = ES.ToUint32(self.length);
        var T;
        if (arguments.length > 1) {
          T = arguments[1];
        }

        // If no callback function or if callback is not a callable function
        if (!isCallable(callbackfn)) {
            throw new TypeError('Array.prototype.forEach callback must be a function');
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                if (typeof T === 'undefined') {
                    callbackfn(self[i], i, object);
                } else {
                    callbackfn.call(T, self[i], i, object);
                }
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.19
// http://es5.github.com/#x15.4.4.19
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
defineProperties(ArrayPrototype, {
    map: function map(callbackfn/*, thisArg*/) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, '') : object;
        var length = ES.ToUint32(self.length);
        var result = $Array(length);
        var T;
        if (arguments.length > 1) {
            T = arguments[1];
        }

        // If no callback function or if callback is not a callable function
        if (!isCallable(callbackfn)) {
            throw new TypeError('Array.prototype.map callback must be a function');
        }

        for (var i = 0; i < length; i++) {
            if (i in self) {
                if (typeof T === 'undefined') {
                    result[i] = callbackfn(self[i], i, object);
                } else {
                    result[i] = callbackfn.call(T, self[i], i, object);
                }
            }
        }
        return result;
    }
}, !properlyBoxesContext(ArrayPrototype.map));

// ES5 15.4.4.20
// http://es5.github.com/#x15.4.4.20
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
defineProperties(ArrayPrototype, {
    filter: function filter(callbackfn/*, thisArg*/) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, '') : object;
        var length = ES.ToUint32(self.length);
        var result = [];
        var value;
        var T;
        if (arguments.length > 1) {
            T = arguments[1];
        }

        // If no callback function or if callback is not a callable function
        if (!isCallable(callbackfn)) {
            throw new TypeError('Array.prototype.filter callback must be a function');
        }

        for (var i = 0; i < length; i++) {
            if (i in self) {
                value = self[i];
                if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
                    pushCall(result, value);
                }
            }
        }
        return result;
    }
}, !properlyBoxesContext(ArrayPrototype.filter));

// ES5 15.4.4.16
// http://es5.github.com/#x15.4.4.16
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
defineProperties(ArrayPrototype, {
    every: function every(callbackfn/*, thisArg*/) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, '') : object;
        var length = ES.ToUint32(self.length);
        var T;
        if (arguments.length > 1) {
            T = arguments[1];
        }

        // If no callback function or if callback is not a callable function
        if (!isCallable(callbackfn)) {
            throw new TypeError('Array.prototype.every callback must be a function');
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                return false;
            }
        }
        return true;
    }
}, !properlyBoxesContext(ArrayPrototype.every));

// ES5 15.4.4.17
// http://es5.github.com/#x15.4.4.17
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
defineProperties(ArrayPrototype, {
    some: function some(callbackfn/*, thisArg */) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, '') : object;
        var length = ES.ToUint32(self.length);
        var T;
        if (arguments.length > 1) {
            T = arguments[1];
        }

        // If no callback function or if callback is not a callable function
        if (!isCallable(callbackfn)) {
            throw new TypeError('Array.prototype.some callback must be a function');
        }

        for (var i = 0; i < length; i++) {
            if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                return true;
            }
        }
        return false;
    }
}, !properlyBoxesContext(ArrayPrototype.some));

// ES5 15.4.4.21
// http://es5.github.com/#x15.4.4.21
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
var reduceCoercesToObject = false;
if (ArrayPrototype.reduce) {
    reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) { return list; }) === 'object';
}
defineProperties(ArrayPrototype, {
    reduce: function reduce(callbackfn/*, initialValue*/) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, '') : object;
        var length = ES.ToUint32(self.length);

        // If no callback function or if callback is not a callable function
        if (!isCallable(callbackfn)) {
            throw new TypeError('Array.prototype.reduce callback must be a function');
        }

        // no value to return if no initial value and an empty array
        if (length === 0 && arguments.length === 1) {
            throw new TypeError('reduce of empty array with no initial value');
        }

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }

                // if array contains no values, no initial value to return
                if (++i >= length) {
                    throw new TypeError('reduce of empty array with no initial value');
                }
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self) {
                result = callbackfn(result, self[i], i, object);
            }
        }

        return result;
    }
}, !reduceCoercesToObject);

// ES5 15.4.4.22
// http://es5.github.com/#x15.4.4.22
// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
var reduceRightCoercesToObject = false;
if (ArrayPrototype.reduceRight) {
    reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) { return list; }) === 'object';
}
defineProperties(ArrayPrototype, {
    reduceRight: function reduceRight(callbackfn/*, initial*/) {
        var object = ES.ToObject(this);
        var self = splitString && isString(this) ? strSplit(this, '') : object;
        var length = ES.ToUint32(self.length);

        // If no callback function or if callback is not a callable function
        if (!isCallable(callbackfn)) {
            throw new TypeError('Array.prototype.reduceRight callback must be a function');
        }

        // no value to return if no initial value, empty array
        if (length === 0 && arguments.length === 1) {
            throw new TypeError('reduceRight of empty array with no initial value');
        }

        var result;
        var i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }

                // if array contains no values, no initial value to return
                if (--i < 0) {
                    throw new TypeError('reduceRight of empty array with no initial value');
                }
            } while (true);
        }

        if (i < 0) {
            return result;
        }

        do {
            if (i in self) {
                result = callbackfn(result, self[i], i, object);
            }
        } while (i--);

        return result;
    }
}, !reduceRightCoercesToObject);

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(searchElement/*, fromIndex */) {
        var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
        var length = ES.ToUint32(self.length);

        if (length === 0) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = ES.ToInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === searchElement) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

// ES5 15.4.4.15
// http://es5.github.com/#x15.4.4.15
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
defineProperties(ArrayPrototype, {
    lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
        var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
        var length = ES.ToUint32(self.length);

        if (length === 0) {
            return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
            i = min(i, ES.ToInteger(arguments[1]));
        }
        // handle negative indices
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && searchElement === self[i]) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2LastIndexOfBug);

// ES5 15.4.4.12
// http://es5.github.com/#x15.4.4.12
var spliceNoopReturnsEmptyArray = (function () {
    var a = [1, 2];
    var result = a.splice();
    return a.length === 2 && isArray(result) && result.length === 0;
}());
defineProperties(ArrayPrototype, {
    // Safari 5.0 bug where .splice() returns undefined
    splice: function splice(start, deleteCount) {
        if (arguments.length === 0) {
            return [];
        } else {
            return array_splice.apply(this, arguments);
        }
    }
}, !spliceNoopReturnsEmptyArray);

var spliceWorksWithEmptyObject = (function () {
    var obj = {};
    ArrayPrototype.splice.call(obj, 0, 0, 1);
    return obj.length === 1;
}());
defineProperties(ArrayPrototype, {
    splice: function splice(start, deleteCount) {
        if (arguments.length === 0) { return []; }
        var args = arguments;
        this.length = max(ES.ToInteger(this.length), 0);
        if (arguments.length > 0 && typeof deleteCount !== 'number') {
            args = arraySlice(arguments);
            if (args.length < 2) {
                pushCall(args, this.length - start);
            } else {
                args[1] = ES.ToInteger(deleteCount);
            }
        }
        return array_splice.apply(this, args);
    }
}, !spliceWorksWithEmptyObject);
var spliceWorksWithLargeSparseArrays = (function () {
    // Per https://github.com/es-shims/es5-shim/issues/295
    // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
    var arr = new $Array(1e5);
    // note: the index MUST be 8 or larger or the test will false pass
    arr[8] = 'x';
    arr.splice(1, 1);
    // note: this test must be defined *after* the indexOf shim
    // per https://github.com/es-shims/es5-shim/issues/313
    return arr.indexOf('x') === 7;
}());
var spliceWorksWithSmallSparseArrays = (function () {
    // Per https://github.com/es-shims/es5-shim/issues/295
    // Opera 12.15 breaks on this, no idea why.
    var n = 256;
    var arr = [];
    arr[n] = 'a';
    arr.splice(n + 1, 0, 'b');
    return arr[n] === 'a';
}());
defineProperties(ArrayPrototype, {
    splice: function splice(start, deleteCount) {
        var O = ES.ToObject(this);
        var A = [];
        var len = ES.ToUint32(O.length);
        var relativeStart = ES.ToInteger(start);
        var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
        var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

        var k = 0;
        var from;
        while (k < actualDeleteCount) {
            from = $String(actualStart + k);
            if (owns(O, from)) {
                A[k] = O[from];
            }
            k += 1;
        }

        var items = arraySlice(arguments, 2);
        var itemCount = items.length;
        var to;
        if (itemCount < actualDeleteCount) {
            k = actualStart;
            var maxK = len - actualDeleteCount;
            while (k < maxK) {
                from = $String(k + actualDeleteCount);
                to = $String(k + itemCount);
                if (owns(O, from)) {
                    O[to] = O[from];
                } else {
                    delete O[to];
                }
                k += 1;
            }
            k = len;
            var minK = len - actualDeleteCount + itemCount;
            while (k > minK) {
                delete O[k - 1];
                k -= 1;
            }
        } else if (itemCount > actualDeleteCount) {
            k = len - actualDeleteCount;
            while (k > actualStart) {
                from = $String(k + actualDeleteCount - 1);
                to = $String(k + itemCount - 1);
                if (owns(O, from)) {
                    O[to] = O[from];
                } else {
                    delete O[to];
                }
                k -= 1;
            }
        }
        k = actualStart;
        for (var i = 0; i < items.length; ++i) {
            O[k] = items[i];
            k += 1;
        }
        O.length = len - actualDeleteCount + itemCount;

        return A;
    }
}, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

var originalJoin = ArrayPrototype.join;
var hasStringJoinBug;
try {
    hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
} catch (e) {
    hasStringJoinBug = true;
}
if (hasStringJoinBug) {
    defineProperties(ArrayPrototype, {
        join: function join(separator) {
            var sep = typeof separator === 'undefined' ? ',' : separator;
            return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
        }
    }, hasStringJoinBug);
}

var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
if (hasJoinUndefinedBug) {
    defineProperties(ArrayPrototype, {
        join: function join(separator) {
            var sep = typeof separator === 'undefined' ? ',' : separator;
            return originalJoin.call(this, sep);
        }
    }, hasJoinUndefinedBug);
}

var pushShim = function push(item) {
    var O = ES.ToObject(this);
    var n = ES.ToUint32(O.length);
    var i = 0;
    while (i < arguments.length) {
        O[n + i] = arguments[i];
        i += 1;
    }
    O.length = n + i;
    return n + i;
};

var pushIsNotGeneric = (function () {
    var obj = {};
    var result = Array.prototype.push.call(obj, undefined);
    return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
}());
defineProperties(ArrayPrototype, {
    push: function push(item) {
        if (isArray(this)) {
            return array_push.apply(this, arguments);
        }
        return pushShim.apply(this, arguments);
    }
}, pushIsNotGeneric);

// This fixes a very weird bug in Opera 10.6 when pushing `undefined
var pushUndefinedIsWeird = (function () {
    var arr = [];
    var result = arr.push(undefined);
    return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
}());
defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);

// ES5 15.2.3.14
// http://es5.github.io/#x15.4.4.10
// Fix boxed string bug
defineProperties(ArrayPrototype, {
    slice: function (start, end) {
        var arr = isString(this) ? strSplit(this, '') : this;
        return arraySliceApply(arr, arguments);
    }
}, splitString);

var sortIgnoresNonFunctions = (function () {
    try {
        [1, 2].sort(null);
        [1, 2].sort({});
        return true;
    } catch (e) { /**/ }
    return false;
}());
var sortThrowsOnRegex = (function () {
    // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
    try {
        [1, 2].sort(/a/);
        return false;
    } catch (e) { /**/ }
    return true;
}());
var sortIgnoresUndefined = (function () {
    // applies in IE 8, for one.
    try {
        [1, 2].sort(undefined);
        return true;
    } catch (e) { /**/ }
    return false;
}());
defineProperties(ArrayPrototype, {
    sort: function sort(compareFn) {
        if (typeof compareFn === 'undefined') {
            return arraySort(this);
        }
        if (!isCallable(compareFn)) {
            throw new TypeError('Array.prototype.sort callback must be a function');
        }
        return arraySort(this, compareFn);
    }
}, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);

//
// Object
// ======
//

// ES5 15.2.3.14
// http://es5.github.com/#x15.2.3.14

// http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
var hasDontEnumBug = !({ 'toString': null }).propertyIsEnumerable('toString');
var hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype');
var hasStringEnumBug = !owns('x', '0');
var equalsConstructorPrototype = function (o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
};
var blacklistedKeys = {
    $window: true,
    $console: true,
    $parent: true,
    $self: true,
    $frame: true,
    $frames: true,
    $frameElement: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $external: true
};
var hasAutomationEqualityBug = (function () {
    /* globals window */
    if (typeof window === 'undefined') { return false; }
    for (var k in window) {
        try {
            if (!blacklistedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
                equalsConstructorPrototype(window[k]);
            }
        } catch (e) {
            return true;
        }
    }
    return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (object) {
    if (typeof window === 'undefined' || !hasAutomationEqualityBug) { return equalsConstructorPrototype(object); }
    try {
        return equalsConstructorPrototype(object);
    } catch (e) {
        return false;
    }
};
var dontEnums = [
    'toString',
    'toLocaleString',
    'valueOf',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'constructor'
];
var dontEnumsLength = dontEnums.length;

// taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
// can be replaced with require('is-arguments') if we ever use a build process instead
var isStandardArguments = function isArguments(value) {
    return toStr(value) === '[object Arguments]';
};
var isLegacyArguments = function isArguments(value) {
    return value !== null &&
        typeof value === 'object' &&
        typeof value.length === 'number' &&
        value.length >= 0 &&
        !isArray(value) &&
        isCallable(value.callee);
};
var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

defineProperties($Object, {
    keys: function keys(object) {
        var isFn = isCallable(object);
        var isArgs = isArguments(object);
        var isObject = object !== null && typeof object === 'object';
        var isStr = isObject && isString(object);

        if (!isObject && !isFn && !isArgs) {
            throw new TypeError('Object.keys called on a non-object');
        }

        var theKeys = [];
        var skipProto = hasProtoEnumBug && isFn;
        if ((isStr && hasStringEnumBug) || isArgs) {
            for (var i = 0; i < object.length; ++i) {
                pushCall(theKeys, $String(i));
            }
        }

        if (!isArgs) {
            for (var name in object) {
                if (!(skipProto && name === 'prototype') && owns(object, name)) {
                    pushCall(theKeys, $String(name));
                }
            }
        }

        if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for (var j = 0; j < dontEnumsLength; j++) {
                var dontEnum = dontEnums[j];
                if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
                    pushCall(theKeys, dontEnum);
                }
            }
        }
        return theKeys;
    }
});

var keysWorksWithArguments = $Object.keys && (function () {
    // Safari 5.0 bug
    return $Object.keys(arguments).length === 2;
}(1, 2));
var keysHasArgumentsLengthBug = $Object.keys && (function () {
    var argKeys = $Object.keys(arguments);
    return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
}(1));
var originalKeys = $Object.keys;
defineProperties($Object, {
    keys: function keys(object) {
        if (isArguments(object)) {
            return originalKeys(arraySlice(object));
        } else {
            return originalKeys(object);
        }
    }
}, !keysWorksWithArguments || keysHasArgumentsLengthBug);

//
// Date
// ====
//

var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
var aNegativeTestDate = new Date(-1509842289600292);
var aPositiveTestDate = new Date(1449662400000);
var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
var hasToDateStringFormatBug;
var hasToStringFormatBug;
var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
if (timeZoneOffset < -720) {
    hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
    hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
} else {
    hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
    hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
}

var originalGetFullYear = call.bind(Date.prototype.getFullYear);
var originalGetMonth = call.bind(Date.prototype.getMonth);
var originalGetDate = call.bind(Date.prototype.getDate);
var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var daysInMonth = function daysInMonth(month, year) {
    return originalGetDate(new Date(year, month, 0));
};

defineProperties(Date.prototype, {
    getFullYear: function getFullYear() {
        if (!this || !(this instanceof Date)) {
            throw new TypeError('this is not a Date object.');
        }
        var year = originalGetFullYear(this);
        if (year < 0 && originalGetMonth(this) > 11) {
            return year + 1;
        }
        return year;
    },
    getMonth: function getMonth() {
        if (!this || !(this instanceof Date)) {
            throw new TypeError('this is not a Date object.');
        }
        var year = originalGetFullYear(this);
        var month = originalGetMonth(this);
        if (year < 0 && month > 11) {
            return 0;
        }
        return month;
    },
    getDate: function getDate() {
        if (!this || !(this instanceof Date)) {
            throw new TypeError('this is not a Date object.');
        }
        var year = originalGetFullYear(this);
        var month = originalGetMonth(this);
        var date = originalGetDate(this);
        if (year < 0 && month > 11) {
            if (month === 12) {
                return date;
            }
            var days = daysInMonth(0, year + 1);
            return (days - date) + 1;
        }
        return date;
    },
    getUTCFullYear: function getUTCFullYear() {
        if (!this || !(this instanceof Date)) {
            throw new TypeError('this is not a Date object.');
        }
        var year = originalGetUTCFullYear(this);
        if (year < 0 && originalGetUTCMonth(this) > 11) {
            return year + 1;
        }
        return year;
    },
    getUTCMonth: function getUTCMonth() {
        if (!this || !(this instanceof Date)) {
            throw new TypeError('this is not a Date object.');
        }
        var year = originalGetUTCFullYear(this);
        var month = originalGetUTCMonth(this);
        if (year < 0 && month > 11) {
            return 0;
        }
        return month;
    },
    getUTCDate: function getUTCDate() {
        if (!this || !(this instanceof Date)) {
            throw new TypeError('this is not a Date object.');
        }
        var year = originalGetUTCFullYear(this);
        var month = originalGetUTCMonth(this);
        var date = originalGetUTCDate(this);
        if (year < 0 && month > 11) {
            if (month === 12) {
                return date;
            }
            var days = daysInMonth(0, year + 1);
            return (days - date) + 1;
        }
        return date;
    }
}, hasNegativeMonthYearBug);

defineProperties(Date.prototype, {
    toUTCString: function toUTCString() {
        if (!this || !(this instanceof Date)) {
            throw new TypeError('this is not a Date object.');
        }
        var day = originalGetUTCDay(this);
        var date = originalGetUTCDate(this);
        var month = originalGetUTCMonth(this);
        var year = originalGetUTCFullYear(this);
        var hour = originalGetUTCHours(this);
        var minute = originalGetUTCMinutes(this);
        var second = originalGetUTCSeconds(this);
        return dayName[day] + ', ' +
            (date < 10 ? '0' + date : date) + ' ' +
            monthName[month] + ' ' +
            year + ' ' +
            (hour < 10 ? '0' + hour : hour) + ':' +
            (minute < 10 ? '0' + minute : minute) + ':' +
            (second < 10 ? '0' + second : second) + ' GMT';
    }
}, hasNegativeMonthYearBug || hasToUTCStringFormatBug);

// Opera 12 has `,`
defineProperties(Date.prototype, {
    toDateString: function toDateString() {
        if (!this || !(this instanceof Date)) {
            throw new TypeError('this is not a Date object.');
        }
        var day = this.getDay();
        var date = this.getDate();
        var month = this.getMonth();
        var year = this.getFullYear();
        return dayName[day] + ' ' +
            monthName[month] + ' ' +
            (date < 10 ? '0' + date : date) + ' ' +
            year;
    }
}, hasNegativeMonthYearBug || hasToDateStringFormatBug);

// can't use defineProperties here because of toString enumeration issue in IE <= 8
if (hasNegativeMonthYearBug || hasToStringFormatBug) {
    Date.prototype.toString = function toString() {
        if (!this || !(this instanceof Date)) {
            throw new TypeError('this is not a Date object.');
        }
        var day = this.getDay();
        var date = this.getDate();
        var month = this.getMonth();
        var year = this.getFullYear();
        var hour = this.getHours();
        var minute = this.getMinutes();
        var second = this.getSeconds();
        var timezoneOffset = this.getTimezoneOffset();
        var hoursOffset = Math.floor(Math.abs(timezoneOffset) / 60);
        var minutesOffset = Math.floor(Math.abs(timezoneOffset) % 60);
        return dayName[day] + ' ' +
            monthName[month] + ' ' +
            (date < 10 ? '0' + date : date) + ' ' +
            year + ' ' +
            (hour < 10 ? '0' + hour : hour) + ':' +
            (minute < 10 ? '0' + minute : minute) + ':' +
            (second < 10 ? '0' + second : second) + ' GMT' +
            (timezoneOffset > 0 ? '-' : '+') +
            (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset) +
            (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
    };
    if (supportsDescriptors) {
        $Object.defineProperty(Date.prototype, 'toString', {
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
}

// ES5 15.9.5.43
// http://es5.github.com/#x15.9.5.43
// This function returns a String value represent the instance in time
// represented by this Date object. The format of the String is the Date Time
// string format defined in 15.9.1.15. All fields are present in the String.
// The time zone is always UTC, denoted by the suffix Z. If the time value of
// this object is not a finite Number a RangeError exception is thrown.
var negativeDate = -62198755200000;
var negativeYearString = '-000001';
var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

defineProperties(Date.prototype, {
    toISOString: function toISOString() {
        if (!isFinite(this)) {
            throw new RangeError('Date.prototype.toISOString called on non-finite value.');
        }

        var year = originalGetUTCFullYear(this);

        var month = originalGetUTCMonth(this);
        // see https://github.com/es-shims/es5-shim/issues/111
        year += Math.floor(month / 12);
        month = (month % 12 + 12) % 12;

        // the date time string format is specified in 15.9.1.15.
        var result = [month + 1, originalGetUTCDate(this), originalGetUTCHours(this), originalGetUTCMinutes(this), originalGetUTCSeconds(this)];
        year = (
            (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
            strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
        );

        for (var i = 0; i < result.length; ++i) {
          // pad months, days, hours, minutes, and seconds to have two digits.
          result[i] = strSlice('00' + result[i], -2);
        }
        // pad milliseconds to have three digits.
        return (
            year + '-' + arraySlice(result, 0, 2).join('-') +
            'T' + arraySlice(result, 2).join(':') + '.' +
            strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
        );
    }
}, hasNegativeDateBug || hasSafari51DateBug);

// ES5 15.9.5.44
// http://es5.github.com/#x15.9.5.44
// This function provides a String representation of a Date object for use by
// JSON.stringify (15.12.3).
var dateToJSONIsSupported = (function () {
    try {
        return Date.prototype.toJSON &&
            new Date(NaN).toJSON() === null &&
            new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
            Date.prototype.toJSON.call({ // generic
                toISOString: function () { return true; }
            });
    } catch (e) {
        return false;
    }
}());
if (!dateToJSONIsSupported) {
    Date.prototype.toJSON = function toJSON(key) {
        // When the toJSON method is called with argument key, the following
        // steps are taken:

        // 1.  Let O be the result of calling ToObject, giving it the this
        // value as its argument.
        // 2. Let tv be ES.ToPrimitive(O, hint Number).
        var O = $Object(this);
        var tv = ES.ToPrimitive(O);
        // 3. If tv is a Number and is not finite, return null.
        if (typeof tv === 'number' && !isFinite(tv)) {
            return null;
        }
        // 4. Let toISO be the result of calling the [[Get]] internal method of
        // O with argument "toISOString".
        var toISO = O.toISOString;
        // 5. If IsCallable(toISO) is false, throw a TypeError exception.
        if (!isCallable(toISO)) {
            throw new TypeError('toISOString property is not callable');
        }
        // 6. Return the result of calling the [[Call]] internal method of
        //  toISO with O as the this value and an empty argument list.
        return toISO.call(O);

        // NOTE 1 The argument is ignored.

        // NOTE 2 The toJSON function is intentionally generic; it does not
        // require that its this value be a Date object. Therefore, it can be
        // transferred to other kinds of objects for use as a method. However,
        // it does require that any such object have a toISOString method. An
        // object is free to use the argument key to filter its
        // stringification.
    };
}

// ES5 15.9.4.2
// http://es5.github.com/#x15.9.4.2
// based on work shared by Daniel Friesen (dantman)
// http://gist.github.com/303249
var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
    // XXX global assignment won't work in embeddings that use
    // an alternate object for the context.
    /* global Date: true */
    /* eslint-disable no-undef */
    var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
    var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
    /* eslint-disable no-implicit-globals */
    Date = (function (NativeDate) {
    /* eslint-enable no-implicit-globals */
    /* eslint-enable no-undef */
        // Date.length === 7
        var DateShim = function Date(Y, M, D, h, m, s, ms) {
            var length = arguments.length;
            var date;
            if (this instanceof NativeDate) {
                var seconds = s;
                var millis = ms;
                if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
                    // work around a Safari 8/9 bug where it treats the seconds as signed
                    var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                    var sToShift = Math.floor(msToShift / 1e3);
                    seconds += sToShift;
                    millis -= sToShift * 1e3;
                }
                date = length === 1 && $String(Y) === Y ? // isString(Y)
                    // We explicitly pass it through parse:
                    new NativeDate(DateShim.parse(Y)) :
                    // We have to manually make calls depending on argument
                    // length here
                    length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) :
                    length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) :
                    length >= 5 ? new NativeDate(Y, M, D, h, m) :
                    length >= 4 ? new NativeDate(Y, M, D, h) :
                    length >= 3 ? new NativeDate(Y, M, D) :
                    length >= 2 ? new NativeDate(Y, M) :
                    length >= 1 ? new NativeDate(Y) :
                                  new NativeDate();
            } else {
                date = NativeDate.apply(this, arguments);
            }
            if (!isPrimitive(date)) {
              // Prevent mixups with unfixed Date object
              defineProperties(date, { constructor: DateShim }, true);
            }
            return date;
        };

        // 15.9.1.15 Date Time String Format.
        var isoDateExpression = new RegExp('^' +
            '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
                                      // 6-digit extended year
            '(?:-(\\d{2})' + // optional month capture
            '(?:-(\\d{2})' + // optional day capture
            '(?:' + // capture hours:minutes:seconds.milliseconds
                'T(\\d{2})' + // hours capture
                ':(\\d{2})' + // minutes capture
                '(?:' + // optional :seconds.milliseconds
                    ':(\\d{2})' + // seconds capture
                    '(?:(\\.\\d{1,}))?' + // milliseconds capture
                ')?' +
            '(' + // capture UTC offset component
                'Z|' + // UTC capture
                '(?:' + // offset specifier +/-hours:minutes
                    '([-+])' + // sign capture
                    '(\\d{2})' + // hours offset capture
                    ':(\\d{2})' + // minutes offset capture
                ')' +
            ')?)?)?)?' +
        '$');

        var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

        var dayFromMonth = function dayFromMonth(year, month) {
            var t = month > 1 ? 1 : 0;
            return (
                months[month] +
                Math.floor((year - 1969 + t) / 4) -
                Math.floor((year - 1901 + t) / 100) +
                Math.floor((year - 1601 + t) / 400) +
                365 * (year - 1970)
            );
        };

        var toUTC = function toUTC(t) {
            var s = 0;
            var ms = t;
            if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
                // work around a Safari 8/9 bug where it treats the seconds as signed
                var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                var sToShift = Math.floor(msToShift / 1e3);
                s += sToShift;
                ms -= sToShift * 1e3;
            }
            return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
        };

        // Copy any custom methods a 3rd party library may have added
        for (var key in NativeDate) {
            if (owns(NativeDate, key)) {
                DateShim[key] = NativeDate[key];
            }
        }

        // Copy "native" methods explicitly; they may be non-enumerable
        defineProperties(DateShim, {
            now: NativeDate.now,
            UTC: NativeDate.UTC
        }, true);
        DateShim.prototype = NativeDate.prototype;
        defineProperties(DateShim.prototype, {
            constructor: DateShim
        }, true);

        // Upgrade Date.parse to handle simplified ISO 8601 strings
        var parseShim = function parse(string) {
            var match = isoDateExpression.exec(string);
            if (match) {
                // parse months, days, hours, minutes, seconds, and milliseconds
                // provide default values if necessary
                // parse the UTC offset component
                var year = $Number(match[1]),
                    month = $Number(match[2] || 1) - 1,
                    day = $Number(match[3] || 1) - 1,
                    hour = $Number(match[4] || 0),
                    minute = $Number(match[5] || 0),
                    second = $Number(match[6] || 0),
                    millisecond = Math.floor($Number(match[7] || 0) * 1000),
                    // When time zone is missed, local offset should be used
                    // (ES 5.1 bug)
                    // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                    isLocalTime = Boolean(match[4] && !match[8]),
                    signOffset = match[9] === '-' ? 1 : -1,
                    hourOffset = $Number(match[10] || 0),
                    minuteOffset = $Number(match[11] || 0),
                    result;
                var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
                if (
                    hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
                    minute < 60 && second < 60 && millisecond < 1000 &&
                    month > -1 && month < 12 && hourOffset < 24 &&
                    minuteOffset < 60 && // detect invalid offsets
                    day > -1 &&
                    day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
                ) {
                    result = (
                        (dayFromMonth(year, month) + day) * 24 +
                        hour +
                        hourOffset * signOffset
                    ) * 60;
                    result = (
                        (result + minute + minuteOffset * signOffset) * 60 +
                        second
                    ) * 1000 + millisecond;
                    if (isLocalTime) {
                        result = toUTC(result);
                    }
                    if (-8.64e15 <= result && result <= 8.64e15) {
                        return result;
                    }
                }
                return NaN;
            }
            return NativeDate.parse.apply(this, arguments);
        };
        defineProperties(DateShim, { parse: parseShim });

        return DateShim;
    }(Date));
    /* global Date: false */
}

// ES5 15.9.4.4
// http://es5.github.com/#x15.9.4.4
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}

//
// Number
// ======
//

// ES5.1 15.7.4.5
// http://es5.github.com/#x15.7.4.5
var hasToFixedBugs = NumberPrototype.toFixed && (
  (0.00008).toFixed(3) !== '0.000' ||
  (0.9).toFixed(0) !== '1' ||
  (1.255).toFixed(2) !== '1.25' ||
  (1000000000000000128).toFixed(0) !== '1000000000000000128'
);

var toFixedHelpers = {
  base: 1e7,
  size: 6,
  data: [0, 0, 0, 0, 0, 0],
  multiply: function multiply(n, c) {
      var i = -1;
      var c2 = c;
      while (++i < toFixedHelpers.size) {
          c2 += n * toFixedHelpers.data[i];
          toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
          c2 = Math.floor(c2 / toFixedHelpers.base);
      }
  },
  divide: function divide(n) {
      var i = toFixedHelpers.size;
      var c = 0;
      while (--i >= 0) {
          c += toFixedHelpers.data[i];
          toFixedHelpers.data[i] = Math.floor(c / n);
          c = (c % n) * toFixedHelpers.base;
      }
  },
  numToString: function numToString() {
      var i = toFixedHelpers.size;
      var s = '';
      while (--i >= 0) {
          if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
              var t = $String(toFixedHelpers.data[i]);
              if (s === '') {
                  s = t;
              } else {
                  s += strSlice('0000000', 0, 7 - t.length) + t;
              }
          }
      }
      return s;
  },
  pow: function pow(x, n, acc) {
      return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
  },
  log: function log(x) {
      var n = 0;
      var x2 = x;
      while (x2 >= 4096) {
          n += 12;
          x2 /= 4096;
      }
      while (x2 >= 2) {
          n += 1;
          x2 /= 2;
      }
      return n;
  }
};

var toFixedShim = function toFixed(fractionDigits) {
    var f, x, s, m, e, z, j, k;

    // Test for NaN and round fractionDigits down
    f = $Number(fractionDigits);
    f = isActualNaN(f) ? 0 : Math.floor(f);

    if (f < 0 || f > 20) {
        throw new RangeError('Number.toFixed called with invalid number of decimals');
    }

    x = $Number(this);

    if (isActualNaN(x)) {
        return 'NaN';
    }

    // If it is too big or small, return the string value of the number
    if (x <= -1e21 || x >= 1e21) {
        return $String(x);
    }

    s = '';

    if (x < 0) {
        s = '-';
        x = -x;
    }

    m = '0';

    if (x > 1e-21) {
        // 1e-21 < x < 1e21
        // -70 < log2(x) < 70
        e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
        z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
        z *= 0x10000000000000; // Math.pow(2, 52);
        e = 52 - e;

        // -18 < e < 122
        // x = z / 2 ^ e
        if (e > 0) {
            toFixedHelpers.multiply(0, z);
            j = f;

            while (j >= 7) {
                toFixedHelpers.multiply(1e7, 0);
                j -= 7;
            }

            toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
            j = e - 1;

            while (j >= 23) {
                toFixedHelpers.divide(1 << 23);
                j -= 23;
            }

            toFixedHelpers.divide(1 << j);
            toFixedHelpers.multiply(1, 1);
            toFixedHelpers.divide(2);
            m = toFixedHelpers.numToString();
        } else {
            toFixedHelpers.multiply(0, z);
            toFixedHelpers.multiply(1 << (-e), 0);
            m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
        }
    }

    if (f > 0) {
        k = m.length;

        if (k <= f) {
            m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
        } else {
            m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
        }
    } else {
        m = s + m;
    }

    return m;
};
defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

var hasToPrecisionUndefinedBug = (function () {
    try {
        return 1.0.toPrecision(undefined) === '1';
    } catch (e) {
        return true;
    }
}());
var originalToPrecision = NumberPrototype.toPrecision;
defineProperties(NumberPrototype, {
    toPrecision: function toPrecision(precision) {
        return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
    }
}, hasToPrecisionUndefinedBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
        var maxSafe32BitInt = Math.pow(2, 32) - 1;

        StringPrototype.split = function (separator, limit) {
            var string = String(this);
            if (typeof separator === 'undefined' && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (!isRegex(separator)) {
                return strSplit(this, separator, limit);
            }

            var output = [];
            var flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline ? 'm' : '') +
                        (separator.unicode ? 'u' : '') + // in ES6
                        (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            var separatorCopy = new RegExp(separator.source, flags + 'g');
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // maxSafe32BitInt
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
            match = separatorCopy.exec(string);
            while (match) {
                // `separatorCopy.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    pushCall(output, strSlice(string, lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        /* eslint-disable no-loop-func */
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (typeof arguments[i] === 'undefined') {
                                    match[i] = void 0;
                                }
                            }
                        });
                        /* eslint-enable no-loop-func */
                    }
                    if (match.length > 1 && match.index < string.length) {
                        array_push.apply(output, arraySlice(match, 1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= splitLimit) {
                        break;
                    }
                }
                if (separatorCopy.lastIndex === match.index) {
                    separatorCopy.lastIndex++; // Avoid an infinite loop
                }
                match = separatorCopy.exec(string);
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separatorCopy.test('')) {
                    pushCall(output, '');
                }
            } else {
                pushCall(output, strSlice(string, lastLastIndex));
            }
            return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (typeof separator === 'undefined' && limit === 0) { return []; }
        return strSplit(this, separator, limit);
    };
}

var str_replace = StringPrototype.replace;
var replaceReportsGroupsCorrectly = (function () {
    var groups = [];
    'x'.replace(/x(.)?/g, function (match, group) {
        pushCall(groups, group);
    });
    return groups.length === 1 && typeof groups[0] === 'undefined';
}());

if (!replaceReportsGroupsCorrectly) {
    StringPrototype.replace = function replace(searchValue, replaceValue) {
        var isFn = isCallable(replaceValue);
        var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
        if (!isFn || !hasCapturingGroups) {
            return str_replace.call(this, searchValue, replaceValue);
        } else {
            var wrappedReplaceValue = function (match) {
                var length = arguments.length;
                var originalLastIndex = searchValue.lastIndex;
                searchValue.lastIndex = 0;
                var args = searchValue.exec(match) || [];
                searchValue.lastIndex = originalLastIndex;
                pushCall(args, arguments[length - 2], arguments[length - 1]);
                return replaceValue.apply(this, args);
            };
            return str_replace.call(this, searchValue, wrappedReplaceValue);
        }
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        var normalizedStart = start;
        if (start < 0) {
            normalizedStart = max(this.length + start, 0);
        }
        return string_substr.call(this, normalizedStart, length);
    }
}, hasNegativeSubstrBug);

// ES5 15.5.4.20
// whitespace from: http://es5.github.io/#x15.5.4.20
var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
    '\u2029\uFEFF';
var zeroWidth = '\u200b';
var wsRegexChars = '[' + ws + ']';
var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
defineProperties(StringPrototype, {
    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
    // http://perfectionkills.com/whitespace-deviations/
    trim: function trim() {
        if (typeof this === 'undefined' || this === null) {
            throw new TypeError("can't convert " + this + ' to object');
        }
        return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
    }
}, hasTrimWhitespaceBug);
var trim = call.bind(String.prototype.trim);

var hasLastIndexBug = StringPrototype.lastIndexOf && 'abcあい'.lastIndexOf('あい', 2) !== -1;
defineProperties(StringPrototype, {
    lastIndexOf: function lastIndexOf(searchString) {
        if (typeof this === 'undefined' || this === null) {
            throw new TypeError("can't convert " + this + ' to object');
        }
        var S = $String(this);
        var searchStr = $String(searchString);
        var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
        var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
        var start = min(max(pos, 0), S.length);
        var searchLen = searchStr.length;
        var k = start + searchLen;
        while (k > 0) {
            k = max(0, k - searchLen);
            var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
            if (index !== -1) {
                return k + index;
            }
        }
        return -1;
    }
}, hasLastIndexBug);

var originalLastIndexOf = StringPrototype.lastIndexOf;
defineProperties(StringPrototype, {
    lastIndexOf: function lastIndexOf(searchString) {
        return originalLastIndexOf.apply(this, arguments);
    }
}, StringPrototype.lastIndexOf.length !== 1);

// ES-5 15.1.2.2
/* eslint-disable radix */
if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
/* eslint-enable radix */
    /* global parseInt: true */
    parseInt = (function (origParseInt) {
        var hexRegex = /^[\-+]?0[xX]/;
        return function parseInt(str, radix) {
            var string = trim(str);
            var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
            return origParseInt(string, defaultedRadix);
        };
    }(parseInt));
}

// https://es5.github.io/#x15.1.2.3
if (1 / parseFloat('-0') !== -Infinity) {
    /* global parseFloat: true */
    parseFloat = (function (origParseFloat) {
        return function parseFloat(string) {
            var inputString = trim(string);
            var result = origParseFloat(inputString);
            return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
        };
    }(parseFloat));
}

if (String(new RangeError('test')) !== 'RangeError: test') {
    var errorToStringShim = function toString() {
        if (typeof this === 'undefined' || this === null) {
            throw new TypeError("can't convert " + this + ' to object');
        }
        var name = this.name;
        if (typeof name === 'undefined') {
            name = 'Error';
        } else if (typeof name !== 'string') {
            name = $String(name);
        }
        var msg = this.message;
        if (typeof msg === 'undefined') {
            msg = '';
        } else if (typeof msg !== 'string') {
            msg = $String(msg);
        }
        if (!name) {
            return msg;
        }
        if (!msg) {
            return name;
        }
        return name + ': ' + msg;
    };
    // can't use defineProperties here because of toString enumeration issue in IE <= 8
    Error.prototype.toString = errorToStringShim;
}

if (supportsDescriptors) {
    var ensureNonEnumerable = function (obj, prop) {
        if (isEnum(obj, prop)) {
            var desc = Object.getOwnPropertyDescriptor(obj, prop);
            desc.enumerable = false;
            Object.defineProperty(obj, prop, desc);
        }
    };
    ensureNonEnumerable(Error.prototype, 'message');
    if (Error.prototype.message !== '') {
      Error.prototype.message = '';
    }
    ensureNonEnumerable(Error.prototype, 'name');
}

if (String(/a/mig) !== '/a/gim') {
    var regexToString = function toString() {
        var str = '/' + this.source + '/';
        if (this.global) {
            str += 'g';
        }
        if (this.ignoreCase) {
            str += 'i';
        }
        if (this.multiline) {
            str += 'm';
        }
        return str;
    };
    // can't use defineProperties here because of toString enumeration issue in IE <= 8
    RegExp.prototype.toString = regexToString;
}

}));

},{}],6:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      })['catch'](function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor()['catch'](function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":7}],7:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],8:[function(require,module,exports){
var promiseExtensions_1 = require("./../helpers/promiseExtensions");
var activityManagementAPI_1 = require("./activityManagementAPI");
var activityAGM_1 = require("../core/activityAGM");
var ActivityAPI = (function () {
    function ActivityAPI(manager, my) {
        this.version = "2.1.3";
        this._manager = manager;
        this._my = my;
        this.all = new activityManagementAPI_1.ActivityManagementAPI(manager, my);
    }
    ActivityAPI.prototype.ready = function (callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this._manager.ready()
                .then(function () {
                resolve(_this);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    Object.defineProperty(ActivityAPI.prototype, "my", {
        get: function () {
            return this._my;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "aware", {
        get: function () {
            return this._my.window !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "inActivity", {
        get: function () {
            return this.aware && this._my.activity !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "agm", {
        get: function () {
            if (!this.aware) {
                return undefined;
            }
            if (!this.inActivity) {
                return new activityAGM_1.ActivityAGM(null);
            }
            return this._my.activity.agm;
        },
        enumerable: true,
        configurable: true
    });
    return ActivityAPI;
})();
exports.ActivityAPI = ActivityAPI;

},{"../core/activityAGM":16,"./../helpers/promiseExtensions":27,"./activityManagementAPI":9}],9:[function(require,module,exports){
var util = require("./../helpers/util");
var ActivityManagementAPI = (function () {
    function ActivityManagementAPI(manager, my) {
        this._manager = manager;
        this._my = my;
        this.activityTypes = {
            get: this._getActivityTypesWrapper.bind(this),
            register: this._manager.registerActivityType.bind(this._manager),
            unregister: this._manager.unregisterActivityType.bind(this._manager),
            subscribe: this._manager.subscribeActivityTypeEvents.bind(this._manager),
            unsubscribe: undefined,
            initiate: this._manager.initiate.bind(this._manager)
        };
        this.windowTypes = {
            get: this._getWindowTypesWrapper.bind(this),
            registerFactory: this._manager.registerWindowFactory.bind(this._manager),
            unregisterFactory: this._manager.unregisterWindowFactory.bind(this._manager),
            subscribe: this._manager.subscribeWindowTypeEvents.bind(this._manager),
            unsubscribe: undefined
        };
        this.windows = {
            get: this._manager.getWindows.bind(this._manager),
            subscribe: this._manager.subscribeWindowEvents.bind(this._manager),
            announce: this._manager.announceWindow.bind(this._manager),
            unsubscribe: undefined,
            create: this._manager.createWindow.bind(this._manager)
        };
        this.instances = {
            get: this._manager.getActivities.bind(this._manager),
            subscribe: this._manager.subscribeActivityEvents.bind(this._manager),
            unsubscribe: undefined
        };
    }
    ActivityManagementAPI.prototype._getActivityTypesWrapper = function (name) {
        if (util.isUndefined(name)) {
            return this._manager.getActivityTypes();
        }
        return this._manager.getActivityType(name);
    };
    ActivityManagementAPI.prototype._getWindowTypesWrapper = function (name) {
        if (util.isUndefined(name)) {
            return this._manager.getWindowTypes();
        }
        return this._manager.getWindowType(name);
    };
    return ActivityManagementAPI;
})();
exports.ActivityManagementAPI = ActivityManagementAPI;

},{"./../helpers/util":29}],10:[function(require,module,exports){
var logger_1 = require("./../helpers/logger");
var util = require("./../helpers/util");
var ActivityMy = (function () {
    function ActivityMy(manager) {
        var _this = this;
        this._myActivityJoinedCallbacks = [];
        this._myActivityRemovedCallbacks = [];
        this._myContextUpdateCallbacks = [];
        this._logger = logger_1.Logger.Get(this);
        this._manager = manager;
        manager.ready()
            .then(function (am) {
            am.subscribeActivityContextChanged(_this._subscribeMyContextChanged.bind(_this));
            am.subscribeWindowEvents(_this._subscribeMyWindowEvent.bind(_this));
        });
    }
    Object.defineProperty(ActivityMy.prototype, "window", {
        get: function () {
            if (util.isUndefinedOrNull(this._window)) {
                var announcedWindows = this._manager.announcedWindows;
                if (announcedWindows.length > 0) {
                    this._window = announcedWindows[0];
                }
            }
            return this._window;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityMy.prototype, "activity", {
        get: function () {
            var myWin = this.window;
            if (util.isUndefinedOrNull(myWin)) {
                return undefined;
            }
            return myWin.activity;
        },
        enumerable: true,
        configurable: true
    });
    ActivityMy.prototype.createWindow = function (windowType) {
        return this._manager.createWindow(this.activity, windowType);
    };
    Object.defineProperty(ActivityMy.prototype, "context", {
        get: function () {
            var activity = this.activity;
            if (util.isUndefined(activity)) {
                return {};
            }
            return activity.context;
        },
        enumerable: true,
        configurable: true
    });
    ActivityMy.prototype.onActivityJoined = function (callback) {
        this._myActivityJoinedCallbacks.push(callback);
        var myWin = this.window;
        if (!util.isUndefinedOrNull(myWin) && !util.isUndefinedOrNull(myWin.activity)) {
            callback(myWin.activity);
        }
    };
    ActivityMy.prototype.onActivityLeft = function (callback) {
        this._myActivityRemovedCallbacks.push(callback);
    };
    ActivityMy.prototype.onContextChanged = function (callback) {
        this._myContextUpdateCallbacks.push(callback);
        var myWin = this.window;
        if (util.isUndefinedOrNull(myWin)) {
            return;
        }
        var activity = myWin.activity;
        if (util.isUndefinedOrNull(activity)) {
            return;
        }
        callback(activity.context, activity.context, [], activity);
    };
    ActivityMy.prototype._subscribeMyContextChanged = function (activity, context, delta, removed) {
        var myWin = this.window;
        if (util.isUndefinedOrNull(myWin)) {
            return;
        }
        var myActivity = myWin.activity;
        if (util.isUndefinedOrNull(myActivity)) {
            return;
        }
        if (activity.id !== myActivity.id) {
            return;
        }
        this._notifyMyContextChanged(activity, context, delta, removed);
    };
    ActivityMy.prototype._subscribeMyWindowEvent = function (activity, window, event) {
        if (util.isUndefinedOrNull(this.window)) {
            return;
        }
        if (this.window.id !== window.id) {
            return;
        }
        if (event === "joined") {
            this._notifyOnJoined(activity);
        }
        else {
            this._notifyMyWindowEvent(activity, this._myActivityRemovedCallbacks);
        }
    };
    ActivityMy.prototype._notifyMyWindowEvent = function (activity, callbackStore) {
        for (var index = 0; index < callbackStore.length; index++) {
            var element = callbackStore[index];
            element(activity, event);
        }
    };
    ActivityMy.prototype._notifyMyContextChanged = function (activity, context, delta, removed) {
        delta = delta || {};
        removed = removed || [];
        for (var index = 0; index < this._myContextUpdateCallbacks.length; index++) {
            var element = this._myContextUpdateCallbacks[index];
            element(context, delta, removed, activity);
        }
    };
    ActivityMy.prototype._notifyOnJoined = function (activity) {
        // when joined to activity notify for :
        // * joined
        // * context change
        this._notifyMyWindowEvent(activity, this._myActivityJoinedCallbacks);
        this._notifyMyContextChanged(activity, activity.context);
    };
    return ActivityMy;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityMy;

},{"./../helpers/logger":26,"./../helpers/util":29}],11:[function(require,module,exports){
var ActivityConfig = (function () {
    function ActivityConfig() {
    }
    return ActivityConfig;
})();
exports.ActivityConfig = ActivityConfig;

},{}],12:[function(require,module,exports){
/// <reference path="../typings/es6-promise/es6-promise.d.ts"/>
/// <reference path="../typings/tick42-agm/agm.d.ts"/>
/// <reference path="../typings/tick42-logger/logger.d.ts"/>
require("es6-promise");
var hcBridge_1 = require("./bridges/hcBridge");
var activityManager_1 = require("./core/activityManager");
var activityMyAPI_1 = require("./API/activityMyAPI");
var logger_1 = require("./helpers/logger");
var util = require("./helpers/util");
var activityConfig_1 = require("./activityConfig");
var activityAPI_1 = require("./API/activityAPI");
var activityAGM_1 = require("./core/activityAGM");
activity = function (config) {
    config = config || new activityConfig_1.ActivityConfig;
    if (!util.isUndefined(config.logLevel)) {
        logger_1.Logger.Level = config.logLevel;
    }
    if (!util.isUndefinedOrNull(config.logger)) {
        logger_1.Logger.GlueLogger = config.logger;
    }
    var bridge;
    if (!util.isUndefined(window.htmlContainer)) {
        bridge = new hcBridge_1['default']();
    }
    else {
        throw new Error("Activity not supported in in browser");
    }
    if (!bridge) {
        throw new Error("A bridge to native activity is needed to create activity lib.");
    }
    activityAGM_1.ActivityAGM.AGM = config.agm;
    var activityManager = new activityManager_1['default'](bridge, !config.disableAutoAnnounce);
    var my = new activityMyAPI_1['default'](activityManager);
    return new activityAPI_1.ActivityAPI(activityManager, my);
};
module.exports = activity;

},{"./API/activityAPI":8,"./API/activityMyAPI":10,"./activityConfig":11,"./bridges/hcBridge":13,"./core/activityAGM":16,"./core/activityManager":17,"./helpers/logger":26,"./helpers/util":29,"es6-promise":6}],13:[function(require,module,exports){
var entityEvent_1 = require("../contracts/entityEvent");
var activityStatus_1 = require("../contracts/activityStatus");
var activityType_1 = require("../entities/activityType");
var windowType_1 = require("../entities/windowType");
var activity_1 = require("../entities/activity");
var activityWindow_1 = require("../entities/activityWindow");
var proxyWindowFactory_1 = require("../core/proxyWindowFactory");
var logger_1 = require("../helpers/logger");
var entityEvent_2 = require("../contracts/entityEvent");
var readyMarker_1 = require("../helpers/readyMarker");
var util = require("../helpers/util");
var entityEvent_3 = require("../contracts/entityEvent");
var HCBridge = (function () {
    function HCBridge(agm) {
        this._activityTypeEntityName = "activityType";
        this._windowTypeEntityName = "windowType";
        this._activityEntityName = "activity";
        this._windowEntityName = "activityWindow";
        this._logger = logger_1.Logger.Get(this);
        this._lastSeq = 0;
        this._eventQueue = [];
        this._activityTypeCallbacks = [];
        this._windowTypeCallbacks = [];
        this._activityCallbacks = [];
        this._windowCallbacks = [];
        this._agm = agm;
    }
    HCBridge.prototype.init = function () {
        var _this = this;
        this._readyMarker = new readyMarker_1.ReadyMarker("HC Bridge", 1);
        this._htmlContainer = window.htmlContainer.activityFacade;
        this._htmlContainer.init(this._agm ? this._agm.instance : undefined, this._hcEventHandler.bind(this), function () {
            _this._readyMarker.signal("Init done from HC");
        }, function (error) {
            _this._readyMarker.error(error);
        });
    };
    HCBridge.prototype.ready = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._readyMarker.setCallback(function (err) {
                if (!err) {
                    resolve(_this);
                }
                else {
                    _this._logger.error("Error initializing HC bridge - " + err);
                    reject(_this._readyMarker.getError());
                }
            });
        });
    };
    HCBridge.prototype._hcEventHandler = function (eventJson) {
        this._logger.trace(eventJson);
        var event = JSON.parse(eventJson);
        this._processEventBySeq(event);
    };
    HCBridge.prototype._processEventBySeq = function (event) {
        var seq = event.sequence;
        if (seq === this._lastSeq + 1) {
            this._processEvent(event);
            this._lastSeq++;
            var nextEvent = this._eventQueue[seq + 1];
            if (!util.isUndefined(nextEvent)) {
                this._logger.debug("replaying message number " + seq);
                this._processEventBySeq(nextEvent);
                delete this._eventQueue[seq + 1];
            }
        }
        else {
            this._eventQueue[seq] = event;
            this._logger.debug("Got out of order event with number " + seq + ". Will wait for previous event(s) before replaying.");
        }
    };
    HCBridge.prototype._processEvent = function (event) {
        var entityType = event.entityType;
        var eventContext = this._convertContext(event.context);
        var entity;
        switch (entityType) {
            case this._activityTypeEntityName:
                entity = HCBridge._hcToJsActivityType(event.entity);
                this._publishActivityTypeStatusChange(entity, eventContext);
                break;
            case this._windowTypeEntityName:
                entity = this._hcToJsWindowType(event.entity);
                this._publishWindowTypeStatusChange(entity, eventContext);
                break;
            case this._activityEntityName:
                entity = this._hcToJsActivity(event.entity);
                this._publishActivityStatusChange(entity, eventContext);
                break;
            case this._windowEntityName:
                entity = HCBridge._hcToJsWindow(event.entity);
                this._publishActivityWindowEvent(entity, eventContext);
                break;
        }
    };
    HCBridge.prototype._convertContext = function (hcContext) {
        if (hcContext.type === entityEvent_1.EntityEventType.StatusChange) {
            var oldStatus = new activityStatus_1.ActivityStatus(hcContext.oldStatus.state, hcContext.oldStatus.statusMessage, hcContext.oldStatus.statusTime);
            var newStatus = new activityStatus_1.ActivityStatus(hcContext.newStatus.state, hcContext.newStatus.statusMessage, hcContext.newStatus.statusTime);
            return new entityEvent_1.EntityStatusChangeEventContext(newStatus, oldStatus);
        }
        else if (hcContext.type === entityEvent_1.EntityEventType.ActivityWindowEvent) {
            var act = this._hcToJsActivity(hcContext.activity);
            return new entityEvent_1.EntityActivityWindowEventContext(act, hcContext.event);
        }
        else if (hcContext.type === entityEvent_1.EntityEventType.ActivityContextChange) {
            return new entityEvent_3.ActivityContextChangedContext(hcContext.newContext, hcContext.updated, hcContext.removed);
        }
        return new entityEvent_1.EntityEventContext(hcContext.type);
    };
    HCBridge._hcToJsWindow = function (hcWindow) {
        return new activityWindow_1['default'](hcWindow.id, hcWindow.name, hcWindow.type, hcWindow.activityId, hcWindow.instance, hcWindow.isIndependent);
    };
    HCBridge.prototype._hcToJsActivity = function (hcAct) {
        var window = hcAct.owner ? HCBridge._hcToJsWindow(hcAct.owner) : null;
        var status = new activityStatus_1.ActivityStatus(hcAct.status.state, hcAct.status.statusMessage, hcAct.status.statusTime);
        var helperWindows = hcAct.windows ? hcAct.windows.map(function (w) { return HCBridge._hcToJsWindow(w); }) : [];
        var context = JSON.parse(hcAct.context);
        return new activity_1['default'](hcAct.id, hcAct.type.name, status, context, window, helperWindows);
    };
    HCBridge._hcToJsActivityType = function (hcActType) {
        return new activityType_1['default'](hcActType.name, hcActType.ownerWindowType, hcActType.helperWindowTypes, hcActType.description);
    };
    HCBridge.prototype._hcToJsWindowType = function (hcWinType) {
        if (util.isUndefined(hcWinType.factories)) {
            hcWinType.factories = [];
        }
        var factories = hcWinType.factories.map(function (f) {
            return HCBridge._hcToJsWindowTypeFactory(f);
        });
        return new windowType_1['default'](hcWinType.name, factories);
    };
    HCBridge._hcToJsWindowTypeFactory = function (hcWinTypeFactory) {
        return new proxyWindowFactory_1.ProxyWindowFactory(hcWinTypeFactory.description);
    };
    HCBridge._getURLParameter = function (name) {
        return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.search) || [, ""])[1].replace(/\+/g, '%20')) || null;
    };
    HCBridge.prototype.getActivityTypes = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getActivityTypes(function (infos) {
                var result = [];
                for (var index = 0; index < infos.length; index++) {
                    var info = infos[index];
                    var newActivityType = HCBridge._hcToJsActivityType(info);
                    result.push(newActivityType);
                }
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.registerActivityType = function (activityTypeName, ownerWindow, helperWindows, layoutConfig, description) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (helperWindows === undefined) {
                helperWindows = [];
            }
            var config = {
                name: activityTypeName,
                ownerWindowType: ownerWindow,
                helperWindowTypes: helperWindows,
                description: description,
                layoutConfig: JSON.stringify(layoutConfig)
            };
            _this._htmlContainer.registerActivityType(JSON.stringify(config), function (info) {
                var newActivityType = HCBridge._hcToJsActivityType(info);
                resolve(newActivityType);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.unregisterActivityType = function (activityTypeName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.unregisterActivityType(activityTypeName, function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.getWindowTypes = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindowTypes(function (infos) {
                var result = [];
                for (var index = 0; index < infos.length; index++) {
                    var info = infos[index];
                    var newWindowType = _this._hcToJsWindowType(info);
                    result.push(newWindowType);
                }
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.registerWindowFactory = function (windowTypeName, factory) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowTypeName)) {
                reject("windowTypeName should be provided");
                return;
            }
            _this._htmlContainer.registerWindowFactory(windowTypeName, factory.create.bind(factory), function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.initiateActivity = function (activityType, context, callback) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activityType)) {
                reject("windowTypeName should be provided");
                return;
            }
            if (util.isUndefinedOrNull(context)) {
                context = {};
            }
            _this._htmlContainer.initiate(activityType, JSON.stringify(context), function (activityId) {
                resolve(activityId);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.getAnnouncementInfo = function () {
        var hc = window.htmlContainer;
        var context = hc.getContext();
        var result = { activityWindowId: "", activityWindowType: "", activityWindowIndependent: false, activityWindowName: "" };
        result.activityWindowType = context.activityWindowType;
        if (util.isUndefined(result.activityWindowType)) {
            result.activityWindowType = HCBridge._getURLParameter("activityWindowType");
        }
        result.activityWindowId = context.activityWindowId;
        if (util.isUndefined(result.activityWindowId)) {
            result.activityWindowId = HCBridge._getURLParameter("activityWindowId");
        }
        result.activityWindowIndependent = context.activityWindowIndependent;
        if (util.isUndefined(result.activityWindowIndependent)) {
        }
        result.activityWindowName = context.activityWindowName;
        if (util.isUndefined(result.activityWindowName)) {
            result.activityWindowName = HCBridge._getURLParameter("activityWindowName");
        }
        return result;
    };
    HCBridge.prototype.announceWindow = function (windowType, activityWindowId) {
        var _this = this;
        if (util.isUndefined(windowType)) {
            throw new Error("can not determine window type");
        }
        if (util.isUndefined(windowType)) {
            throw new Error("can not determine window activityWindowId");
        }
        this._htmlContainer.announceWindow(windowType, activityWindowId, function (error) {
            _this._logger.error("Error announcing activity window with id '" + activityWindowId + "'. " + error);
        });
    };
    HCBridge.prototype.getActivities = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._logger.trace("Executing getActivities()");
            _this._htmlContainer.getActivities(function (activitiesStr) {
                _this._logger.trace("Got getActivities() :" + activitiesStr);
                var activities = JSON.parse(activitiesStr);
                var result = activities.map(function (act) { return _this._hcToJsActivity(act); });
                resolve(result);
            }, function (error) {
                _this._logger.trace("Error in getActivities() :" + error);
                reject(error);
            });
        });
    };
    HCBridge.prototype.updateActivityContext = function (activity, context, fullReplace, removedKeys) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefined(removedKeys)) {
                removedKeys = [];
            }
            var options = {
                fullReplace: fullReplace,
                removedKeys: removedKeys
            };
            _this._htmlContainer.setActivityContext(activity.id, JSON.stringify(context), JSON.stringify(options), function (newContextString) {
                var newContext = JSON.parse(newContextString);
                resolve(newContext);
            }, function (error) { return reject(error); });
        });
    };
    HCBridge.prototype.getActivityWindows = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindows(function (windows) {
                var result = windows.map(function (wind) { return HCBridge._hcToJsWindow(wind); });
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.stopActivity = function (activity) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.stopActivity(activity.id, function (result) {
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.unregisterWindowFactory = function (windowTypeName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.registerWindowFactory(windowTypeName, function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.createWindow = function (id, windowDefinition) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.createWindow(id, JSON.stringify(windowDefinition), function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.onActivityTypeStatusChange = function (callback) {
        this._activityTypeCallbacks.push(callback);
    };
    HCBridge.prototype.onWindowTypeStatusChange = function (callback) {
        this._windowTypeCallbacks.push(callback);
    };
    HCBridge.prototype.onActivityStatusChange = function (callback) {
        this._activityCallbacks.push(callback);
    };
    HCBridge.prototype.onActivityWindowChange = function (callback) {
        this._windowCallbacks.push(callback);
    };
    HCBridge.prototype.getWindowBounds = function (id) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindowBounds(id, function (bounds) {
                resolve(bounds);
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.setWindowBounds = function (id, bounds) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.setWindowBounds(id, JSON.stringify(bounds), function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.registerWindow = function (type, name, independent) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.registerWindow(type, name, independent, function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.closeWindow = function (id) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.closeWindow(id, function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype._publishStatusChange = function (entity, context, callbacks) {
        var entityEvent = new entityEvent_2.EntityEvent(entity, context);
        callbacks.forEach(function (callback) {
            callback(entityEvent);
        });
    };
    HCBridge.prototype._publishActivityTypeStatusChange = function (at, context) {
        this._publishStatusChange(at, context, this._activityTypeCallbacks);
    };
    HCBridge.prototype._publishWindowTypeStatusChange = function (wt, context) {
        this._publishStatusChange(wt, context, this._windowTypeCallbacks);
    };
    HCBridge.prototype._publishActivityStatusChange = function (act, context) {
        this._publishStatusChange(act, context, this._activityCallbacks);
    };
    HCBridge.prototype._publishActivityWindowEvent = function (w, context) {
        this._publishStatusChange(w, context, this._windowCallbacks);
    };
    return HCBridge;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= HCBridge;

},{"../contracts/activityStatus":14,"../contracts/entityEvent":15,"../core/proxyWindowFactory":19,"../entities/activity":20,"../entities/activityType":22,"../entities/activityWindow":23,"../entities/windowType":24,"../helpers/logger":26,"../helpers/readyMarker":28,"../helpers/util":29}],14:[function(require,module,exports){
var ActivityStatus = (function () {
    function ActivityStatus(state, message, time) {
        this.state = state;
        this.message = message;
        this.time = time;
    }
    ActivityStatus.prototype.getState = function () {
        return this.state;
    };
    ActivityStatus.prototype.getMessage = function () {
        return this.message;
    };
    ActivityStatus.prototype.getTime = function () {
        return this.time;
    };
    return ActivityStatus;
})();
exports.ActivityStatus = ActivityStatus;

},{}],15:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var EntityEvent = (function () {
    function EntityEvent(entitiy, context) {
        this.entity = entitiy;
        this.context = context;
    }
    return EntityEvent;
})();
exports.EntityEvent = EntityEvent;
var EntityEventContext = (function () {
    function EntityEventContext(eventType) {
        this.type = eventType;
    }
    return EntityEventContext;
})();
exports.EntityEventContext = EntityEventContext;
var EntityStatusChangeEventContext = (function (_super) {
    __extends(EntityStatusChangeEventContext, _super);
    function EntityStatusChangeEventContext(newStatus, oldStatus) {
        _super.call(this, EntityEventType.StatusChange);
        this.newStatus = newStatus;
        this.oldStatus = oldStatus;
    }
    return EntityStatusChangeEventContext;
})(EntityEventContext);
exports.EntityStatusChangeEventContext = EntityStatusChangeEventContext;
var EntityActivityWindowEventContext = (function (_super) {
    __extends(EntityActivityWindowEventContext, _super);
    function EntityActivityWindowEventContext(activity, event) {
        _super.call(this, EntityEventType.ActivityWindowEvent);
        this.activity = activity;
        this.event = event;
    }
    return EntityActivityWindowEventContext;
})(EntityEventContext);
exports.EntityActivityWindowEventContext = EntityActivityWindowEventContext;
var ActivityContextChangedContext = (function (_super) {
    __extends(ActivityContextChangedContext, _super);
    function ActivityContextChangedContext(context, updated, removed) {
        _super.call(this, EntityEventType.ActivityContextChange);
        this.updated = updated;
        this.removed = removed;
        this.context = JSON.parse(context);
    }
    return ActivityContextChangedContext;
})(EntityEventContext);
exports.ActivityContextChangedContext = ActivityContextChangedContext;
var EntityEventType = (function () {
    function EntityEventType() {
    }
    EntityEventType.Added = "added";
    EntityEventType.Removed = "removed";
    EntityEventType.Updated = "updated";
    EntityEventType.FactoryRegistered = "factoryRegistered";
    EntityEventType.FactoryUnregistered = "factoryUnregistered";
    EntityEventType.StatusChange = "statusChange";
    EntityEventType.ActivityContextChange = "activityContextUpdate";
    EntityEventType.ActivityWindowEvent = "activityWindowEvent";
    return EntityEventType;
})();
exports.EntityEventType = EntityEventType;

},{}],16:[function(require,module,exports){
var util = require("../helpers/util");
var ActivityAGM = (function () {
    function ActivityAGM(activity) {
        this._activity = activity;
    }
    ActivityAGM.prototype.register = function (definition, handler) {
        this._ensureHasAgm();
        ActivityAGM.AGM.register(definition, handler);
    };
    ActivityAGM.prototype.servers = function () {
        this._ensureHasAgm();
        if (util.isUndefinedOrNull(this._activity)) {
            return [];
        }
        return this._activity.windows.map(function (w) {
            return w.instance;
        });
    };
    ActivityAGM.prototype.methods = function () {
        this._ensureHasAgm();
        if (util.isUndefinedOrNull(this._activity)) {
            return [];
        }
        var windows = this._activity.windows;
        var methodNames = [];
        var methods = [];
        for (var index = 0; index < windows.length; index++) {
            var window_1 = windows[index];
            var windowMethods = this.methodsForWindow(window_1);
            for (var methodIndex = 0; methodIndex < windowMethods.length; methodIndex++) {
                var currentWindowMethod = windowMethods[methodIndex];
                if (methodNames.indexOf(currentWindowMethod.name) === -1) {
                    methodNames.push(currentWindowMethod.name);
                    methods.push(currentWindowMethod);
                }
            }
        }
        return methods;
    };
    ActivityAGM.prototype.methodsForWindow = function (window) {
        this._ensureHasAgm();
        if (!window.instance) {
            return [];
        }
        return ActivityAGM.AGM.methodsForInstance(window.instance);
    };
    ActivityAGM.prototype.invoke = function (methodName, arg, target, options, success, error) {
        this._ensureHasAgm();
        var activityServers = this.servers();
        var serversToInvokeAgainst = [];
        if (util.isUndefinedOrNull(target)) {
            target = "activity.all";
        }
        if (util.isString(target)) {
            if (target === "activity.all") {
                serversToInvokeAgainst = activityServers;
            }
            else if (target === "activity.best") {
                var potentialTargets = activityServers.filter(function (server) {
                    var methods = ActivityAGM.AGM.methodsForInstance(server);
                    return methods.filter(function (m) {
                        return m.name === methodName;
                    }).length > 0;
                });
                if (potentialTargets.length > 0) {
                    serversToInvokeAgainst = [potentialTargets[0]];
                }
            }
            else if (target === "all" || target === "best") {
                return ActivityAGM.AGM.invoke(methodName, arg, target, options, success, error);
            }
            else {
                throw new Error("Invalid invoke target " + target);
            }
        }
        else if (util.isArray(target)) {
            if (target.length >= 0) {
                var firstElem = target[0];
                if (this._isAgmInstance(firstElem)) {
                    serversToInvokeAgainst = target.map(function (instance) { return instance; });
                }
                else if (this._isActivityWindow(firstElem)) {
                    serversToInvokeAgainst = target.map(function (win) { return win.instance; });
                }
                else {
                    throw new Error("Unknown target object");
                }
            }
        }
        else {
            if (this._isAgmInstance(target)) {
                serversToInvokeAgainst = [target];
            }
            else if (this._isActivityWindow(target)) {
                serversToInvokeAgainst = [target.instance];
            }
            else {
                throw new Error("Unknown target object");
            }
        }
        return ActivityAGM.AGM.invoke(methodName, arg, serversToInvokeAgainst, options, success, error);
    };
    ActivityAGM.prototype.unregister = function (definition) {
        this._ensureHasAgm();
        return ActivityAGM.AGM.unregister(definition);
    };
    ActivityAGM.prototype.createStream = function (methodDefinition, subscriberAddedHandler, subscriberRemovedFunction) {
        this._ensureHasAgm();
        ActivityAGM.AGM.createStream(methodDefinition, subscriberAddedHandler, subscriberRemovedFunction);
    };
    ActivityAGM.prototype.subscribe = function (methodDefinition, parameters, target) {
        this._ensureHasAgm();
        var servers = this.servers();
        return ActivityAGM.AGM.subscribe(methodDefinition, parameters, servers);
    };
    ActivityAGM.prototype._ensureHasAgm = function () {
        if (util.isUndefinedOrNull(ActivityAGM.AGM)) {
            throw new Error("Agm should be configured to be used in activity");
        }
    };
    ActivityAGM.prototype._isAgmInstance = function (obj) {
        return obj.application != undefined;
    };
    ActivityAGM.prototype._isActivityWindow = function (obj) {
        return obj.instance !== undefined;
    };
    return ActivityAGM;
})();
exports.ActivityAGM = ActivityAGM;

},{"../helpers/util":29}],17:[function(require,module,exports){
/// <reference path="../../typings/es6-promise/es6-promise.d.ts"/>
var entityEvent_1 = require("../contracts/entityEvent");
var activityType_1 = require("../entities/activityType");
var promiseExtensions_1 = require("../helpers/promiseExtensions");
var readyMarker_1 = require("../helpers/readyMarker");
var entityObservableCollection_1 = require("../helpers/entityObservableCollection");
var logger_1 = require("../helpers/logger");
var util = require("../helpers/util");
var localWindowFactory_1 = require("./localWindowFactory");
var ActivityManager = (function () {
    function ActivityManager(bridge, autoAnnounce) {
        var _this = this;
        this._logger = logger_1.Logger.Get(this);
        this._announcedWindows = [];
        this._bridge = bridge;
        this._activityTypes = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._windowTypes = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._activities = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._windows = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._dataReadyMarker = new readyMarker_1.ReadyMarker("Activity Manager Data", ["GetActivityTypes", "GetWindowTypes", "GetActivities", "GetWindows"].length);
        if (autoAnnounce) {
            var announceMaker = new readyMarker_1.ReadyMarker("Activity Manager Announce", ["Announcement"].length);
            this._readyMarker = announceMaker;
            this._dataReadyMarker.setCallback(function (err) {
                if (err) {
                    _this._readyMarker.error(err);
                }
                _this._logger.debug("Auto announcing window");
                _this.announceWindow()
                    .then(function (w) {
                    _this._announcedWindows.push(w);
                    _this._readyMarker.signal("Successfully announced window with id '" + w.id + "'");
                })['catch'](function (err) {
                    _this._logger.debug("Will not announce window - " + err);
                    _this._readyMarker.signal();
                });
            });
        }
        else {
            this._readyMarker = this._dataReadyMarker;
        }
        this._bridge.init();
        this._bridge
            .ready()
            .then(function (aw) {
            _this._subscribeForData();
        })['catch'](function (error) {
            console.log(error);
        });
    }
    Object.defineProperty(ActivityManager.prototype, "announcedWindows", {
        get: function () {
            return this._announcedWindows;
        },
        set: function (v) {
            throw new Error("not allowed");
        },
        enumerable: true,
        configurable: true
    });
    ActivityManager.prototype.ready = function (callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this._readyMarker.setCallback(function (err) {
                if (!err) {
                    resolve(_this);
                }
                else {
                    reject(_this._readyMarker.getError());
                }
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getActivityTypes = function () {
        return this._activityTypes.get();
    };
    ActivityManager.prototype.getActivityType = function (name) {
        return this._activityTypes.getByName(name);
    };
    ActivityManager.prototype.registerActivityType = function (activityTypeName, ownerWindowType, helperWindowTypes, layoutConfig, description, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activityTypeName)) {
                reject("activityTypeName argument can not be undefined");
            }
            if (!util.isString(activityTypeName)) {
                reject("activityTypeName should be string");
            }
            var actType = _this.getActivityType(activityTypeName);
            if (!util.isUndefinedOrNull(actType)) {
                reject("Activity type '" + activityTypeName + "' already exists");
            }
            var ownerDefinition;
            if (util.isUndefined(ownerWindowType)) {
                reject("Owner window type can not be undefined");
            }
            if (util.isString(ownerWindowType)) {
                ownerDefinition = { type: ownerWindowType, name: "", isIndependent: false, arguments: {} };
            }
            else {
                ownerDefinition = ownerWindowType;
            }
            var helperDefinitions = [];
            if (!util.isUndefined(helperWindowTypes) && util.isArray(helperWindowTypes)) {
                for (var index in helperWindowTypes) {
                    var item = helperWindowTypes[index];
                    if (util.isString(item)) {
                        var definition = { type: item, name: "", isIndependent: false, arguments: {}, relativeTo: "", relativeDirection: "", windowStyleAttributes: {} };
                        helperDefinitions.push(definition);
                    }
                    else {
                        helperDefinitions.push(item);
                    }
                }
            }
            _this._bridge
                .registerActivityType(activityTypeName, ownerDefinition, helperDefinitions, layoutConfig, description)
                .then(function (activityType) {
                _this._grabEntity(activityType);
                resolve(activityType);
            })['catch'](function (error) {
                reject(error);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.unregisterActivityType = function (type, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var actType = _this.getActivityType(type);
            if (util.isUndefined(actType)) {
                reject("Activity type '" + type + "' does not exists");
            }
            return _this._bridge.unregisterActivityType(type);
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.initiate = function (activityType, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var actType = _this.getActivityType(activityType);
            if (util.isUndefined(actType)) {
                reject("Activity type '" + activityType + "' does not exists");
            }
            _this._bridge
                .initiateActivity(activityType, context)
                .then(function (actId) {
                _this._activities
                    .getOrWait(actId)
                    .then(function (act) {
                    resolve(act);
                })['catch'](function (err) { return reject(err); });
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.subscribeActivityTypeEvents = function (handler) {
        this._activityTypes.subscribe(function (at, context) {
            handler(at, context.type);
        });
    };
    ActivityManager.prototype.getWindowTypes = function () {
        return this._windowTypes.get();
    };
    ActivityManager.prototype.getWindowType = function (name) {
        return this._windowTypes.getByName(name);
    };
    ActivityManager.prototype.registerWindowFactory = function (windowType, factoryMethod, description, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowType)) {
                reject("no windowType specified");
                return;
            }
            if (util.isObject(windowType)) {
                windowType = windowType.getName();
            }
            else if (!util.isString(windowType)) {
                reject("windowType should be string or object that has getName method");
                return;
            }
            var factory = new localWindowFactory_1.LocalWindowFactory(factoryMethod, description);
            _this._bridge
                .registerWindowFactory(windowType, factory)
                .then(function (v) {
                resolve(v);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.unregisterWindowFactory = function (windowType, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowType)) {
                reject("no windowType specified");
                return;
            }
            if (!util.isString(windowType)) {
                reject("windowType should be a string");
                return;
            }
            _this._bridge
                .unregisterWindowFactory(windowType)
                .then(function (v) {
                resolve(v);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getActivities = function (activityType) {
        var act = this._activities.get();
        if (!activityType) {
            return act;
        }
        var types = activityType;
        if (util.isString(activityType)) {
            types = [activityType];
        }
        else if (activityType instanceof activityType_1['default']) {
            types = [activityType.name];
        }
        else if (activityType instanceof Array) {
        }
        else {
            throw new Error("Invalid input argument 'activityType' = " + activityType);
        }
        return act.filter(function (act) {
            var type = act.type;
            return util.some(types, function (t) {
                return type.id == t.id;
            });
        });
    };
    ActivityManager.prototype.getActivityById = function (id) {
        return this._activities.getByName(id);
    };
    ActivityManager.prototype.announceWindow = function (activityWindowId, windowType) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var announcementInfo = _this._bridge.getAnnouncementInfo();
            if (util.isUndefined(activityWindowId)) {
                activityWindowId = announcementInfo.activityWindowId;
            }
            if (util.isUndefined(windowType)) {
                windowType = announcementInfo.activityWindowType;
            }
            if (util.isUndefinedOrNull(windowType)) {
                throw new Error("Can not announce - unknown windowType");
            }
            if (util.isUndefinedOrNull(activityWindowId)) {
                _this._logger.debug("Registering window with type:'" + windowType + "', name:'" + announcementInfo.activityWindowName + "', ind.:'" + announcementInfo.activityWindowIndependent + "'");
                _this._bridge.registerWindow(windowType, announcementInfo.activityWindowName, announcementInfo.activityWindowIndependent)
                    .then(_this._windows.getOrWait.bind(_this._windows))
                    .then(function (w) {
                    resolve(w);
                })['catch'](function (err) {
                    _this._logger.error(err);
                });
            }
            else {
                _this._logger.debug("Announcing window with id '" + activityWindowId + "' and type '" + windowType + "'");
                var currentWindow = _this._windows.getByName(activityWindowId);
                if (!util.isUndefinedOrNull(currentWindow)) {
                    _this._logger.debug("Window with id '" + activityWindowId + "' already announced - reusing the window");
                    resolve(currentWindow);
                    return;
                }
                var windowEventHandler = function (a, w, e) {
                    if (activityWindowId === w.id) {
                        if (e === "joined") {
                            var activity = w.activity;
                            if (util.isUndefined(activity)) {
                                reject("UNDEFINED ACTIVITY");
                            }
                            _this._logger.trace("Got joined event for id '" + activityWindowId + "'");
                            resolve(w);
                            _this.unsubscribeWindowEvents(windowEventHandler);
                        }
                    }
                };
                _this.subscribeWindowEvents(windowEventHandler);
                _this._logger.trace("Waiting for joined event for id '" + activityWindowId + "'");
                _this._bridge.announceWindow(windowType, activityWindowId);
            }
        });
        return promise;
    };
    ActivityManager.prototype.subscribeWindowTypeEvents = function (handler) {
        this._windowTypes.subscribe(function (wt, context) {
            handler(wt, context.type);
        });
    };
    ActivityManager.prototype.subscribeActivityEvents = function (handler) {
        this._activities.subscribe(function (act, context) {
            if (context.type === entityEvent_1.EntityEventType.StatusChange) {
                var p = context;
                handler(act, p.newStatus, p.oldStatus);
            }
        });
    };
    ActivityManager.prototype.subscribeWindowEvents = function (handler) {
        this._windows.subscribe(function (window, context) {
            if (context.type === entityEvent_1.EntityEventType.ActivityWindowEvent) {
                var p = context;
                handler(window.activity, window, p.event);
            }
        });
    };
    ActivityManager.prototype.unsubscribeWindowEvents = function (handler) {
    };
    ActivityManager.prototype.createWindow = function (activity, windowType, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity is undefined");
            }
            if (util.isUndefinedOrNull(windowType)) {
                reject("windowType is undefined");
            }
            var windowDefinition;
            if (util.isString(windowType)) {
                windowDefinition = { type: windowType, name: "", isIndependent: false, arguments: {} };
            }
            else {
                windowDefinition = windowType;
            }
            var relativeToWindow;
            if (!util.isUndefinedOrNull(windowDefinition.relativeTo)) {
                relativeToWindow = windowDefinition.relativeTo;
                if (util.isString(relativeToWindow)) {
                    var windows = _this.getWindows({ type: relativeToWindow });
                    if (!util.isUndefinedOrNull(windows) && windows.length > 0) {
                        windowDefinition.relativeTo = windows[0].id;
                    }
                }
                else if (!util.isUndefinedOrNull(relativeToWindow.type)) {
                    var windows = _this.getWindows({ type: relativeToWindow.type });
                    if (!util.isUndefinedOrNull(windows) && windows.length > 0) {
                        windowDefinition.relativeTo = windows[0].id;
                    }
                }
                else if (!util.isUndefinedOrNull(relativeToWindow.windowId)) {
                    windowDefinition.relativeTo = relativeToWindow.windowId;
                }
            }
            _this._bridge.createWindow(activity.id, windowDefinition)
                .then(function (wid) {
                var window = _this._windows.getByName(wid);
                if (!util.isUndefined(window)) {
                    resolve(window);
                }
                _this._logger.debug("Window created, waiting for window entity with id " + wid);
                var handler = function (window, context) {
                    if (window.id === wid) {
                        this._logger.debug("Got entity window with id " + wid);
                        resolve(window);
                        this._windows.unsubscribe(handler);
                    }
                }.bind(_this);
                _this._windows.subscribe(handler);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.joinWindowToActivity = function (activity, window, callback) {
        return undefined;
    };
    ActivityManager.prototype.leaveWindowFromActivity = function (activity, window, callback) {
        return undefined;
    };
    ActivityManager.prototype.setActivityContext = function (activity, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity can not be null");
            }
            _this._bridge
                .updateActivityContext(activity, context, true)
                .then(function (obj) {
                resolve(obj);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.updateActivityContext = function (activity, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity can not be null");
            }
            var removedKeys = [];
            for (var key in context) {
                if (context.hasOwnProperty(key) && context[key] === null) {
                    removedKeys.push(key);
                }
            }
            _this._bridge
                .updateActivityContext(activity, context, false, removedKeys)
                .then(function (obj) {
                resolve(obj);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.subscribeActivityContextChanged = function (handler) {
        this._activities.subscribe(function (act, context) {
            if (context.type === entityEvent_1.EntityEventType.ActivityContextChange) {
                var updateContext = context;
                handler(act, updateContext.context, updateContext.updated, updateContext.removed);
            }
        });
    };
    ActivityManager.prototype.stopActivity = function (activity, callback) {
        var promise = this._bridge.stopActivity(activity);
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getWindows = function (filter) {
        if (util.isUndefined(filter)) {
            return this._windows.get();
        }
        if (!util.isUndefined(filter.id)) {
            return [this._windows.getByName(filter.id)];
        }
        var allWindows = this._windows.get();
        return allWindows.filter(function (w) {
            if (!util.isUndefined(filter.type) && w.type.id !== filter.type) {
                return false;
            }
            if (!util.isUndefined(filter.name) && w.name !== filter.name) {
                return false;
            }
            if (!util.isUndefined(filter.activityId)) {
                if (util.isUndefinedOrNull(w.activity)) {
                    return false;
                }
                if (w.activity.id !== filter.activityId) {
                    return false;
                }
            }
            return true;
        });
    };
    ActivityManager.prototype._grabEntity = function (entity) {
        entity.manager = this;
    };
    ActivityManager.prototype._subscribeForData = function () {
        var _this = this;
        this._logger.debug("Start getting initial data...");
        this._bridge.onActivityTypeStatusChange(function (event) {
            _this._activityTypes.process(event);
        });
        this._bridge.getActivityTypes()
            .then(function (at) {
            _this._activityTypes.add(at);
            _this._dataReadyMarker.signal("Got act types");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity types -" + error);
        });
        this._bridge.onWindowTypeStatusChange(function (event) {
            _this._windowTypes.process(event);
        });
        this._bridge.getWindowTypes()
            .then(function (wt) {
            _this._windowTypes.add(wt);
            _this._dataReadyMarker.signal("Got window types");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting window types  " + error);
        });
        this._bridge.onActivityStatusChange(function (event) {
            _this._activities.process(event);
        });
        this._bridge.getActivities()
            .then(function (ac) {
            _this._activities.add(ac);
            _this._dataReadyMarker.signal("Got activities");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity instances -" + error);
        });
        this._bridge.onActivityWindowChange(function (event) {
            _this._windows.process(event);
        });
        this._bridge.getActivityWindows()
            .then(function (aw) {
            _this._windows.add(aw);
            _this._dataReadyMarker.signal("Got windows");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity windows -" + error);
        });
    };
    ActivityManager.prototype.getWindowBounds = function (id) {
        return this._bridge.getWindowBounds(id);
    };
    ActivityManager.prototype.setWindowBounds = function (id, bounds, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this._bridge.setWindowBounds(id, bounds)
                .then(function () { return resolve(); })['catch'](function (err) { return reject(err); });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.closeWindow = function (id) {
        return this._bridge.closeWindow(id);
    };
    return ActivityManager;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityManager;

},{"../contracts/entityEvent":15,"../entities/activityType":22,"../helpers/entityObservableCollection":25,"../helpers/logger":26,"../helpers/promiseExtensions":27,"../helpers/readyMarker":28,"../helpers/util":29,"./localWindowFactory":18}],18:[function(require,module,exports){
var LocalWindowFactory = (function () {
    function LocalWindowFactory(createFunction, description) {
        this._createFunction = createFunction;
        this._description = description;
    }
    LocalWindowFactory.prototype.create = function (activityWindowId, context, layout) {
        return this._createFunction(activityWindowId, context, layout);
    };
    LocalWindowFactory.prototype.description = function () {
        return this._description;
    };
    return LocalWindowFactory;
})();
exports.LocalWindowFactory = LocalWindowFactory;

},{}],19:[function(require,module,exports){
var ProxyWindowFactory = (function () {
    function ProxyWindowFactory(description) {
        this._description = description;
    }
    ProxyWindowFactory.prototype.create = function (activityWindowId, context) {
        return undefined;
    };
    ProxyWindowFactory.prototype.description = function () {
        return this._description;
    };
    return ProxyWindowFactory;
})();
exports.ProxyWindowFactory = ProxyWindowFactory;

},{}],20:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var activityAGM_1 = require("../core/activityAGM");
var Activity = (function (_super) {
    __extends(Activity, _super);
    function Activity(id, actType, status, context, owner, helperWindows) {
        _super.call(this, id);
        this._id = id;
        this._actType = actType;
        this._status = status;
        this._context = context;
        this._owner = owner;
        this._helperWindows = helperWindows;
        this._agm = new activityAGM_1.ActivityAGM(this);
    }
    Object.defineProperty(Activity.prototype, "type", {
        get: function () {
            if (this.manager) {
                return this.manager.getActivityType(this._actType);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "context", {
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "status", {
        get: function () {
            return this._status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "owner", {
        get: function () {
            return this._owner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "windows", {
        get: function () {
            return this.manager.getWindows({ activityId: this._id });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "agm", {
        get: function () {
            return this._agm;
        },
        enumerable: true,
        configurable: true
    });
    Activity.prototype.join = function (window, callback) {
        return this.manager.joinWindowToActivity(this, window, callback);
    };
    Activity.prototype.createWindow = function (windowType, callback) {
        return this.manager.createWindow(this, windowType, callback);
    };
    Activity.prototype.leave = function (window, callback) {
        return this.manager.leaveWindowFromActivity(this, window, callback);
    };
    Activity.prototype.getWindowsByType = function (windowType) {
        var filter = { activityId: this._id, type: windowType };
        return this.manager.getWindows(filter);
    };
    Activity.prototype.setContext = function (context, callback) {
        return this.manager.setActivityContext(this, context, callback);
    };
    Activity.prototype.updateContext = function (context, callback) {
        return this.manager.updateActivityContext(this, context, callback);
    };
    Activity.prototype.onStatusChange = function (handler) {
        var _this = this;
        this.manager.subscribeActivityEvents(function (a, ns, os) {
            if (a.id === _this.id) {
                handler(a, ns, os);
            }
        });
    };
    Activity.prototype.onWindowEvent = function (handler) {
        var _this = this;
        this.manager.subscribeWindowEvents(function (a, w, e) {
            if (a.id === _this.id) {
                handler(a, w, e);
            }
        });
    };
    Activity.prototype.onContextChanged = function (handler) {
        var _this = this;
        this.manager.subscribeActivityContextChanged(function (act, context, delta, removed) {
            if (act.id === _this.id) {
                handler(context, delta, removed, act);
            }
        });
        handler(this.context, this.context, [], this);
    };
    Activity.prototype.stop = function () {
        this.manager.stopActivity(this);
    };
    Activity.prototype.updateCore = function (activity) {
        _super.prototype.updateCore.call(this, activity);
        this._actType = activity._actType;
        this._context = activity._context;
        this._status = activity._status;
        this._helperWindows = activity._helperWindows;
        this._owner = activity._owner;
    };
    return Activity;
})(activityEntity_1['default']);
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= Activity;

},{"../core/activityAGM":16,"./activityEntity":21}],21:[function(require,module,exports){
var ActivityEntity = (function () {
    function ActivityEntity(id) {
        this.listeners = [];
        this._id = id;
    }
    Object.defineProperty(ActivityEntity.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    ActivityEntity.prototype.onUpdated = function (handler) {
        this.listeners.push(handler);
    };
    ActivityEntity.prototype.update = function (other) {
        if (other._id != this._id) {
            throw Error("Can not update from entity with different id.");
        }
        this.updateCore(other);
        this.notify();
    };
    ActivityEntity.prototype.updateCore = function (other) {
    };
    ActivityEntity.prototype.notify = function () {
        for (var index = 0; index < this.listeners.length; index++) {
            var listener = this.listeners[index];
            listener(this);
        }
    };
    return ActivityEntity;
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityEntity;

},{}],22:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var ActivityType = (function (_super) {
    __extends(ActivityType, _super);
    function ActivityType(name, ownerWindow, helperWindows, description) {
        _super.call(this, name);
        this._name = name;
        this._description = description;
        this._ownerWindow = ownerWindow;
        this._helperWindows = helperWindows || [];
    }
    Object.defineProperty(ActivityType.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "description", {
        get: function () {
            return this._description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "helperWindows", {
        get: function () {
            return this._helperWindows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "ownerWindow", {
        get: function () {
            return this._ownerWindow;
        },
        enumerable: true,
        configurable: true
    });
    ActivityType.prototype.subscribeActivityStatusChange = function (handler) {
        return undefined;
    };
    ActivityType.prototype.initiate = function (context, callback) {
        return this.manager.initiate(this._name, context, callback);
    };
    ActivityType.prototype.updateCore = function (type) {
        _super.prototype.updateCore.call(this, type);
        this._description = type._description;
        this._ownerWindow = type._ownerWindow;
        this._helperWindows = type._helperWindows;
    };
    return ActivityType;
})(activityEntity_1['default']);
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityType;

},{"./activityEntity":21}],23:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var logger_1 = require("../helpers/logger");
var util = require("../helpers/util");
var ActivityWindow = (function (_super) {
    __extends(ActivityWindow, _super);
    function ActivityWindow(id, name, type, activityId, instance, isIndependent) {
        _super.call(this, id);
        this._logger = logger_1.Logger.Get(this);
        this._type = type;
        this._activityId = activityId;
        this._name = name;
        this._instance = instance;
        this._isIndependent = isIndependent;
    }
    ActivityWindow.prototype.getBounds = function () {
        return this.manager.getWindowBounds(this.id);
    };
    Object.defineProperty(ActivityWindow.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "isIndependent", {
        get: function () {
            return this._isIndependent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "type", {
        get: function () {
            if (this.manager) {
                return this.manager.getWindowType(this._type);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "activity", {
        get: function () {
            if (util.isUndefined(this._activityId)) {
                return undefined;
            }
            return this.manager.getActivityById(this._activityId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "isOwner", {
        get: function () {
            var act = this.activity;
            if (util.isUndefined(act)) {
                return false;
            }
            return act.owner.id === this.id;
        },
        enumerable: true,
        configurable: true
    });
    ActivityWindow.prototype.setVisible = function (isVisible, callback) {
        return undefined;
    };
    ActivityWindow.prototype.setTitle = function (title, callback) {
        return undefined;
    };
    ActivityWindow.prototype.setBounds = function (bounds, callback) {
        return this.manager.setWindowBounds(this.id, bounds, callback);
    };
    ActivityWindow.prototype.setState = function (state, callback) {
        return undefined;
    };
    ActivityWindow.prototype.close = function () {
        return this.manager.closeWindow(this.id);
    };
    Object.defineProperty(ActivityWindow.prototype, "instance", {
        get: function () {
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    ActivityWindow.prototype.onActivityJoined = function (callback) {
        this._subscribeForActivityWindowEvent("joined", callback);
    };
    ActivityWindow.prototype.onActivityRemoved = function (callback) {
        this._subscribeForActivityWindowEvent("removed", callback);
    };
    ActivityWindow.prototype.updateCore = function (other) {
        this._activityId = other._activityId;
        this._isIndependent = other._isIndependent;
        if (!util.isUndefinedOrNull(other._instance)) {
            this._instance = other._instance;
        }
    };
    ActivityWindow.prototype._subscribeForActivityWindowEvent = function (eventName, callback) {
        var _this = this;
        this.manager.subscribeWindowEvents(function (activity, window, event) {
            if (window.id !== _this.id) {
                return;
            }
            if (event === eventName) {
                callback(activity);
            }
        });
    };
    return ActivityWindow;
})(activityEntity_1['default']);
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityWindow;

},{"../helpers/logger":26,"../helpers/util":29,"./activityEntity":21}],24:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var WindowType = (function (_super) {
    __extends(WindowType, _super);
    function WindowType(name, factories) {
        _super.call(this, name);
        this._name = name;
        this._factories = factories;
    }
    Object.defineProperty(WindowType.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowType.prototype, "factories", {
        get: function () {
            return this._factories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowType.prototype, "windows", {
        get: function () {
            return this.manager.getWindows({ type: this._name });
        },
        enumerable: true,
        configurable: true
    });
    WindowType.prototype.registerFactory = function (factory, factoryMethod, description, callback) {
        return this.manager.registerWindowFactory(this, factoryMethod, description);
    };
    return WindowType;
})(activityEntity_1['default']);
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= WindowType;

},{"./activityEntity":21}],25:[function(require,module,exports){
var entityEvent_1 = require("../contracts/entityEvent");
var EntityObservableCollection = (function () {
    function EntityObservableCollection(processNew) {
        this._items = {};
        this._listeners = [];
        this._processNew = processNew;
    }
    EntityObservableCollection.prototype.addOne = function (item) {
        this.add([item]);
    };
    EntityObservableCollection.prototype.add = function (items) {
        for (var index = 0; index < items.length; index++) {
            var element = items[index];
            this.process(new entityEvent_1.EntityEvent(element, new entityEvent_1.EntityEventContext(entityEvent_1.EntityEventType.Added)));
        }
    };
    EntityObservableCollection.prototype.process = function (event) {
        var context = event.context;
        var type = context.type;
        var entity = event.entity;
        var internalEntity = this._updateInternalCollections(entity, type);
        this._notifyListeners(internalEntity, context);
    };
    EntityObservableCollection.prototype.get = function () {
        var result = [];
        for (var key in this._items) {
            if (this._items.hasOwnProperty(key)) {
                var element = this._items[key];
                result.push(element);
            }
        }
        return result;
    };
    EntityObservableCollection.prototype.getByName = function (name) {
        for (var key in this._items) {
            if (key === name) {
                return this._items[key];
            }
        }
        return undefined;
    };
    EntityObservableCollection.prototype.getOrWait = function (name) {
        var _this = this;
        return new Promise(function (resolve) {
            var entityAddedHandler = function (entity) {
                if (entity.id !== name) {
                    return;
                }
                resolve(entity);
                _this.unsubscribe(entityAddedHandler);
            };
            _this.subscribe(entityAddedHandler);
            var window = _this.getByName(name);
            if (window) {
                resolve(window);
                return;
            }
        });
    };
    EntityObservableCollection.prototype.subscribe = function (handler) {
        this._listeners.push(handler);
        for (var key in this._items) {
            var element = this._items[key];
            handler(element, new entityEvent_1.EntityEventContext(entityEvent_1.EntityEventType.Added.toString()));
        }
    };
    EntityObservableCollection.prototype.unsubscribe = function (handler) {
        var index = this._listeners.indexOf(handler);
        if (index != -1) {
            this._listeners.splice(index, 1);
        }
    };
    EntityObservableCollection.prototype._notifyListeners = function (entity, context) {
        for (var index = 0; index < this._listeners.length; index++) {
            var listener = this._listeners[index];
            listener(entity, context);
        }
    };
    EntityObservableCollection.prototype._updateInternalCollections = function (entity, type) {
        if (type === entityEvent_1.EntityEventType.Removed) {
            delete this._items[entity.id];
            return entity;
        }
        else {
            var key = entity.id;
            if (!this._items.hasOwnProperty(key)) {
                this._processNew(entity);
                this._items[entity.id] = entity;
            }
            else {
                this._items[entity.id].update(entity);
            }
        }
        return this._items[entity.id];
    };
    return EntityObservableCollection;
})();
exports.EntityObservableCollection = EntityObservableCollection;

},{"../contracts/entityEvent":15}],26:[function(require,module,exports){
var util = require("./util");
var LogLevel = (function () {
    function LogLevel() {
    }
    LogLevel.Trace = "trace";
    LogLevel.Debug = "debug";
    LogLevel.Info = "info";
    LogLevel.Warn = "warn";
    LogLevel.Error = "error";
    return LogLevel;
})();
exports.LogLevel = LogLevel;
var Logger = (function () {
    function Logger(name) {
        this._name = name;
        if (!util.isUndefinedOrNull(Logger.GlueLogger)) {
            this._glueLogger = Logger.GlueLogger.subLogger(name);
        }
    }
    Logger.GetNamed = function (name) {
        return new Logger(name);
    };
    Logger.Get = function (owner) {
        return new Logger(Logger.GetTypeName(owner));
    };
    Logger.prototype.trace = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.trace(message);
        }
        else {
            if (Logger.Level === LogLevel.Trace) {
                console.info(this._getMessage(message, LogLevel.Trace));
            }
        }
    };
    Logger.prototype.debug = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.debug(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace) {
                console.info(this._getMessage(message, LogLevel.Debug));
            }
        }
    };
    Logger.prototype.info = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.info(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace ||
                Logger.Level === LogLevel.Info) {
                console.info(this._getMessage(message, LogLevel.Info));
            }
        }
    };
    Logger.prototype.warn = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.warn(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace ||
                Logger.Level === LogLevel.Info ||
                Logger.Level === LogLevel.Warn) {
                console.info(this._getMessage(message, LogLevel.Info));
            }
        }
    };
    Logger.prototype.error = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.error(message);
        }
        else {
            console.error(this._getMessage(message, LogLevel.Error));
            console.trace();
        }
    };
    Logger.prototype._getMessage = function (message, level) {
        return "[" + level + "] " + this._name + " - " + message;
    };
    Logger.GetTypeName = function (object) {
        var funcNameRegex = /function (.{1,})\(/;
        var results = (funcNameRegex).exec(object.constructor.toString());
        return (results && results.length > 1) ? results[1] : "";
    };
    Logger.Level = LogLevel.Info;
    return Logger;
})();
exports.Logger = Logger;

},{"./util":29}],27:[function(require,module,exports){
var util = require("../helpers/util");
var nextTick = function (cb) { setTimeout(cb, 0); };
function nodeify(promise, callback) {
    if (!util.isFunction(callback)) {
        return promise;
    }
    promise.then(function (resp) {
        nextTick(function () {
            callback(null, resp);
        });
    }, function (err) {
        nextTick(function () {
            callback(err, null);
        });
    });
}
exports.nodeify = nodeify;
;

},{"../helpers/util":29}],28:[function(require,module,exports){
var logger_1 = require("./logger");
var util = require("../helpers/util");
var ReadyMarker = (function () {
    function ReadyMarker(name, signalsToWait) {
        this._logger = logger_1.Logger.GetNamed("ReadyMarker [" + name + "]");
        this._logger.debug("Initializing ready marker for '" + name + "' with " + signalsToWait + " signals to wait");
        if (signalsToWait <= 0) {
            throw new Error("Invalid signal number. Should be > 0");
        }
        this._signals = signalsToWait;
        this._callbacks = [];
        this._name = name;
    }
    ReadyMarker.prototype.setCallback = function (callback) {
        if (this.isSet()) {
            callback(undefined);
            return;
        }
        else if (this.isError()) {
            callback(this._error);
            return;
        }
        this._callbacks.push(callback);
    };
    ReadyMarker.prototype.signal = function (message) {
        this._logger.debug("Signaled - " + message + " - signals left " + (this._signals - 1));
        this._signals--;
        if (this._signals < 0) {
            throw new Error("Error in ready marker '" + this._name + " - signals are " + this._signals);
        }
        if (this.isSet()) {
            this._callbacks.forEach(function (callback) {
                callback(undefined);
            });
        }
    };
    ReadyMarker.prototype.error = function (error) {
        this._error = error;
        this._callbacks.forEach(function (errorCallback) {
            errorCallback(error);
        });
    };
    ReadyMarker.prototype.isSet = function () {
        if (this.isError()) {
            return false;
        }
        return this._signals === 0;
    };
    ReadyMarker.prototype.isError = function () {
        return !util.isUndefined(this._error);
    };
    ReadyMarker.prototype.getError = function () {
        return this._error;
    };
    return ReadyMarker;
})();
exports.ReadyMarker = ReadyMarker;

},{"../helpers/util":29,"./logger":26}],29:[function(require,module,exports){
// some small useful functions (so we don't reference underscore or lodash)
function isNumber(arg) {
    return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === 'string';
}
exports.isString = isString;
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isArray(arg) {
    if (Array.isArray) {
        return Array.isArray(arg);
    }
    return toString.call(arg) === '[object Array]';
}
exports.isArray = isArray;
function isUndefined(arg) {
    return typeof arg === 'undefined';
}
exports.isUndefined = isUndefined;
function isUndefinedOrNull(arg) {
    return !arg || typeof arg === 'undefined';
}
exports.isUndefinedOrNull = isUndefinedOrNull;
function isEmpty(arg) {
    for (var prop in arg) {
        if (arg.hasOwnProperty(prop))
            return false;
    }
    return true;
}
exports.isEmpty = isEmpty;
function isFunction(arg) {
    return !!(arg && arg.constructor && arg.call && arg.apply);
}
exports.isFunction = isFunction;
;
function some(array, predicate) {
    for (var index = 0; index < array.length; index++) {
        if (predicate(array[index], index)) {
            return true;
        }
    }
    return false;
}
exports.some = some;
function first(array, predicate) {
    for (var index = 0; index < array.length; index++) {
        if (predicate(array[index], index)) {
            return array[index];
        }
    }
    return undefined;
}
exports.first = first;

},{}],30:[function(require,module,exports){
(function (global){
var connection = require("tick42-gateway-connection");
var client = require("./agm_client");
var server = require("./agm_server"); 
var instance = require("./agm_instance");
var native_agm = require("./agm_native");
//var add_sugar= require("./agm_sugar");
//Init namespace if not already there 



//Add a global function that makes an AGM instance
agm = function(configuration){
	"use strict";
	
	//We will store the library here
	var agm = {};
    
	agm.version = "2.1.1";
	
	//Init debug
	if(typeof configuration!=="object"){configuration = {};}
   
   	//Init child configuration if it is not already passed by user
   	var child_configurations = ["connection", "client", "server"];
	child_configurations.forEach(function(conf){
		if(typeof configuration[conf]!=="object"){configuration[conf] = {};}
		//Set debug if global debug is not set:
		if(configuration.debug){configuration[conf].debug = true;}
	});
	
	//Init connection
	var c = configuration.connection;
  	//Determine if we are given a connection object. If not, create it ourselves:
	agm.connection =(typeof c==="object"&&typeof c.send==="function"&&typeof c.on ==="function")?c:connection(configuration.connection);
	
	//Create a connection proxy which sets the product name automatically
	var product_name = "agm";
	var agm_enabled_connection = {
    send:function(type, message){
        agm.connection.send(product_name, type, message);
    },
    on:function(type, handler){
        agm.connection.on(product_name, type, handler);
    }
	
	};
	 
	//Save a reference to the root system object that we are given
	var metrics_root = configuration.metrics;
	
	//Create subsystems for our modules and save them in their configuration.
	if(metrics_root !== undefined){
		configuration.client.metrics = metrics_root.subSystem("Client");
		configuration.server.metrics = metrics_root.subSystem("Server");
	} 
	
    //Initialize our modules
  	agm.instance = instance(configuration.instance, agm_enabled_connection);
	agm.client = client(agm_enabled_connection, agm.instance, configuration.client);
	agm.server = server(agm_enabled_connection, agm.instance, configuration.server);

	//Add method aliases
	agm.invoke=agm.client.invoke;
	agm.register=agm.server.register;
	agm.unregister=agm.server.unregister;
	agm.servers=agm.client.servers;
	agm.methods=agm.client.methods;
	agm.methods_for_instance=agm.client.methods_for_instance;
	agm.methodsForInstance=agm.client.methods_for_instance;
    agm.method=agm.client.method;
	agm.method_added=agm.client.method_added;
	agm.methodAdded=agm.client.method_added;
	agm.method_removed=agm.client.method_removed;
	agm.methodRemoved=agm.client.method_removed;

	agm.server_method_added=agm.client.server_method_added;
	agm.serverMethodAdded=agm.client.server_method_added;
	agm.server_method_removed=agm.client.server_method_removed;
	agm.serverMethodRemoved=agm.client.server_method_removed;

	agm.server_added=agm.client.server_added;
	agm.serverAdded=agm.client.server_added;
	agm.server_removed=agm.client.server_removed;
	agm.serverRemoved=agm.client.server_removed;

	agm.start = agm.server.start;
	agm.stop = agm.server.stop;
	
    if(global.console!==undefined && agm.debug===true){
	    console.log("AGM started.");
    }
	
	return agm;
    //return add_sugar(agm);

};

agm = global.htmlContainer!==undefined?native_agm:agm;

//Export for browsers
if(global.tick42===undefined){global.tick42 = {};}
global.tick42.agm = agm;

module.exports = agm;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_client":31,"./agm_instance":36,"./agm_native":37,"./agm_server":38,"tick42-gateway-connection":50}],31:[function(require,module,exports){
(function (global){
/*
 The AGM Client analyses server presences, collects information about their methods and allows users to invoke these methods.
 */
var client_serverstate = require('./agm_client_serverstate');
var client_invocationsstate = require('./agm_client_invocationsstate');
var helpers = require('./agm_helpers');
module.exports = function (connection, instance, configuration) {
    //Validate configuration
    if (typeof configuration !== 'object') {
        configuration = {};
        if (global.console !== undefined && configuration.debug === true) {
            console.log('Creating an AGM client with default configuration.');
        }
    }
    if (typeof configuration.remove_server_on_n_missing_heartbeats !== 'number') {
        configuration.remove_server_on_n_missing_heartbeats = 3;
    }
    if (typeof configuration.method_response_timeout !== 'number') {
        configuration.method_response_timeout = 3000;
    }
    if (typeof configuration.wait_for_method_timeout !== 'number') {
        configuration.wait_for_method_timeout = 3000;
    }
    //Instantiate the module which keeps track of all available servers and methods
    var servers = client_serverstate(configuration, instance);
    //..and when you receive a heartbeat/presence from a server, delegate its processing to the module:
    connection.on('ServerPresenceMessage', function(msg){servers.process_presence(msg, true);});
    connection.on('ServerHeartbeatMessage', function(msg){servers.process_presence(msg, false);});
    //Instantiate the module that handles method execution and responses
    var response = client_invocationsstate(configuration, instance, function (m) {
        connection.send('MethodInvocationRequestMessage', m);
    });
    //..and delegate responses to it.
    connection.on('MethodInvocationResultMessage', response.process_method_response);




//   //Adds client callbacks which are executed when a new method is added or stops being available
//   function method_added(callback) {
//     if (typeof callback === 'function') {
//       //Add the callback
//       configuration.on_method_added = callback;
//       //Call the callback for all the method which were added before the callback was registered.
//       servers.get_methods().forEach(function (method) {
//         callback(method);
//       });
//     } else {
//       throw '\'method_added\' must be called with a function as an argument';
//     }
//   }
//   function method_removed(callback) {
//     if (typeof callback === 'function') {
//       //Add the callback
//       configuration.on_method_removed = callback;
//     } else {
//       throw '\'method_removed\' must be called with a function as an argument';
//     }
//   }

//   //Adds client callbacks which are executed when a new method is added or stops being available
//   function server_added(callback) {
//     if (typeof callback === 'function') {
//       //Add the callback
//       configuration.on_server_added = callback;
//       //Call the callback for all the method which were added before the callback was registered.
//       servers.get_servers().forEach(function (server) {
//         callback(server);
//       });
//     } else {
//       throw '\'server_added\' must be called with a function as an argument';
//     }
//   }
//   function server_removed(callback) {
//     if (typeof callback === 'function') {
//       //Add the callback
//       configuration.on_server_removed = callback;
//     } else {
//       throw '\'server_removed\' must be called with a function as an argument';
//     }
//   }
    //Abstract get_method and get_servers functions
    //They rely on  get_method and get_servers from the "servers" module
    //In those ones you don't need to specify all of the method's props to find it.
    function get_method(method_filter) {
        if (typeof method_filter === 'string') {
            method_filter = { name: method_filter };
        }
        //Do not execute for empty filter
        if (method_filter === undefined) {
            return;
        }
        var exact_match = servers.get_method(method_filter);
        //Try calling the original "get_method" function (it will work if all method properties are specified):
        if (exact_match !== undefined) {
            return exact_match  //Take all available methods and iterate them until we find a match
              ;
        } else {
            return takeWhile(servers.get_methods(), function (method) {
                return method_match(method_filter, method);
            });
        }
    }
    function get_methods(method_filter) {
        if (method_filter === undefined) {
            return servers.get_methods();
        }
        if (typeof method_filter === 'string') {
            method_filter = { name: method_filter };
        }
        return servers.get_methods().filter(function (method) {
            return method_match(method_filter, method);
        });
    }

    //Retrieves all servers that support any of several methods, listed as an array
    function get_methods_for_instance(instance_filter) {
        var exact_match = servers.get_methods(instance_filter);
        //Try calling the original "get_methods" function (it will work if all instance properties are specified):
        if (exact_match.length !== 0) {
            return exact_match;
        } else {
            var method_ids = get_servers().filter(function (server) {
                return instance_match(instance_filter, server);
            }).reduce(function (methods, server) {
                servers.get_method_ids(server).forEach(function (method_id) {
                    methods[method_id] = true;
                });
                return methods;
            }, {});
            return Object.keys(method_ids).map(function (method_id) {
                return servers.get_method(method_id);
            });
        }
    }

    //Retrieves all servers that support a given method
    function get_servers(method_filter) {
        //No method - get all servers
        if (method_filter === undefined) {
            return servers.get_servers();
        }
        //Non-existing method - return an empty array
        var method = get_method(method_filter);
        if (method === undefined) {
            return [];
        }
        //Else, return servers for method
        return servers.get_servers(method);
    }


    //Retrieves all servers that support any of several methods, listed as an array
    function servers_for_methods(methods){
        return methods.reduce(function (so_far, method) {
            return so_far.concat(servers.get_servers(method, true));//(the second argument is there because we also need the request subject)
        }, []).sort(servers.compare_servers);
    }

    function servers_for_method_and_target(method_filter, target){
        //Get the methods which match the filter
        var methods = get_methods(method_filter);
        //Determine where to execute the method(s) (the "target" argument)
        //Get all servers that support the method(s) and get the ones that match the target criteria
        return filter_by_target(target, servers_for_methods(methods));
    }





    //Invokes an AGM method (mostly it does input checking), the actual job is done by "request.invoke"
    function invoke(method_filter, argument_obj, target, additional_options, success, error) {
        var promise = new Promise(function (resolve, reject) {
            var successProxy, errorProxy;

            successProxy = function (args) {
                //var parsed = JSON.parse(args);
                resolve(args);
            };
            errorProxy = function (args) {
                //var parsed = JSON.parse(args);
                reject(args);
            };
            //Add default params
            if (argument_obj === undefined) {
                argument_obj = {};
            }
            if (target === undefined) {
                target = 'best';
            }
            if (typeof target === "string" && target !== "all" && target !== "best") {
                reject({message: '"' + target + '" is not a valid target. Valid targets are "all" and "best".'});
            }
            if (additional_options === undefined) {
                additional_options = {};
            }

            if (additional_options.method_response_timeout === undefined) {
                additional_options.method_response_timeout = configuration.method_response_timeout;
            }
            if (additional_options.wait_for_method_timeout === undefined) {
                additional_options.wait_for_method_timeout = configuration.wait_for_method_timeout;
            }


            //Check if the arguments are an object
            if (typeof argument_obj !== 'object') {
                reject({message: 'The method arguments must be an object.'});
            }

            if (typeof method_filter === 'string') {
                method_filter = {name: method_filter};
            }

            var servers = servers_for_method_and_target(method_filter, target);

            if (servers.length === 0) {

                invoke_unexisting(method_filter, argument_obj, target, additional_options, successProxy, errorProxy);

            } else if (servers.length === 1) {
                if (global.console !== undefined && configuration.debug === true) {
                    console.log('>>> Invoking "' + method_filter.name + '" on 1 server');
                }

                response.invoke(method_filter, argument_obj, servers[0], additional_options, successProxy, errorProxy);

            } else {
                if (global.console !== undefined && configuration.debug === true) {
                    console.log('>>> Invoking "' + method_filter.name + '" on ' + servers.length + ' servers');
                }

                invoke_on_all(method_filter, argument_obj, servers, additional_options, successProxy, errorProxy);
            }
        });

        return helpers.promisify(promise, success, error);
    }


    //Called when the user tries to invoke a method which does not exist
    function invoke_unexisting(method_filter, argument_obj, target, additional_options, success, error){
        var server_found = false;

        if(additional_options.wait_for_method_timeout === 0){
            call_error();
        }else{
            setTimeout(function(){
                configuration.server_method_added = configuration.server_method_added.filter(function(callback){return callback !== new_server;});
                if(!server_found){call_error();}
            },additional_options.wait_for_method_timeout);

            register_callback("server_method_added", identity, new_server);
        }



        function new_server(){
            if(server_found){return;}
            var server = servers_for_method_and_target(method_filter, target)[0];
            if(server !== undefined){
                server_found = true;
                response.invoke(method_filter, argument_obj, server, additional_options, success, error);
            }
        }



        function call_error(){
            //Check if the method exists and if it doesnt', return an error
            if (get_methods(method_filter).length === 0) {
                error({
                    method: method_filter,
                    called_with: argument_obj,
                    message: 'I could not find a method with those properties: ' + JSON.stringify(method_filter)
                });
            } else {
                error({
                    method: method_filter,
                    called_with: argument_obj,
                    message: 'I could not find servers with these properties: ' + JSON.stringify(target)
                });
                return;
            }
        }

    }


    //Called when the invokes a method with multiple targets
    //Calls a method for all servers and unifies the results they return into one:
    function invoke_on_all(method, argument_obj, servers, additional_options, success, error){
        //Here we will store the results that the servers return
        var successes = [];
        var errors = [];
        //These are the callbacks
        var success_callback = function (result) {
            successes.push(result);
            send_response(successes, errors);
        };
        var error_callback = function (result) {
            errors.push(result);
            send_response(successes, errors);
        };
        //Call the method for all targets
        servers.forEach(function (server) {
            response.invoke(method, argument_obj, server, additional_options, success_callback, error_callback);
        });


        //Calls the main success and error callbacks with the aggregated results
        function send_response() {
            //wait till everybody is finished
            if (successes.length + errors.length < servers.length) {
                return;
            }
            //Execute the "success" callback
            if (successes.length !== 0) {
                var result = successes.reduce(function (obj, success) {
                    obj.method = success.method;
                    obj.called_with = success.called_with;
                    obj.returned = success.returned;
                    obj.all_return_values.push({
                        executed_by: success.executed_by,
                        returned: success.returned
                    });
                    obj.executed_by = success.executed_by;
                    return obj;
                }, { all_return_values: [] });

                //If we get errors from one of the servers add them to the success object that will be resolved.
                if (errors.length !== 0) {
                    result.all_errors = [];
                    errors.forEach(function (obj) {
                        result.all_errors.push({
                            //executed_by : obj.executed_by, // we don't get executed_by object from the error response
                            name : obj.method.name,
                            message : obj.message
                        });
                    });
                }

                success(result);

            }else if (errors.length !== 0) { //Execute the "error" callback
                error(errors.reduce(function (obj, error) {
                    obj.method = error.method;
                    obj.called_with = error.called_with;
                    obj.message = error.message;
                    obj.all_errors.push({
                        executed_by: error.executed_by,
                        message: error.message
                    });
                    //obj.executed_by = success.executed_by;
                    return obj;
                }, { all_errors: [] }));
            }
        }
    }





    var register_callback = helpers.save_callback_in.bind(this, configuration);

    var apply_on_servers = apply_on.bind(null, servers.get_servers);
    var apply_on_methods = apply_on.bind(null, servers.get_methods);
    var identity = function(a){return a;};

    return {
        invoke: invoke,
        method: get_method,
        servers: get_servers,
        methods: get_methods,
        methods_for_instance: get_methods_for_instance,
        method_added: register_callback.bind(null, "method_added", apply_on_methods),
        method_removed: register_callback.bind(null, "method_removed", identity),
        server_added: register_callback.bind(null, "server_added", apply_on_servers),
        server_removed: register_callback.bind(null, "server_removed", identity),
        server_method_added: register_callback.bind(null, "server_method_added", identity),
        server_method_removed: register_callback.bind(null, "server_method_removed", identity),
        parse_signature: helpers.signature_parse_friendly
    };
};




//Filters an array of servers and returns the ones which match the target criteria
function filter_by_target(target, servers){
    //If the user specified target as string:
    if (typeof target === 'string') {
        if (target === 'all') {
            target = servers;
        } else if (target === 'best') {
            target = servers[0]!==undefined?[servers[0]]:[];  //If the user specified the target as server filter
        }
    } else {
        if (target.constructor.name !== 'Array') {
            target = [target];
        }
        var unexisting_servers = [];
        //Retrieve all servers that match the filters
        target = target.reduce(function (matches, filter) {
            //Add matches for each filter
            var my_matches = servers.filter(function (server) {
                return instance_match(filter, server);
            });
            return matches.concat(my_matches);
        }, []);
    }
    return target;
}




//Matches a server definition against a server filter
function instance_match(instance_filter, instance_definition) {
    return contains_props(instance_filter, instance_definition);
}


//Matches a method definition against a method filter
function method_match(method_filter, method_definition) {
    [
        'accepts',
        'returns'
    ].forEach(function (prop) {
        if (method_filter[prop] !== undefined) {
            method_filter[prop] = helpers.signature_normalize(method_filter[prop]);
        }
    });
    return contains_props(method_filter, method_definition);
}


//Helpers

/*
 function contains_props(filter, object) {
 var match = true;
 Object.keys(filter).forEach(function (prop) {
 if (String(filter[prop]).toLowerCase() !== String(object[prop]).toLowerCase()) {
 match = false;
 }
 });
 return match;
 }
 */

function contains_props(filter, object) {
    return Object.keys(filter).reduce(function (match, prop) {
        if (filter[prop].constructor === RegExp){
            if(!filter[prop].test(object[prop])) {return false;}
            else{return match;}
        } else {
            if(String(filter[prop]).toLowerCase() !== String(object[prop]).toLowerCase()){return false;}
            else{return match;}
        }
    }, true);
}



function takeWhile(array, pred) {
    var sz = array.length;
    for (var index = 0; index < sz; index++) {
        if (pred(array[index]) === true) {
            break;
        }
    }
    return array[index];
}


function apply_on(objects, func){
    return objects().map(func);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_client_invocationsstate":32,"./agm_client_serverstate":34,"./agm_helpers":35}],32:[function(require,module,exports){
(function (global){
/*
The Invcationsstate module handles AGM method invocations. via the 'invoke' method
It sends and receives all invocation-related messages, via the "process_response" method
that it exposes and via the "send_request" callback 

*/

var helpers = require("./agm_helpers");

module.exports = function(configuration, instance, send_request){
    "use strict";
	
	//Here we store all pending callbacks
    var pending_callbacks = {};
	
	
	//Invokes an AGM method to a single AGM server, given valid input.
	function invoke(method, argument_obj, target, stuff, success, error){
		 //Generate a unique invocation ID, for this invocation
         var invocation_id = Math.floor(Math.random()*10000000000);
        
        //Register the user's callbacks
        register_invocation(invocation_id, {method:method, called_with:argument_obj},success, error, stuff.method_response_timeout);

        //Get a response subject for this invocation
        instance.response_subject(method, function(response_subject){
             
             //Construct a message
             var message = {
                     MethodRequestSubject:target.request_subject,
                     MethodResponseSubject:response_subject,
                     Client:instance.info(),
                     Context:{
                         Arguments: helpers.parameters_stringify(argument_obj),
                         InvocationId:invocation_id,
                         ObjectType:stuff.object_type,
                         DisplayContext:stuff.display_context,
                         MethodName:method.name,
                         ExecutionServer:target,
                         Timeout:stuff.method_response_timeout
                     }
                 };
             //Send it

             send_request(message);
			 if(global.console!==undefined&& configuration.debug===true){
				console.debug("%c>>> sending MethodInvocationRequestMessage", "background-color:hsla(198, 51%, 79%, 0.5)");
				console.debug("%c"+JSON.stringify(message), "background-color:hsla(198, 51%, 79%, 0.5)");
			}
       
        });    
	}
	
	
	
	//Adds callbacks for a given invocation ID
    function register_invocation(invocation_id, response, success, error, timeout){
        //Adds the callbacks
        pending_callbacks[invocation_id] = {response:response, success:success, error:error};
        //Schedules to throw a timeout if nobody answers
        setTimeout(function(){
            if(pending_callbacks[invocation_id]===undefined){return;}
            error({
                method:response.method, called_with:response.argument_obj,
                message:"Timeout reached"
            });
            delete pending_callbacks[invocation_id];
        }, timeout);
    }
    
	function process_method_response(message){
		//Finds the appropriate callback
        var callback = pending_callbacks[message.InvocationId];
        if(callback!==undefined){
            if(global.console!==undefined&& configuration.debug===true){
                console.debug("%c<<< receiving MethodInvocationResultMessage", "background-color:hsla(118, 51%, 79%, 0.5)");
                console.debug("%c"+JSON.stringify(message), "background-color:hsla(118, 51%, 79%, 0.5)");
            }
            //If the server returned success, execute the success callback
            if(message.Status === 0&&typeof callback.success==="function"){
                //parse the result
                var result = helpers.parameters_parse(message.ResultContext).arguments;
				//If the result is an empty object, there is no result
                if(Object.keys(result).length===0){result = undefined;}

                //Log that we received a result
                if(global.console!==undefined && configuration.debug===true){
                    console.log('<<<  "'+callback.response.method.name+'" was executed by '+JSON.stringify(helpers.preprocess_server(message.Server)));
                }
                //Execute the success callback
                callback.success({
                    method:callback.response.method,
                    called_with:callback.response.called_with,
                    executed_by:helpers.preprocess_server(message.Server),
                    returned:result,
                    message:message.ResultMessage,
                    log_details:message.ResultLogDetails
                });
             //Else, return an error
            }else if(typeof callback.error==="function"){
               if(global.console!==undefined && configuration.debug===true){
                   console.log('<<<  "'+callback.response.method.name+'" was executed with error by '+JSON.stringify(helpers.preprocess_server(message.Server)));
               }
               callback.error({
                   method:callback.response.method,
                   called_with:callback.response.called_with,
                   message:message.ResultMessage,
                   log_details:message.ResultLogDetails,
                   status:message.status
               });
            }
			//Finally, remove the callbacks
            delete pending_callbacks[message.InvocationId];
        }
    }
	
    return {process_method_response:process_method_response, invoke:invoke};
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":35}],33:[function(require,module,exports){
(function (global){
/*
The Methodstate module, keeps the state of available AGM methods in the network.
*/

var helpers = require("./agm_helpers");

module.exports = function(configuration){
	//A list of all available AGM methods
	var methods = {};

	//Save the reference to the metric function if it exists
	var objectMetric = (configuration.metrics!==undefined)?configuration.metrics.numberMetric.bind(configuration.metrics):function(){};

    //Adds a new server to a method. Creates the method if it is not created previously.
    function add_server_to_method(method_info, server_id, server_info){
        //Get the method ID
        var method_id = get_method_id(method_info);

        

        //One method can have several request subjects per server.
        //So the request subject is actually not a property of the method
        var request_subject = method_info.request_subject;
        delete  method_info.request_subject;


		//Copy the method and server objects to a format suitable for sending to users
        var method_info_friendly = helpers.clone_object(method_info);
    	var server_info_friendly = helpers.clone_object(server_info);



        var method = methods[method_id];

        //If the method does not exist, create it
        if(method ===undefined){
            //Save the info
            method = methods[method_id] = {info:method_info, servers:{}};
			//Add request_subject
          	method = add_request_subject(method, server_id, request_subject);

             //Execute user callbacks
            helpers.execute_all_with(configuration.method_added, method_info_friendly);
            //Log and publish metrics
            if(global.console!==undefined && console.table!==undefined && configuration.debug===true){
                console.log(">>>>>> New method detected: "+JSON.stringify(method_info_friendly));
                console.table(get_methods());
            }
			objectMetric("Methods total count", Object.keys(methods).length);
        }else{
			//Else, just add the request subject
        	method = add_request_subject(method, server_id, request_subject);
        }
        //Execute user callbacks
        helpers.execute_all_with(configuration.server_method_added, {method:method_info_friendly, server:server_info_friendly});
    }

	//Adds request subject for server and method
    function add_request_subject(method, server_id, request_subject){
    	method.servers[server_id] = request_subject;
    	return method;
    }


    //Removes a server from a method. Deletes the method if there are no more servers left.
    function remove_server_from_method(method_id, server_id, server_info) {
      //Obtain info about the method before removing it.
      var method_info_friendly = get_method(method_id);
      var server_info_friendly = helpers.clone_object(server_info);


      //Remove the server from the list
      var servers = methods[method_id].servers;
      delete servers[server_id];
      //Remove the method if there aren't any servers left
      if (Object.keys(servers).length === 0) {
        var callback = configuration.on_method_removed;
        helpers.execute_all_with(configuration.method_removed, method_info_friendly);
        //remove method
        delete methods[method_id];
        //Log and metrics
        if (global.console !== undefined && console.table !== undefined && configuration.debug === true) {
          console.log("<<<<<< Method stopped being available: " + JSON.stringify(method_info_friendly));
          console.table(get_methods());
        }
        objectMetric("Methods total count", Object.keys(methods).length);
      }
      //Execute user callbacks
      helpers.execute_all_with(configuration.server_method_removed, {
        method: method_info_friendly,
        server: server_info_friendly
      });

    }

	//Generates a unique if for a method
    function get_method_id(m){
		//Setting properies to defaults:
		var accepts = m.accepts !==undefined?m.accepts:"";
		var returns = m.returns !==undefined?m.returns:"";
		var version =  m.version !==undefined?m.version:0;
		return (m.name+accepts+returns+version).toLowerCase();
    }


    //Retrieve all methods
    function get_methods(){
        return Object.keys(methods).map(function(method){
            return helpers.clone_object(methods[method].info);
        });
    }
    //Retrieve an array of the ID's of the servers for a method
    function get_servers_for_method(method_info){
        var method = methods[get_method_id(method_info)];
        if(method !==undefined){return method.servers;}
        else{return {};}
    }

    //Retrieves a copy of the method, by its ID
    function get_method(method_id){
        if(typeof method_id === "object"){method_id = get_method_id(method_id);}
        if(methods[method_id]!==undefined)
        //We clone the method definition so it can be mutated without affecting the original
        return helpers.clone_object(methods[method_id].info);
    }


    return {
            get_methods:get_methods,
            get_method:get_method,
            get_method_id:get_method_id,
            add_server_to_method:add_server_to_method,
            remove_server_from_method:remove_server_from_method,
            get_servers_for_method:get_servers_for_method
            };

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":35}],34:[function(require,module,exports){
(function (global){
/*
The Serverstate module processes server presences and keeps the state of available AGM servers in the network.
*/
var helpers = require("./agm_helpers");

var get_server_id = helpers.get_server_id;

var client_methodstate = require("./agm_client_methodstate");

module.exports = function(configuration, instance){
    "use strict";

	//A list of all the servers in the network
	var servers = {};

	//Instantiates the "methodstate" module
    var methods = client_methodstate(configuration);


	//Processes a presence message from a server
    function process_presence(presence, is_presence){
        //console.log(presence.Instance)
		//Get server info.
		var serverinfo = helpers.preprocess_server(presence.Instance);

        //If it is a new server, register it.
		if(!exists(serverinfo)){
			add_server(serverinfo);
		}


		if(!(is_presence && presence.PublishingInterval === 0)){
			//Do nothing for presence messages with interval 0
			//Take care of the timeouts
			set_timeout(serverinfo, presence.PublishingInterval);
        }


		//Finally, update the methods
		if(presence.MethodDefinitions!==undefined){
			update_methods(serverinfo, presence.MethodDefinitions);
		}

	}

	//This function sets a timeout which removes the server unless
	//the function is called again before the timeout is over
    function set_timeout(serverinfo, duration){

		if(duration ===-1) return;
		 //Retrieve the server
         var server_id = get_server_id(serverinfo);
         var server = servers[server_id];
         //Stop the previous timeout
         if(server.bomb !==undefined){
			clearTimeout(server.bomb);
         }
		 //Set a new one
		 server.bomb = setTimeout(function(){
			remove_server(serverinfo);
		 }, duration*configuration.remove_server_on_n_missing_heartbeats+1);

    }
    //Checks if a servers exists
    function exists(serverinfo){
        var server_id = get_server_id(serverinfo);
        return servers[server_id]!==undefined;
    }
	//Register a server
	function add_server(serverinfo){
        //Obtain a server ID and store the new server
        var server_id = get_server_id(serverinfo);
		servers[server_id] = {info:serverinfo, methods:[], bomb:undefined};

		//Log in console
        if(global.console!==undefined && console.table!==undefined && configuration.debug===true){
        	console.log(">>>>>> New server detected: "+JSON.stringify(serverinfo));
            console.table(get_servers());
        }

        //Execute user callbacks
        helpers.execute_all_with(configuration.server_added, serverinfo);

		return server_id;
	}
	//Unregisters a server
	function remove_server(serverinfo){
		//Obtain a server ID
        var server_id = get_server_id(serverinfo);
        //Remove the server's methods
        servers[server_id].methods.forEach(function(method_id){
            methods.remove_server_from_method(method_id, server_id, serverinfo);
        });
        //Remove the server itself
        delete servers[server_id];
        //Log in console
         if(global.console!==undefined && console.table!==undefined && configuration.debug===true){
            console.log("<<<<<< Server stopped being available:"+JSON.stringify(serverinfo));
            console.table(get_servers());
        }

         //Execute user callbacks
        helpers.execute_all_with(configuration.server_removed, serverinfo);
	}

    //Updates the methods of a server
	function update_methods(serverinfo, new_methods){
        var server_id = get_server_id(serverinfo);
        //Get an array of the methods the server had before we started this
		var old_methods_ids = servers[server_id].methods;
        //Get an array of the methods that the server has now
        new_methods = new_methods.map(helpers.preprocess_method).reduce(function(obj, method){
           obj[methods.get_method_id(method)] = method;
           return obj;
        }, {});
        //For each of the old methods
        old_methods_ids.forEach(function(method_id){
            //Check if it is still there
            if(new_methods[method_id]===undefined){
               //If it isn't, remove it
               methods.remove_server_from_method(method_id, server_id, serverinfo);
            }else{
                //If it is there in both the old array and the new one, we don't need to add it again
                new_methods[method_id] = undefined;
            }
        });
        //Now add the new methods
        var new_methods_ids = Object.keys(new_methods);
        new_methods_ids.forEach(function(id){
            if(new_methods[id]!==undefined){
                methods.add_server_to_method(new_methods[id], server_id, serverinfo);
            }
        });
        //Now all we have to do is replace the list of methods the server has
        servers[server_id].methods = new_methods_ids;

    }

    //Get all servers for a given method
    function get_servers(method, include_request_subject){
        var server_ids;
		//If there isn't a method get the ID's of all servers
        if(method ===undefined){
           server_ids = Object.keys(servers);
		//Else, get a list of the servers that have the method
        }else{
           var ids_to_request_subjects = methods.get_servers_for_method(method);
           server_ids = Object.keys(ids_to_request_subjects);
        }
		//Format the list
        return server_ids.map(function(server_id){
            var server =  helpers.clone_object(servers[server_id].info);
            //Include the request subject for each server for each method:
            if(include_request_subject){server.request_subject = ids_to_request_subjects[server_id];}
            return server;
        }).sort(compare_servers);
    }
    //A comparer function. Sorts the servers based on availability
    function compare_servers(server1, server2){
		var s1 = 0;
		var s2 = 0;
		//+2 if the server is on the same machine
		if(server1.machine ===instance.machine){s1 = s1+2;}
		if(server2.machine ===instance.machine){s2 = s2+2;}
		//+1 if it runs under the same user
		if(server1.user === instance.user){s1 = s1+1;}
		if(server2.user === instance.user){s2 = s2+1;}
		return s2 - s1;
	}

    function get_method_ids(server){
        return servers[get_server_id(server)].methods;
    }


    //Get all methods for a given server
	function get_methods(server){
        //If there is no server specified, return all
        if(server ===undefined){
            return methods.get_methods();
        //Else, get the methods from the server object
        }else if(exists(server)){
             return get_method_ids(server).map(function(method_id){
                return methods.get_method(method_id);
            });
        //If the server is specified, but it does not exist, return an empty array
        }else{
            return [];
        }
	}

    return {process_presence:process_presence,
            get_methods:get_methods,
            get_method_ids:get_method_ids,
            get_servers:get_servers,
           	get_method:methods.get_method,
            exists:exists,
			compare_servers:compare_servers
            };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_client_methodstate":33,"./agm_helpers":35}],35:[function(require,module,exports){
(function (global){

//Converts arguments to an AGM frame	
function parameters_stringify(argumentlist, argument_datatypes){
	//Our final result will be here
	var encoded_arguments=[];
	//No datatypes, no problem (most of the time we can deduce them from the values)
	if (argument_datatypes===undefined){argument_datatypes = {};}

	for(var i in argumentlist){
		if(argumentlist[i]===undefined){break;}
		if(argumentlist[i].constructor !== Object){
			encoded_arguments.push({
				Name:i,
				composite:false,
				CompositeValue:null,
				Value: encode_argument(argumentlist[i],argument_datatypes[i])
			});
		}else{
			//if (argument_datatypes[i]===undefined){argument_datatypes[i] = {}}
			encoded_arguments.push({
				Name:i,
				composite:true,
				//Value: null,
				CompositeValue:parameters_stringify(argumentlist[i], argument_datatypes[i])

			});

		}
	}
	return encoded_arguments;	

	 //Encodes a single argument (int, string, boolean, date) or arrays of arguments
	function encode_argument(value, datatype){
		var array = false;
		var encoded_datatype;
		if(datatype === undefined){
			//Try to get the datatype from the argument itself

			//Test if it is array

			//myvalue points to the value, if we are not dealing with an array
			//if we do, it points to the its first value.
			var myvalue;
			if(value instanceof Array){
				array = true;myvalue=value[0];
			}else{
				myvalue = value;
			}


			//Try to guess the argument type
			if(typeof myvalue == 'string' || myvalue instanceof String){encoded_datatype=4;}
			else if(myvalue instanceof Date){encoded_datatype=5;}
			else if(typeof myvalue ==="boolean"){encoded_datatype=0;}
			else if(!isNaN(myvalue)){encoded_datatype=2;}

		}else if (isNaN(datatype)){
			//Check if it is an array( the datatype of arrays ends with [])
			datatype = datatype.split("[]");
			if (datatype.length===2){array=true;}
			datatype=datatype[0];
			//Convert the elementary datatype to number
			var datatypes={Boolean:0, Integer:1, Double:2, Long:3, String:4, Date:5};
			encoded_datatype = datatypes[datatype];
			//Convert Date objects to timestamps 
			if (datatype==="DateTime"){
				//For date arrays
				if(value instanceof Array){
					for(var i = 0;i<value.length;i++){
						value[i] = value[i].getTime();
					}
				//For dates
				} else{value = value.getTime();}

			}
		}

		return {value:value, type:encoded_datatype, isArray:array};
	}
}

//Decodes an AGM-style object to pure JSON
function parameters_parse(args){
	 var decoded={};
   var signature={};
	 for(var i = 0;i<args.length; i++){   
		var argument = args[i];

		if (argument.composite || (argument.CompositeValue!== null && argument.CompositeValue !== undefined)){
			//If the argument is a composite one, we call the function recursively
			decoded[argument.Name]=parameters_parse(argument.CompositeValue).arguments;
			signature[argument.Name]=parameters_parse(argument.CompositeValue).signature;
		}else{
			//If it is not, we just decode the value
			decoded[argument.Name]=decode_argument(argument.Value);
			signature[argument.Name] = decode_signature(argument.Value);
		}
	}
	return {arguments:decoded, signature:signature};
	//Decodes a single argument (int, string, boolean, date) or arrays of arguments
	function decode_argument(value){
	 if (value.isArray){
			var type = value.type;
			var values = value.value;
		for (var i in values){
				values[i] = decode_value(values[i], type);
		   }
			return values; 
		}else{
			return decode_value(value.value, value.type);
		}
	   //Decodes a single argument (int, string, boolean, date)
	   function decode_value(value, type){
			//Date
		   if (type ===5){return new Date(value);}
		   return value;
		}    
   }
   function decode_signature(value){
	   var datatypes={"0":"Bool", "1":"Int", "2":"Double", "3":"Long", "4":"String", "5":"DateTime"};
	   var datatype = datatypes[value.type+""];
	   if (value.isArray){datatype = datatype+"[]";}
		return datatype;
   }

}

var datatypes=["Bool", "Int", "Double", "Long", "String", "DateTime"];

function signature_stringify(array){
	//No signature - return undefined (the default undefined value in AGM for this property is empty string)
	if(array===undefined||array ===""){return "";}
	try {
		return array.sort(function(a, b){
			if (a.Name > b.Name)
				return 1;
			if (a.Name < b.Name)
				return -1;
	
			return 0;
		})
		.map(function(par){
			var req ="?";
			if(par.IsRequired){req ="";}
			var arr ="";
			if(par.isArray){arr ="[]";}
	
			var data_type = datatypes[parseInt(par.Type)];
			if(data_type===undefined){throw "Invalid datatype "+par.Type;}
	
			return data_type+req+arr+" "+par.Name;
		}).join(", ");
	} catch(e) {
		return "";
	}

}

function signature_parse(string){
	 if(string===undefined||string ===""){return undefined;}
	 return string.split(",").map(function(argument){
		 var arg = {};
		 var p = argument.trim().split(" ");
		 if (p.length!==2){throw "Invalid argument: "+argument+".";}

		 arg.Name = p[1];

		 var data = p[0];

		 arg.isArray = false;

		 if(data.indexOf("[]")!==-1){
			 data = data.replace("[]", "");
			 arg.isArray = true;
		 }

		 arg.IsRequired = true;
		 if(data.indexOf("?")!==-1){
			 data = data.replace("?", "");
			 arg.IsRequired = false;
		 }

		 var arg_type = datatypes.indexOf(data);
		 if(arg_type!==-1){
			arg.Type = arg_type+"";
		 }else{
			 throw "Invalid datatype: "+data+". The accepted datatypes are Int, Double, Long, DateTime, Bool and String";
		 }

		 return arg;

	 });
}

function signature_parse_friendly(string){
	return signature_parse(string).reduce(function(obj, arg){
		obj[arg.Name] = {type:datatypes[parseInt(arg.Type)], is_array:arg.isArray, is_required:arg.IsRequired};
		return obj;
	},{});
}

function signature_normalize(string){
	return signature_stringify(signature_parse(string));
}


//Converts server properties from camel to snake case
function preprocess_server(m){
	return{
		machine:m.MachineName,
		pid:m.ProcessId,
		started:m.ProcessStartTime,
		user:m.UserName,
		application:m.ApplicationName,
		environment:m.Environment,
		region:m.Region,
		service_name:m.ServiceName,
		metrics_repository_id:m.MetricsRepositoryId,
		state:m.State
	};
}

function clone_object(method){
	var new_method ={};
	for(var i in method){
		//Remove undefined values from object before passing it to the user
		if(method[i]!==undefined&&method[i]!==""&&method[i]!==0){
			new_method[i] = method[i];
		}
	}
	return new_method;
} 

	//Helper: preprocesses the method definition
function preprocess_method(method_info){
	var method = method_info.Method;
	return{
		name:method.Name,
		accepts:method.InputSignature,
		returns:method.ResultSignature,
		request_subject:method_info.MethodRequestSubject, 
		description:method.Description,
		display_name:method.DisplayName,
		version:method.Version,
		object_types:method.ObjectTypeRestrictions
	};
}   


  function save_callback_in(callback_obj, event, on_callback_add, callback){
		if (typeof callback === 'function'){
			callback_obj[event] = callback_obj[event]||[];
			callback_obj[event].push(callback);
			on_callback_add(callback);
		}else{
			throw '"'+event+'" must be called with a function as an argument';
		}
  }

  function execute_all_with(callbacks, input){
	if(typeof callbacks ==="object"){
		callbacks.forEach(function(callback){
			callback(input);
		});
	}
}

//Generates a unique ID for a server
function get_server_id(serverinfo){
	if(serverinfo===undefined){return undefined;}
	//The matching is case-insensitive
	return (serverinfo.application+serverinfo.user).toLowerCase();
}

function promisify(promise, successCallback, errorCallback){
    if (typeof successCallback !== 'function' && typeof errorCallback !== 'function') {
        return promise;
    }

    if(typeof successCallback !== 'function'){
        successCallback = function(args){
            if(global.console!==undefined && agm.debug===true){
                console.log("Success!");
            }
        };
    }else if(typeof errorCallback !== 'function'){
        errorCallback = function(args){
            if(global.console!==undefined && agm.debug===true){
                console.log("An error occurred.");
            }
        };
    }

    promise.then(successCallback, errorCallback);
}

module.exports = {
	get_server_id:get_server_id,
	execute_all_with:execute_all_with,
	save_callback_in:save_callback_in,
	parameters_stringify:parameters_stringify,
	parameters_parse:parameters_parse,
	signature_stringify:signature_stringify,
	signature_parse:signature_parse,
	signature_parse_friendly:signature_parse_friendly,
	signature_normalize:signature_normalize,
	preprocess_server:preprocess_server,
	preprocess_method:preprocess_method,
	clone_object:clone_object,
	promisify:promisify
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],36:[function(require,module,exports){
(function (global){
/*
The AGM instance collects information about the machine we are in, 
and interacts with the .NET gateway in other ways, 
to deliver full AGM compatibility to AGM.JS.

To do so, it relies on the default AGM client.
*/

var document = global.document || global.process;

module.exports = function(c, connection){
	var instance = {};
	//Generate default instance properties
	instance.ApplicationName = document.title+Math.floor(Math.random()*1000000000);
	instance.ProcessId = Math.floor(Math.random()*1000000000);
	instance.ProcessStartTime = new Date().getTime(); 
    
	//Apply user-submitted instance properties 
	if(typeof c === "object"){
        if(c.application!==undefined){instance.ApplicationName = c.application;}
		instance.MachineName=c.machine;
		instance.UserName=c.user;
		instance.Environment=c.environment;
		instance.Region=c.region;
		instance.ServiceName=c.service_name;
		instance.MetricsRepositoryId=c.metrics_repository_id;
		instance.State=1;
	}
    var identity_updated = false;
    connection.on("Instance", function(i){
		if(identity_updated){return;}
        if(instance.MachineName===undefined){instance.MachineName = i.MachineName;}
        if(instance.UserName===undefined){instance.UserName = i.UserName;}
        if(instance.Environment===undefined){instance.Environment = i.Environment;}
        if(instance.Region===undefined){instance.Region = i.Region;}
        if(instance.ServiceName===undefined){instance.ServiceName = i.ServiceName;}
        if(instance.MetricsRepositoryId===undefined){instance.MetricsRepositoryId = i.MetricsRepositoryId;}
        if(instance.State===undefined){instance.State = i.State;}
        if(global.console!==undefined&& global.console.table!==undefined  && agm.debug===true){
            console.log("Received instance with info from Gateway.");
        }
		identity_updated = true;
    });
	//Create a method for accessing a property
    function create_getter(property){
        return instance[property];
    }
	//Generates a request subject for a method
	//Delegates it to the .NET gateway if it is online, 
	//to create subjects which are valid in the scope of the transport that is being used.
    var req_subject = 0;
	function request_subject(method_identifier, callback){
        callback("req"+(req_subject++)+instance.ProcessId);
	}
    //Generates a response subject subject for a method invocation
	//Delegates it to the .NET gateway if it is online, 
	//to create subjects which are valid in the scope of the transport that is being used.
    var resp_subject = 0;
	function response_subject(method_identifier, callback){
        callback("resp"+(resp_subject++)+instance.ProcessId);	
	}
	//Returns all instance properties
    function info(){
        return instance;
    }

    return {request_subject:request_subject, 
            response_subject:response_subject,
            info:info,
            application:create_getter("ApplicationName"),
            pid:create_getter("ProcessId"),
			user:create_getter("UserName"),
			machine:create_getter("MachineName")

          };   

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],37:[function(require,module,exports){
(function (global){
var Promise = require('es6-promise').Promise;
var h = require("./agm_helpers");

module.exports = function (configuration) {
    function paramToJson(param, stringPropName, objectPropName) {
        var obj = {};
        if (typeof param == 'string') {
            obj[stringPropName] = param;
            return JSON.stringify(obj);
        }
        else {
            if (objectPropName === undefined) {
                return JSON.stringify(param);
            }
            obj[objectPropName] = param;
            return JSON.stringify(obj);
        }
    }

    // helper function for parsing dates properly
    function agmParse(str) {
        return JSON.parse(str, function (k, v) {
            if (typeof v !== 'string') {
                return v;
            }

            // pre-seed - this should be a bit faster than indexOf
            if (v[0] !== dateTimeIdentifier[0]) {
                return v;
            }

            if (v.indexOf(dateTimeIdentifier) !== 0) {
                return v;
            }

            var unixTimestampMs = v.substr(lenOfIdentitifier);
            return new Date(parseFloat(unixTimestampMs));
        });
    }

    /**
     * Converts a target argument to object ready to be passed to Agm facade
     * @param target
     */
    function targetArgToObject(target){

        target = target || 'best';

        if (typeof target === "string") {
            if (target !== "all" && target !== "best") {
                throw new Error('"' + target + '" is not a valid target. Valid targets are "all" and "best".');
            }
            return {target : target};
        } else {
            if (target.constructor.name !== 'Array') {
                target = [target];
            }

            target = target.map(function (e) {
                return convertInstanceToRegex(e);
            });

            return {serverFilter: target};
        }
    }

    function convertInstanceToRegex(instance) {
        var instance_converted = {};

        Object.keys(instance).forEach(function (key) {
            var propValue = instance[key];
            instance_converted[key] = propValue;

            if (typeof propValue === "undefined" || propValue === null) {
                return;
            }

            if (typeof propValue === "string") {
                // do exact matching if user passed a string
                instance_converted[key] = "^" + instance[key] + "$";
            }
            else if (instance[key].constructor === RegExp) {
                instance_converted[key] = instance[key].source;
            }
            else {
                instance_converted[key] = instance[key];
            }
        });
        return instance_converted;
    }

    var result = {

        // Registers a JavaScript function as an AGM method, thus making it available other AGM instances on the same transport.
        register: function (methodInfo, callback) {

            this.agmFacade.register(paramToJson(methodInfo, "name"),
                function (arg) {
                    var result = callback(JSON.parse(arg));
                    return JSON.stringify(result);
                });
        },

        unregister: function (methodFilter) {
            this.agmFacade.unregister(paramToJson(methodFilter, "name"));
        },

        // Invokes an AGM method asynchronously.
        invoke: function (methodFilter, args, target, options, successCallback, errorCallback) {

            var promise = new Promise(function (resolve, reject) {
                var successProxy, errorProxy;

                successProxy = function (args) {
                    var parsed = JSON.parse(args);
                    resolve(parsed);
                };
                errorProxy = function (args) {
                    var parsed = JSON.parse(args);
                    reject(parsed);
                };

                if (args === undefined) {
                    args = {};
                }

                if (typeof args !== 'object') {
                    reject({message: 'The method arguments must be an object.'});
                }

                if (options === undefined) {
                    options = {};
                }

                var target = targetArgToObject(target);

                this.agmFacade.invoke(
                    paramToJson(methodFilter, "name"),
                    JSON.stringify(args),
                    JSON.stringify(target),
                    JSON.stringify(options),
                    successProxy,
                    errorProxy
                );
            }.bind(this));

            return h.promisify(promise, successCallback, errorCallback);
        },

        // Registers a handler which notifies you when a new AGM method is available.
        methodAdded: function (callback) {
            this.agmFacade.methodAdded(callback);
        },

        // Registers a handler which notifies you when an AGM method stops being available.
        methodRemoved: function (callback) {
            this.agmFacade.methodRemoved(callback);
        },

        serverAdded: function (callback) {
            this.agmFacade.serverAdded(callback);
        },

        serverRemoved: function (callback) {
            this.agmFacade.serverRemoved(callback);
        },

        serverMethodAdded: function (callback) {
            this.agmFacade.serverMethodAdded(callback);
        },

        serverMethodRemoved: function (callback) {
            this.agmFacade.serverMethodRemoved(callback);
        },

        // Retrieves a list of AGM servers (instances) optionally filtered by method.
        servers: function (methodFilter) {
            var jsonResult = this.agmFacade.servers(JSON.stringify(methodFilter));
            return agmParse(jsonResult);
        },

        // Retrieves a list of methods that matches a given filter. You can use this to check if a given method exists.
        methods: function (methodFilter) {
            var jsonResult = this.agmFacade.methods(JSON.stringify(methodFilter));
            return agmParse(jsonResult);
        },

        methodsForInstance: function (instanceFilter) {
            var jsonResult = this.agmFacade.methodsForInstance(JSON.stringify(instanceFilter));
            return agmParse(jsonResult);
        },

        // streaming support
        subscribe: function (name, options, successCallback, errorCallback) {
            var promise = new Promise(function (resolve, reject) {
                if (options === undefined) {
                    options = {};
                }
                options.args = JSON.stringify(options.arguments || {});
                options.target = targetArgToObject(options.target);

                this.agmFacade.subscribe2(name,
                    JSON.stringify(options),
                    function(stream){
                        resolve(stream);
                    },
                    function(error){
                        reject(error);
                    }
                );
            }.bind(this));

            return h.promisify(promise, successCallback, errorCallback);
        },

        createStream: function(streamDef, callbacks, successCallback, errorCallback){
            var promise = new Promise(function (resolve, reject) {
                if (typeof streamDef === "string") {
                    streamDef = {name: streamDef};
                }

                if (!callbacks){
                    callbacks = {};
                }

                this.agmFacade.createStream2(
                    JSON.stringify(streamDef),
                    // TODO - wrap to transform params
                    callbacks.subscriptionRequestHandler,
                    // TODO - wrap to transform params
                    callbacks.subscriptionAddedHandler,
                    // TODO - wrap to transform params
                    callbacks.subscriptionRemovedHandler,
                    // success handler
                    function (stream) {
                        resolve(stream);
                    },
                    // error handler
                    function (error) {
                        reject(error);
                    }
                );
            }.bind(this));

            return h.promisify(promise, successCallback, errorCallback);
        }
    };

    result.version = "2.1.1";

    // add metrics
    if (configuration !== undefined && configuration.metrics !== undefined) {
        configuration.metrics.metricsIdentity = configuration.metrics.identity;


        // quick and dirty - we need to stringify the configuration so we need to replace the metrics object (which has circular references)
        // with an object that holds only the properties needed
        var metricsConfig = {
            metricsIdentity: configuration.metrics.metricsIdentity,
            path: configuration.metrics.path
        };
        configuration.metrics = metricsConfig;
    }


    //create new AGM façade for this instance
    var facade = global.htmlContainer.jsAgmFacade;
    result.instance = facade.init(JSON.stringify(configuration));
    result.agmFacade = facade;

    // date parsing
    var dateTimeIdentifier = result.agmFacade.jsonValueDatePrefix;
    var lenOfIdentitifier = dateTimeIdentifier.length;

    // deprecated API
    result.create_stream = result.createStream;
    result.methods_for_instance = result.methodsForInstance;
    result.method_added = result.methodAdded;
    result.method_removed = result.methodRemoved;
    result.server_added = result.serverAdded;
    result.server_removed = result.serverRemoved;
    result.server_method_added = result.serverMethodAdded;
    result.server_method_removed = result.serverMethodRemoved;

    return result;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":35,"es6-promise":6}],38:[function(require,module,exports){
(function (global){
/*
The AGM Server allows users register AGM methods.
It exposes these methods to AGM clients (using presence messages) and listens for their invocation
*/

var helpers = require("./agm_helpers");

module.exports = function(connection, instance, configuration){
 
    //Validate configuration
    if(typeof configuration!=="object"){
		configuration = {};

	    if(global.console!==undefined && configuration.debug===true){
            console.log('Creating an AGM server with default configuration.');
        }
	}
    //Add defaults
    if(typeof configuration.hearbeat_interval!=="number"){
        configuration.hearbeat_interval = 5000;
    }

    if(typeof configuration.presence_interval!=="number"){
        configuration.presence_interval = 10000;
    }

    //Save the reference to the metric function if it exists
    var metric = (configuration.metrics!==undefined)?configuration.metrics.numberMetric.bind(configuration.metrics):function(){};
    //An array of the server's methods
    var methods = [];

    var presence_timer;

    var heartbeat_timer;

    if(heartbeat_timer===undefined){
        heartbeat_timer = setInterval(send_heartbeat, configuration.hearbeat_interval);
    }

	//Registers a new method in AGM
	function register(method_definition, the_function){
		if(typeof method_definition === "string"){method_definition = {name:method_definition};}
		//Get a request subject for this method
		instance.request_subject(method_definition, function(request_subject){
            var method = convert_method(method_definition);
            method.MethodRequestSubject = request_subject;
            //Add the method (store the unformatted definition in order to do checkups in the unregister method)
            methods.push({method:method, definition:method_definition, the_function:the_function});
            //Send presence so the clients know we have it
            send_presence();
            //Start sending presence regularily (if we aren't already doing it)
            if(presence_timer===undefined){
                presence_timer = setInterval(send_presence, configuration.presence_interval);
            }
						metric("Registered methods", methods.length);

        });

	}
	var invocations = 0;

	//Listens for method invocations
	connection.on("MethodInvocationRequestMessage",function(message){
        //Find the method
        var method;
		methods.forEach(function(m){
            if(m.method.MethodRequestSubject ===message.MethodRequestSubject){
                method = m;
            }
        });
	if(method===undefined){return;}
        if(global.console!==undefined&& configuration.debug===true){
            console.debug("%c<<< receiving MethodInvocationRequestMessage", "background-color:hsla(198, 51%, 79%, 0.5)");
            console.debug("%c"+JSON.stringify(message), "background-color:hsla(198, 51%, 79%, 0.5)");
        }
				metric("Invocations count", invocations++);

        var result;
        var error;
        try{
        	//Execute it and save the result
        	result = method.the_function(helpers.parameters_parse(message.Context.Arguments).arguments);
		}catch(e){
			if(typeof e ==="string"){
				error = e;
			}
			else if(typeof e.message == 'string'){
				error = e.message;
			}else{
				error = null;
			}
		}
		//The AGM library only transfers objects. If the result is not an object, put it in one
        if(typeof result!=="object"||result.constructor === Array){
            result = {_result:result};
        }
		//Don't send result if the client does not require it
		if(message.MethodResponseSubject==="null"){return;}

		var result_message = {
			MethodRequestSubject:message.MethodRequestSubject,
			MethodResponseSubject:message.MethodResponseSubject,
			MethodName:method.method.Method.Name,
            InvocationId:message.Context.InvocationId,
            ResultContext:helpers.parameters_stringify(result),
			Server:instance.info(),
			ResultMessage:error,
			Status:(error === undefined)?0:1
		};
		//Send result
        connection.send("MethodInvocationResultMessage", result_message);

		if(global.console!==undefined&& configuration.debug===true){
			console.debug("%c>>> sending MethodInvocationResultMessage", "background-color:hsla(118, 51%, 79%, 0.5)");
			console.debug("%c"+JSON.stringify(result_message), "background-color:hsla(118, 51%, 79%, 0.5)");
		}

	});



	//Constructs a heartbeat message
	function construct_heartbeat(){
		return{
			PublishingInterval:configuration.hearbeat_interval,
			Instance:instance.info()
		};
	}
	//Constructs a presence message
	function construct_presence(){
		var p = {
            PublishingInterval:configuration.presence_interval,
            Instance:instance.info()
        };
		p.MethodDefinitions = methods.map(function(method){
			return method.method;
		});
		return p;
	}

    //True if we should be broadcasting presences and heartbeats, false otherwise
    var broadcasting = true;
    
    function start(){
        broadcasting = true;
    }

    function stop(){
        broadcasting = false;
    }

    //Sends a presence
    function send_presence(){
        if(broadcasting) {connection.send("ServerPresenceMessage", construct_presence());}
    }

    //Sends a heartbeat
    function send_heartbeat(){
        if(broadcasting){connection.send("ServerHeartbeatMessage", construct_heartbeat());}
    }




	//Converts the method definition from camel case to snake case
    function convert_method(method_identifier){
        //If we are given a string instead of an object, we presume that is the method's name:
        if(typeof method_identifier === "string"){method_identifier = {name:method_identifier};}

        //Set default values
        if(typeof method_identifier.version!=="number"){method_identifier.version=0;}


        //Convert the method definition to the format that AGM requires
       return {
            Method: {
              Name: method_identifier.name,
              InputSignature: method_identifier.accepts,
              ResultSignature: method_identifier.returns,
              Description: method_identifier.description,
              DisplayName: method_identifier.display_name,
              Version: method_identifier.version,
              ObjectTypeRestrictions: method_identifier.object_types
            }
        };
    }

    function contains_props(filter, object){
        var match = true;
        Object.keys(filter).forEach(function(prop){
            if(filter[prop]!==object[prop]){match = false;}
        });
        return match;
	}

    //Unregisters a previously registered AGM method
    function unregister(method_filter){
    	if(typeof method_filter === "string"){method_filter = {name:method_filter};}
        methods = methods.filter(function(method){
             return !contains_props(method_filter, method.definition);
        });
				metric("Registered methods", methods.length);
    }


	return {register:register, unregister:unregister, start:start, stop:stop};
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":35}],39:[function(require,module,exports){
(function (global){
var application = require("./application");
var instance = require("./instance");
var helpers = require("./helpers");

module.exports = global.app_manager = function app_manager(agm, windows){
	var apps = application(agm, function(){return instances;});
	var instances = instance(agm, apps);
	var manager = {
		applications: apps.all,
		application:apps.get_by_id,
		on_app_added: helpers.add_callback("added").bind(apps),
		on_app_available: helpers.add_callback("available").bind(apps),
		on_app_removed: helpers.add_callback("removed").bind(apps),
		on_app_unavailable: helpers.add_callback("unavailable").bind(apps),
		
		instances: instances.all,
		on_instance_started: helpers.add_callback("started").bind(instances),
		on_instance_stopped: helpers.add_callback("stopped").bind(instances),

		get_branches:function(success, error){
			agm.invoke("T42.ACS.GetBranches", {}, "best", {}, function(e){
				if(success){
					success(helpers.vals(e.returned.Branches));
				}
			}, error);
		},
		get_current_branch:function(success, error){
			agm.invoke("T42.ACS.GetCurrentBranch", {}, "best", {}, function(e){
				if(success){
					success(e.returned.Branch);
				}
			}, error); 
		},
		set_current_branch:function(branch, success, error){
			agm.invoke("T42.ACS.SetCurrentBranch", {Branch:branch}, "best", {}, success, error);
		},
		current_user:function(success, error) {
			agm.invoke("T42.ACS.GetUser", {}, "best", {}, success, error);
		},
		get_functional_entitlement:function(fn, success, error) {
			agm.invoke("T42.ACS.GetFunctionalEntitlement", {Function:fn}, "best", {}, function(e) {
				if(success) {
					success(e.returned.Entitlement); 
				}
			}, error);
		},
		can_i:function(fn, success, error) {
			agm.invoke("T42.ACS.CanI", {Function:fn}, "best", {}, success, error);
		},
		exit:function() {
			agm.invoke("T42.ACS.Shutdown", {}, "all", {}, 
				function(a) { console.log(a); }, 
				function(e) { console.log(e); });
		},

		_trigger_app_event:apps._trigger,
		_trigger_instance_event:instances._trigger

	};

	function call_with(prop, func ){
		return function(result){
			func(result[prop]); 
		};

	}
	
	//Create event bindings
	
	//Tell the app when its instances are added/removed
	
	manager.on_instance_started(function(instance){
		if(instance.application){
			//Trigger "instance_started" event on application
			manager._trigger_app_event("instance_started", instance, instance.application.name);
			
			//Trigger "window_opened" event on instance
			var container;
			if(windows){
				var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
				container = instance.application.configuration.container.split(".")[1];
				glue.agm.invoke("T42.Wnd.FindById", {windowId: instance.id}, {application: instance.application.configuration.container}, {}, window_opened);
			}

		}
		function window_opened(a){
			//Wrap the window in a window object, using the glue windows lib
			var w = a.returned [ Object.keys(a.returned)[0] ];
			var win = glue.windows._from_event(w.windowName, container, w.url, w.windowId );
			
			//Trigger the window opened event
			manager._trigger_instance_event("window_added", win, id);

		}


	});
	
	manager.on_instance_stopped(function(instance){
		if(instance.application){
			manager._trigger_app_event("instance_stopped", instance, instance.application.name);
			
			var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
			manager._trigger_instance_event("window_removed", {}, id);
			
		}
		
		

	});

	//When an app is removed, remove also its instances
	
	manager.on_app_removed(function(app){
		app.instances.forEach(function(instance){
			var id =  (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
			manager._trigger_instance_event("stopped", {}, id);
		});
	});
	var branch_changed_callback;
	manager.on_branches_changed = function(callback){
		branch_changed_callback = callback;
	};

	function on_branch_changed(e){
		if (typeof branch_changed_callback === "function") {
			branch_changed_callback( helpers.vals(e) );
		}
	}

	function handle_app_ready(app){
		if(app.IsReady){
			manager._trigger_app_event("available", app);
		}else{
			
			manager._trigger_app_event("unavailable", app);
		}
	}

	function app_failed(e){
		manager._trigger_instance_event("error", e, e.Context.guid);
	}


	if(agm && agm.subscribe){
	
		manager.agm = agm;
		var handlers =[
			{event:"OnApplicationAdded", trigger:"added", on:apps},
			{event:"OnApplicationRemoved", trigger:"removed", on:apps},
			{event:"OnApplicationChanged", trigger:"changed", on:apps},
			{event:"OnApplicationStarted", trigger:"started", on:instances},
			{event:"OnApplicationStopped", trigger:"stopped", on:instances},
			{event:"OnApplicationAgmServerReady", trigger:"agm_ready", on:instances},
			{event:"OnApplicationReady", func:handle_app_ready},
			{event:"OnBranchesModified", func:on_branch_changed},
			{event:"OnApplicationStartFailed", raw_func:app_failed}
		];

		
		agm.subscribe("T42.ACS.OnEvent", {target:"all"})
			.then(function(subscription) {

				subscription.onData(streamData)
				{
					var events = streamData.data;
					handlers.forEach(function (handler) {
						var objects = events[handler.event];
						if (objects) {

							if (handler.raw_func !== undefined) {
								handler.raw_func(objects);
								return;
							}

							helpers.vals(objects).forEach(function (object) {
								if (handler.on !== undefined) {
									handler.on._trigger(handler.trigger, object);
								} else {
									handler.func(object);
								}
							});
						}
					});
				}
			});
	}
	
	manager.version = "2.0.0";
	
	return manager;

};

global.tick42 = global.tick42 ||{};
global.tick42.app_manager = global.app_manager;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./application":40,"./helpers":42,"./instance":43}],40:[function(require,module,exports){
var event_manager = require("./event_manager");
var helpers = require("./helpers");

module.exports = function(agm, instances){
	var app_proto = helpers.add_callbacks( {

		start:function(params, success, error){
			params = params ||{};
			params.guid = params.guid || Math.floor(Math.random()*10000000);
			if(agm){
				agm.invoke("T42.ACS.StartApplication", {Name:this.name, Context: params}, "best", {}, function(e){
				}, error);
			}
			return instances()._trigger("create", {Context:params});
		
		}		

	}, ["added", "removed", "available", "unavailable", "instance_started", "instance_stopped", "changed" ], "on_" );

//constructor, init_event, id_field
	

	function update_app(props, obj ){
		obj.name = props.Name;
		obj.title = props.Title;
		obj.version = props.Version;
		obj.instances = [];
		obj.configuration = {};
		obj.configuration.auto_start = props.AutoStart;
		obj.configuration.caption = props.Caption;
		obj.configuration.hidden = props.IsHidden;
		obj.configuration.container = props.ApplicationName;
		//obj.disabled = props.IsDisabled;
		obj.configuration.allow_multiple = props.AllowMultiple;
		obj.available = props.IsReady || false;
		obj.icon = props.Icon;
		return obj;
	}

	return event_manager({
		create:function create_app(props){
			return update_app( props, Object.create(app_proto));
		},
	       	update:update_app,
		init_event:"added", 
		exit_event:"removed",
		id_field:"Name",
		callbacks:{
			available:function(){
				this.available = true;
			},
			changed:function(props){
				this.icon = props.Icon;
				this.title = props.Title;
				this.configuration.caption = props.Caption;
			},
			unavailable:function(){
				this.available = false;
			},
			instance_started:function(instance){
				this.instances.push(instance);
			},
			instance_stopped:function(instance){
				this.instances = this.instances.filter(function(my_instance){ return my_instance !== instance;});
			}
		}
	});
	
};

},{"./event_manager":41,"./helpers":42}],41:[function(require,module,exports){
var helpers = require("./helpers");

function exec_callbacks(obj, arr, val) {
  if (arr !== undefined) {
    arr.forEach(function (callback) {
      callback.call(obj, val);
    });
  }
}

module.exports = function create_environment(settings) {
  var objects = {};
  var global_callbacks = {};
  return {
    all: function () {
      return helpers.vals(objects);
    }, 
    get_by_id: function (id) {
      return objects[id];
    },
    _trigger: function (type, props, id) {
      id = id || ( typeof settings.id_field === "function" ? settings.id_field(props) : props[settings.id_field]);

      //Quit if we receive an event for an object before initiating it.
      if( objects[id] === undefined &&( type !== settings.init_event && type !== settings.create_event)){
        //console.log ("Received '"+type+"' event before '"+settings.init_event+"'");
       return;}

      
      //Create or retrieve an object, representing the entity
      var obj = objects[id] = objects[id] || init_object(settings.create(props));

      if (type === settings.init_event){
         //Quit if we receive a init event for an object that is already active
	if(obj.active){
          //console.log ("Received second '"+settings.init_event+"' for app "+id);
          return;
        //Else, make it active
        }else{
          obj.active = true;
	  settings.update(props, obj);
        }
      //When the entity is removed, set it to non-active
      } else if(type === settings.exit_event){
	obj.active = false;
      
      //When a create event is received, just return the object without doing anything else
      } else if (type === settings.create_event){
      	return obj;

      }

      //Execute system callbacks
      if(settings.callbacks[type] !== undefined){
      	settings.callbacks[type].call(obj, props);
      }

      //Execute global callbacks
      exec_callbacks(undefined, global_callbacks[type], obj);
      
      //Execute user-defined callbacks that are attached to the object
      exec_callbacks(obj, obj.callbacks[type], props);

      //When the entity is removed, remove all callbacks (after you execute them)
      if(type === settings.exit_event){
      	obj.callbacks = {};
      }
      return obj;

    },
    //Expose the global callbacks object so that user can register some
    callbacks: global_callbacks
  };
};



function init_object(object){
	object.callbacks = {};
	object.active = false;
	return object;
}

},{"./helpers":42}],42:[function(require,module,exports){
function noop(){}

function exec_if(condition){
	return function(app, callback){
		if(condition(app)){callback.call(app);}
	};

}


exports.add_callbacks = function add_callbacks(object, events, prefix){
	events.forEach(function( event){
		if (typeof event === "string"){
			event = {name:event, trigger_when:noop};
		}
		
		object[ prefix + event.name ] = exports.add_callback( event.name, exec_if(event.trigger_when) );
	});
	return object;

};




exports.add_callback = function add_callback( key, on_add ){
	return function(callback){
		var obj = this.callbacks;
		if(obj[key]===undefined){obj[key] = [callback];}
		else {obj[key].push(callback);}
		if(typeof on_add === "function"){on_add(this, callback);}
		return this;
	};
};
exports.vals = function vals(obj){
	return Object.keys(obj).reduce(function(arr, key){arr.push(obj[key]);return arr;}, []);
};

},{}],43:[function(require,module,exports){
var event_manager = require("./event_manager");
var helpers = require("./helpers");
module.exports = function(agm, apps){
	var instance_proto = helpers.add_callbacks( {
		stop:function(params, success, error){
			agm.invoke("T42.ACS.StopApplication", {Name:this.application.name, Id:this.id}, "best", {}, function(e){
				console.log(e);
			}, error);
		},
		activate:function(params, success, error) {
			agm.invoke("T42.ACS.ActivateApplication", {Name:this.application.name, Id:this.id}, "best", {}, function(e){
				console.log(e);
			}, error);
		}
	}, [
		{name:"window_added", trigger_when: function(app){return app.active && app.main_window !== undefined;}}, 
		{name:"window_removed", trigger_when: function(app){return app.main_window === undefined;}}, 
		{name:"started", trigger_when:function(app){return app.id !== undefined && app.active;}}, 
		{name:"stopped", trigger_when:function(app){return app.id !== undefined && !app.active;}}, 
		{name:"agm_ready", trigger_when:function(app){return app.active && app.agm !== undefined;}},
		{name:"error", trigger_when:function(app){return app.error !== undefined;}},
	], "on_" ); 
	
	function update_instance(props, obj){
		obj.id = props.Id;
		obj.application = apps.get_by_id(props.Name);
		obj.context = props.Context;
		return obj;
	
	}

	return event_manager({
		create:function(props){
			return update_instance(props, Object.create(instance_proto));
		},
		update:update_instance, 
		create_event:"create", 
		init_event:"started", 
		exit_event:"stopped",
		id_field:function(e){return e.Context !== undefined && e.Context.guid!== undefined? e.Context.guid: e.Id;},
		callbacks:{
			agm_ready:function(e){
				//get the first AGM
				var server_name = Object.keys(e.AgmServers)[0];
				//Attach it to the object
				this.agm = convert_agm_instance(e.AgmServers[server_name]);
			},
	       		error:function(e){
				this.error = e;
			},
			window_added:function(win){
				this.main_window = win;
				this.windows = this.windows||[];
				this.windows.push(win);
			},
			window_removed:function(){
				this.main_window = undefined;
				this.windows = [];
			}
		}
	});

	

};


function convert_agm_instance(agm){
	return {
		machine:agm.machineName,
		user:agm.userName,
		environment:agm.environment,
		application:agm.applicationName

	};
}

},{"./event_manager":41,"./helpers":42}],44:[function(require,module,exports){
/**
 * @module appconfig
 */
'use strict';

var _ = require('./util');
var Model = require('./model');
var helpers = require('./helpers');

var events = {
  connect: 'connect',
  disconnect: 'disconnect',
  update: 'update',
  status: 'status'
};

var EventBus = function () {
  var subscriptionsByType;
  var on = function (type, once, callback, scope) {
    if (!_.isFunction(callback)) {
      return;
    }

    var subscription = {
      type: type,
      once: once,
      callback: callback,
      scope: scope
    };

    var subscriptions = subscriptionsByType[type];
    if (typeof subscriptions === 'undefined') {
      subscriptions = subscriptionsByType[type] = [];
    }
    subscription.id = subscriptions.push(subscription) - 1;
    return subscription;
  };

  var emit = function () {
    var args = [].slice.call(arguments);
    var type = args.splice(0, 1)[0];
    var subscriptions = subscriptionsByType[type];
    if (typeof subscriptions === 'undefined') {
      subscriptions = subscriptionsByType[type] = [];
    }
    subscriptions.forEach(function (subscription) {
      if (!subscription) {
        return;
      }

      try {
        subscription.callback.apply(subscription.scope, args);
      } catch (x) {
        _.warn('Exception during execution of callback', subscription, args, x);
      }
      if (subscription.once) {
        off(subscription);
      }
    });
  };
  var off = function (subscription) {
    var subscriptions = subscriptionsByType[subscription.type];
    if (typeof subscriptions !== 'undefined') {
      delete subscriptions[subscription.id];
    }
  };

  var resume = function (subscription) {
    if (typeof subscription.id === 'undefined') {
      return on(subscription.type, subscription.once, subscription.callback, subscription.scope);
    } else {
      var subscriptions = subscriptionsByType[subscription.type];
      if (typeof subscriptions === 'undefined') {
        subscriptions = subscriptionsByType[subscription.type] = [];
      }
      subscriptions[subscription.id] = subscription;
      return subscription;
    }
  };

  var reset = function () {
    if (typeof subscriptionsByType !== 'undefined') {
      Object.keys(subscriptionsByType).forEach(function (type) {
        var subscriptions = subscriptionsByType[type];
        if (typeof subscriptions !== 'undefined') {
          subscriptions.forEach(function (subscription) {
            delete subscription.id;
          });
        }
      });
    }
    subscriptionsByType = {};
  };
  reset();
  return {
    on: on,
    emit: emit,
    off: off,
    resume: resume,
    reset: reset

  };
};

var AppConfig = function () {

  var defaultListen  = true;
  var gateway;
  var initGateway;
  var bus = new EventBus();
  var model = new Model(bus);

  var root = require('./props')(model.root);
  var self = this;

  var gatewayConnection;
  var pollingIntervalId;
  var clearPollingInterval = function () {
    if (typeof pollingIntervalId !== 'undefined') {
      clearInterval(pollingIntervalId);
    }
  };

  // Public API
  self.init = function (settings) {
    settings = settings || {};
    var isIdentityValid = typeof settings.identity === 'object' &&
      Object.keys(settings.identity).length > 0;

    if (isIdentityValid) {
      self.identity = settings.identity;
    }
    defaultListen = settings.defaultListen || defaultListen;
    if (!self.identity) {
      throw new TypeError('identity must be non empty object.');
    }

    model.separator = settings.defaultSeparator || model.separator;

    self.schema = settings.schema || self.schema || 'ApplicationConfiguration';

    initGateway = _.isFunction(settings.gateway) ?
      settings.gateway :
      function () {
        if (typeof settings.gateway === 'undefined') {
          settings.gateway = {};
        }
        if (typeof settings.gateway.instance === 'undefined') {
          settings.gateway.instance = _.uuid();
        }
        return require('./gateway')(settings.gateway);
      };
  };

  self.connect = function (listen, callback, scope) {
    clearPollingInterval();
    var subscription;
    if (arguments.length > 0) {
      if (_.isFunction(listen)) {
        callback = listen;
        scope = callback;
        listen = defaultListen;
      }
      subscription = bus.on(events.connect, true, callback, scope);
    }

    var error;
    if (!self.identity) {
      error = 'identity is not specified. did you forget to call init()?';
    } else {
      if (!gateway) {
        gateway = initGateway();
      }
      if (!listen) {
        gatewayConnection =
          gateway.connect(
            self.schema,
            self.identity,
            false,
            function (error, snapshot, updates) {
              if (typeof error === 'undefined') {
                model.applySnapshot(snapshot);
              }
              bus.emit(events.connect, error);
            },
            function (error, status) {
              bus.emit(events.status, error, status);
            });
      } else {
        var connectEmitted = false;
        gatewayConnection = gateway.connect(
          self.schema,
          self.identity,
          true,
          function (error, snapshot, updates) {
            if (typeof snapshot !== 'undefined') {
              model.applySnapshot(snapshot);
            }
            if (typeof updates !== 'undefined') {
              model.applyUpdates(updates);
            }
            if (!connectEmitted) {
              connectEmitted = true;
              bus.emit(events.connect, error);
            }
          },
          function (error, status) {
            var LISTEN_NOT_SUPPORTED = 8;
            if (status.code === LISTEN_NOT_SUPPORTED) {
              pollingIntervalId = setInterval(function () {
                gateway.disconnect(gatewayConnection);
                gatewayConnection = gateway.connect(self.schema, self.identity, false, function (error, snapshot) {
                  model.applySnapshot(snapshot, false);
                });
              }, 2000);
            }
          });
      }
    }

    if (error) {
      setTimeout(bus.emit, 0, events.connect, error);
      throw new Error(error);
    }

    return subscription;

  };

  self.props = function (section, separator) {
    return root.props(section, separator);
  };

  self.modify = function (modifications, callback, scope) {
    if (typeof modifications === 'object') {
      modifications = [modifications];
    }
    var subscription = bus.on(events.update, true, callback, scope);

    return subscription;
  };

  self.onConnect = function (callback, scope) {
    return bus.on(events.connect, false, callback, scope);

  };

  self.onDisconnect = function (callback, scope) {
    return bus.on(events.disconnect, false, callback, scope);
  };

  self.off = function (subscription) {
    if (subscription) {
      bus.off(subscription);
    }
  };

  self.on = function (subscription) {
    if (subscription) {
      bus.resume(subscription);
    }
  };

  self.disconnect = function (callback, scope) {
    if (_.isFunction(callback)) {
      bus.on(events.disconnect, true, callback, scope);
    }
    clearPollingInterval();
    if (typeof gateway !== 'undefined') {
      gateway.disconnect(gatewayConnection, function (error) {
        bus.emit(events.disconnect, error);
      });
      gateway = undefined;
    } else {
      bus.emit(events.disconnect, 'not connected');
    }
  };
};

AppConfig.prototype.identityEqual = helpers.identityEqual;
AppConfig.prototype.identityToString = helpers.identityToString;

module.exports = function () {
  return new AppConfig();
};

},{"./gateway":45,"./helpers":46,"./model":47,"./props":48,"./util":49}],45:[function(require,module,exports){
'use strict';

var gatewayConnection = require('tick42-gateway-connection');
var helpers = require('./helpers');
var identityToString = helpers.identityToString;
var PRODUCT = 'appconfig';

var GatewayTransport = function (options) {
  var connection;
  var dataHandlers = {};
  var statusHandlers = {};
  options = options || {};

  function handleStatusMessage(msg) {
    var handler = statusHandlers[msg.instance];
    if (handler) {
      handler(msg.error, msg.status);
    }
  }
  function handleDataMessage(msg) {
    var schema = msg.schema;
    var schemaHandlers = dataHandlers[schema];
    if (typeof schemaHandlers === 'undefined') {
      return;
    }
    var identityKey = identityToString(msg.identity, true);
    var identityHandlers = schemaHandlers[identityKey];
    if (typeof identityHandlers === 'undefined') {
      return;
    }
    identityHandlers.forEach(function (handler) {
      if (handler) {
        handler(msg.error, msg.snapshot, msg.updates);
      }
    });
  }
  function ensureConnection() {
    if (typeof(connection) === 'undefined') {
      if (typeof options.connection !== 'undefined')
      {
        connection = options.connection;
      }
      else {
        connection = gatewayConnection(options.settings, options.custom_connection);
      }
    }
  }
  var dataSubscription;
  var statusSubscription;
  var connect = function (schema, identity, listen, handler, statusHandler) {
    ensureConnection();
    var schemaHandlers = dataHandlers[schema];
    if (typeof schemaHandlers === 'undefined') {
      schemaHandlers = dataHandlers[schema] = {};
    }
    var identityKey = identityToString(identity, true);
    var identityHandlers = schemaHandlers[identityKey];
    if (typeof identityHandlers === 'undefined') {
      identityHandlers = schemaHandlers[identityKey] = [];
    }
    var handlerToRegister;
    var index;
    if (listen) {
      handlerToRegister = handler;
    } else {
      handlerToRegister = function (error, snapshot, updates) {
        handler(error, snapshot, updates);
        delete identityHandlers[index];
      };
    }

    index = identityHandlers.push(handlerToRegister) - 1;

    if (typeof (dataSubscription) === 'undefined') {
      dataSubscription = connection.on(PRODUCT, GatewayTransport.MessageType.DATA, function (msg) {
        handleDataMessage(msg);
      });
    }
    var instance = options.instance;
    statusHandlers[instance] = statusHandler;
    if (typeof (statusSubscription) === 'undefined') {
      statusSubscription = connection.on(PRODUCT, GatewayTransport.MessageType.STATUS, function (msg) {
        handleStatusMessage(msg);
      });
    }

    var msg = {
      schema: schema,
      identity: identity,
      instance: instance,
      listen: listen
    };
    connection.send(PRODUCT, GatewayTransport.MessageType.CONNECT, msg);
    return {
      schema: schema,
      identity: identity,
      listen: listen,
      handler: handler,
      index : index
    };
  };

  var modify = function (schema, identity, modifications) {
    ensureConnection();
    connection.send(PRODUCT, GatewayTransport.MessageType.MODIFY, modifications);
  };
  var disconnect = function (descriptor) {
    var schemaHandlers = dataHandlers[descriptor.schema];
    if (typeof schemaHandlers !== 'undefined') {
      var identityKey = identityToString(descriptor.identity, true);
      var identityHandlers = schemaHandlers[identityKey];
      if (typeof identityHandlers !== 'undefined') {
        var handler = identityHandlers[descriptor.index];
        if (typeof handler !== 'undefined') {
          var msg = {
            schema: descriptor.schema,
            identity: descriptor.identity,
            instance: options.instance
          };
          connection.send(GatewayTransport.MessageType.DISCONNECT, msg);
          delete identityHandlers[descriptor.index];
        }
        if (identityHandlers.length === 0) {
          delete schemaHandlers[identityKey];
        }
      }
      if (Object.keys(schemaHandlers).length === 0) {
        delete dataHandlers[descriptor.schema];
      }
    }
    if (Object.keys(dataHandlers).length === 0) {
      if (typeof (dataSubscription) !== 'undefined') {
        connection.off(dataSubscription);
      }
    }
    delete statusHandlers[descriptor.instance];
    if (Object.keys(statusHandlers).length === 0) {
      if (typeof statusSubscription !== 'undefined') {
        connection.off(statusSubscription);
      }
    }
  };
  return {
    connect: connect,
    modify: modify,
    disconnect: disconnect
  };
};

GatewayTransport.MessageType = {
  // { schema: 'ApplicationConfiguration', identity: {}, listen: true, instance: '' }
  CONNECT: 'connect',
  // { schema: 'ApplicationConfiguration', identity: {}, instance: '' }
  DISCONNECT: 'disconnect',
  // { schema: 'ApplicationConfiguration', identity: {}, updates: [], instance: '' }
  MODIFY: 'modify',
  // { schema: 'ApplicationConfiguration', identity: {}, error: '', snapshot: {defaultKeyValue: '', keys: [], props: {}}, updates: [] }
  DATA: 'data',
  // { schema: 'ApplicationConfiguration', identity: {}, instance: '', status: '', error: '' }
  STATUS: 'status'
};

module.exports = GatewayTransport;

},{"./helpers":46,"tick42-gateway-connection":50}],46:[function(require,module,exports){
'use strict';

function escapeIdentityText(text) {
  if (typeof text === 'string') {
    return text.replace(/[\\]/g, '\\\\').replace(/[:]/g, '\\:');
  } else {
    return text;
  }
}

function identityToString(identity, includeKeys, separator, order) {
  if (typeof(identity) === 'undefined') {
    return null;
  }
  separator = separator || '/';
  var keys = Object.keys(identity);
  if (typeof(order) === 'function') {
    keys.sort(order);
  } else {
    keys.sort();
  }
  return keys.map(function (key) {
    return includeKeys ? (escapeIdentityText(key) + ':' + escapeIdentityText(identity[key])) : identity[key];
  }).join(separator);
}

function identityEqual(identity1, identity2) {
  return identityToString(identity1, true) === identityToString(identity2, true);
}

function flatten(props, separator, name) {
  separator = separator || '.';
  var prefix = name ? name + separator : '';
  var val = {};
  Object.keys(props).forEach(function (key) {
    if (key.indexOf(prefix) !== 0) {
      return;
    }
    var path = key.substring(prefix.length);
    var target = val;
    var parts = path.split(separator);
    var i;
    for (i = 0; i < parts.length - 1; i++) {
      if (!target[parts[i]]) {
        target[parts[i]] = {};
      }
      target = target[parts[i]];
    }
    target[parts[i]] = props[key].value;
  });
  return val;
}

function propEqual(lhs, rhs) {
  if (lhs.value !== rhs.value) {
    return false;
  }
  for (var i = 0; i < lhs.underlying.length; i++) {
    var lhsUnderlying = lhs.underlying[i];
    var rhsUnderlying = rhs.underlying[i] || {};
    if (lhsUnderlying.value !== rhsUnderlying.value || !identityEqual(lhsUnderlying.parent, rhsUnderlying.parent)) {
      return false;
    }
  }
  return true;
}

module.exports = {
  flatten: flatten,
  propEqual: propEqual,
  identityToString: identityToString,
  identityEqual: identityEqual
};

},{}],47:[function(require,module,exports){
'use strict';

var propEqual = require('./helpers').propEqual;

var UpdateType = {
  Added: 'Added',
  Changed: 'Changed',
  Removed: 'Removed'
};

var Model = function (bus, separator) {
  this.bus = bus;
  this.root = new ViewModel(this, '', separator || '.');
  this.views = {};
};

var ViewModel = function (model, path, separator) {
  var self = this;
  self.model = model;
  self.props = {};
  self.separator = separator || model.separator;
  self.path = path;
};

ViewModel.prototype.getViewModel = function (name, separator) {
  var path = this.path + name + (separator ? separator : '.');
  var model = this.model;
  if (path === '') {
    return model.root;
  }
  if (!model.views[path]) {
    var bestParent = '';
    // fill subview references and choose best parent props to copy from.
    Object.keys(model.views).forEach(function (key) {
      if (path.indexOf(key) === 0) {
        if (bestParent.length < key.length) {
          bestParent = key;
        }
        // keep subviews sorted.
        var subviews = model.views[key].subviews;
        for (var i = 0; i < subviews.length; i++) {
          if (subviews[i].indexOf(path)) {
            subviews.splice(i, 0, path);
            return;
          }
        }
        subviews.push(path);
      }
    });
    var viewModel = new ViewModel(model, path, separator);

    var parentProps = bestParent === '' ? model.root.props : model.views[bestParent].model.props;
    Object.keys(parentProps).forEach(function (key) {
      var prop = parentProps[key];
      if (prop.name.indexOf(path) === 0) {
        var name = prop.name.substring(path.length);
        viewModel.props[name] = prop;
      }
    });

    model.views[path] = {
      subviews: [],
      model: viewModel
    };
  }
  return model.views[path].model;
};

ViewModel.prototype.on = function (callback, scope) {
  return this.model.on(this.path, callback, scope);
};

Model.prototype.on = function (path, callback, scope) {
  var type = updateTypeForPath(path);
  return this.bus.on(type, false, callback, scope);
};

Model.prototype.applySnapshot = function (snapshot, isSnapshot) {
  isSnapshot = typeof isSnapshot === 'undefined' ? true : isSnapshot;

  var updates = toUpdates(isSnapshot ? {} : this.root.props, snapshot.props);
  applyUpdatesAndEmitEvents(this, updates, isSnapshot);
};

function updateTypeForPath(path) {
  var type = 'update';
  if (path !== '') {
    type = type + '|' + path;
  }
  return type;
}

// shallow copy
function cloneUpdateForPath(update, path) {
  var clone = {
    type: update.type,
    name: update.name.substring(path.length)
  };

  switch (update.type) {
    case UpdateType.Changed:
      clone.oldValue = update.oldValue;
      /* falls through */
    case UpdateType.Added:
      clone.value = update.value;
      break;
    case UpdateType.Removed:
      /* falls through */
    default:
      break;
  }
  return clone;
}

function applyUpdatesAndEmitEvents(model, updates, isSnapshot) {
  var views = Object.keys(model.views);
  var effectiveUpdates = {
    '': updates
  };
  if (views.length > 0) {
    // sort views for prefix search
    if (views.length > 1) {
      views.sort();
    }
    updates.forEach(function (update) {
      for (var i = 0; i < views.length; views++) {
        if (update.name.indexOf(views[i]) === 0) {
          break;
        }
      }
      var view = views[i];
      if (typeof view === 'undefined') {
        return;
      }
      effectiveUpdates[view].push(cloneUpdateForPath(update, view));
    });
  }

  var affectedPaths = Object.keys(effectiveUpdates);
  if (affectedPaths.length > 1) {
    affectedPaths.sort();
  }
  affectedPaths.forEach(function (path) {
    var viewModel = path === '' ? model.root : model.views[path].model;
    if (isSnapshot) {
      viewModel.props = {};
    }
    effectiveUpdates[path].forEach(function (update) {
      switch (update.type) {
        case UpdateType.Added:
          // fall-through
        case UpdateType.Changed:
          // changed works even for missing properties
          viewModel.props[update.name] = update.value;
          break;
        case UpdateType.Removed:
          delete viewModel.props[update.name];
          break;
        default:
          // do nothing
          break;
      }
    });
  });
  affectedPaths.forEach(function (path) {
    var type = updateTypeForPath(path);
    model.bus.emit(type, isSnapshot, updates);
  });
}
Model.prototype.applyUpdates = function (updates) {
  applyUpdatesAndEmitEvents(this, updates, false);
};

function toUpdates(image, snapshot) {
  snapshot = snapshot || {};
  var updates = [];
  var toDelete = Object.keys(image);
  Object.keys(snapshot).forEach(function (key) {
    var update = {};
    if (typeof image[key] === 'undefined') {
      update.type = UpdateType.Added;
    } else {
      if (!propEqual(image[key], snapshot[key])) {
        update.type = UpdateType.Changed;
        update.oldValue = image[key];
      }
      for (var i = 0; i < toDelete.length; toDelete++) {
        if (toDelete[i] === key) {
          break;
        }
      }
      if (typeof toDelete[i] !== 'undefined') {
        toDelete.splice(i, 1);
      }
    }
    if (update.type) {
      update.value = snapshot[key];
      update.name = key;
      updates.push(update);
    }
  });
  toDelete.forEach(function (key) {
    updates.push({
      type: UpdateType.Removed,
      name: key
    });
  });
  return updates;
}

module.exports = Model;

},{"./helpers":46}],48:[function(require,module,exports){
'use strict';
var flatten = require('./helpers').flatten;

var Props = function (model) {
  var prop = function (name) {
    return model.props[name];
  };
  var val = function val(name) {
    if (typeof name === 'undefined' || typeof model.props[name] === 'undefined') {
      return flatten(model.props, model.separator, name);
    }
    return model.props[name].value;
  };

  var props = function (section, separator) {
    section = section || '';
    if (section === '') {
      // TODO: support separator change for '' (same) section.
      return self;
    }
    separator = separator || model.separator;
    return new Props(model.getViewModel(section, separator));
  };
  var forEach = function (callback, scope) {
    Object.keys(model.props).forEach(function (key) {
      callback.call(scope, model.props[key]);
    });
  };
  var onUpdate = function (callback, scope) {
    model.on(callback, scope);
  };
  var self = {
    prop: prop,
    val: val,
    props: props,
    forEach: forEach,
    onUpdate: onUpdate
  };
  return self;
};

module.exports = Props;

},{"./helpers":46}],49:[function(require,module,exports){
'use strict';

var uuid = function () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0;
    var v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
};
var isFunction = function (value) {
  if (value === undefined || value === null) {
    return false;
  }
  return typeof value === 'function';
};

var isString = function (value) {
  return typeof value === 'string';
};

var levels = {
  debug: 'debug',
  info: 'info',
  warn: 'warn',
  error: 'error'
};
var log = function (level, args) {
  if (console) {
    var logger = console[level];
    if (isFunction(logger)) {
      var now = new Date();
      [].splice.call(args, 0, 0, now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds());
      logger.apply(console, args);
    }
  }
};
var info = function () {
  log(levels.info, arguments);
};

var warn = function () {
  log(levels.warn, arguments);
};

var debug = function () {
  log(levels.debug, arguments);
};

module.exports = {
  uuid: uuid,
  isFunction: isFunction,
  isString: isString,
  log: log,
  warn: warn,
  info: info,
  debug: debug
};

},{}],50:[function(require,module,exports){
(function (global){
var connection = function (settings, custom_connection){
	settings = settings||{};
	//The message handlers that have to be executed for each received message
	var message_handlers = {};
	
	var ids = 0;
	
	var connection = {
		//Executes appropriate message handlers for the message type.
		_handle_message: function (message){
			 //Retrieve handlers for the message type
			 var handlers = message_handlers[message.type];
			 if(handlers !==undefined){
				 //Execute them
				 Object.keys(handlers).forEach(function(handler_id){
					var handler = handlers[handler_id];
					if(handler!==undefined){handler(message.message);}
				 });
			 }
		},
		//Attaches a handler
		on: function(product, type, message_handler){
		   if(message_handlers[type] === undefined){message_handlers[type] = {};}
		   var id = ids++;
		   message_handlers[type][id]= message_handler;
		   return {type:type, id:id};
		},
		
		//Remove a handler 
		off: function(info){
			delete message_handlers[info.type][info.id];
		},
		//Dummy functions for transports that are always connected
		connected:function(a){a();},
		disconnected:function(){},
		version: "1.3.1"
	};

	function create_custom_connection(connection){
		connection.send = function(product, type, message){
			custom_connection.publish({type:type, message:message});
		};
		custom_connection.subscribe(connection._handle_message);
		return connection;
	}

	if(settings.websocket_url!==undefined){
		return require("./ws")(connection, settings);
  }else if(settings.http_url !== undefined){
    return require("./http")(connection, settings);
  }else if(global.fin !==undefined){
		return require("./fin")(connection, settings);
	}else if(custom_connection!==undefined){
		return create_custom_connection(connection, settings);
	//Connect via HTML Container facade
	}else if (global.htmlContainer!==undefined){
		return require("./cont")(connection, settings);
	}else {
		throw "No connection. Make sure you are running the application from OpenFin, or Tick42 HTML Container or fill the 'connection.websocket_url' property.";
	}
};

if(global.tick42===undefined){global.tick42 = {};}
global.tick42.connection = connection;

module.exports = connection;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./cont":51,"./fin":52,"./http":53,"./ws":54}],51:[function(require,module,exports){
(function (global){
module.exports = function(connection){
	var connection_id =  Math.floor(1e10 * Math.random()).toString();
	//Route messages to facade(s)
	connection.send = function (product, type, message){
		if(product ==="metrics"){
			global.htmlContainer.metricsFacade.send(type, JSON.stringify(message));
		}else if(product ==="log"){
			global.htmlContainer.loggingFacade.send(type, JSON.stringify(message));
		}else if (product == "appconfig") {
            global.htmlContainer.appConfigFacade.send(type, JSON.stringify(message), connection_id);
        }
	};
	if (global.htmlContainer.appConfigFacade !== undefined) {
        global.htmlContainer.appConfigFacade.initConnection(
            connection_id,
            function (messageAsJson) {
                return connection._handle_message(JSON.parse(messageAsJson));
            });
    }
	global.connections = global.connections||{}; 
	//Expose function for sending messages:
	global.connections['connection'+connection_id] = connection._handle_message;

	return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],52:[function(require,module,exports){
(function (global){
module.exports = function(connection, settings){
	if(global.console!==undefined&& settings.debug===true){
		console.log("Attemping to connect to Gateway via OpenFin Inter Application Bus.");
	}

	//A function for sending a message 
	connection.send = function(product, type, message){
		fin.desktop.InterApplicationBus.publish("AGM", {type:type, message:message});
	};
	//A function that receives messages
	fin.desktop.InterApplicationBus.subscribe('*','AGM', connection._handle_message);
	if(global.console!==undefined&& settings.debug===true){
		console.log("Connected to OpenFin transport.");
	}
	
	return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],53:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
  var url = settings.http_url;
  // polling interval in ms, default is 1 second
  var interval = settings.http_interval_ms;
  if (!interval) interval = 1000;

  function log_debug(message) {
    if (global.console !== undefined && (settings.debug === true || settings.trace === true)) {
      console.log(message);
    }
  }

  function log_trace(message) {
    if (global.console !== undefined && settings.trace === true) {
      console.log(message);
    }
  }

  log_debug("Attemping to connect to Gateway via HTTP with url '" + url + "' and polling interval " + interval + " ms");

  poll(url, interval, 0, function (items) {
    for (var index = 0; index < items.length; index++) {
      connection._handle_message(items[index]);
    }
  });

  connection.send = function (product, type, message, id) {
    var msg = JSON.stringify({ type: type, message: message, id: id });
    http_post(url, msg);
  };

  /**
   * Polls data from a given url on some interval
   * @param url       Base server url. A sequence url param may be added based on the seq param
   * @param interval  Interval (in ms) between polling requestts
   * @param seq       Next sequence number we should ask for (if 0 the server will return the last known message)
   * @param ondata    Data callback    
   */
  function poll(url, interval, seq, ondata) {
    // construct the get Url - if seq != 0 add as url param to get 
    // only messages after this sequence
    var getUrl = url;

    if (seq !== 0) {
      getUrl = url + "?sequence=" + seq + "&no-cache=" + new Date().getTime();
    }    
        
    // create a request    
    var xmlhttp = createCORSRequest("GET", getUrl, function () {
      if (seq === 0){
        log_debug("Connected to Gateway on " + url);
      }
      log_trace("Response from '" + getUrl + "' is " + xmlhttp.responseText);
      var message = JSON.parse(xmlhttp.responseText);
      // the server returns the number of the next sequence that we must query for
      var nextSeq = message.nextSequence;
      // call user callbacke    
      ondata(message.data);
      // re-schedule
      setTimeout(function () {
        poll(url, interval, nextSeq, ondata);
      }, interval);
    });

    xmlhttp.onerror = function (ev) {
      console.log("Error polling data from http server '" + getUrl + "' - " + ev);
      // re-schedule
      setTimeout(function () {
        poll(url, interval, seq, ondata);
      }, interval);
    };

    log_trace("Sending GET to '" + getUrl + "'");
    xmlhttp.send();
  }

  /** 
   * POSTs a message to a given url 
   */
  function http_post(url, message) {
    // create a request    
    var xmlhttp = createCORSRequest("POST", url);
    log_trace("Sending POST to '" + url + "' : " + message);
    xmlhttp.send(message);
  }

  /** 
   * Creates CORS request (cross domain requests) for different browsers - XMLHttpRequest withCredentials
   * for Chrome and FF and XDomainRequest for IE
   */
  function createCORSRequest(method, url, result_callback) {
    var xhr = new XMLHttpRequest();    
    
    if ("withCredentials" in xhr) {
      // Check if the XMLHttpRequest object has a "withCredentials" property.
      // "withCredentials" only exists on XMLHTTPRequest2 objects.
      xhr.open(method, url, true);
      if (typeof result_callback !== "undefined"){
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4 && xhr.status == 200) {
            result_callback();
          }
        };
      }
    } else if (typeof XDomainRequest != "undefined") {
      // Otherwise, check if XDomainRequest.
      // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
      xhr = new XDomainRequest();
      xhr.open(method, url);
      if (typeof result_callback !== "undefined"){
        xhr.onload = result_callback;
      }
    } else {
      // Otherwise, CORS is not supported by the browser.
      xhr = null;
    }
    return xhr;
  }
 
  return connection;
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],54:[function(require,module,exports){
(function (global){
module.exports = function(connection, settings){
	var connected = false;
	
	//Load the 'ws' library, but only if we are running under node js
	var WebSocket = require("detect-node")?require("ws"):global.WebSocket;
	
	function initiate_socket(){
		if(global.console!==undefined&& settings.debug===true){
			console.log("Attemping to connect to Gateway via WebSocket.");
		}

		var ws = new WebSocket(settings.websocket_url);
		//Add user callbacks
		ws.onclose = function(event){
			if(typeof settings.disconnected==="function"){settings.disconnected(settings.websocket_url, event);}
			connected = false;
		};
		//Log on connection
		ws.onopen = function(){
			if(typeof settings.connected==="function"){settings.connected(settings.websocket_url);}
			if(global.console!==undefined && settings.debug===true){
				console.log("Connected to WS URL "+settings.websocket_url);
			}
			connected = true;
		};
		//Attach handler
		ws.onmessage = function(message){
			connection._handle_message(JSON.parse(message.data));
		};
		return ws;
	}
	
	//Initiate a new socket (this gets re-executed on reconnect)
	var socket = initiate_socket();
	
	//Create a function for sending a message
	connection.send = function(product, type, message, id){
		//If we are connected send the message
		if(socket.readyState ===1){
			socket.send(JSON.stringify({type:type, message:message, id:id}));
		//If we are not connected and we are not attempting to connect right now, attempt to connect
		}else if (socket.readyState !==0){
			socket = initiate_socket();
		}
	};
	connection.websocket_url = function(a){
		settings.websocket_url = a;
		socket.close();
		socket = initiate_socket();
	};
	
	connection.connected = function(a){
		if(connected){a(settings.websocket_url);}
		settings.connected = a;
	};
	connection.disconnected = function(a){
		settings.disconnected = a;
	};
	
	return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-node":55,"ws":56}],55:[function(require,module,exports){
(function (global){
module.exports = false;

// Only Node.JS has a process variable that is of [[Class]] process
try {
 module.exports = Object.prototype.toString.call(global.process) === '[object process]' 
} catch(e) {}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],56:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],57:[function(require,module,exports){
var asciiTable = require("ascii-table");
var tick42Connection = require("tick42-gateway-connection");

var levels = [ 'trace', 'debug', 'info', 'warn', 'error', 'off' ];

function serializePath(path) {
	return path.length === 0 ? "" : path.join(".");
}

var isConnection = function(c) {
	return typeof c === "object" && typeof c.send === "function" && typeof c.on === "function";
};

function getLevel(logger, level) {
	//Retrieves the console or publish level of a logger
	//logger - the logger for which to retrieve the level
	//level - a string which can either be "publishLevel" for retrieving the publish level or "c_level" for retrieving the console level.
	if (logger[level] !== undefined) {
		return logger[level];
	} else if (logger.parent !== undefined) {
		return getLevel(logger.parent, level);
	}
}

function messageToTable(title, rows) {
	//Display message as table in file
	var keys = getAllKeys(rows);
	//fill rows with message properties
	var tableRows = rows.map(function (obj) {
		return keys.map(function (key) {
			return obj[key];
		});
	});

	var table_message = asciiTable.factory({
		title: title,
		heading: keys,
		rows: tableRows
	});
	return table_message.toString();
}

function getAllKeys(data) {
	//Accepts an array of objects and returns an array of all the keys from all objects
	var allKeys = [];

	data.forEach(function (obj) {
		Object.keys(obj).forEach(function (key) {
			if (allKeys.indexOf(key) === -1) {
				allKeys.push(key);
			}
		});
	});
	return allKeys;
}

function logger(configuration) {
	if (typeof configuration.connection !== "object") {
		configuration.connection = {};
	}

	//Set debug for the connection module if global debug is set
	configuration.connection.debug = configuration.debug;

	//Init connection
	//Determine if we are given a ready 'connection' object or a configuration.
	var connection = isConnection(configuration.connection) ? configuration.connection : tick42Connection(configuration.connection);

	var idKeys = ["system", "service", "instance"];

	//Convert instance to string, throw exceptions if it is not full
	var instance_str = idKeys.map(function (key) {
		var prop = configuration.identity[key];
		if (typeof prop !== "string") {
			throw 'Please specify "' + key + '" in your identity';
		}
		return prop;
	}).join("/");

	var loggerProto = {
		subLogger: function (name) {
			//Check if the sublogger is already created
			var existingSublogger = this.subloggers.filter(function (subLogger) {
				return subLogger.name === name;
			})[0];

			if (existingSublogger !== undefined) {
				return existingSublogger;
			}

			//Check if the name isn't the same as one of the parent properties
			Object.keys(this).forEach(function (key) {
				if (key === name) {
					throw 'This sub logger name is not allowed.';
				}
			});
			//Check if the name isn't the same as one of the parent methods
			Object.keys(loggerProto).forEach(function (key) {
				if (key === name) {
					throw 'This sub logger name is not allowed.';
				}
			});

			var path = this.path.slice(0);
			path.push(this.name);
			return createLogger(name, path, this);
		},

		publishLevel: function (level) {
			if (level !== null && level !== undefined) {
				this._publishLevel = level;
			}
			return getLevel(this, "_publishLevel");
		},

		consoleLevel: function (level) {
			if (level !== null && level !== undefined) {
				this._consoleLevel = level;
			}
			return getLevel(this, "_consoleLevel");
		},

		metricsLevel: function (level, metricsSystem) {
			if (level !== null && level !== undefined) {
				this._metricLevel = level;
			}

			if (metricsSystem !== undefined) {
				if (typeof metricsSystem === "object" && typeof metricsSystem.objectMetric === "function") {
					this.metricSystem = metricsSystem;
				} else {
					throw "Please specify metric system ";
				}
			}
		},

		table: function (message) {
			//message must be in an array, to be displayed as table
			if (!Array.isArray(message)) {
				throw 'The message must be in an array';
			}

			//Retrieve logger name and levels
			var loggerName = getLoggerName(this);

			//Publish in console
			if (shouldPublish(getLevel(this, '_consoleLevel'), 'info')) {
				console.info(loggerName + ':');
				console.table(message);
			}
			//Publish in file
			if (shouldPublish(getLevel(this, '_publishLevel'), 'info')) {
				connection.send('log', 'LogMessage', {
					instance: instance_str,
					level: levels.indexOf('info'),
					logger: loggerName,
					message: messageToTable(loggerName, message)
				});
			}
		},

		log: function (message, level) {
			publishMessage(this, level || "info", message);
		}
	};

	function createLogger(name, path, parent) {
		var logger = Object.create(loggerProto);
		logger.name = name;
		logger.path = path;
		logger.subloggers = [];
		logger.parent = parent;
		if (parent !== undefined) {
			//add sublogger to subloggers array
			parent.subloggers.push(logger);
			//add easy access to sublogger
			parent[logger.name] = logger;
			//create metric system
			if (parent.metricSystem !== undefined) {
				logger.metricsLevel('warn', parent.metricSystem.subSystem(logger.name));
			}
		}
		levels.forEach(function (level) {
			logger[level] = function (message) {
				publishMessage(logger, level, message);
			};
		});

		logger.off = function(){};

		logger.version = "2.0.1";

		return logger;
	}

	function publishMessage(logger, level, message) {
		//Retrieve logger name and levels
		var logger_name = getLoggerName(logger);

		//Add stack trace if the message is an error
		if (level === 'error') {
			var e = new Error();
			if (e.stack) {
				message = message + "\n" + (e.stack.split("\n").slice(3).join("\n"));
			}
		}

		//Publish in console
		if (shouldPublish(getLevel(logger, '_consoleLevel'), level)) {
			console[level](logger_name + ": " + message);
		}
		//Publish in file
		if (shouldPublish(getLevel(logger, '_publishLevel'), level)) {
			connection.send('log', 'LogMessage', {
				instance: instance_str,
				level: levels.indexOf(level),
				logger: logger_name,
				message: message
			});
		}

		//Publish in metrics
		if (shouldPublish(getLevel(logger, '_metricLevel'), level)) {
			if (logger.metricSystem !== undefined) {
				logger.metricSystem.objectMetric('LogMessage', {
					Time: new Date(),
					Logger: logger_name,
					Level: level,
					Message: message
				});
			}
		}
	}

	var shouldPublish = function (publishLevel, messageLevel) {
		return (!publishLevel || levels.indexOf(publishLevel) <= levels.indexOf(messageLevel));
	};

	var getLoggerName = function (logger) {
		var loggerPathAndName = logger.path.slice();
		loggerPathAndName.push(logger.name);
		return "[" + serializePath(loggerPathAndName) + "]";
	};

	var mainLogger = createLogger("main", [], undefined);
	mainLogger.publishLevel("warn");
	mainLogger.consoleLevel("info");
	mainLogger.metricsLevel("warn");

	return mainLogger;
}

if(window.tick42===undefined){ window.tick42 = {}; }
window.tick42.log = logger;

module.exports = logger;

},{"ascii-table":3,"tick42-gateway-connection":50}],58:[function(require,module,exports){
var objectMetric_1 = require("../metrics/objectMetric");
var stringMetric_1 = require("../metrics/stringMetric");
var numberMetric_1 = require("../metrics/numberMetric");
var timestampMetric_1 = require("../metrics/timestampMetric");
var MetricSerializer = (function () {
    function MetricSerializer() {
    }
    MetricSerializer.metricToMessage = function (metric) {
        var def = MetricSerializer._getMetricDefinition(metric.name, metric.value, metric.path, metric.type, metric.description, metric.period, metric.resolution);
        return {
            id: metric.id,
            instance: metric.repo.instance,
            definition: def,
            value: MetricSerializer._serializeValue(metric.value),
        };
    };
    MetricSerializer._getMetricDefinition = function (name, value, path, type, description, resolution, period) {
        var def = {
            name: name,
            description: description,
            type: type ? type : MetricSerializer._getTypeFromValue(value),
            path: path,
            resolution: resolution,
            period: period
        };
        if (def.type === objectMetric_1.ObjectMetric.type) {
            def.Composite = Object.keys(value).reduce(function (arr, key) {
                var val = value[key];
                arr.push(MetricSerializer._getMetricDefinition(key, val, path));
                return arr;
            }, []);
        }
        return def;
    };
    MetricSerializer._serializeValue = function (value) {
        if (value && value.constructor === Date) {
            return {
                value: {
                    type: this._valueTypes.indexOf("date"),
                    value: value.valueOf(),
                    isArray: false
                }
            };
        }
        else if (typeof value === "object") {
            return {
                CompositeValue: Object.keys(value).reduce(function (arr, key) {
                    var val = MetricSerializer._serializeValue(value[key]);
                    val.InnerMetricName = key;
                    arr.push(val);
                    return arr;
                }, [])
            };
        }
        else {
            return { value: { type: this._valueTypes.indexOf(typeof value), value: value, isArray: false } };
        }
    };
    MetricSerializer._getTypeFromValue = function (value) {
        var typeAsString = value.constructor === Date ? 'timestamp' : typeof value;
        switch (typeAsString) {
            case 'string':
                return stringMetric_1.StringMetric.type;
            case 'number':
                return numberMetric_1.NumberMetric.type;
            case 'timestamp':
                return timestampMetric_1.TimestampMetric.type;
            case 'object':
                return objectMetric_1.ObjectMetric.type;
        }
        return 0;
    };
    MetricSerializer._valueTypes = [
        "boolean",
        "int",
        "number",
        "long",
        "string",
        "date",
        "object"];
    return MetricSerializer;
})();
exports.MetricSerializer = MetricSerializer;

},{"../metrics/numberMetric":63,"../metrics/objectMetric":64,"../metrics/stringMetric":67,"../metrics/timestampMetric":69}],59:[function(require,module,exports){
var metricSerializer_1 = require("./metricSerializer");
var MetricsBridge = (function () {
    function MetricsBridge(repo, connection) {
        var _this = this;
        this._repo = repo;
        this._connection = connection;
        connection.on('metrics', "MetricsSnapshotRequest", function (instanceInfo) {
            if (instanceInfo.Instance !== repo.instance) {
                return;
            }
            _this.sendFull(_this._repo);
        });
    }
    MetricsBridge.prototype.sendFull = function (repo) {
        var rootSystem = repo.root;
        if (!rootSystem) {
            return;
        }
        if (rootSystem.subSystems.length == 0) {
            return;
        }
        this.sendFullSystem(rootSystem);
    };
    MetricsBridge.prototype.sendFullSystem = function (s) {
        var _this = this;
        this.createSystem(s);
        s.subSystems.forEach(function (sub) {
            _this.sendFullSystem((sub));
        });
        s.metrics.forEach(function (m) {
            _this.createMetric(m);
        });
    };
    MetricsBridge.prototype.createMetric = function (metric) {
        this._send("CreateMetric", metricSerializer_1.MetricSerializer.metricToMessage(metric));
    };
    MetricsBridge.prototype.updateMetric = function (metric) {
        this._send("UpdateMetric", metricSerializer_1.MetricSerializer.metricToMessage(metric));
    };
    MetricsBridge.prototype.createSystem = function (system) {
        if (system.parent !== undefined) {
            this._send("CreateMetricSystem", {
                id: system.id,
                instance: system.repo.instance,
                definition: { name: system.name, description: system.description, path: system.path }
            });
        }
    };
    MetricsBridge.prototype.updateSystem = function (system, state) {
        this._send("UpdateMetricSystem", {
            id: system.id,
            instance: system.repo.instance,
            state: state
        });
    };
    MetricsBridge.prototype.heartbeat = function (repo, interval) {
        this._send("HeartbeatMetrics", { publishingInterval: interval, instance: repo.instance });
    };
    MetricsBridge.prototype._send = function (type, message) {
        this._connection.send("metrics", type, message);
    };
    return MetricsBridge;
})();
exports.MetricsBridge = MetricsBridge;

},{"./metricSerializer":58}],60:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var AddressMetric = (function (_super) {
    __extends(AddressMetric, _super);
    function AddressMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, AddressMetric.type, value || '');
    }
    AddressMetric.type = 8;
    return AddressMetric;
})(metric_1.Metric);
exports.AddressMetric = AddressMetric;

},{"./metric":62}],61:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var CountMetric = (function (_super) {
    __extends(CountMetric, _super);
    function CountMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, CountMetric.type, value || 0);
    }
    CountMetric.prototype.increment = function () {
        this.incrementBy(1);
    };
    CountMetric.prototype.decrement = function () {
        this.decrementBy(1);
    };
    CountMetric.prototype.incrementBy = function (n) {
        this.update((this.value || 0) + n);
    };
    CountMetric.prototype.decrementBy = function (n) {
        this.update((this.value || 0) - n);
    };
    CountMetric.type = 3;
    return CountMetric;
})(metric_1.Metric);
exports.CountMetric = CountMetric;

},{"./metric":62}],62:[function(require,module,exports){
var Metric = (function () {
    function Metric(def, parent, transport, type, value) {
        this.name = def.name;
        this.description = def.description;
        this.system = parent;
        this.repo = parent.repo;
        this.id = parent.path + "/" + this.name;
        this.value = value;
        this.type = type;
        this.path = parent.path.slice(0);
        this.path.push(parent.name);
        this._transport = transport;
        this._transport.createMetric(this);
    }
    Metric.prototype.update = function (value) {
        this.value = value;
        this._transport.updateMetric(this);
    };
    Metric.type = 0;
    return Metric;
})();
exports.Metric = Metric;

},{}],63:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var NumberMetric = (function (_super) {
    __extends(NumberMetric, _super);
    function NumberMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, NumberMetric.type, value || 0);
    }
    NumberMetric.prototype.increment = function () {
        this.incrementBy(1);
    };
    NumberMetric.prototype.decrement = function () {
        this.decrementBy(1);
    };
    NumberMetric.prototype.incrementBy = function (n) {
        this.update((this.value || 0) + n);
    };
    NumberMetric.prototype.decrementBy = function (n) {
        this.update((this.value || 0) - n);
    };
    NumberMetric.type = 2;
    return NumberMetric;
})(metric_1.Metric);
exports.NumberMetric = NumberMetric;

},{"./metric":62}],64:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var ObjectMetric = (function (_super) {
    __extends(ObjectMetric, _super);
    function ObjectMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, ObjectMetric.type, value);
    }
    ObjectMetric.prototype.update = function (value) {
        _super.prototype.update.call(this, value);
    };
    ObjectMetric.type = 11;
    return ObjectMetric;
})(metric_1.Metric);
exports.ObjectMetric = ObjectMetric;

},{"./metric":62}],65:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var RateMetric = (function (_super) {
    __extends(RateMetric, _super);
    function RateMetric(def, parent, transport, value) {
        this.period = def.period;
        this.resolution = def.resolution;
        _super.call(this, def, parent, transport, RateMetric.type, value || 0);
    }
    RateMetric.type = 4;
    return RateMetric;
})(metric_1.Metric);
exports.RateMetric = RateMetric;

},{"./metric":62}],66:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var StatisticsMetric = (function (_super) {
    __extends(StatisticsMetric, _super);
    function StatisticsMetric(def, parent, transport, value) {
        this.period = def.period;
        this.resolution = def.resolution;
        _super.call(this, def, parent, transport, StatisticsMetric.type, value || 0);
    }
    StatisticsMetric.type = 6;
    return StatisticsMetric;
})(metric_1.Metric);
exports.StatisticsMetric = StatisticsMetric;

},{"./metric":62}],67:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var StringMetric = (function (_super) {
    __extends(StringMetric, _super);
    function StringMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, StringMetric.type, value || '');
    }
    StringMetric.type = 1;
    return StringMetric;
})(metric_1.Metric);
exports.StringMetric = StringMetric;

},{"./metric":62}],68:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var TimespanMetric = (function (_super) {
    __extends(TimespanMetric, _super);
    function TimespanMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, TimespanMetric.type, value || false);
    }
    TimespanMetric.prototype.start = function () {
        this.update(true);
    };
    TimespanMetric.prototype.stop = function () {
        this.update(false);
    };
    TimespanMetric.type = 10;
    return TimespanMetric;
})(metric_1.Metric);
exports.TimespanMetric = TimespanMetric;

},{"./metric":62}],69:[function(require,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var TimestampMetric = (function (_super) {
    __extends(TimestampMetric, _super);
    function TimestampMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, TimestampMetric.type, value || new Date());
    }
    TimestampMetric.prototype.now = function () {
        this.update(new Date());
    };
    TimestampMetric.type = 7;
    return TimestampMetric;
})(metric_1.Metric);
exports.TimestampMetric = TimestampMetric;

},{"./metric":62}],70:[function(require,module,exports){
var system_1 = require("./system");
var transport_1 = require("./bridge/transport");
var Repository = (function () {
    function Repository(config) {
        this._config = config;
        this._transport = new transport_1.MetricsBridge(this, config.connection);
        this.instance = config.identity.system + '/' + config.identity.service + '/' + config.identity.instance;
        this.identity = config.identity;
        this._startHeartbeating();
        this.root = new system_1.System('', this, this._transport);
        this._initSystemMetrics(this.root, config.clickStream || config.clickStream === undefined);
    }
    Repository.prototype._startHeartbeating = function () {
        var _this = this;
        this._transport.heartbeat(this, this._config.settings.heartbeatInterval);
        setInterval(function () {
            _this._transport.heartbeat(_this, _this._config.settings.heartbeatInterval);
        }, this._config.settings.heartbeatInterval);
    };
    Repository.prototype._initSystemMetrics = function (rootSystem, useClickStream) {
        if (navigator) {
            rootSystem.stringMetric('UserAgent', navigator.userAgent);
        }
        if (useClickStream && document) {
            var clickStream = rootSystem.subSystem("ClickStream");
            var documentClickHandler = function (e) {
                if (!e.target) {
                    return;
                }
                clickStream.objectMetric("LastBrowserEvent", {
                    type: "click",
                    timestamp: new Date(),
                    target: {
                        className: e.target ? e.target.className : '',
                        id: e.target.id,
                        type: '<' + e.target.tagName.toLowerCase() + '>',
                        href: e.target.href || ""
                    }
                });
            };
            clickStream.objectMetric("Page", {
                title: document.title,
                page: window.location.href
            });
            if (document.addEventListener) {
                document.addEventListener('click', documentClickHandler);
            }
            else {
                document.attachEvent('onclick', documentClickHandler);
            }
        }
    };
    return Repository;
})();
exports.Repository = Repository;

},{"./bridge/transport":59,"./system":71}],71:[function(require,module,exports){
var numberMetric_1 = require("./metrics/numberMetric");
var timespanMetric_1 = require("./metrics/timespanMetric");
var stringMetric_1 = require("./metrics/stringMetric");
var addressMetric_1 = require("./metrics/addressMetric");
var objectMetric_1 = require("./metrics/objectMetric");
var timestampMetric_1 = require("./metrics/timestampMetric");
var countMetric_1 = require("./metrics/countMetric");
var statisticsMetric_1 = require("./metrics/statisticsMetric");
var rateMetric_1 = require("./metrics/rateMetric");
var System = (function () {
    function System(name, repo, transport, parent, description) {
        this.metrics = [];
        this.subSystems = [];
        this.name = name;
        this.description = description || '';
        this.repo = repo;
        this.parent = parent;
        this._transport = transport;
        this.path = this._buildPath(this.parent);
        this.id = (this.path.length > 0 ? this.path.join('/') + '/' : '') + this.name;
        this.identity = repo.identity;
        this.root = repo.root;
        this._transport.createSystem(this);
    }
    System.prototype.subSystem = function (name, description) {
        if (!name || name.length === 0) {
            throw new Error('name is required');
        }
        var matchingSystems = this.subSystems.filter(function (s) { return s.name === name; });
        if (matchingSystems.length > 0) {
            return matchingSystems[0];
        }
        var system = new System(name, this.repo, this._transport, this, description);
        this.subSystems.push(system);
        return system;
    };
    System.prototype.setState = function (state, description) {
        this._transport.updateSystem(this, { state: state, description: description });
    };
    System.prototype.stringMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, stringMetric_1.StringMetric.type, value, function (metricDef) {
            return new stringMetric_1.StringMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.numberMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, numberMetric_1.NumberMetric.type, value, function (metricDef) {
            return new numberMetric_1.NumberMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.countMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, countMetric_1.CountMetric.type, value, function (metricDef) {
            return new countMetric_1.CountMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.addressMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, addressMetric_1.AddressMetric.type, value, function (metricDef) {
            return new addressMetric_1.AddressMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.objectMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, objectMetric_1.ObjectMetric.type, value, function (metricDef) {
            return new objectMetric_1.ObjectMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.timespanMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, timespanMetric_1.TimespanMetric.type, value, function (metricDef) {
            return new timespanMetric_1.TimespanMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.timestampMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, timestampMetric_1.TimestampMetric.type, value, function (metricDef) {
            return new timestampMetric_1.TimestampMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.rateMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, rateMetric_1.RateMetric.type, value, function (metricDef) {
            return new rateMetric_1.RateMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.statiticsMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, statisticsMetric_1.StatisticsMetric.type, value, function (metricDef) {
            return new statisticsMetric_1.StatisticsMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype._unionToMetricDef = function (definition) {
        var metricDef;
        if (typeof definition === 'string') {
            metricDef = { name: definition };
        }
        else {
            metricDef = definition;
        }
        if (metricDef.name === undefined) {
            throw new Error('Metric name is required.');
        }
        return metricDef;
    };
    System.prototype._getOrCreateMetric = function (definition, expectedType, value, createFunc) {
        var metricDef = this._unionToMetricDef(definition);
        var matchingMetrics = this.metrics.filter(function (m) { return m.name === metricDef.name; });
        if (matchingMetrics.length > 0) {
            var existingMetric = matchingMetrics[0];
            if (existingMetric.type !== expectedType) {
                throw new Error('A metric named ' + metricDef.name + ' is already defined with different type');
            }
            if (typeof value !== 'undefined') {
                existingMetric.update(value);
            }
            return existingMetric;
        }
        var newMetric = createFunc(metricDef);
        this.metrics.push(newMetric);
        return newMetric;
    };
    System.prototype._buildPath = function (system) {
        if (!system || !system.parent) {
            return [];
        }
        var path = this._buildPath(system.parent);
        path.push(system.name);
        return path;
    };
    return System;
})();
exports.System = System;

},{"./metrics/addressMetric":60,"./metrics/countMetric":61,"./metrics/numberMetric":63,"./metrics/objectMetric":64,"./metrics/rateMetric":65,"./metrics/statisticsMetric":66,"./metrics/stringMetric":67,"./metrics/timespanMetric":68,"./metrics/timestampMetric":69}],72:[function(require,module,exports){
var repository_1 = require("./core/repository");
var tick42_gateway_connection_1 = require('tick42-gateway-connection');
var windowAsAny = window;
windowAsAny.tick42 = windowAsAny.tick42 || {};
windowAsAny.tick42.metrics = windowAsAny.tick42.metrics || function (config) {
    if (!config.identity) {
        throw new Error('Identity missing from metrics configuration');
    }
    if (!config.identity.service || typeof config.identity.service !== 'string') {
        throw new Error('Service missing or invalid in metrics identity configuration');
    }
    if (!config.identity.system || typeof config.identity.system !== 'string') {
        throw new Error('System missing or invalid in metrics identity configuration');
    }
    if (!config.identity.instance || typeof config.identity.instance !== 'string') {
        throw new Error('Instancemissing or invalid in metrics identity configuration');
    }
    config.settings = config.settings || {};
    config.settings.heartbeatInterval = config.settings.heartbeatInterval || 15000;
    if (typeof config.connection !== "object") {
        config.connection = {};
    }
    if (!(typeof config.connection === "object" && typeof config.connection.send === "function" && typeof config.connection.on === "function")) {
        config.connection = tick42_gateway_connection_1.connection(config.connection);
    }
    var repo = new repository_1.Repository(config);
    repo['version'] = repo.root['version'] = '2.0.10';
    return repo.root;
};
module.exports = windowAsAny.tick42.metrics;

},{"./core/repository":70,"tick42-gateway-connection":50}],73:[function(require,module,exports){
var windows = function(agm){
	
	if(agm.subscribe){
		agm.subscribe("T42.Wnd.WindowStateChanged", {target:"all"}).then(function(stream){
			stream.onData(function (streamData) {
				update_window(streamData.data, container_from_filter(streamData.server));
			});

			// attach callbacks
			//stream.on("end", handleStreamClosed);
			//stream.on("close", handleStreamClosed);

		});

	}
	//Store windows that are tracked by ID and receive updates	
	var windows = {};	

	function update_window (window_info, container_name){
		
		var window_id = container_name+"."+window_info.windowName;

		var the_window = windows[window_id];
		 
		if (the_window === undefined) {
			//If the user is subscribed for the global events, create the window object.
			if( get_callbacks(window_added_callbacks, container_name).length > 0 || get_callbacks(window_removed_callbacks, container_name).length > 0 ) {
				the_window = a_window_from(window_info.windowName, container_name, window_info.url, window_info.windowId);
			} else {
				return;
			}
		}
		
		if(the_window.id === undefined){
			the_window.id = window_info.windowId;
			exec_callbacks(the_window.callbacks.on_available, the_window);
		} 
		
		if (the_window.url !== window_info.url){
			the_window.url = window_info.url;
			exec_callbacks(the_window.callbacks.on_url_changed, window_info.url);
		}
		
		if(window_info.state ==="Created"){
			//Execute global "window_added" callbacks
			exec_callbacks(get_callbacks(window_added_callbacks, container_name), the_window);
		} 
			
		//Clear the window on close event
		if(window_info.state ==="Closed"){
			//Execute global "window_removed" callbacks
			exec_callbacks(get_callbacks(window_removed_callbacks, container_name), the_window);
			//Execute window-specific "window_removed" callbacks
			exec_callbacks(the_window.callbacks.on_close);
			//Refresh the window object state
			the_window.id = undefined;
			the_window.callbacks = {};
			return;
		}
	}
	
	//Create a dictionary to store the callbacks for the method "window_added".
	var window_added_callbacks = {
		containers_callbacks: {}, 
		all_containers_callbacks: []
	};	
	
	//Create a dictionary to store the callbacks for the method "window_removed".
	var window_removed_callbacks = {
		containers_callbacks: {},
		all_containers_callbacks: []
	};
	
	//Creates a new window object or returns an existing one
	//Accepts window name, container and URL
	//Returns a window object.
	
	//It is not guaranteed to return the window with the same URL and ID
	function a_window_from(name, container, url, id){
		
		//By default we are using our own container
		container = container||(window.htmlContainer !== undefined?htmlContainer.containerName:undefined);
		
		//Throw if we don't know the container, throw
		if(container === undefined){throw "Please specify a container.";}

		var window_id = container+"."+name;
		
		var existing_window = windows[window_id] ;

		if(existing_window!==undefined){
			
			//If the window is closed, update the URL in the reference
			if(!existing_window.opened()){
				existing_window.url = url;
			}
			return existing_window;
		}else{

			//Init object
			var window_obj = Object.create(window_proto);
			window_obj.name = name;
			window_obj.container = container;
			window_obj.url = url;
            window_obj.id = id;
			window_obj.callbacks = {};			

			//Insert AGM server properties
			window_obj.application = window_id;
			
			windows[window_id] = window_obj;

			return window_obj;
		}
	}
	
	//Binds a given window object to an actual window
	function bind_window(the_window, success, error){
		
		//Typically the binding occurs when we receive an event, so we will retrieve some info about the window
		//and if it exists we will trigger an artificial event with it. 

		//Check if the window isn't already bound
		if(the_window.id===undefined){
			
			//Retrieve window parameters 	
			agm.invoke("T42.Wnd.FindByName", {windowName:the_window.name}, container_filter(the_window.container), {}, bind_from_info, error);
		
		}else{
			invoke_agm_success_callback(success, the_window);
		}
		return the_window;

		function bind_from_info(e){
			//Retrieve window info (a bit hacky because the response format is weird)
			var window_info = vals(e.returned)[0];
			
			if(window_info===undefined){
				if(typeof error === "function"){error("we cound not open/find this window");}
			}else{
				//Trigger an event
				window_info.state = "Attached";
				update_window(window_info, the_window.container);
				
				//Exec user callback
				invoke_agm_success_callback(success, the_window);
			}
		}
	}

	//Functions for opening, closing, resizing windows
	var window_proto = {
		
		open:function(dimensions, style, success, error){
			

			//A wrapper for the standard AGM "open" function 
			
			var the_window = this;
			
			//Init style objects if they are null
			dimensions=dimensions||{};
            		style=style||{};
			
			//Take out the sticky-windows related properties from the style object
			
			var isSticky = style.isSticky;
			delete style.isSticky;

			var stickyGroup = style.stickyGroup;
			delete style.stickyGroup;



			
			agm.invoke("T42.Html.CreateWindow", 
                       {
			//Window name and url
		       	windowName:the_window.name, url:the_window.url, 
			//dimensions
		       	top:dimensions.top, left:dimensions.left, width:dimensions.width, height:dimensions.height, 
			//Stickywindows - related props
			isSticky: isSticky, stickyGroup:stickyGroup, 
			//Style attributes
                   	windowStyleAttributes:JSON.stringify(style)
			
			}, 
                       container_filter(the_window.container), 
                       {}, 
                       opened,
                       cannot_open);
			
			function opened(message){
				//Add id to the current windows because the current HTML Container
				//doesn't support tracking the updates of the window				
				if(message.returned !== undefined) {
					the_window.id = message.returned.id;
				}
				invoke_agm_success_callback(success, the_window);
			}

			function cannot_open(e){
				//Call the error callback
				if(typeof error === "function") {error(e);}
				
				//Try to bind the returned object in case...
				bind_window(the_window);
			}
			
			return the_window;
		},
        set_style:function(style, success, error){ return agm_action("T42.Wnd.SetWindowStyle").call(this, success, error,{windowStyleAttributes:JSON.stringify(style)});},
       
	    opened:function(){return this.id!==undefined;},

		on_available:add_callback("on_available", function(the_window, callback){if(the_window.opened()){callback(the_window);}}),

		close:agm_action("T42.Wnd.Close"),

		on_close:add_callback("on_close"),

		navigate:function(url, success, error){ return agm_action("T42.Html.OpenUrl").call(this, success, error,{url:url});},

		on_url_changed:add_callback("on_url_changed"),

		focus:agm_action("T42.Wnd.Activate"),
		
		set_title:function(title, success, error){
			//Invoke the AGM method
			agm.invoke("T42.Wnd.SetWindowTitle", {windowId: this.id, title:title}, container_filter(this.container), {}, title_is_set, title_cannot_be_set);
			
			function title_is_set() {
				invoke_agm_success_callback(success, this);
			}
			
			function title_cannot_be_set(e) {
				invoke_agm_error_callback(error, e);
			}
		},
		
		get_details:function(success, error) {
			var window_id = this.id;
			agm.invoke("T42.Wnd.FindById", {windowId: this.id}, container_filter(this.container), {}, returned_dimensions, cannot_return_dimensions);

			function returned_dimensions(value) {
				invoke_agm_success_callback(success, value.returned[window_id]);
			}
			
			function cannot_return_dimensions(e) {
				invoke_agm_error_callback(error, e);
			}
		},
		
		move_resize:function(dimensions, success, error){ return agm_action("T42.Wnd.resizeAndMove").call(this, success, error, dimensions);},
		
		maximize:agm_action("T42.Wnd.Maximize"),
		
		restore:agm_action("T42.Wnd.Restore"),

		minimize:agm_action("T42.Wnd.Minimize"),
		
		maximize_restore:agm_action("T42.Wnd.MaximizeOrRestoreDown")	
	};
	
	//Adds an alias of an AGM method in the Window prototype
	function agm_action(action){
		return function(success, error, args){

			//Stop if the window is closed
			if(this.url === undefined){
				if(typeof error === "function"){error("Cannot execute a command on a closed window.");}
			
			return;}

			//Add the window ID to the arguments
			args = args||{};
			args.windowId = this.id;

			//Invoke the AGM method
			agm.invoke(action, args, container_filter(this.container), {}, fulfilled, error);

			var the_window = this;
			function fulfilled(){
				invoke_agm_success_callback(success, the_window);
			}
			return this;
		};
	}
		
	//The API itself
	var api = {

		my:function(){
						
			var h = window.htmlContainer;			
			//Retrieve the current window (the onw in which your application currently resides).
			return h === undefined? undefined: a_window_from(h.browserWindowName, h.containerName, window.location.href, h.windowId);
		},
		
		open:function(name, url, container, dimensions, style, success, error){
			return a_window_from(name, container, url).open(dimensions, style, success, error);
		},

		find:function(name, container, success, error){
			return bind_window(a_window_from(name, container), success, error);
		},
		_from_event:a_window_from,

		list:function(container, success, error){            
            if (typeof success !== 'function'){return;}
            
			agm.invoke("T42.Wnd.ListWindows", {}, container_filter(container), {wait_for_method_timeout: 15000}, listed, cannot_list);
                    
            function listed(value) {
            	if(value.returned === undefined){success([]) ;return;}
                var result = vals(value.returned).map(function(opened_window){                                        
                    return a_window_from(opened_window.windowName, container, opened_window.url, opened_window.windowId);
                });
                success(result);
            }
             
			function cannot_list(e) {
				invoke_agm_error_callback(error, e);
			}
		},
		
		//Add callback for window added for the list of containers.
		window_added: function(callback, container) {
			//Add the current callback to the callback dictionary.
			put_callbacks(window_added_callbacks, callback, container);

			//Execute all the callbacks for already existing windows.
			
			//Get all existing html containers.
			api.container_added(function(server) {
				//If the user is subscribed to the container
				if(container === undefined || container === server) {
					//list all the windows in the container.
					api.list(server, 
						function(list_of_windows) {
							//execute the callback for each window.
							list_of_windows.forEach(function(existing_window) {
								callback(existing_window);
							});
						},
						//Error callback if the windows cannot be listed.
						function(e) {console.log('Unable to load existing windows. ' + e.message);}
					);
				}
			});
		},
		
		window_removed: function(callback, container) {
			//Add the current callback to the callback dictionary.
			put_callbacks(window_removed_callbacks, callback, container);
		},
				
		container_added: function(callback) {
            agm.server_added(function(server){
                if(server.application.indexOf('HtmlContainer.')!==-1) {
                	invoke_agm_success_callback(callback, container_from_filter(server));
                }
            });
        },

		container_removed: function(callback) {
            agm.server_removed(function(server){
                if(server.application.indexOf('HtmlContainer.')!==-1) {
                    invoke_agm_success_callback(callback, container_from_filter(server));
                }
            });
        }
	};
	
	api.version = "2.0.1";
	
	return api;
};

if(window.tick42 === undefined){window.tick42 = {};}
window.tick42.windows = windows;
module.exports = windows;
  
function add_callback(key, on_add){
	return function(callback){
		var obj = this.callbacks;
		if(obj[key]===undefined){obj[key] = [callback];}
		else {obj[key].push(callback);}
		if(typeof on_add === "function"){on_add(this, callback);}
	};
}

function exec_callbacks(arr, val){
	if(arr!==undefined){
		arr.forEach(function(callback){callback(val);});
	}
}

function eq(key,val){
	return function(obj){
		return key===undefined||val===undefined||obj[key]===val;
	};
}

function vals(obj){
	return Object.keys(obj).reduce(function(arr, key){arr.push(obj[key]);return arr;}, []);
}

function map_obj(obj, f){
	return Object.keys(obj).reduce(function(new_obj, key){new_obj[key] = f(obj[key]) ;return new_obj;}, {});
}

function container_filter(name){
  var containerFullName = "HtmlContainer.";

  if (htmlContainer.env.env !== undefined || htmlContainer.env.region !== undefined) {
    if(name.indexOf(htmlContainer.env.env) === -1 && name.indexOf(htmlContainer.env.region) === -1) {
      containerFullName += htmlContainer.env.env + '-' + htmlContainer.env.region + '.';
    }
  }

  containerFullName += name;

  return {application: containerFullName};
}

function container_from_filter(filter){
	return filter.application.match(/HtmlContainer\.(.*?)$/)[1];
}

function invoke_agm_success_callback(callback, callback_argument) {
	if(typeof callback === "function") {callback(callback_argument);}
}

function invoke_agm_error_callback(callback, error) {
	if(typeof callback === "function") {callback(error.message);}
}

function get_callbacks(callbacks, container_name) {
	if(callbacks.containers_callbacks[container_name] !== undefined) {
		return callbacks.all_containers_callbacks.concat(callbacks.containers_callbacks[container_name]);
	} else {
		return callbacks.all_containers_callbacks;
	}
}

function put_callbacks(global_callbacks, callback, container) {
	if(container === undefined) {
		global_callbacks.all_containers_callbacks.push(callback);
	} else {
		if(global_callbacks.containers_callbacks[container] === undefined) {
			global_callbacks.containers_callbacks[container] = [callback];
		} else {
			global_callbacks.containers_callbacks[container].push(callback);
		}
	}
}

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWJyYXJ5L2dsdWUuanMiLCJub2RlX21vZHVsZXMvYXNjaWktdGFibGUvYXNjaWktdGFibGUuanMiLCJub2RlX21vZHVsZXMvYXNjaWktdGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LXNoaW0vZXM1LXNoYW0uanMiLCJub2RlX21vZHVsZXMvZXM1LXNoaW0vZXM1LXNoaW0uanMiLCJub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvQVBJL2FjdGl2aXR5QVBJLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL0FQSS9hY3Rpdml0eU1hbmFnZW1lbnRBUEkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvQVBJL2FjdGl2aXR5TXlBUEkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvYWN0aXZpdHlDb25maWcuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvYWN0aXZpdHlNb2R1bGUuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvYnJpZGdlcy9oY0JyaWRnZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9jb250cmFjdHMvYWN0aXZpdHlTdGF0dXMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvY29udHJhY3RzL2VudGl0eUV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2NvcmUvYWN0aXZpdHlBR00uanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvY29yZS9hY3Rpdml0eU1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvY29yZS9sb2NhbFdpbmRvd0ZhY3RvcnkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvY29yZS9wcm94eVdpbmRvd0ZhY3RvcnkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvZW50aXRpZXMvYWN0aXZpdHkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvZW50aXRpZXMvYWN0aXZpdHlFbnRpdHkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvZW50aXRpZXMvYWN0aXZpdHlUeXBlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2VudGl0aWVzL2FjdGl2aXR5V2luZG93LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2VudGl0aWVzL3dpbmRvd1R5cGUuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvaGVscGVycy9lbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9oZWxwZXJzL2xvZ2dlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9oZWxwZXJzL3Byb21pc2VFeHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2hlbHBlcnMvcmVhZHlNYXJrZXIuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvaGVscGVycy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ20uanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L2FnbV9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L2FnbV9jbGllbnRfaW52b2NhdGlvbnNzdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX2NsaWVudF9tZXRob2RzdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX2NsaWVudF9zZXJ2ZXJzdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L2FnbV9pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX25hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX3NlcnZlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9hcHBfbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9hcHBsaWNhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9ldmVudF9tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHAtbWFuYWdlci9saWJyYXJ5L2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcC1tYW5hZ2VyL2xpYnJhcnkvaW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9zcmMvanMvYXBwY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHBjb25maWcvc3JjL2pzL2dhdGV3YXkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9zcmMvanMvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL3NyYy9qcy9tb2RlbC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL3NyYy9qcy9wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL3NyYy9qcy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS9jb25uZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS9jb250LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS9maW4uanMiLCJub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L2h0dHAuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L3dzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbm9kZV9tb2R1bGVzL2RldGVjdC1ub2RlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbm9kZV9tb2R1bGVzL3dzL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1sb2dnZXIvbGlicmFyeS9sb2dnZXIuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL2JyaWRnZS9tZXRyaWNTZXJpYWxpemVyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9icmlkZ2UvdHJhbnNwb3J0LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL2FkZHJlc3NNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3MvY291bnRNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3MvbWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL251bWJlck1ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy9vYmplY3RNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3MvcmF0ZU1ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy9zdGF0aXN0aWNzTWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL3N0cmluZ01ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy90aW1lc3Bhbk1ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy90aW1lc3RhbXBNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL3JlcG9zaXRvcnkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL3N5c3RlbS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL21ldHJpY3NNb2R1bGUuanMiLCJub2RlX21vZHVsZXMvdGljazQyLXdpbmRvd3MvbGlicmFyeS93aW5kb3dzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6b0JBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3YvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Y4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDamVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdlRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24oKSB7XHJcbiAgLy9EbyBub3QgZG8gYW55dGhpbmcgaWYgdGhlcmUgaXMgbm8gc3VwcG9ydCBvZiBFQ01BU2NyaXB0IDVcclxuICBpZiAodHlwZW9mIFtdLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJlcXVpcmUoXCJlczUtc2hpbVwiKTtcclxuICAgIHJlcXVpcmUoXCJlczUtc2hpbS9lczUtc2hhbVwiKTtcclxuICB9XHJcblxyXG5cdHZhciBtZXRyaWNzID0gcmVxdWlyZShcInRpY2s0Mi1tZXRyaWNzXCIpO1xyXG5cdHZhciBhZ20gPSByZXF1aXJlKFwidGljazQyLWFnbVwiKTtcclxuXHR2YXIgZ2F0ZXdheUNvbm5lY3Rpb24gPSByZXF1aXJlKFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvblwiKTtcclxuXHR2YXIgbG9nZ2VyID0gcmVxdWlyZShcInRpY2s0Mi1sb2dnZXJcIik7XHJcblx0dmFyIGFwcGNvbmZpZyA9IHJlcXVpcmUoXCJ0aWNrNDItYXBwY29uZmlnL3NyYy9qcy9hcHBjb25maWdcIik7XHJcblx0dmFyIHdpbmRvd3MgPSByZXF1aXJlKFwidGljazQyLXdpbmRvd3NcIik7XHJcblx0dmFyIGFwcE1hbmFnZXIgPSByZXF1aXJlKFwidGljazQyLWFwcC1tYW5hZ2VyXCIpO1xyXG5cdHZhciBhY3Rpdml0eSA9IHJlcXVpcmUoXCJ0aWNrNDItYWN0aXZpdHlcIik7XHJcblxyXG4gIC8vRG8gbm90IGRvIGFueXRoaW5nIGlmIHRoZSB1c2VyIHR1cm5lZCBvZmYgdGhlIGF1dG8gaW5pdGlhbGl6YXRpb25cclxuXHRpZiAod2luZG93LmdsdWVfYXV0b19pbml0aWFsaXplID09PSBmYWxzZSkge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcbiAgLy9Jbml0IHRoZSBHTFVFIG5hbWVzcGFjZVxyXG5cdHZhciBnbHVlID0ge307XHJcblx0Z2x1ZS52ZXJzaW9uID0gXCIyLjMuMFwiO1xyXG5cdC8vQmFzZSBjb25maWd1cmF0aW9ucy4gTGF0ZXIgdGhleSBhcmUgdXBkYXRlZCBkZXBlbmRpbmcgb24gdGhlIHJ1bnRpbWUuXHJcblx0dmFyIGxvZ2dlckNvbmZpZ3VyYXRpb24gPSB7aWRlbnRpdHk6IHtzeXN0ZW06IFwiVGljazQyXCJ9fTtcclxuXHR2YXIgbWV0cmljc0NvbmZpZ3VyYXRpb24gPSB7aWRlbnRpdHk6IHtzeXN0ZW06IFwiVGljazQyXCJ9fTtcclxuXHR2YXIgYWdtQ29uZmlndXJhdGlvbiA9IHtpbnN0YW5jZToge30sIHNlcnZlcjoge3ByZXNlbmNlX2ludGVydmFsOiAzMDAwfX07XHJcblxyXG5cdC8vSGVyZSB3ZSB3aWxsIHN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb25uZWN0aW9uIHdpdGggdGhlIFNlcnZpY2UgUHJvdmlkZXJcclxuXHRnbHVlLmNvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XHJcblx0dmFyIGFwcF9uYW1lO1xyXG5cclxuXHQvL0lmIHdlIGFyZSBydW5uaW5nIGluIGFuIEhUTUwgQ29udGFpbmVyLCB1c2UgdGhlIEhUTUwgQ29udGFpbmVyIGVudmlyb25tZW50IHZhcmlhYmxlc1xyXG5cdGlmICh3aW5kb3cuaHRtbENvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHQvL0dlbmVyYXRlIEFHTSBhcHAgbmFtZVxyXG5cdFx0YXBwX25hbWUgPSB3aW5kb3cuYWdtX2FwcGxpY2F0aW9uIHx8IHdpbmRvdy5odG1sQ29udGFpbmVyLmNvbnRhaW5lck5hbWUgKyBcIi5cIiArIHdpbmRvdy5odG1sQ29udGFpbmVyLmJyb3dzZXJXaW5kb3dOYW1lO1xyXG5cclxuXHRcdC8vRmlsbCBsb2dnZXIgY29uZmlndXJhdGlvbnMgd2l0aCBjdXN0b20gcHJvcGVydGllc1xyXG5cdFx0YWdtQ29uZmlndXJhdGlvbi5pbnN0YW5jZS5hcHBsaWNhdGlvbiA9IGFwcF9uYW1lO1xyXG5cdFx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zeXN0ZW0gPSBcIkh0bWxDb250YWluZXIuXCIgKyB3aW5kb3cuaHRtbENvbnRhaW5lci5jb250YWluZXJOYW1lO1xyXG5cdFx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zZXJ2aWNlID0gXCJKUy5cIiArIHdpbmRvdy5odG1sQ29udGFpbmVyLmJyb3dzZXJXaW5kb3dOYW1lO1xyXG5cdFx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5pbnN0YW5jZSA9IFwiflwiICsgd2luZG93Lmh0bWxDb250YWluZXIubWFjaGluZU5hbWU7XHJcblxyXG5cdFx0aWYgKHdpbmRvdy5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZSAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZS5jb25maWcgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHQvLyBJbml0aWFsaXplIEFwcENvbmZpZ1xyXG5cdFx0XHRnbHVlLmFwcGNvbmZpZyA9IGFwcGNvbmZpZygpO1xyXG5cdFx0XHRnbHVlLmFwcGNvbmZpZy5pbml0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRmdW5jdGlvbiBzdXBwbGFudCh0ZW1wbGF0ZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xceyhbXnt9XSopXFx9L2csIGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XHJcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXM7XHJcblx0XHRcdFx0XHRcdGtleS5zcGxpdCgnLicpLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogbWF0Y2g7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBzZXR0aW5ncyA9IHdpbmRvdy5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZS5jb25maWc7XHJcblx0XHRcdFx0dmFyIGlkZW50aXR5ID0ge307XHJcblx0XHRcdFx0T2JqZWN0LmtleXMoc2V0dGluZ3MuaWRlbnRpdHkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gc3VwcGxhbnQoc2V0dGluZ3MuaWRlbnRpdHlba2V5XSk7XHJcblx0XHRcdFx0XHRpZGVudGl0eVtrZXldID0gdmFsdWU7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0c2V0dGluZ3MuaWRlbnRpdHkgPSBpZGVudGl0eTtcclxuXHRcdFx0XHRyZXR1cm4gc2V0dGluZ3M7XHJcblx0XHRcdH0oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Jbml0IHRoZSBDb25uZWN0aW9uXHJcblx0XHRnbHVlLmNvbm5lY3Rpb24gPSBnYXRld2F5Q29ubmVjdGlvbigpO1xyXG5cclxuXHRcdC8vSWYgd2UgYXJlIHJ1bm5pbmcgaW4gbm9ybWFsIGJyb3dzZXIsIGNvbm5lY3QgdmlhIFdlYnNvY2tldFxyXG5cdH0gZWxzZSB7XHJcbiAgICB2YXIgY29ubmVjdGlvbl9jb25maWcgPSB7fTtcclxuICAgIHZhciB1aWRfcHJlZml4O1xyXG5cclxuICAgIGlmICh0eXBlb2Ygd2luZG93LldlYlNvY2tldCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAvLyBpZiBubyBzdXBwb3J0IGZvciBXZWJTb2NrZXQgdXNlIEhUVFBcclxuICAgICAgdWlkX3ByZWZpeCA9IFwiSFRUUFwiO1xyXG4gICAgICAvLyBkb24ndCBtYWtlIGluc2VjdXJlIHJlcXVlc3RzIGZyb20gc2VjdXJlIGVudlxyXG4gICAgICB2YXIgZGVmYXVsdF9odHRwX3VybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHA6JyA/IFwiaHR0cDovL2xvY2FsaG9zdDoyMjAzN1wiIDogXCJodHRwczovL2xvY2FsaG9zdDoyMjAzN1wiO1xyXG4gICAgICBjb25uZWN0aW9uX2NvbmZpZy5odHRwX3VybCA9IHdpbmRvdy5nbHVlX2h0dHBfdXJsIHx8IGRlZmF1bHRfaHR0cF91cmw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB1aWRfcHJlZml4ID0gXCJXU1wiO1xyXG4gICAgICAvL1dlYnNvY2tldCBVUkwgKHRoaXMgaXMgdGhlIGRlZmF1bHQgdGhhdCBpcyB1c2VkIGluIHRoZSBkZW1vIFdTIHNlcnZlcilcclxuICAgICAgdmFyIGRlZmF1bHRfd3NfdXJsID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cDonID8gXCJ3czovL2xvY2FsaG9zdDoyMjAzN1wiIDogXCJ3c3M6Ly9sb2NhbGhvc3Q6MjIwMzdcIjtcclxuICAgICAgY29ubmVjdGlvbl9jb25maWcud2Vic29ja2V0X3VybCA9IHdpbmRvdy5nbHVlX3dzX3VybCB8fCBkZWZhdWx0X3dzX3VybDtcclxuICAgIH1cclxuXHJcbiAgICAvL0dlbmVyYXRlIGFwcGxpY2F0aW9uIFVJRCB0byBhbGxvdyBmb3IgdGhlIHNhbWUgYXBwbGljYXRpb24gdG8gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxyXG4gICAgdmFyIHVpZCA9IHVpZF9wcmVmaXggKyBNYXRoLmZsb29yKDFlMTAgKiBNYXRoLnJhbmRvbSgpKTtcclxuXHJcbiAgICAvL0dlbmVyYXRlIEFHTSBhcHAgbmFtZVxyXG5cdFx0YXBwX25hbWUgPSB3aW5kb3cuYWdtX2FwcGxpY2F0aW9uIHx8IGRvY3VtZW50LnRpdGxlICsgdWlkO1xyXG5cclxuXHRcdC8vRmlsbCBjb25maWd1cmF0aW9ucyB3aXRoIGN1c3RvbSBwcm9wZXJ0aWVzXHJcblx0XHRhZ21Db25maWd1cmF0aW9uLmluc3RhbmNlLmFwcGxpY2F0aW9uID0gYXBwX25hbWU7XHJcblx0XHRsb2dnZXJDb25maWd1cmF0aW9uLmlkZW50aXR5LnN5c3RlbSA9IFwiQnJvd3NlclwiO1xyXG5cdFx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zZXJ2aWNlID0gZG9jdW1lbnQudGl0bGUgfHwgJ3Vua25vd24nO1xyXG5cdFx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5pbnN0YW5jZSA9IFwiflwiICsgdWlkO1xyXG5cclxuXHRcdC8vIEluaXQgdGhlIENvbm5lY3Rpb24gYW5kIHNwZWNpZnkgdGhlIFVSTCBvZiB0aGUgV2ViIFNvY2tldCBzZXJ2ZXIgdGhhdCB3ZSBhcmUgY29ubmVjdGluZyB0by5cclxuXHRcdGdsdWUuY29ubmVjdGlvbiA9IGdhdGV3YXlDb25uZWN0aW9uKGNvbm5lY3Rpb25fY29uZmlnKTtcclxuXHR9XHJcblxyXG5cdC8vUGxhY2UgdGhlIENvbm5lY3Rpb24sIGFzIHBhcnQgb2YgdGhlIGNvbXBvbmVudHMnIGNvbmZpZ3VyYXRpb25cclxuXHRsb2dnZXJDb25maWd1cmF0aW9uLmNvbm5lY3Rpb24gPSBnbHVlLmNvbm5lY3Rpb247XHJcblx0bWV0cmljc0NvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiA9IGdsdWUuY29ubmVjdGlvbjtcclxuXHRhZ21Db25maWd1cmF0aW9uLmNvbm5lY3Rpb24gPSBnbHVlLmNvbm5lY3Rpb247XHJcblxyXG5cdC8vT3ZlcnJpZGUgc29tZSBwcm9wcyB3aXRoIGVudmlyb25tZW50IHZhcmlhYmxlcywgaWYgcHJvdmlkZWRcclxuXHRsb2dnZXJDb25maWd1cmF0aW9uLmlkZW50aXR5LnN5c3RlbSA9IHdpbmRvdy5nbHVlX21ldHJpY19zeXN0ZW0gfHwgbG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zeXN0ZW07XHJcblx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zZXJ2aWNlID0gd2luZG93LmdsdWVfbWV0cmljX3NlcnZpY2UgfHwgbG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zZXJ2aWNlO1xyXG5cdGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHkuaW5zdGFuY2UgPSB3aW5kb3cuZ2x1ZV9tZXRyaWNfaW5zdGFuY2UgfHwgbG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5pbnN0YW5jZTtcclxuXHJcblx0Ly9Jbml0aWFsaXplIExvZ2dlciAodXNlcyB0aGUgc2FtZSBjb25maWd1cmF0aW9uIGFzIE1ldHJpY3MpXHJcblx0Z2x1ZS5sb2dnZXIgPSBsb2dnZXIobG9nZ2VyQ29uZmlndXJhdGlvbik7XHJcblxyXG5cdC8vRmlsbCBtZXRyaWNzIGNvbmZpZ3VyYXRpb24gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIG1ldHJpY3MgY29uZmlndXJhdGlvbnNcclxuXHRtZXRyaWNzQ29uZmlndXJhdGlvbi5pZGVudGl0eSA9IGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHk7XHJcblx0bWV0cmljc0NvbmZpZ3VyYXRpb24ubG9nZ2VyID0gZ2x1ZS5sb2dnZXIuc3ViTG9nZ2VyKFwibWV0cmljc1wiKTtcclxuXHJcblx0Ly9Jbml0aWFsaXplIE1ldHJpY3MgYW5kIHNhdmUgaW50byB0aGUgJ2dsdWUnIGdsb2JhbCB2YXJpYWJsZVxyXG5cdGdsdWUubWV0cmljcyA9IG1ldHJpY3MobWV0cmljc0NvbmZpZ3VyYXRpb24pLnN1YlN5c3RlbShcIkFwcFwiKTtcclxuXHJcblx0Ly9Jbml0aWFsaXplIHRoZSBtZXRyaWNzIHN5c3RlbSBpbiB0aGUgbG9nZ2VyJ3MgXCJtZXRyaWNzX2xldmVsXCIgbWV0aG9kXHJcblx0Z2x1ZS5sb2dnZXIubWV0cmljc0xldmVsKFwid2FyblwiLCBnbHVlLm1ldHJpY3MucGFyZW50LnN1YlN5c3RlbShcIkxvZ0V2ZW50c1wiKSk7XHJcblxyXG5cdGFnbUNvbmZpZ3VyYXRpb24uaW5zdGFuY2UuYXBwbGljYXRpb24gPSB3aW5kb3cuZ2x1ZV9hZ21fYXBwbGljYXRpb24gfHwgYWdtQ29uZmlndXJhdGlvbi5pbnN0YW5jZS5hcHBsaWNhdGlvbjtcclxuXHJcblx0Ly9JbmNsdWRlIHRoZSBtZXRyaWMgcmVwbyBpbiB0aGUgQUdNIGNvbmZpZ3VyYXRpb24gKHNvIHRoYXQgQUdNIGNhbiBicm9hZGNhc3QgbWV0cmljcylcclxuXHRhZ21Db25maWd1cmF0aW9uLm1ldHJpY3MgPSBnbHVlLm1ldHJpY3Muc3ViU3lzdGVtKFwiQUdNXCIpO1xyXG5cclxuXHQvL0luaXRpYWxpemUgQUdNIHNhdmUgaW50byB0aGUgJ2dsdWUnIGdsb2JhbCB2YXJpYWJsZVxyXG5cdGdsdWUuYWdtID0gYWdtKGFnbUNvbmZpZ3VyYXRpb24pO1xyXG5cclxuXHQvLyBBZGQgYWN0aXZpdHkgaW4gdGhlIGNvbnRhaW5lciBvbmx5XHJcblx0dmFyIGFjdGl2aXRpZXNGYWNhZGUgPSB3aW5kb3cuaHRtbENvbnRhaW5lciA/IHdpbmRvdy5odG1sQ29udGFpbmVyLmFjdGl2aXR5RmFjYWRlIDogdW5kZWZpbmVkO1xyXG5cdGlmICh0eXBlb2YgYWN0aXZpdGllc0ZhY2FkZSAhPT0gXCJ1bmRlZmluZWRcIil7XHJcblx0XHR2YXIgYWN0aXZpdHlMb2dnZXIgPSBnbHVlLmxvZ2dlci5zdWJMb2dnZXIoXCJhY3Rpdml0eVwiKTtcclxuXHRcdGFjdGl2aXR5TG9nZ2VyLnB1Ymxpc2hMZXZlbChcImRlYnVnXCIpO1xyXG5cdFx0YWN0aXZpdHlMb2dnZXIuY29uc29sZUxldmVsKFwiaW5mb1wiKTtcclxuICAgIGFjdGl2aXR5TG9nZ2VyLm1ldHJpY3NMZXZlbChcIm9mZlwiKTtcclxuXHRcdGdsdWUuYWN0aXZpdGllcyA9IGFjdGl2aXR5KHthZ206IGdsdWUuYWdtLCBsb2dnZXI6IGFjdGl2aXR5TG9nZ2VyfSk7XHJcblx0fVxyXG5cclxuXHRnbHVlLndpbmRvd3MgPSB3aW5kb3dzKGdsdWUuYWdtKTtcclxuXHJcblx0Ly8gY2FtZWwgY2FzZSBmb3IgQXBwIE1hbmFnZXJcclxuXHRnbHVlLmFwcE1hbmFnZXIgPSBhcHBNYW5hZ2VyKGdsdWUuYWdtLCBnbHVlLndpbmRvd3MpO1xyXG5cclxuICBnbHVlLmluZm8gPSB7XHJcbiAgICBnbHVlVmVyc2lvbiA6ICcyLjMuMCcsXHJcbiAgICBhY3Rpdml0aWVzIDogZ2x1ZS5hY3Rpdml0aWVzID8gZ2x1ZS5hY3Rpdml0aWVzLnZlcnNpb24gOiAndW5rbm93bicsIFxyXG4gICAgbWV0cmljczogZ2x1ZS5tZXRyaWNzLnJlcG8udmVyc2lvbixcclxuICAgIGFnbTogZ2x1ZS5hZ20udmVyc2lvbixcclxuICAgIHdpbmRvd3M6IGdsdWUud2luZG93cy52ZXJzaW9uLFxyXG4gICAgbG9nZ2VyOiBnbHVlLmxvZ2dlci52ZXJzaW9uLFxyXG4gICAgYXBwTWFuYWdlcjogZ2x1ZS5hcHBNYW5hZ2VyLnZlcnNpb24sXHJcbiAgICBjb25uZWN0aW9uOiBnbHVlLmNvbm5lY3Rpb24udmVyc2lvbiAgICBcclxuICB9O1xyXG4gIFxyXG5cdC8vIG5vIGNvbmZsaWN0IGZ1bmN0aW9uXHJcblx0dmFyIG9yaWdpbmFsR2x1ZSA9IHdpbmRvdy5nbHVlO1xyXG5cdGdsdWUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHR3aW5kb3cuZ2x1ZSA9IG9yaWdpbmFsR2x1ZTtcclxuXHRcdHJldHVybiBnbHVlO1xyXG5cdH07XHJcblxyXG5cdC8vRXhwb3J0IEdMVUVcclxuXHR3aW5kb3cuZ2x1ZSA9IGdsdWU7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBnbHVlO1xyXG59KCkpOyIsIi8qKlxuICogKGMpIDIwMTMgQmVhdSBTb3JlbnNlblxuICogTUlUIExpY2Vuc2VkXG4gKiBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vc29yZW5zZW4vYXNjaWktdGFibGVcbiAqL1xuXG47KGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgLCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuLyoqXG4gKiBBc2NpaVRhYmxlIGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB0aXRsZSBvciBKU09OIHRhYmxlXG4gKiBAcGFyYW0ge09iamVjdH0gdGFibGUgb3B0aW9uc1xuICogIC0gYHByZWZpeGAgLSBzdHJpbmcgcHJlZml4IGFkZGVkIHRvIGVhY2ggbGluZSBvbiByZW5kZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBBc2NpaVRhYmxlKG5hbWUsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB0aGlzLnJlc2V0KG5hbWUpXG59XG5cbi8qIVxuICogQ3VycmVudCBsaWJyYXJ5IHZlcnNpb24sIHNob3VsZCBtYXRjaCBgcGFja2FnZS5qc29uYFxuICovXG5cbkFzY2lpVGFibGUuVkVSU0lPTiA9ICcwLjAuOCdcblxuLyohXG4gKiBBbGlnbm1lbnQgY29uc3RhbnRzXG4gKi9cblxuQXNjaWlUYWJsZS5MRUZUID0gMFxuQXNjaWlUYWJsZS5DRU5URVIgPSAxXG5Bc2NpaVRhYmxlLlJJR0hUID0gMlxuXG4vKiFcbiAqIFN0YXRpYyBtZXRob2RzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdGFibGUgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHRpdGxlIG9yIEpTT04gdGFibGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YWJsZSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUuZmFjdG9yeSA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBBc2NpaVRhYmxlKG5hbWUsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogQWxpZ24gdGhlIGEgc3RyaW5nIGF0IHRoZSBnaXZlbiBsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGlucHV0XG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaW5nIGxlbmd0aFxuICogQHBhcmFtIHtOdW1iZXJ9IHBhZGRpbmcgY2hhcmFjdGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUuYWxpZ24gPSBmdW5jdGlvbihkaXIsIHN0ciwgbGVuLCBwYWQpIHtcbiAgaWYgKGRpciA9PT0gQXNjaWlUYWJsZS5MRUZUKSByZXR1cm4gQXNjaWlUYWJsZS5hbGlnbkxlZnQoc3RyLCBsZW4sIHBhZClcbiAgaWYgKGRpciA9PT0gQXNjaWlUYWJsZS5SSUdIVCkgcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25SaWdodChzdHIsIGxlbiwgcGFkKVxuICBpZiAoZGlyID09PSBBc2NpaVRhYmxlLkNFTlRFUikgcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25DZW50ZXIoc3RyLCBsZW4sIHBhZClcbiAgcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25BdXRvKHN0ciwgbGVuLCBwYWQpXG59XG5cbi8qKlxuICogTGVmdCBhbGlnbiBhIHN0cmluZyBieSBwYWRkaW5nIGl0IGF0IGEgZ2l2ZW4gbGVuZ3RoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmluZyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWRkaW5nIGNoYXJhY3RlciAob3B0aW9uYWwsIGRlZmF1bHQgJycpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUuYWxpZ25MZWZ0ID0gZnVuY3Rpb24oc3RyLCBsZW4sIHBhZCkge1xuICBpZiAoIWxlbiB8fCBsZW4gPCAwKSByZXR1cm4gJydcbiAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkIHx8IHN0ciA9PT0gbnVsbCkgc3RyID0gJydcbiAgaWYgKHR5cGVvZiBwYWQgPT09ICd1bmRlZmluZWQnKSBwYWQgPSAnICdcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICB2YXIgYWxlbiA9IGxlbiArIDEgLSBzdHIubGVuZ3RoXG4gIGlmIChhbGVuIDw9IDApIHJldHVybiBzdHJcbiAgcmV0dXJuIHN0ciArIEFycmF5KGxlbiArIDEgLSBzdHIubGVuZ3RoKS5qb2luKHBhZClcbn1cblxuLyoqXG4gKiBDZW50ZXIgYWxpZ24gYSBzdHJpbmcgYnkgcGFkZGluZyBpdCBhdCBhIGdpdmVuIGxlbmd0aFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpbmcgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFkZGluZyBjaGFyYWN0ZXIgKG9wdGlvbmFsLCBkZWZhdWx0ICcnKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLmFsaWduQ2VudGVyID0gZnVuY3Rpb24oc3RyLCBsZW4sIHBhZCkge1xuICBpZiAoIWxlbiB8fCBsZW4gPCAwKSByZXR1cm4gJydcbiAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkIHx8IHN0ciA9PT0gbnVsbCkgc3RyID0gJydcbiAgaWYgKHR5cGVvZiBwYWQgPT09ICd1bmRlZmluZWQnKSBwYWQgPSAnICdcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICB2YXIgbkxlbiA9IHN0ci5sZW5ndGhcbiAgICAsIGhhbGYgPSBNYXRoLmZsb29yKGxlbiAvIDIgLSBuTGVuIC8gMilcbiAgICAsIG9kZHMgPSBNYXRoLmFicygobkxlbiAlIDIpIC0gKGxlbiAlIDIpKVxuICAgICwgbGVuID0gc3RyLmxlbmd0aFxuXG4gIHJldHVybiBBc2NpaVRhYmxlLmFsaWduUmlnaHQoJycsIGhhbGYsIHBhZCkgXG4gICAgKyBzdHJcbiAgICArIEFzY2lpVGFibGUuYWxpZ25MZWZ0KCcnLCBoYWxmICsgb2RkcywgcGFkKVxufVxuXG4vKipcbiAqIFJpZ2h0IGFsaWduIGEgc3RyaW5nIGJ5IHBhZGRpbmcgaXQgYXQgYSBnaXZlbiBsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaW5nIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHBhZGRpbmcgY2hhcmFjdGVyIChvcHRpb25hbCwgZGVmYXVsdCAnJylcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5hbGlnblJpZ2h0ID0gZnVuY3Rpb24oc3RyLCBsZW4sIHBhZCkge1xuICBpZiAoIWxlbiB8fCBsZW4gPCAwKSByZXR1cm4gJydcbiAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkIHx8IHN0ciA9PT0gbnVsbCkgc3RyID0gJydcbiAgaWYgKHR5cGVvZiBwYWQgPT09ICd1bmRlZmluZWQnKSBwYWQgPSAnICdcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICB2YXIgYWxlbiA9IGxlbiArIDEgLSBzdHIubGVuZ3RoXG4gIGlmIChhbGVuIDw9IDApIHJldHVybiBzdHJcbiAgcmV0dXJuIEFycmF5KGxlbiArIDEgLSBzdHIubGVuZ3RoKS5qb2luKHBhZCkgKyBzdHJcbn1cblxuLyoqXG4gKiBBdXRvIGFsaWduIHN0cmluZyB2YWx1ZSBiYXNlZCBvbiBvYmplY3QgdHlwZVxuICpcbiAqIEBwYXJhbSB7QW55fSBvYmplY3QgdG8gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaW5nIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHBhZGRpbmcgY2hhcmFjdGVyIChvcHRpb25hbCwgZGVmYXVsdCAnJylcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5hbGlnbkF1dG8gPSBmdW5jdGlvbihzdHIsIGxlbiwgcGFkKSB7XG4gIGlmIChzdHIgPT09IHVuZGVmaW5lZCB8fCBzdHIgPT09IG51bGwpIHN0ciA9ICcnXG4gIHZhciB0eXBlID0gdG9TdHJpbmcuY2FsbChzdHIpXG4gIHBhZCB8fCAocGFkID0gJyAnKVxuICBsZW4gPSArbGVuXG4gIGlmICh0eXBlICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHN0ciA9IHN0ci50b1N0cmluZygpXG4gIH1cbiAgaWYgKHN0ci5sZW5ndGggPCBsZW4pIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzogcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25SaWdodChzdHIsIGxlbiwgcGFkKVxuICAgICAgZGVmYXVsdDogcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25MZWZ0KHN0ciwgbGVuLCBwYWQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJcbn1cblxuLyoqXG4gKiBGaWxsIGFuIGFycmF5IGF0IGEgZ2l2ZW4gc2l6ZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhcnJheSBzaXplXG4gKiBAcGFyYW0ge0FueX0gZmlsbCB2YWx1ZVxuICogQHJldHVybiB7QXJyYXl9IGZpbGxlZCBhcnJheVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLmFycmF5RmlsbCA9IGZ1bmN0aW9uKGxlbiwgZmlsbCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGxlbjsgaSsrKSB7XG4gICAgYXJyW2ldID0gZmlsbDtcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbi8qIVxuICogSW5zdGFuY2UgbWV0aG9kc1xuICovXG5cbi8qKlxuICogUmVzZXQgdGhlIHRhYmxlIHN0YXRlIGJhY2sgdG8gZGVmYXVsdHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHRpdGxlIG9yIEpTT04gdGFibGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUucmVzZXQgPSBcbkFzY2lpVGFibGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24obmFtZSkge1xuICB0aGlzLl9fbmFtZSA9ICcnXG4gIHRoaXMuX19uYW1lQWxpZ24gPSBBc2NpaVRhYmxlLkNFTlRFUlxuICB0aGlzLl9fcm93cyA9IFtdXG4gIHRoaXMuX19tYXhDZWxscyA9IDBcbiAgdGhpcy5fX2FsaWducyA9IFtdXG4gIHRoaXMuX19jb2xNYXhlcyA9IFtdXG4gIHRoaXMuX19zcGFjaW5nID0gMVxuICB0aGlzLl9faGVhZGluZyA9IG51bGxcbiAgdGhpcy5fX2hlYWRpbmdBbGlnbiA9IEFzY2lpVGFibGUuQ0VOVEVSXG4gIHRoaXMuc2V0Qm9yZGVyKClcblxuICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICB0aGlzLl9fbmFtZSA9IG5hbWVcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHRoaXMuZnJvbUpTT04obmFtZSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFNldCB0aGUgdGFibGUgYm9yZGVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhvcml6b250YWwgZWRnZXMgKG9wdGlvbmFsLCBkZWZhdWx0IGB8YClcbiAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJ0aWNhbCBlZGdlcyAob3B0aW9uYWwsIGRlZmF1bHQgYC1gKVxuICogQHBhcmFtIHtTdHJpbmd9IHRvcCBjb3JuZXJzIChvcHRpb25hbCwgZGVmYXVsdCBgLmApXG4gKiBAcGFyYW0ge1N0cmluZ30gYm90dG9tIGNvcm5lcnMgKG9wdGlvbmFsLCBkZWZhdWx0IGAnYClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc2V0Qm9yZGVyID0gZnVuY3Rpb24oZWRnZSwgZmlsbCwgdG9wLCBib3R0b20pIHtcbiAgdGhpcy5fX2JvcmRlciA9IHRydWVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBmaWxsID0gdG9wID0gYm90dG9tID0gZWRnZVxuICB9XG4gIHRoaXMuX19lZGdlID0gZWRnZSB8fCAnfCdcbiAgdGhpcy5fX2ZpbGwgPSBmaWxsIHx8ICctJ1xuICB0aGlzLl9fdG9wID0gdG9wIHx8ICcuJ1xuICB0aGlzLl9fYm90dG9tID0gYm90dG9tIHx8IFwiJ1wiXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0YWJsZSBib3JkZXJzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5yZW1vdmVCb3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX2JvcmRlciA9IGZhbHNlXG4gIHRoaXMuX19lZGdlID0gJyAnXG4gIHRoaXMuX19maWxsID0gJyAnXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogU2V0IHRoZSBjb2x1bW4gYWxpZ25tZW50IGF0IGEgZ2l2ZW4gaW5kZXhcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29sdW1uIGluZGV4XG4gKiBAcGFyYW0ge051bWJlcn0gYWxpZ25tZW50IGRpcmVjdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zZXRBbGlnbiA9IGZ1bmN0aW9uKGlkeCwgZGlyKSB7XG4gIHRoaXMuX19hbGlnbnNbaWR4XSA9IGRpclxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFNldCB0aGUgdGl0bGUgb2YgdGhlIHRhYmxlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24obmFtZSkge1xuICB0aGlzLl9fbmFtZSA9IG5hbWVcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRpdGxlIG9mIHRoZSB0YWJsZVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gdGl0bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19uYW1lXG59XG5cbi8qKlxuICogU2V0IHRhYmxlIHRpdGxlIGFsaWdubWVudFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc2V0VGl0bGVBbGlnbiA9IGZ1bmN0aW9uKGRpcikge1xuICB0aGlzLl9fbmFtZUFsaWduID0gZGlyXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQXNjaWlUYWJsZSBzb3J0aW5nIHNob3J0Y3V0IHRvIHNvcnQgcm93c1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRpbmcgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgdGhpcy5fX3Jvd3Muc29ydChtZXRob2QpXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogU29ydCByb3dzIGJhc2VkIG9uIHNvcnQgbWV0aG9kIGZvciBnaXZlbiBjb2x1bW5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29sdW1uIGluZGV4XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0aW5nIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zb3J0Q29sdW1uID0gZnVuY3Rpb24oaWR4LCBtZXRob2QpIHtcbiAgdGhpcy5fX3Jvd3Muc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIG1ldGhvZChhW2lkeF0sIGJbaWR4XSlcbiAgfSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBTZXQgdGFibGUgaGVhZGluZyBmb3IgY29sdW1uc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc2V0SGVhZGluZyA9IGZ1bmN0aW9uKHJvdykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgfHwgdG9TdHJpbmcuY2FsbChyb3cpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcm93ID0gc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIH1cbiAgdGhpcy5fX2hlYWRpbmcgPSByb3dcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBHZXQgdGFibGUgaGVhZGluZyBmb3IgY29sdW1uc1xuICpcbiAqIEByZXR1cm4ge0FycmF5fSBjb3B5IG9mIGhlYWRpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLmdldEhlYWRpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19oZWFkaW5nLnNsaWNlKClcbn1cblxuLyoqXG4gKiBTZXQgaGVhZGluZyBhbGlnbm1lbnRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNldEhlYWRpbmdBbGlnbiA9IGZ1bmN0aW9uKGRpcikge1xuICB0aGlzLl9faGVhZGluZ0FsaWduID0gZGlyXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQWRkIGEgcm93IG9mIGluZm9ybWF0aW9uIHRvIHRoZSB0YWJsZVxuICogXG4gKiBAcGFyYW0gey4uLnxBcnJheX0gYXJndW1lbnQgdmFsdWVzIGluIG9yZGVyIG9mIGNvbHVtbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuYWRkUm93ID0gZnVuY3Rpb24ocm93KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSB8fCB0b1N0cmluZy5jYWxsKHJvdykgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByb3cgPSBzbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgfVxuICB0aGlzLl9fbWF4Q2VsbHMgPSBNYXRoLm1heCh0aGlzLl9fbWF4Q2VsbHMsIHJvdy5sZW5ndGgpXG4gIHRoaXMuX19yb3dzLnB1c2gocm93KVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEdldCBhIGNvcHkgb2YgYWxsIHJvd3Mgb2YgdGhlIHRhYmxlXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGNvcHkgb2Ygcm93c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5nZXRSb3dzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcm93cy5zbGljZSgpLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICByZXR1cm4gcm93LnNsaWNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBBZGQgcm93cyBpbiB0aGUgZm9ybWF0IG9mIGEgcm93IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHJvdyBtYXRyaXhcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuYWRkUm93TWF0cml4ID0gZnVuY3Rpb24ocm93cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmFkZFJvdyhyb3dzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQWRkIHJvd3MgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhcnJheSwgcHJvY2Vzc2VkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbiByb3dDYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gKiBAcGFyYW0gKEZ1bmN0aW9uKSByb3dDYWxsYmFja1xuICogQHBhcmFtIChCb29sZWFuKSBhc01hdHJpeCAtIGNvbnRyb2xzIGlmIHRoZSByb3cgY3JlYXRlZCBieSByb3dDYWxsYmFjayBzaG91bGQgYmUgYXNzaWduZWQgYXMgcm93IG1hdHJpeFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5hZGREYXRhID0gZnVuY3Rpb24oZGF0YSwgcm93Q2FsbGJhY2ssIGFzTWF0cml4KSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZm9yICh2YXIgaW5kZXggPSAwLCBsaW1pdCA9IGRhdGEubGVuZ3RoOyBpbmRleCA8IGxpbWl0OyBpbmRleCsrKSB7XG4gICAgdmFyIHJvdyA9IHJvd0NhbGxiYWNrKGRhdGFbaW5kZXhdKTtcbiAgICBpZihhc01hdHJpeCkge1xuICAgICAgdGhpcy5hZGRSb3dNYXRyaXgocm93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRSb3cocm93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuICAvKipcbiAqIFJlc2V0IHRoZSBjdXJyZW50IHJvdyBzdGF0ZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuY2xlYXJSb3dzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19yb3dzID0gW11cbiAgdGhpcy5fX21heENlbGxzID0gMFxuICB0aGlzLl9fY29sTWF4ZXMgPSBbXVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEFwcGx5IGFuIGV2ZW4gc3BhY2VkIGNvbHVtbiBqdXN0aWZpY2F0aW9uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBvbiAvIG9mZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zZXRKdXN0aWZ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgJiYgKHZhbCA9IHRydWUpXG4gIHRoaXMuX19qdXN0aWZ5ID0gISF2YWxcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBjdXJyZW50IGluc3RhbmNlIHRvIGEgSlNPTiBzdHJ1Y3R1cmVcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGpzb24gcmVwcmVzZW50YXRpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdGl0bGU6IHRoaXMuZ2V0VGl0bGUoKVxuICAsIGhlYWRpbmc6IHRoaXMuZ2V0SGVhZGluZygpXG4gICwgcm93czogdGhpcy5nZXRSb3dzKClcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIHRoZSB0YWJsZSBmcm9tIGEgSlNPTiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbiByZXByZXNlbnRhdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5wYXJzZSA9IFxuQXNjaWlUYWJsZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRoaXNcbiAgICAuY2xlYXIoKVxuICAgIC5zZXRUaXRsZShvYmoudGl0bGUpXG4gICAgLnNldEhlYWRpbmcob2JqLmhlYWRpbmcpXG4gICAgLmFkZFJvd01hdHJpeChvYmoucm93cylcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIHRhYmxlIHdpdGggdGhlIGN1cnJlbnQgaW5mb3JtYXRpb25cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCB0YWJsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5yZW5kZXIgPVxuQXNjaWlUYWJsZS5wcm90b3R5cGUudmFsdWVPZiA9XG5Bc2NpaVRhYmxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGJvZHkgPSBbXVxuICAgICwgbUxlbiA9IHRoaXMuX19tYXhDZWxsc1xuICAgICwgbWF4ID0gQXNjaWlUYWJsZS5hcnJheUZpbGwobUxlbiwgMClcbiAgICAsIHRvdGFsID0gbUxlbiAqIDNcbiAgICAsIHJvd3MgPSB0aGlzLl9fcm93c1xuICAgICwganVzdGlmeVxuICAgICwgYm9yZGVyID0gdGhpcy5fX2JvcmRlclxuICAgICwgYWxsID0gdGhpcy5fX2hlYWRpbmcgXG4gICAgICAgID8gW3RoaXMuX19oZWFkaW5nXS5jb25jYXQocm93cylcbiAgICAgICAgOiByb3dzXG5cbiAgLy8gQ2FsY3VsYXRlIG1heCB0YWJsZSBjZWxsIGxlbmd0aHMgYWNyb3NzIGFsbCByb3dzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJvdyA9IGFsbFtpXVxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbUxlbjsgaysrKSB7XG4gICAgICB2YXIgY2VsbCA9IHJvd1trXVxuICAgICAgbWF4W2tdID0gTWF0aC5tYXgobWF4W2tdLCBjZWxsID8gY2VsbC50b1N0cmluZygpLmxlbmd0aCA6IDApXG4gICAgfVxuICB9XG4gIHRoaXMuX19jb2xNYXhlcyA9IG1heFxuICBqdXN0aWZ5ID0gdGhpcy5fX2p1c3RpZnkgPyBNYXRoLm1heC5hcHBseShudWxsLCBtYXgpIDogMFxuXG4gIC8vIEdldCBcbiAgbWF4LmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIHRvdGFsICs9IGp1c3RpZnkgPyBqdXN0aWZ5IDogeCArIHNlbGYuX19zcGFjaW5nXG4gIH0pXG4gIGp1c3RpZnkgJiYgKHRvdGFsICs9IG1heC5sZW5ndGgpXG4gIHRvdGFsIC09IHRoaXMuX19zcGFjaW5nXG5cbiAgLy8gSGVhZGluZ1xuICBib3JkZXIgJiYgYm9keS5wdXNoKHRoaXMuX3NlcGVyYXRvcih0b3RhbCAtIG1MZW4gKyAxLCB0aGlzLl9fdG9wKSlcbiAgaWYgKHRoaXMuX19uYW1lKSB7XG4gICAgYm9keS5wdXNoKHRoaXMuX3JlbmRlclRpdGxlKHRvdGFsIC0gbUxlbiArIDEpKVxuICAgIGJvcmRlciAmJiBib2R5LnB1c2godGhpcy5fc2VwZXJhdG9yKHRvdGFsIC0gbUxlbiArIDEpKVxuICB9XG4gIGlmICh0aGlzLl9faGVhZGluZykge1xuICAgIGJvZHkucHVzaCh0aGlzLl9yZW5kZXJSb3codGhpcy5fX2hlYWRpbmcsICcgJywgdGhpcy5fX2hlYWRpbmdBbGlnbikpXG4gICAgYm9keS5wdXNoKHRoaXMuX3Jvd1NlcGVyYXRvcihtTGVuLCB0aGlzLl9fZmlsbCkpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9fcm93cy5sZW5ndGg7IGkrKykge1xuICAgIGJvZHkucHVzaCh0aGlzLl9yZW5kZXJSb3codGhpcy5fX3Jvd3NbaV0sICcgJykpXG4gIH1cbiAgYm9yZGVyICYmIGJvZHkucHVzaCh0aGlzLl9zZXBlcmF0b3IodG90YWwgLSBtTGVuICsgMSwgdGhpcy5fX2JvdHRvbSkpXG5cbiAgdmFyIHByZWZpeCA9IHRoaXMub3B0aW9ucy5wcmVmaXggfHwgJydcbiAgcmV0dXJuIHByZWZpeCArIGJvZHkuam9pbignXFxuJyArIHByZWZpeClcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBsaW5lIHNlcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpbmcgc2l6ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZGUgdmFsdWVzIChkZWZhdWx0ICd8JylcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLl9zZXBlcmF0b3IgPSBmdW5jdGlvbihsZW4sIHNlcCkge1xuICBzZXAgfHwgKHNlcCA9IHRoaXMuX19lZGdlKVxuICByZXR1cm4gc2VwICsgQXNjaWlUYWJsZS5hbGlnblJpZ2h0KHNlcCwgbGVuLCB0aGlzLl9fZmlsbClcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByb3cgc2VwZXJhdG9yXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBzZXBlcmF0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLl9yb3dTZXBlcmF0b3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJsYW5rcyA9IEFzY2lpVGFibGUuYXJyYXlGaWxsKHRoaXMuX19tYXhDZWxscywgdGhpcy5fX2ZpbGwpXG4gIHJldHVybiB0aGlzLl9yZW5kZXJSb3coYmxhbmtzLCB0aGlzLl9fZmlsbClcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIHRhYmxlIHRpdGxlIGluIGEgY2VudGVyZWQgYm94XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmluZyBzaXplXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCB0aXRsZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuX3JlbmRlclRpdGxlID0gZnVuY3Rpb24obGVuKSB7XG4gIHZhciBuYW1lID0gJyAnICsgdGhpcy5fX25hbWUgKyAnICdcbiAgICAsIHN0ciA9IEFzY2lpVGFibGUuYWxpZ24odGhpcy5fX25hbWVBbGlnbiwgbmFtZSwgbGVuIC0gMSwgJyAnKVxuICByZXR1cm4gdGhpcy5fX2VkZ2UgKyBzdHIgKyB0aGlzLl9fZWRnZVxufVxuXG4vKipcbiAqIFJlbmRlciBhbiBpbnZkaXZpZHVhbCByb3dcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSByb3dcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW4gc2VwZXJhdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWwgcm93IGFsaWdubWVudCAob3B0aW9uYWwsIGRlZmF1bHQgYGF1dG9gKVxuICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgcm93XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5fcmVuZGVyUm93ID0gZnVuY3Rpb24ocm93LCBzdHIsIGFsaWduKSB7XG4gIHZhciB0bXAgPSBbJyddXG4gICAgLCBtYXggPSB0aGlzLl9fY29sTWF4ZXNcblxuICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuX19tYXhDZWxsczsgaysrKSB7XG4gICAgdmFyIGNlbGwgPSByb3dba11cbiAgICAgICwganVzdCA9IHRoaXMuX19qdXN0aWZ5ID8gTWF0aC5tYXguYXBwbHkobnVsbCwgbWF4KSA6IG1heFtrXVxuICAgICAgLy8gLCBwYWQgPSBrID09PSB0aGlzLl9fbWF4Q2VsbHMgLSAxID8ganVzdCA6IGp1c3QgKyB0aGlzLl9fc3BhY2luZ1xuICAgICAgLCBwYWQgPSBqdXN0XG4gICAgICAsIGNBbGlnbiA9IHRoaXMuX19hbGlnbnNba11cbiAgICAgICwgdXNlID0gYWxpZ25cbiAgICAgICwgbWV0aG9kID0gJ2FsaWduQXV0bydcbiAgXG4gICAgaWYgKHR5cGVvZiBhbGlnbiA9PT0gJ3VuZGVmaW5lZCcpIHVzZSA9IGNBbGlnblxuXG4gICAgaWYgKHVzZSA9PT0gQXNjaWlUYWJsZS5MRUZUKSBtZXRob2QgPSAnYWxpZ25MZWZ0J1xuICAgIGlmICh1c2UgPT09IEFzY2lpVGFibGUuQ0VOVEVSKSBtZXRob2QgPSAnYWxpZ25DZW50ZXInXG4gICAgaWYgKHVzZSA9PT0gQXNjaWlUYWJsZS5SSUdIVCkgbWV0aG9kID0gJ2FsaWduUmlnaHQnXG5cbiAgICB0bXAucHVzaChBc2NpaVRhYmxlW21ldGhvZF0oY2VsbCwgcGFkLCBzdHIpKVxuICB9XG4gIHZhciBmcm9udCA9IHRtcC5qb2luKHN0ciArIHRoaXMuX19lZGdlICsgc3RyKVxuICBmcm9udCA9IGZyb250LnN1YnN0cigxLCBmcm9udC5sZW5ndGgpXG4gIHJldHVybiBmcm9udCArIHN0ciArIHRoaXMuX19lZGdlXG59XG5cbi8qIVxuICogQWxpYXNlc1xuICovXG5cbi8vIENyZWF0ZSBtZXRob2Qgc2hvcnRjdXRzIHRvIGFsbCBhbGlnbm1lbnQgbWV0aG9kcyBmb3IgZWFjaCBkaXJlY3Rpb25cbjtbJ0xlZnQnLCAnUmlnaHQnLCAnQ2VudGVyJ10uZm9yRWFjaChmdW5jdGlvbihkaXIpIHtcbiAgdmFyIGNvbnN0YW50ID0gQXNjaWlUYWJsZVtkaXIudG9VcHBlckNhc2UoKV1cblxuICA7WydzZXRBbGlnbicsICdzZXRUaXRsZUFsaWduJywgJ3NldEhlYWRpbmdBbGlnbiddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgLy8gQ2FsbCB0aGUgYmFzZSBtZXRob2Qgd2l0aCB0aGUgZGlyZWN0aW9uIGNvbnN0YW50IGFzIHRoZSBsYXN0IGFyZ3VtZW50XG4gICAgQXNjaWlUYWJsZS5wcm90b3R5cGVbbWV0aG9kICsgZGlyXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KGNvbnN0YW50KVxuICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKVxuICAgIH1cbiAgfSlcbn0pXG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IEFzY2lpVGFibGVcbn0gZWxzZSB7XG4gIHRoaXMuQXNjaWlUYWJsZSA9IEFzY2lpVGFibGVcbn1cblxufSkuY2FsbCh0aGlzKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9hc2NpaS10YWJsZScpIiwiLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbiAqIEBsaWNlbnNlIGVzNS1zaGltIENvcHlyaWdodCAyMDA5LTIwMTUgYnkgY29udHJpYnV0b3JzLCBNSVQgTGljZW5zZVxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuLy8gdmltOiB0cz00IHN0cz00IHN3PTQgZXhwYW5kdGFiXG5cbi8vIEFkZCBzZW1pY29sb24gdG8gcHJldmVudCBJSUZFIGZyb20gYmVpbmcgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIGNvbmNhdGVuYXRlZCBjb2RlLlxuO1xuXG4vLyBVTUQgKFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbilcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL3RlbXBsYXRlcy9yZXR1cm5FeHBvcnRzLmpzXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lLCBleHBvcnRzLCBtb2R1bGUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbnZhciBwcm90b3R5cGVPZk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgb3ducyA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgaXNFbnVtZXJhYmxlID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciB0b1N0ciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC50b1N0cmluZyk7XG5cbi8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvcnMgY3JlYXRpbmcgc2hvcnRjdXRzLlxudmFyIGRlZmluZUdldHRlcjtcbnZhciBkZWZpbmVTZXR0ZXI7XG52YXIgbG9va3VwR2V0dGVyO1xudmFyIGxvb2t1cFNldHRlcjtcbnZhciBzdXBwb3J0c0FjY2Vzc29ycyA9IG93bnMocHJvdG90eXBlT2ZPYmplY3QsICdfX2RlZmluZUdldHRlcl9fJyk7XG5pZiAoc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuICAgIGRlZmluZUdldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZUdldHRlcl9fKTtcbiAgICBkZWZpbmVTZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19kZWZpbmVTZXR0ZXJfXyk7XG4gICAgbG9va3VwR2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwR2V0dGVyX18pO1xuICAgIGxvb2t1cFNldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cFNldHRlcl9fKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG59XG5cbi8vIEVTNSAxNS4yLjMuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjJcbmlmICghT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3VlcyNpc3N1ZS8yXG4gICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL29iamVjdGdldHByb3RvdHlwZW9mL1xuICAgIC8vIHJlY29tbWVuZGVkIGJ5IGZzY2hhZWZlciBvbiBnaXRodWJcbiAgICAvL1xuICAgIC8vIHN1cmUsIGFuZCB3ZWJyZWZsZWN0aW9uIHNheXMgXl9eXG4gICAgLy8gLi4uIHRoaXMgd2lsbCBuZXJldmVyIHBvc3NpYmx5IHJldHVybiBudWxsXG4gICAgLy8gLi4uIE9wZXJhIE1pbmkgYnJlYWtzIGhlcmUgd2l0aCBpbmZpbml0ZSBsb29wc1xuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKG9iamVjdCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgICAgICB2YXIgcHJvdG8gPSBvYmplY3QuX19wcm90b19fO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAgIGlmIChwcm90byB8fCBwcm90byA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICB9IGVsc2UgaWYgKHRvU3RyKG9iamVjdC5jb25zdHJ1Y3RvcikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDb3JyZWN0bHkgcmV0dXJuIG51bGwgZm9yIE9iamVjdHMgY3JlYXRlZCB3aXRoIGBPYmplY3QuY3JlYXRlKG51bGwpYFxuICAgICAgICAgIC8vIChzaGFtbWVkIG9yIG5hdGl2ZSkgb3IgYHsgX19wcm90b19fOiBudWxsfWAuICBBbHNvIHJldHVybnMgbnVsbCBmb3JcbiAgICAgICAgICAvLyBjcm9zcy1yZWFsbSBvYmplY3RzIG9uIGJyb3dzZXJzIHRoYXQgbGFjayBgX19wcm90b19fYCBzdXBwb3J0IChsaWtlXG4gICAgICAgICAgLy8gSUUgPDExKSwgYnV0IHRoYXQncyB0aGUgYmVzdCB3ZSBjYW4gZG8uXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuMi4zLjNcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4zXG5cbnZhciBkb2VzR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29yayA9IGZ1bmN0aW9uIGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKG9iamVjdCkge1xuICAgIHRyeSB7XG4gICAgICAgIG9iamVjdC5zZW50aW5lbCA9IDA7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgJ3NlbnRpbmVsJykudmFsdWUgPT09IDA7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG4vLyBjaGVjayB3aGV0aGVyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciB3b3JrcyBpZiBpdCdzIGdpdmVuLiBPdGhlcndpc2UsIHNoaW0gcGFydGlhbGx5LlxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3Jrc09uT2JqZWN0ID0gZG9lc0dldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmsoe30pO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3Jrc09uRG9tID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgIGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICBpZiAoIWdldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmtzT25Eb20gfHwgIWdldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmtzT25PYmplY3QpIHtcbiAgICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvckZhbGxiYWNrID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICB9XG59XG5cbmlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciB8fCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGYWxsYmFjaykge1xuICAgIHZhciBFUlJfTk9OX09CSkVDVCA9ICdPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIGNhbGxlZCBvbiBhIG5vbi1vYmplY3Q6ICc7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3QgIT09ICdmdW5jdGlvbicpIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVCArIG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICAgICAgLy8gZm9yIEk4J3MgRE9NIGVsZW1lbnRzLlxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE93blByb3BlcnR5RGVzY3JpcHRvckZhbGxiYWNrLmNhbGwoT2JqZWN0LCBvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgICAgICAvLyBJZiBvYmplY3QgZG9lcyBub3Qgb3ducyBwcm9wZXJ0eSByZXR1cm4gdW5kZWZpbmVkIGltbWVkaWF0ZWx5LlxuICAgICAgICBpZiAoIW93bnMob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgb2JqZWN0IGhhcyBhIHByb3BlcnR5IHRoZW4gaXQncyBmb3Igc3VyZSBgY29uZmlndXJhYmxlYCwgYW5kXG4gICAgICAgIC8vIHByb2JhYmx5IGBlbnVtZXJhYmxlYC4gRGV0ZWN0IGVudW1lcmFiaWxpdHkgdGhvdWdoLlxuICAgICAgICBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogaXNFbnVtZXJhYmxlKG9iamVjdCwgcHJvcGVydHkpLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSWYgSlMgZW5naW5lIHN1cHBvcnRzIGFjY2Vzc29yIHByb3BlcnRpZXMgdGhlbiBwcm9wZXJ0eSBtYXkgYmUgYVxuICAgICAgICAvLyBnZXR0ZXIgb3Igc2V0dGVyLlxuICAgICAgICBpZiAoc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHkgYF9fbG9va3VwR2V0dGVyX19gIHdpbGwgcmV0dXJuIGEgZ2V0dGVyIGV2ZW5cbiAgICAgICAgICAgIC8vIGlmIG9iamVjdCBoYXMgb3duIG5vbiBnZXR0ZXIgcHJvcGVydHkgYWxvbmcgd2l0aCBhIHNhbWUgbmFtZWRcbiAgICAgICAgICAgIC8vIGluaGVyaXRlZCBnZXR0ZXIuIFRvIGF2b2lkIG1pc2JlaGF2aW9yIHdlIHRlbXBvcmFyeSByZW1vdmVcbiAgICAgICAgICAgIC8vIGBfX3Byb3RvX19gIHNvIHRoYXQgYF9fbG9va3VwR2V0dGVyX19gIHdpbGwgcmV0dXJuIGdldHRlciBvbmx5XG4gICAgICAgICAgICAvLyBpZiBpdCdzIG93bmVkIGJ5IGFuIG9iamVjdC5cbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBvYmplY3QuX19wcm90b19fO1xuICAgICAgICAgICAgdmFyIG5vdFByb3RvdHlwZU9mT2JqZWN0ID0gb2JqZWN0ICE9PSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgICAgICAgIC8vIGF2b2lkIHJlY3Vyc2lvbiBwcm9ibGVtLCBicmVha2luZyBpbiBPcGVyYSBNaW5pIHdoZW5cbiAgICAgICAgICAgIC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJylcbiAgICAgICAgICAgIC8vIG9yIGFueSBvdGhlciBPYmplY3QucHJvdG90eXBlIGFjY2Vzc29yXG4gICAgICAgICAgICBpZiAobm90UHJvdG90eXBlT2ZPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlT2ZPYmplY3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB2YXIgc2V0dGVyID0gbG9va3VwU2V0dGVyKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICBpZiAobm90UHJvdG90eXBlT2ZPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmNlIHdlIGhhdmUgZ2V0dGVyIGFuZCBzZXR0ZXIgd2UgY2FuIHB1dCB2YWx1ZXMgYmFjay5cbiAgICAgICAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2V0dGVyIHx8IHNldHRlcikge1xuICAgICAgICAgICAgICAgIGlmIChnZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5nZXQgPSBnZXR0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQgPSBzZXR0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGl0IHdhcyBhY2Nlc3NvciBwcm9wZXJ0eSB3ZSdyZSBkb25lIGFuZCByZXR1cm4gaGVyZVxuICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIGFkZGluZyBgdmFsdWVgIHRvIHRoZSBkZXNjcmlwdG9yLlxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHdlIGtub3cgdGhhdCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB0aGF0IGlzXG4gICAgICAgIC8vIG5vdCBhbiBhY2Nlc3NvciBzbyB3ZSBzZXQgaXQgYXMgYSB2YWx1ZSBhbmQgcmV0dXJuIGRlc2NyaXB0b3IuXG4gICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8vIEVTNSAxNS4yLjMuNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjRcbmlmICghT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjVcbmlmICghT2JqZWN0LmNyZWF0ZSkge1xuXG4gICAgLy8gQ29udHJpYnV0ZWQgYnkgQnJhbmRvbiBCZW52aWUsIE9jdG9iZXIsIDIwMTJcbiAgICB2YXIgY3JlYXRlRW1wdHk7XG4gICAgdmFyIHN1cHBvcnRzUHJvdG8gPSAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiBPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBwcm9kdWNlcyBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIE9wZXJhIE1pbmkgPT4gbm90IGEgcmVsaWFibGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdC5wcm90b3R5cGUuX19wcm90b19fID09PSBudWxsXG5cbiAgICAvLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4gICAgLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuICAgIC8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4gICAgLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgKi9cbiAgICB2YXIgc2hvdWxkVXNlQWN0aXZlWCA9IGZ1bmN0aW9uIHNob3VsZFVzZUFjdGl2ZVgoKSB7XG4gICAgICAgIC8vIHJldHVybiBlYXJseSBpZiBkb2N1bWVudC5kb21haW4gbm90IHNldFxuICAgICAgICBpZiAoIWRvY3VtZW50LmRvbWFpbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIW5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBUaGlzIHN1cHBvcnRzIElFOCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyB1c2VkXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4gICAgLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbiAgICB2YXIgZ2V0RW1wdHlWaWFBY3RpdmVYID0gZnVuY3Rpb24gZ2V0RW1wdHlWaWFBY3RpdmVYKCkge1xuICAgICAgICB2YXIgZW1wdHk7XG4gICAgICAgIHZhciB4RG9jO1xuXG4gICAgICAgIHhEb2MgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcblxuICAgICAgICB4RG9jLndyaXRlKCc8c2NyaXB0PjxcXC9zY3JpcHQ+Jyk7XG4gICAgICAgIHhEb2MuY2xvc2UoKTtcblxuICAgICAgICBlbXB0eSA9IHhEb2MucGFyZW50V2luZG93Lk9iamVjdC5wcm90b3R5cGU7XG4gICAgICAgIHhEb2MgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9O1xuXG4gICAgLy8gVGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIHVzaW5nIGFuIGlmcmFtZVxuICAgIC8vIGJlZm9yZSB0aGUgYWN0aXZleCBhcHByb2FjaCB3YXMgYWRkZWRcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbiAgICB2YXIgZ2V0RW1wdHlWaWFJRnJhbWUgPSBmdW5jdGlvbiBnZXRFbXB0eVZpYUlGcmFtZSgpIHtcbiAgICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICB2YXIgcGFyZW50ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHZhciBlbXB0eTtcblxuICAgICAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNjcmlwdC11cmwgKi9cbiAgICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2NyaXB0LXVybCAqL1xuXG4gICAgICAgIGVtcHR5ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0LnByb3RvdHlwZTtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgIGlmcmFtZSA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH07XG5cbiAgICAvKiBnbG9iYWwgZG9jdW1lbnQgKi9cbiAgICBpZiAoc3VwcG9ydHNQcm90byB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgX19wcm90b19fOiBudWxsIH07XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gb2xkIElFIF9fcHJvdG9fXyBjYW4ndCBiZSB1c2VkIHRvIG1hbnVhbGx5IHNldCBgbnVsbGAsIG5vciBkb2VzXG4gICAgICAgIC8vIGFueSBvdGhlciBtZXRob2QgZXhpc3QgdG8gbWFrZSBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIG5vdGhpbmcsXG4gICAgICAgIC8vIGFzaWRlIGZyb20gT2JqZWN0LnByb3RvdHlwZSBpdHNlbGYuIEluc3RlYWQsIGNyZWF0ZSBhIG5ldyBnbG9iYWxcbiAgICAgICAgLy8gb2JqZWN0IGFuZCAqc3RlYWwqIGl0cyBPYmplY3QucHJvdG90eXBlIGFuZCBzdHJpcCBpdCBiYXJlLiBUaGlzIGlzXG4gICAgICAgIC8vIHVzZWQgYXMgdGhlIHByb3RvdHlwZSB0byBjcmVhdGUgbnVsbGFyeSBvYmplY3RzLlxuICAgICAgICBjcmVhdGVFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBhcHByb2FjaCB0byB1c2VcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuICAgICAgICAgICAgdmFyIGVtcHR5ID0gc2hvdWxkVXNlQWN0aXZlWCgpID8gZ2V0RW1wdHlWaWFBY3RpdmVYKCkgOiBnZXRFbXB0eVZpYUlGcmFtZSgpO1xuXG4gICAgICAgICAgICBkZWxldGUgZW1wdHkuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkuaGFzT3duUHJvcGVydHk7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkucHJvcGVydHlJc0VudW1lcmFibGU7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkuaXNQcm90b3R5cGVPZjtcbiAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS50b0xvY2FsZVN0cmluZztcbiAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS50b1N0cmluZztcbiAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS52YWx1ZU9mO1xuXG4gICAgICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gZW1wdHk7XG4gICAgICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IGZ1dHVyZSBjYWxsc1xuICAgICAgICAgICAgY3JlYXRlRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHkoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIHZhciBvYmplY3Q7XG4gICAgICAgIHZhciBUeXBlID0gZnVuY3Rpb24gVHlwZSgpIHt9OyAvLyBBbiBlbXB0eSBjb25zdHJ1Y3Rvci5cblxuICAgICAgICBpZiAocHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBjcmVhdGVFbXB0eSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm90b3R5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uIGBwYXJlbnRgIGNhbiBiZSBgbnVsbGBcbiAgICAgICAgICAgICAgICAvLyBPUiAqYW55KiBgaW5zdGFuY2VvZiBPYmplY3RgICAoT2JqZWN0fEZ1bmN0aW9ufEFycmF5fFJlZ0V4cHxldGMpXG4gICAgICAgICAgICAgICAgLy8gVXNlIGB0eXBlb2ZgIHRobywgYi9jIGluIG9sZCBJRSwgRE9NIGVsZW1lbnRzIGFyZSBub3QgYGluc3RhbmNlb2YgT2JqZWN0YFxuICAgICAgICAgICAgICAgIC8vIGxpa2UgdGhleSBhcmUgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2luZyBgT2JqZWN0LmNyZWF0ZWAgb24gRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgLy8gaXMuLi5lcnIuLi5wcm9iYWJseSBpbmFwcHJvcHJpYXRlLCBidXQgdGhlIG5hdGl2ZSB2ZXJzaW9uIGFsbG93cyBmb3IgaXQuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IHByb3RvdHlwZSBtYXkgb25seSBiZSBhbiBPYmplY3Qgb3IgbnVsbCcpOyAvLyBzYW1lIG1zZyBhcyBDaHJvbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICAgICAgb2JqZWN0ID0gbmV3IFR5cGUoKTtcbiAgICAgICAgICAgIC8vIElFIGhhcyBubyBidWlsdC1pbiBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmdldFByb3RvdHlwZU9mYFxuICAgICAgICAgICAgLy8gbmVpdGhlciBgX19wcm90b19fYCwgYnV0IHRoaXMgbWFudWFsbHkgc2V0dGluZyBgX19wcm90b19fYCB3aWxsXG4gICAgICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCB3aWxsIHdvcmsgYXMgZXhwZWN0ZWQgd2l0aFxuICAgICAgICAgICAgLy8gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIGBPYmplY3QuY3JlYXRlYFxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydGllcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuMi4zLjZcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy42XG5cbi8vIFBhdGNoIGZvciBXZWJLaXQgYW5kIElFOCBzdGFuZGFyZCBtb2RlXG4vLyBEZXNpZ25lZCBieSBoYXggPGhheC5naXRodWIuY29tPlxuLy8gcmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3VlcyNpc3N1ZS81XG4vLyBJRTggUmVmZXJlbmNlOlxuLy8gICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kZDI4MjkwMC5hc3B4XG4vLyAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RkMjI5OTE2LmFzcHhcbi8vIFdlYktpdCBCdWdzOlxuLy8gICAgIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjQyM1xuXG52YXIgZG9lc0RlZmluZVByb3BlcnR5V29yayA9IGZ1bmN0aW9uIGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsob2JqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3NlbnRpbmVsJywge30pO1xuICAgICAgICByZXR1cm4gJ3NlbnRpbmVsJyBpbiBvYmplY3Q7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG4vLyBjaGVjayB3aGV0aGVyIGRlZmluZVByb3BlcnR5IHdvcmtzIGlmIGl0J3MgZ2l2ZW4uIE90aGVyd2lzZSxcbi8vIHNoaW0gcGFydGlhbGx5LlxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eVdvcmtzT25PYmplY3QgPSBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKHt9KTtcbiAgICB2YXIgZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICBpZiAoIWRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdCB8fCAhZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tKSB7XG4gICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG4gICAgfVxufVxuXG5pZiAoIU9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrKSB7XG4gICAgdmFyIEVSUl9OT05fT0JKRUNUX0RFU0NSSVBUT1IgPSAnUHJvcGVydHkgZGVzY3JpcHRpb24gbXVzdCBiZSBhbiBvYmplY3Q6ICc7XG4gICAgdmFyIEVSUl9OT05fT0JKRUNUX1RBUkdFVCA9ICdPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbGVkIG9uIG5vbi1vYmplY3Q6ICc7XG4gICAgdmFyIEVSUl9BQ0NFU1NPUlNfTk9UX1NVUFBPUlRFRCA9ICdnZXR0ZXJzICYgc2V0dGVycyBjYW4gbm90IGJlIGRlZmluZWQgb24gdGhpcyBqYXZhc2NyaXB0IGVuZ2luZSc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdCAhPT0gJ2Z1bmN0aW9uJykgfHwgb2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9OT05fT0JKRUNUX1RBUkdFVCArIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlb2YgZGVzY3JpcHRvciAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlc2NyaXB0b3IgIT09ICdmdW5jdGlvbicpIHx8IGRlc2NyaXB0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiArIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2UgYSB2YWxpYW50IGF0dGVtcHQgdG8gdXNlIHRoZSByZWFsIGRlZmluZVByb3BlcnR5XG4gICAgICAgIC8vIGZvciBJOCdzIERPTSBlbGVtZW50cy5cbiAgICAgICAgaWYgKGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5RmFsbGJhY2suY2FsbChPYmplY3QsIG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBzaGltIGlmIHRoZSByZWFsIG9uZSBkb2Vzbid0IHdvcmtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3MgYSBkYXRhIHByb3BlcnR5LlxuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAvLyBmYWlsIHNpbGVudGx5IGlmICd3cml0YWJsZScsICdlbnVtZXJhYmxlJywgb3IgJ2NvbmZpZ3VyYWJsZSdcbiAgICAgICAgICAgIC8vIGFyZSByZXF1ZXN0ZWQgYnV0IG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvLyBhbHRlcm5hdGUgYXBwcm9hY2g6XG4gICAgICAgICAgICBpZiAoIC8vIGNhbid0IGltcGxlbWVudCB0aGVzZSBmZWF0dXJlczsgYWxsb3cgZmFsc2UgYnV0IG5vdCB0cnVlXG4gICAgICAgICAgICAgICAgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci53cml0YWJsZSkgfHxcbiAgICAgICAgICAgICAgICAoJ2VudW1lcmFibGUnIGluIGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkgfHxcbiAgICAgICAgICAgICAgICAoJ2NvbmZpZ3VyYWJsZScgaW4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUpXG4gICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lcyBub3Qgc3VwcG9ydCBjb25maWd1cmFibGUsIGVudW1lcmFibGUsIG9yIHdyaXRhYmxlLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzICYmIChsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSkgfHwgbG9va3VwU2V0dGVyKG9iamVjdCwgcHJvcGVydHkpKSkge1xuICAgICAgICAgICAgICAgIC8vIEFzIGFjY2Vzc29ycyBhcmUgc3VwcG9ydGVkIG9ubHkgb24gZW5naW5lcyBpbXBsZW1lbnRpbmdcbiAgICAgICAgICAgICAgICAvLyBgX19wcm90b19fYCB3ZSBjYW4gc2FmZWx5IG92ZXJyaWRlIGBfX3Byb3RvX19gIHdoaWxlIGRlZmluaW5nXG4gICAgICAgICAgICAgICAgLy8gYSBwcm9wZXJ0eSB0byBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBoaXQgYW4gaW5oZXJpdGVkXG4gICAgICAgICAgICAgICAgLy8gYWNjZXNzb3IuXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gb2JqZWN0Ll9fcHJvdG9fXztcbiAgICAgICAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlT2ZPYmplY3Q7XG4gICAgICAgICAgICAgICAgLy8gRGVsZXRpbmcgYSBwcm9wZXJ0eSBhbnl3YXkgc2luY2UgZ2V0dGVyIC8gc2V0dGVyIG1heSBiZVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZWQgb24gb2JqZWN0IGl0c2VsZi5cbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIG9yaWdpbmFsIGBfX3Byb3RvX19gIGJhY2sgbm93LlxuICAgICAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydHNBY2Nlc3NvcnMgJiYgKCgnZ2V0JyBpbiBkZXNjcmlwdG9yKSB8fCAoJ3NldCcgaW4gZGVzY3JpcHRvcikpKSB7XG4gICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGF0IGZhciB0aGVuIGdldHRlcnMgYW5kIHNldHRlcnMgY2FuIGJlIGRlZmluZWQgISFcbiAgICAgICAgICAgIGlmICgnZ2V0JyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lR2V0dGVyKG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnc2V0JyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lU2V0dGVyKG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuN1xuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjdcbmlmICghT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgfHwgZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcykge1xuICAgICAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBkZWZpbmVQcm9wZXJ0aWVzXG4gICAgICAgIGlmIChkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnRpZXNGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBwcm9wZXJ0aWVzW3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuOFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjhcbmlmICghT2JqZWN0LnNlYWwpIHtcbiAgICBPYmplY3Quc2VhbCA9IGZ1bmN0aW9uIHNlYWwob2JqZWN0KSB7XG4gICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Quc2VhbCBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIGlzIG1pc2xlYWRpbmcgYW5kIGJyZWFrcyBmZWF0dXJlLWRldGVjdGlvbiwgYnV0XG4gICAgICAgIC8vIGFsbG93cyBcInNlY3VyYWJsZVwiIGNvZGUgdG8gXCJncmFjZWZ1bGx5XCIgZGVncmFkZSB0byB3b3JraW5nXG4gICAgICAgIC8vIGJ1dCBpbnNlY3VyZSBjb2RlLlxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuOVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjlcbmlmICghT2JqZWN0LmZyZWV6ZSkge1xuICAgIE9iamVjdC5mcmVlemUgPSBmdW5jdGlvbiBmcmVlemUob2JqZWN0KSB7XG4gICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuZnJlZXplIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgbWlzbGVhZGluZyBhbmQgYnJlYWtzIGZlYXR1cmUtZGV0ZWN0aW9uLCBidXRcbiAgICAgICAgLy8gYWxsb3dzIFwic2VjdXJhYmxlXCIgY29kZSB0byBcImdyYWNlZnVsbHlcIiBkZWdyYWRlIHRvIHdvcmtpbmdcbiAgICAgICAgLy8gYnV0IGluc2VjdXJlIGNvZGUuXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcbn1cblxuLy8gZGV0ZWN0IGEgUmhpbm8gYnVnIGFuZCBwYXRjaCBpdFxudHJ5IHtcbiAgICBPYmplY3QuZnJlZXplKGZ1bmN0aW9uICgpIHt9KTtcbn0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgIE9iamVjdC5mcmVlemUgPSAoZnVuY3Rpb24gKGZyZWV6ZU9iamVjdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJlZXplT2JqZWN0KG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfShPYmplY3QuZnJlZXplKSk7XG59XG5cbi8vIEVTNSAxNS4yLjMuMTBcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xMFxuaWYgKCFPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcbiAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPSBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhvYmplY3QpIHtcbiAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIGlzIG1pc2xlYWRpbmcgYW5kIGJyZWFrcyBmZWF0dXJlLWRldGVjdGlvbiwgYnV0XG4gICAgICAgIC8vIGFsbG93cyBcInNlY3VyYWJsZVwiIGNvZGUgdG8gXCJncmFjZWZ1bGx5XCIgZGVncmFkZSB0byB3b3JraW5nXG4gICAgICAgIC8vIGJ1dCBpbnNlY3VyZSBjb2RlLlxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuMTFcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xMVxuaWYgKCFPYmplY3QuaXNTZWFsZWQpIHtcbiAgICBPYmplY3QuaXNTZWFsZWQgPSBmdW5jdGlvbiBpc1NlYWxlZChvYmplY3QpIHtcbiAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5pc1NlYWxlZCBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuLy8gRVM1IDE1LjIuMy4xMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjEyXG5pZiAoIU9iamVjdC5pc0Zyb3plbikge1xuICAgIE9iamVjdC5pc0Zyb3plbiA9IGZ1bmN0aW9uIGlzRnJvemVuKG9iamVjdCkge1xuICAgICAgICBpZiAoT2JqZWN0KG9iamVjdCkgIT09IG9iamVjdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmlzRnJvemVuIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuMi4zLjEzXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTNcbmlmICghT2JqZWN0LmlzRXh0ZW5zaWJsZSkge1xuICAgIE9iamVjdC5pc0V4dGVuc2libGUgPSBmdW5jdGlvbiBpc0V4dGVuc2libGUob2JqZWN0KSB7XG4gICAgICAgIC8vIDEuIElmIFR5cGUoTykgaXMgbm90IE9iamVjdCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuaXNFeHRlbnNpYmxlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDIuIFJldHVybiB0aGUgQm9vbGVhbiB2YWx1ZSBvZiB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgTy5cbiAgICAgICAgdmFyIG5hbWUgPSAnJztcbiAgICAgICAgd2hpbGUgKG93bnMob2JqZWN0LCBuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSArPSAnPyc7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W25hbWVdID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gb3ducyhvYmplY3QsIG5hbWUpO1xuICAgICAgICBkZWxldGUgb2JqZWN0W25hbWVdO1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfTtcbn1cblxufSkpO1xuIiwiLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbiAqIEBsaWNlbnNlIGVzNS1zaGltIENvcHlyaWdodCAyMDA5LTIwMTUgYnkgY29udHJpYnV0b3JzLCBNSVQgTGljZW5zZVxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuLy8gdmltOiB0cz00IHN0cz00IHN3PTQgZXhwYW5kdGFiXG5cbi8vIEFkZCBzZW1pY29sb24gdG8gcHJldmVudCBJSUZFIGZyb20gYmVpbmcgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIGNvbmNhdGVuYXRlZCBjb2RlLlxuO1xuXG4vLyBVTUQgKFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbilcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL3RlbXBsYXRlcy9yZXR1cm5FeHBvcnRzLmpzXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lLCBleHBvcnRzLCBtb2R1bGUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuLyoqXG4gKiBCcmluZ3MgYW4gZW52aXJvbm1lbnQgYXMgY2xvc2UgdG8gRUNNQVNjcmlwdCA1IGNvbXBsaWFuY2VcbiAqIGFzIGlzIHBvc3NpYmxlIHdpdGggdGhlIGZhY2lsaXRpZXMgb2YgZXJzdHdoaWxlIGVuZ2luZXMuXG4gKlxuICogQW5ub3RhdGVkIEVTNTogaHR0cDovL2VzNS5naXRodWIuY29tLyAoc3BlY2lmaWMgbGlua3MgYmVsb3cpXG4gKiBFUzUgU3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VjbWEtMjYyLnBkZlxuICogUmVxdWlyZWQgcmVhZGluZzogaHR0cDovL2phdmFzY3JpcHR3ZWJsb2cud29yZHByZXNzLmNvbS8yMDExLzEyLzA1L2V4dGVuZGluZy1qYXZhc2NyaXB0LW5hdGl2ZXMvXG4gKi9cblxuLy8gU2hvcnRjdXQgdG8gYW4gb2Z0ZW4gYWNjZXNzZWQgcHJvcGVydGllcywgaW4gb3JkZXIgdG8gYXZvaWQgbXVsdGlwbGVcbi8vIGRlcmVmZXJlbmNlIHRoYXQgY29zdHMgdW5pdmVyc2FsbHkuIFRoaXMgYWxzbyBob2xkcyBhIHJlZmVyZW5jZSB0byBrbm93bi1nb29kXG4vLyBmdW5jdGlvbnMuXG52YXIgJEFycmF5ID0gQXJyYXk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSAkQXJyYXkucHJvdG90eXBlO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSAkRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyICRTdHJpbmcgPSBTdHJpbmc7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gJFN0cmluZy5wcm90b3R5cGU7XG52YXIgJE51bWJlciA9IE51bWJlcjtcbnZhciBOdW1iZXJQcm90b3R5cGUgPSAkTnVtYmVyLnByb3RvdHlwZTtcbnZhciBhcnJheV9zbGljZSA9IEFycmF5UHJvdG90eXBlLnNsaWNlO1xudmFyIGFycmF5X3NwbGljZSA9IEFycmF5UHJvdG90eXBlLnNwbGljZTtcbnZhciBhcnJheV9wdXNoID0gQXJyYXlQcm90b3R5cGUucHVzaDtcbnZhciBhcnJheV91bnNoaWZ0ID0gQXJyYXlQcm90b3R5cGUudW5zaGlmdDtcbnZhciBhcnJheV9jb25jYXQgPSBBcnJheVByb3RvdHlwZS5jb25jYXQ7XG52YXIgYXJyYXlfam9pbiA9IEFycmF5UHJvdG90eXBlLmpvaW47XG52YXIgY2FsbCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG52YXIgYXBwbHkgPSBGdW5jdGlvblByb3RvdHlwZS5hcHBseTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGF2aW5nIGEgdG9TdHJpbmcgbG9jYWwgdmFyaWFibGUgbmFtZSBicmVha3MgaW4gT3BlcmEgc28gdXNlIHRvX3N0cmluZy5cbnZhciB0b19zdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8qIGVzbGludC1kaXNhYmxlIG9uZS12YXItZGVjbGFyYXRpb24tcGVyLWxpbmUgKi9cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG52YXIgaXNDYWxsYWJsZTsgLyogaW5saW5lZCBmcm9tIGh0dHBzOi8vbnBtanMuY29tL2lzLWNhbGxhYmxlICovIHZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLCB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKSB7IHRyeSB7IGZuVG9TdHIuY2FsbCh2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9LCBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJywgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nOyBpc0NhbGxhYmxlID0gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkgeyBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfSBpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfSB2YXIgc3RyQ2xhc3MgPSB0b19zdHJpbmcuY2FsbCh2YWx1ZSk7IHJldHVybiBzdHJDbGFzcyA9PT0gZm5DbGFzcyB8fCBzdHJDbGFzcyA9PT0gZ2VuQ2xhc3M7IH07XG52YXIgaXNSZWdleDsgLyogaW5saW5lZCBmcm9tIGh0dHBzOi8vbnBtanMuY29tL2lzLXJlZ2V4ICovIHZhciByZWdleEV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWMsIHRyeVJlZ2V4RXhlYyA9IGZ1bmN0aW9uIHRyeVJlZ2V4RXhlYyh2YWx1ZSkgeyB0cnkgeyByZWdleEV4ZWMuY2FsbCh2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9LCByZWdleENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXSc7IGlzUmVnZXggPSBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7IGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfSByZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlSZWdleEV4ZWModmFsdWUpIDogdG9fc3RyaW5nLmNhbGwodmFsdWUpID09PSByZWdleENsYXNzOyB9O1xudmFyIGlzU3RyaW5nOyAvKiBpbmxpbmVkIGZyb20gaHR0cHM6Ly9ucG1qcy5jb20vaXMtc3RyaW5nICovIHZhciBzdHJWYWx1ZSA9IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZiwgdHJ5U3RyaW5nT2JqZWN0ID0gZnVuY3Rpb24gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSB7IHRyeSB7IHN0clZhbHVlLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJzsgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkgeyBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgeyByZXR1cm4gdHJ1ZTsgfSBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH0gcmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSA6IHRvX3N0cmluZy5jYWxsKHZhbHVlKSA9PT0gc3RyaW5nQ2xhc3M7IH07XG4vKiBlc2xpbnQtZW5hYmxlIG9uZS12YXItZGVjbGFyYXRpb24tcGVyLWxpbmUgKi9cblxuLyogaW5saW5lZCBmcm9tIGh0dHA6Ly9ucG1qcy5jb20vZGVmaW5lLXByb3BlcnRpZXMgKi9cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICd4JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG9iaiB9KTtcbiAgICAgICAgZm9yICh2YXIgXyBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBvYmoueCA9PT0gb2JqO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IChmdW5jdGlvbiAoaGFzKSB7XG4gIC8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlLCBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbiAgLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbiAgdmFyIGRlZmluZVByb3BlcnR5O1xuICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICAgIG9iamVjdFtuYW1lXSA9IG1ldGhvZDtcbiAgICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBtYXAsIGZvcmNlQXNzaWduKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICAgIGlmIChoYXMuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcbn0oT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5KSk7XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCAvaGVscGVycy9pc1ByaW1pdGl2ZSAqL1xudmFyIGlzUHJpbWl0aXZlID0gZnVuY3Rpb24gaXNQcmltaXRpdmUoaW5wdXQpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICByZXR1cm4gaW5wdXQgPT09IG51bGwgfHwgKHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGUgIT09ICdmdW5jdGlvbicpO1xufTtcblxudmFyIGlzQWN0dWFsTmFOID0gJE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0geDsgfTtcblxudmFyIEVTID0ge1xuICAgIC8vIEVTNSA5LjRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS90by1pbnRlZ2VyXG4gICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub0ludGVnZXIgKi9cbiAgICBUb0ludGVnZXI6IGZ1bmN0aW9uIFRvSW50ZWdlcihudW0pIHtcbiAgICAgICAgdmFyIG4gPSArbnVtO1xuICAgICAgICBpZiAoaXNBY3R1YWxOYU4obikpIHtcbiAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9LFxuXG4gICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub1ByaW1pdGl2ZSAqL1xuICAgIFRvUHJpbWl0aXZlOiBmdW5jdGlvbiBUb1ByaW1pdGl2ZShpbnB1dCkge1xuICAgICAgICB2YXIgdmFsLCB2YWx1ZU9mLCB0b1N0cjtcbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlT2YgPSBpbnB1dC52YWx1ZU9mO1xuICAgICAgICBpZiAoaXNDYWxsYWJsZSh2YWx1ZU9mKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsdWVPZi5jYWxsKGlucHV0KTtcbiAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b1N0ciA9IGlucHV0LnRvU3RyaW5nO1xuICAgICAgICBpZiAoaXNDYWxsYWJsZSh0b1N0cikpIHtcbiAgICAgICAgICAgIHZhbCA9IHRvU3RyLmNhbGwoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9LFxuXG4gICAgLy8gRVM1IDkuOVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuOVxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9PYmplY3QgKi9cbiAgICBUb09iamVjdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRPYmplY3Qobyk7XG4gICAgfSxcblxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9VaW50MzIgKi9cbiAgICBUb1VpbnQzMjogZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgICAgICByZXR1cm4geCA+Pj4gMDtcbiAgICB9XG59O1xuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG52YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEZ1bmN0aW9uUHJvdG90eXBlLCB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxuICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICcgKyB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgIC8vICAgYXJndW1lbnQgdmFsdWVzIHByb3ZpZGVkIGFmdGVyIHRoaXNBcmcgKGFyZzEsIGFyZzIgZXRjKSwgaW4gb3JkZXIuXG4gICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAvLyA0LiBMZXQgRiBiZSBhIG5ldyBuYXRpdmUgRUNNQVNjcmlwdCBvYmplY3QuXG4gICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcbiAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgLy8gMTIuIFNldCB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxuICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMi5cbiAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgdmFyIGJvdW5kO1xuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGFwcGx5LmNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlfY29uY2F0LmNhbGwoYXJncywgYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCRPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjEgW1tDYWxsXV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vICAgb2YgdGFyZ2V0IHByb3ZpZGluZyBib3VuZFRoaXMgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgLy8gZXF1aXY6IHRhcmdldC5jYWxsKHRoaXMsIC4uLmJvdW5kQXJncywgLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICBhcnJheV9jb25jYXQuY2FsbChhcmdzLCBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxuICAgICAgICAvLyAgICAgYi4gU2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gZWl0aGVyIDAgb3IgTCwgd2hpY2hldmVyIGlzXG4gICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cblxuICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBtYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5X3B1c2guY2FsbChib3VuZEFyZ3MsICckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICBib3VuZCA9ICRGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGFycmF5X2pvaW4uY2FsbChib3VuZEFyZ3MsICcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbn0pO1xuXG4vLyBfUGxlYXNlIG5vdGU6IFNob3J0Y3V0cyBhcmUgZGVmaW5lZCBhZnRlciBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIGFzIHdlXG4vLyB1c2UgaXQgaW4gZGVmaW5pbmcgc2hvcnRjdXRzLlxudmFyIG93bnMgPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciB0b1N0ciA9IGNhbGwuYmluZChPYmplY3RQcm90b3R5cGUudG9TdHJpbmcpO1xudmFyIGFycmF5U2xpY2UgPSBjYWxsLmJpbmQoYXJyYXlfc2xpY2UpO1xudmFyIGFycmF5U2xpY2VBcHBseSA9IGFwcGx5LmJpbmQoYXJyYXlfc2xpY2UpO1xudmFyIHN0clNsaWNlID0gY2FsbC5iaW5kKFN0cmluZ1Byb3RvdHlwZS5zbGljZSk7XG52YXIgc3RyU3BsaXQgPSBjYWxsLmJpbmQoU3RyaW5nUHJvdG90eXBlLnNwbGl0KTtcbnZhciBzdHJJbmRleE9mID0gY2FsbC5iaW5kKFN0cmluZ1Byb3RvdHlwZS5pbmRleE9mKTtcbnZhciBwdXNoQ2FsbCA9IGNhbGwuYmluZChhcnJheV9wdXNoKTtcbnZhciBpc0VudW0gPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciBhcnJheVNvcnQgPSBjYWxsLmJpbmQoQXJyYXlQcm90b3R5cGUuc29ydCk7XG5cbi8vXG4vLyBBcnJheVxuLy8gPT09PT1cbi8vXG5cbnZhciBpc0FycmF5ID0gJEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8vIEVTNSAxNS40LjQuMTJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xM1xuLy8gUmV0dXJuIGxlbithcmdDb3VudC5cbi8vIFtidWdmaXgsIGllbHQ4XVxuLy8gSUUgPCA4IGJ1ZzogW10udW5zaGlmdCgwKSA9PT0gdW5kZWZpbmVkIGJ1dCBzaG91bGQgYmUgXCIxXCJcbnZhciBoYXNVbnNoaWZ0UmV0dXJuVmFsdWVCdWcgPSBbXS51bnNoaWZ0KDApICE9PSAxO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXJyYXlfdW5zaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxufSwgaGFzVW5zaGlmdFJldHVyblZhbHVlQnVnKTtcblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcygkQXJyYXksIHsgaXNBcnJheTogaXNBcnJheSB9KTtcblxuLy8gVGhlIElzQ2FsbGFibGUoKSBjaGVjayBpbiB0aGUgQXJyYXkgZnVuY3Rpb25zXG4vLyBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGEgc3RyaWN0IGNoZWNrIG9uIHRoZVxuLy8gaW50ZXJuYWwgY2xhc3Mgb2YgdGhlIG9iamVjdCB0byB0cmFwIGNhc2VzIHdoZXJlXG4vLyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2FzIGFjdHVhbGx5IGEgcmVndWxhclxuLy8gZXhwcmVzc2lvbiBsaXRlcmFsLCB3aGljaCBpbiBWOCBhbmRcbi8vIEphdmFTY3JpcHRDb3JlIGlzIGEgdHlwZW9mIFwiZnVuY3Rpb25cIi4gIE9ubHkgaW5cbi8vIFY4IGFyZSByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHMgcGVybWl0dGVkIGFzXG4vLyByZWR1Y2UgcGFyYW1ldGVycywgc28gaXQgaXMgZGVzaXJhYmxlIGluIHRoZVxuLy8gZ2VuZXJhbCBjYXNlIGZvciB0aGUgc2hpbSB0byBtYXRjaCB0aGUgbW9yZVxuLy8gc3RyaWN0IGFuZCBjb21tb24gYmVoYXZpb3Igb2YgcmVqZWN0aW5nIHJlZ3VsYXJcbi8vIGV4cHJlc3Npb25zLlxuXG4vLyBFUzUgMTUuNC40LjE4XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMThcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2FycmF5L2ZvckVhY2hcblxuLy8gQ2hlY2sgZmFpbHVyZSBvZiBieS1pbmRleCBhY2Nlc3Mgb2Ygc3RyaW5nIGNoYXJhY3RlcnMgKElFIDwgOSlcbi8vIGFuZCBmYWlsdXJlIG9mIGAwIGluIGJveGVkU3RyaW5nYCAoUmhpbm8pXG52YXIgYm94ZWRTdHJpbmcgPSAkT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgIHZhciB0aHJld0V4Y2VwdGlvbiA9IGZhbHNlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnKSB7IHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTsgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICB9LCAneCcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJld0V4Y2VwdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmICF0aHJld0V4Y2VwdGlvbiAmJiBwcm9wZXJseUJveGVzTm9uU3RyaWN0ICYmIHByb3Blcmx5Qm94ZXNTdHJpY3Q7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgIHZhciBUO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZm9yRWFjaCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja2ZuLmNhbGwoVCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4vLyBFUzUgMTUuNC40LjE5XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTlcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvbWFwXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJEFycmF5KGxlbmd0aCk7XG4gICAgICAgIHZhciBUO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5tYXAgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjYWxsYmFja2ZuKHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLm1hcCkpO1xuXG4vLyBFUzUgMTUuNC40LjIwXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjBcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvZmlsdGVyXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIFQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbHRlciBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGZbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrZm4odmFsdWUsIGksIG9iamVjdCkgOiBjYWxsYmFja2ZuLmNhbGwoVCwgdmFsdWUsIGksIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZpbHRlcikpO1xuXG4vLyBFUzUgMTUuNC40LjE2XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTZcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2V2ZXJ5XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4vKiwgdGhpc0FyZyovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgdmFyIFQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmV2ZXJ5IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiAhKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KSA6IGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZXZlcnkpKTtcblxuLy8gRVM1IDE1LjQuNC4xN1xuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE3XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuLyosIHRoaXNBcmcgKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICB2YXIgVDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuc29tZSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KSA6IGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuc29tZSkpO1xuXG4vLyBFUzUgMTUuNC40LjIxXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjFcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvcmVkdWNlXG52YXIgcmVkdWNlQ29lcmNlc1RvT2JqZWN0ID0gZmFsc2U7XG5pZiAoQXJyYXlQcm90b3R5cGUucmVkdWNlKSB7XG4gICAgcmVkdWNlQ29lcmNlc1RvT2JqZWN0ID0gdHlwZW9mIEFycmF5UHJvdG90eXBlLnJlZHVjZS5jYWxsKCdlczUnLCBmdW5jdGlvbiAoXywgX18sIF9fXywgbGlzdCkgeyByZXR1cm4gbGlzdDsgfSkgPT09ICdvYmplY3QnO1xufVxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4vKiwgaW5pdGlhbFZhbHVlKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIHZhbHVlIHRvIHJldHVybiBpZiBubyBpbml0aWFsIHZhbHVlIGFuZCBhbiBlbXB0eSBhcnJheVxuICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKCsraSA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrZm4ocmVzdWx0LCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59LCAhcmVkdWNlQ29lcmNlc1RvT2JqZWN0KTtcblxuLy8gRVM1IDE1LjQuNC4yMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L3JlZHVjZVJpZ2h0XG52YXIgcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QgPSBmYWxzZTtcbmlmIChBcnJheVByb3RvdHlwZS5yZWR1Y2VSaWdodCkge1xuICAgIHJlZHVjZVJpZ2h0Q29lcmNlc1RvT2JqZWN0ID0gdHlwZW9mIEFycmF5UHJvdG90eXBlLnJlZHVjZVJpZ2h0LmNhbGwoJ2VzNScsIGZ1bmN0aW9uIChfLCBfXywgX19fLCBsaXN0KSB7IHJldHVybiBsaXN0OyB9KSA9PT0gJ29iamVjdCc7XG59XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4vKiwgaW5pdGlhbCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIHZhbHVlIHRvIHJldHVybiBpZiBubyBpbml0aWFsIHZhbHVlLCBlbXB0eSBhcnJheVxuICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZVJpZ2h0IG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGkgPSBsZW5ndGggLSAxO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmW2ktLV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIGFycmF5IGNvbnRhaW5zIG5vIHZhbHVlcywgbm8gaW5pdGlhbCB2YWx1ZSB0byByZXR1cm5cbiAgICAgICAgICAgICAgICBpZiAoLS1pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFja2ZuKHJlc3VsdCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoaS0tKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0sICFyZWR1Y2VSaWdodENvZXJjZXNUb09iamVjdCk7XG5cbi8vIEVTNSAxNS40LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxudmFyIGhhc0ZpcmVmb3gySW5kZXhPZkJ1ZyA9IEFycmF5UHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudC8qLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gRVMuVG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IG1heCgwLCBsZW5ndGggKyBpKTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbi8vIEVTNSAxNS40LjQuMTVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGFzdEluZGV4T2ZcbnZhciBoYXNGaXJlZm94Mkxhc3RJbmRleE9mQnVnID0gQXJyYXlQcm90b3R5cGUubGFzdEluZGV4T2YgJiYgWzAsIDFdLmxhc3RJbmRleE9mKDAsIC0zKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQvKiwgZnJvbUluZGV4ICovKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSBsZW5ndGggLSAxO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSBtaW4oaSwgRVMuVG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogbGVuZ3RoIC0gTWF0aC5hYnMoaSk7XG4gICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWFyY2hFbGVtZW50ID09PSBzZWxmW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gyTGFzdEluZGV4T2ZCdWcpO1xuXG4vLyBFUzUgMTUuNC40LjEyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTJcbnZhciBzcGxpY2VOb29wUmV0dXJuc0VtcHR5QXJyYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gWzEsIDJdO1xuICAgIHZhciByZXN1bHQgPSBhLnNwbGljZSgpO1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gMiAmJiBpc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCA9PT0gMDtcbn0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgLy8gU2FmYXJpIDUuMCBidWcgd2hlcmUgLnNwbGljZSgpIHJldHVybnMgdW5kZWZpbmVkXG4gICAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlfc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG59LCAhc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5KTtcblxudmFyIHNwbGljZVdvcmtzV2l0aEVtcHR5T2JqZWN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgQXJyYXlQcm90b3R5cGUuc3BsaWNlLmNhbGwob2JqLCAwLCAwLCAxKTtcbiAgICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMTtcbn0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBtYXgoRVMuVG9JbnRlZ2VyKHRoaXMubGVuZ3RoKSwgMCk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2YgZGVsZXRlQ291bnQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHB1c2hDYWxsKGFyZ3MsIHRoaXMubGVuZ3RoIC0gc3RhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzWzFdID0gRVMuVG9JbnRlZ2VyKGRlbGV0ZUNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlfc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbn0sICFzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCk7XG52YXIgc3BsaWNlV29ya3NXaXRoTGFyZ2VTcGFyc2VBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzI5NVxuICAgIC8vIFNhZmFyaSA3LzggYnJlYWtzIHdpdGggc3BhcnNlIGFycmF5cyBvZiBzaXplIDFlNSBvciBncmVhdGVyXG4gICAgdmFyIGFyciA9IG5ldyAkQXJyYXkoMWU1KTtcbiAgICAvLyBub3RlOiB0aGUgaW5kZXggTVVTVCBiZSA4IG9yIGxhcmdlciBvciB0aGUgdGVzdCB3aWxsIGZhbHNlIHBhc3NcbiAgICBhcnJbOF0gPSAneCc7XG4gICAgYXJyLnNwbGljZSgxLCAxKTtcbiAgICAvLyBub3RlOiB0aGlzIHRlc3QgbXVzdCBiZSBkZWZpbmVkICphZnRlciogdGhlIGluZGV4T2Ygc2hpbVxuICAgIC8vIHBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzMxM1xuICAgIHJldHVybiBhcnIuaW5kZXhPZigneCcpID09PSA3O1xufSgpKTtcbnZhciBzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMjk1XG4gICAgLy8gT3BlcmEgMTIuMTUgYnJlYWtzIG9uIHRoaXMsIG5vIGlkZWEgd2h5LlxuICAgIHZhciBuID0gMjU2O1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBhcnJbbl0gPSAnYSc7XG4gICAgYXJyLnNwbGljZShuICsgMSwgMCwgJ2InKTtcbiAgICByZXR1cm4gYXJyW25dID09PSAnYSc7XG59KCkpO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICB2YXIgTyA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgQSA9IFtdO1xuICAgICAgICB2YXIgbGVuID0gRVMuVG9VaW50MzIoTy5sZW5ndGgpO1xuICAgICAgICB2YXIgcmVsYXRpdmVTdGFydCA9IEVTLlRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIHZhciBhY3R1YWxTdGFydCA9IHJlbGF0aXZlU3RhcnQgPCAwID8gbWF4KChsZW4gKyByZWxhdGl2ZVN0YXJ0KSwgMCkgOiBtaW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcbiAgICAgICAgdmFyIGFjdHVhbERlbGV0ZUNvdW50ID0gbWluKG1heChFUy5Ub0ludGVnZXIoZGVsZXRlQ291bnQpLCAwKSwgbGVuIC0gYWN0dWFsU3RhcnQpO1xuXG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgdmFyIGZyb207XG4gICAgICAgIHdoaWxlIChrIDwgYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGFjdHVhbFN0YXJ0ICsgayk7XG4gICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgIEFba10gPSBPW2Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW1zID0gYXJyYXlTbGljZShhcmd1bWVudHMsIDIpO1xuICAgICAgICB2YXIgaXRlbUNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICB2YXIgdG87XG4gICAgICAgIGlmIChpdGVtQ291bnQgPCBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgayA9IGFjdHVhbFN0YXJ0O1xuICAgICAgICAgICAgdmFyIG1heEsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDtcbiAgICAgICAgICAgIHdoaWxlIChrIDwgbWF4Sykge1xuICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCk7XG4gICAgICAgICAgICAgICAgdG8gPSAkU3RyaW5nKGsgKyBpdGVtQ291bnQpO1xuICAgICAgICAgICAgICAgIGlmIChvd25zKE8sIGZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgT1t0b107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgPSBsZW47XG4gICAgICAgICAgICB2YXIgbWluSyA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaXRlbUNvdW50O1xuICAgICAgICAgICAgd2hpbGUgKGsgPiBtaW5LKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIE9bayAtIDFdO1xuICAgICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpdGVtQ291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgayA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICAgICAgd2hpbGUgKGsgPiBhY3R1YWxTdGFydCkge1xuICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIHRvID0gJFN0cmluZyhrICsgaXRlbUNvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKG93bnMoTywgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBPW3RvXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgayAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGsgPSBhY3R1YWxTdGFydDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgT1trXSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgayArPSAxO1xuICAgICAgICB9XG4gICAgICAgIE8ubGVuZ3RoID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpdGVtQ291bnQ7XG5cbiAgICAgICAgcmV0dXJuIEE7XG4gICAgfVxufSwgIXNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzIHx8ICFzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyk7XG5cbnZhciBvcmlnaW5hbEpvaW4gPSBBcnJheVByb3RvdHlwZS5qb2luO1xudmFyIGhhc1N0cmluZ0pvaW5CdWc7XG50cnkge1xuICAgIGhhc1N0cmluZ0pvaW5CdWcgPSBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKCcxMjMnLCAnLCcpICE9PSAnMSwyLDMnO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0cmluZ0pvaW5CdWcgPSB0cnVlO1xufVxuaWYgKGhhc1N0cmluZ0pvaW5CdWcpIHtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc2VwID0gdHlwZW9mIHNlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyAnLCcgOiBzZXBhcmF0b3I7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxKb2luLmNhbGwoaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiB0aGlzLCBzZXApO1xuICAgICAgICB9XG4gICAgfSwgaGFzU3RyaW5nSm9pbkJ1Zyk7XG59XG5cbnZhciBoYXNKb2luVW5kZWZpbmVkQnVnID0gWzEsIDJdLmpvaW4odW5kZWZpbmVkKSAhPT0gJzEsMic7XG5pZiAoaGFzSm9pblVuZGVmaW5lZEJ1Zykge1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBzZXAgPSB0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyA/ICcsJyA6IHNlcGFyYXRvcjtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEpvaW4uY2FsbCh0aGlzLCBzZXApO1xuICAgICAgICB9XG4gICAgfSwgaGFzSm9pblVuZGVmaW5lZEJ1Zyk7XG59XG5cbnZhciBwdXNoU2hpbSA9IGZ1bmN0aW9uIHB1c2goaXRlbSkge1xuICAgIHZhciBPID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgdmFyIG4gPSBFUy5Ub1VpbnQzMihPLmxlbmd0aCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBPW24gKyBpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaSArPSAxO1xuICAgIH1cbiAgICBPLmxlbmd0aCA9IG4gKyBpO1xuICAgIHJldHVybiBuICsgaTtcbn07XG5cbnZhciBwdXNoSXNOb3RHZW5lcmljID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZS5wdXNoLmNhbGwob2JqLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgb2JqLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2Ygb2JqWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhvYmosIDApO1xufSgpKTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheV9wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1c2hTaGltLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxufSwgcHVzaElzTm90R2VuZXJpYyk7XG5cbi8vIFRoaXMgZml4ZXMgYSB2ZXJ5IHdlaXJkIGJ1ZyBpbiBPcGVyYSAxMC42IHdoZW4gcHVzaGluZyBgdW5kZWZpbmVkXG52YXIgcHVzaFVuZGVmaW5lZElzV2VpcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgcmVzdWx0ID0gYXJyLnB1c2godW5kZWZpbmVkKTtcbiAgICByZXR1cm4gcmVzdWx0ICE9PSAxIHx8IGFyci5sZW5ndGggIT09IDEgfHwgdHlwZW9mIGFyclswXSAhPT0gJ3VuZGVmaW5lZCcgfHwgIW93bnMoYXJyLCAwKTtcbn0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7IHB1c2g6IHB1c2hTaGltIH0sIHB1c2hVbmRlZmluZWRJc1dlaXJkKTtcblxuLy8gRVM1IDE1LjIuMy4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMTBcbi8vIEZpeCBib3hlZCBzdHJpbmcgYnVnXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgc2xpY2U6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBhcnIgPSBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IHRoaXM7XG4gICAgICAgIHJldHVybiBhcnJheVNsaWNlQXBwbHkoYXJyLCBhcmd1bWVudHMpO1xuICAgIH1cbn0sIHNwbGl0U3RyaW5nKTtcblxudmFyIHNvcnRJZ25vcmVzTm9uRnVuY3Rpb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBbMSwgMl0uc29ydChudWxsKTtcbiAgICAgICAgWzEsIDJdLnNvcnQoe30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7IC8qKi8gfVxuICAgIHJldHVybiBmYWxzZTtcbn0oKSk7XG52YXIgc29ydFRocm93c09uUmVnZXggPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIHRoaXMgaXMgYSBwcm9ibGVtIGluIEZpcmVmb3ggNCwgaW4gd2hpY2ggYHR5cGVvZiAvYS8gPT09ICdmdW5jdGlvbidgXG4gICAgdHJ5IHtcbiAgICAgICAgWzEsIDJdLnNvcnQoL2EvKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG4gICAgcmV0dXJuIHRydWU7XG59KCkpO1xudmFyIHNvcnRJZ25vcmVzVW5kZWZpbmVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBhcHBsaWVzIGluIElFIDgsIGZvciBvbmUuXG4gICAgdHJ5IHtcbiAgICAgICAgWzEsIDJdLnNvcnQodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiovIH1cbiAgICByZXR1cm4gZmFsc2U7XG59KCkpO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZUZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29tcGFyZUZuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5U29ydCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY29tcGFyZUZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnNvcnQgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5U29ydCh0aGlzLCBjb21wYXJlRm4pO1xuICAgIH1cbn0sIHNvcnRJZ25vcmVzTm9uRnVuY3Rpb25zIHx8ICFzb3J0SWdub3Jlc1VuZGVmaW5lZCB8fCAhc29ydFRocm93c09uUmVnZXgpO1xuXG4vL1xuLy8gT2JqZWN0XG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS4yLjMuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xNFxuXG4vLyBodHRwOi8vd2hhdHRoZWhlYWRzYWlkLmNvbS8yMDEwLzEwL2Etc2FmZXItb2JqZWN0LWtleXMtY29tcGF0aWJpbGl0eS1pbXBsZW1lbnRhdGlvblxudmFyIGhhc0RvbnRFbnVtQnVnID0gISh7ICd0b1N0cmluZyc6IG51bGwgfSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG52YXIgaGFzUHJvdG9FbnVtQnVnID0gZnVuY3Rpb24gKCkge30ucHJvcGVydHlJc0VudW1lcmFibGUoJ3Byb3RvdHlwZScpO1xudmFyIGhhc1N0cmluZ0VudW1CdWcgPSAhb3ducygneCcsICcwJyk7XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuICAgIHZhciBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbn07XG52YXIgYmxhY2tsaXN0ZWRLZXlzID0ge1xuICAgICR3aW5kb3c6IHRydWUsXG4gICAgJGNvbnNvbGU6IHRydWUsXG4gICAgJHBhcmVudDogdHJ1ZSxcbiAgICAkc2VsZjogdHJ1ZSxcbiAgICAkZnJhbWU6IHRydWUsXG4gICAgJGZyYW1lczogdHJ1ZSxcbiAgICAkZnJhbWVFbGVtZW50OiB0cnVlLFxuICAgICR3ZWJraXRJbmRleGVkREI6IHRydWUsXG4gICAgJHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuICAgICRleHRlcm5hbDogdHJ1ZVxufTtcbnZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qIGdsb2JhbHMgd2luZG93ICovXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvciAodmFyIGsgaW4gd2luZG93KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWJsYWNrbGlzdGVkS2V5c1snJCcgKyBrXSAmJiBvd25zKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufSgpKTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHsgcmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG9iamVjdCk7IH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUob2JqZWN0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xudmFyIGRvbnRFbnVtcyA9IFtcbiAgICAndG9TdHJpbmcnLFxuICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgJ3ZhbHVlT2YnLFxuICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgJ2NvbnN0cnVjdG9yJ1xuXTtcbnZhciBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG4vLyB0YWtlbiBkaXJlY3RseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvaXMtYXJndW1lbnRzL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBjYW4gYmUgcmVwbGFjZWQgd2l0aCByZXF1aXJlKCdpcy1hcmd1bWVudHMnKSBpZiB3ZSBldmVyIHVzZSBhIGJ1aWxkIHByb2Nlc3MgaW5zdGVhZFxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgIHJldHVybiB0b1N0cih2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICAgIWlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgIGlzQ2FsbGFibGUodmFsdWUuY2FsbGVlKTtcbn07XG52YXIgaXNBcmd1bWVudHMgPSBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cykgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG5cbmRlZmluZVByb3BlcnRpZXMoJE9iamVjdCwge1xuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgIHZhciBpc0ZuID0gaXNDYWxsYWJsZShvYmplY3QpO1xuICAgICAgICB2YXIgaXNBcmdzID0gaXNBcmd1bWVudHMob2JqZWN0KTtcbiAgICAgICAgdmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuICAgICAgICB2YXIgaXNTdHIgPSBpc09iamVjdCAmJiBpc1N0cmluZyhvYmplY3QpO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QgJiYgIWlzRm4gJiYgIWlzQXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoZUtleXMgPSBbXTtcbiAgICAgICAgdmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0ZuO1xuICAgICAgICBpZiAoKGlzU3RyICYmIGhhc1N0cmluZ0VudW1CdWcpIHx8IGlzQXJncykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwdXNoQ2FsbCh0aGVLZXlzLCAkU3RyaW5nKGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgb3ducyhvYmplY3QsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKHRoZUtleXMsICRTdHJpbmcobmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgICAgICAgdmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb250RW51bXNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBkb250RW51bSA9IGRvbnRFbnVtc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW0gPT09ICdjb25zdHJ1Y3RvcicpICYmIG93bnMob2JqZWN0LCBkb250RW51bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwodGhlS2V5cywgZG9udEVudW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhlS2V5cztcbiAgICB9XG59KTtcblxudmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAkT2JqZWN0LmtleXMgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTYWZhcmkgNS4wIGJ1Z1xuICAgIHJldHVybiAkT2JqZWN0LmtleXMoYXJndW1lbnRzKS5sZW5ndGggPT09IDI7XG59KDEsIDIpKTtcbnZhciBrZXlzSGFzQXJndW1lbnRzTGVuZ3RoQnVnID0gJE9iamVjdC5rZXlzICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ0tleXMgPSAkT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCAhPT0gMSB8fCBhcmdLZXlzLmxlbmd0aCAhPT0gMSB8fCBhcmdLZXlzWzBdICE9PSAxO1xufSgxKSk7XG52YXIgb3JpZ2luYWxLZXlzID0gJE9iamVjdC5rZXlzO1xuZGVmaW5lUHJvcGVydGllcygkT2JqZWN0LCB7XG4gICAga2V5czogZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMoYXJyYXlTbGljZShvYmplY3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbn0sICFrZXlzV29ya3NXaXRoQXJndW1lbnRzIHx8IGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcpO1xuXG4vL1xuLy8gRGF0ZVxuLy8gPT09PVxuLy9cblxudmFyIGhhc05lZ2F0aXZlTW9udGhZZWFyQnVnID0gbmV3IERhdGUoLTM1MDk4MjczMjk2MDAyOTIpLmdldFVUQ01vbnRoKCkgIT09IDA7XG52YXIgYU5lZ2F0aXZlVGVzdERhdGUgPSBuZXcgRGF0ZSgtMTUwOTg0MjI4OTYwMDI5Mik7XG52YXIgYVBvc2l0aXZlVGVzdERhdGUgPSBuZXcgRGF0ZSgxNDQ5NjYyNDAwMDAwKTtcbnZhciBoYXNUb1VUQ1N0cmluZ0Zvcm1hdEJ1ZyA9IGFOZWdhdGl2ZVRlc3REYXRlLnRvVVRDU3RyaW5nKCkgIT09ICdNb24sIDAxIEphbiAtNDU4NzUgMTE6NTk6NTkgR01UJztcbnZhciBoYXNUb0RhdGVTdHJpbmdGb3JtYXRCdWc7XG52YXIgaGFzVG9TdHJpbmdGb3JtYXRCdWc7XG52YXIgdGltZVpvbmVPZmZzZXQgPSBhTmVnYXRpdmVUZXN0RGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuaWYgKHRpbWVab25lT2Zmc2V0IDwgLTcyMCkge1xuICAgIGhhc1RvRGF0ZVN0cmluZ0Zvcm1hdEJ1ZyA9IGFOZWdhdGl2ZVRlc3REYXRlLnRvRGF0ZVN0cmluZygpICE9PSAnVHVlIEphbiAwMiAtNDU4NzUnO1xuICAgIGhhc1RvU3RyaW5nRm9ybWF0QnVnID0gISgvXlRodSBEZWMgMTAgMjAxNSBcXGRcXGQ6XFxkXFxkOlxcZFxcZCBHTVRbLVxcK11cXGRcXGRcXGRcXGQoPzogfCQpLykudGVzdChhUG9zaXRpdmVUZXN0RGF0ZS50b1N0cmluZygpKTtcbn0gZWxzZSB7XG4gICAgaGFzVG9EYXRlU3RyaW5nRm9ybWF0QnVnID0gYU5lZ2F0aXZlVGVzdERhdGUudG9EYXRlU3RyaW5nKCkgIT09ICdNb24gSmFuIDAxIC00NTg3NSc7XG4gICAgaGFzVG9TdHJpbmdGb3JtYXRCdWcgPSAhKC9eV2VkIERlYyAwOSAyMDE1IFxcZFxcZDpcXGRcXGQ6XFxkXFxkIEdNVFstXFwrXVxcZFxcZFxcZFxcZCg/OiB8JCkvKS50ZXN0KGFQb3NpdGl2ZVRlc3REYXRlLnRvU3RyaW5nKCkpO1xufVxuXG52YXIgb3JpZ2luYWxHZXRGdWxsWWVhciA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRGdWxsWWVhcik7XG52YXIgb3JpZ2luYWxHZXRNb250aCA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRNb250aCk7XG52YXIgb3JpZ2luYWxHZXREYXRlID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldERhdGUpO1xudmFyIG9yaWdpbmFsR2V0VVRDRnVsbFllYXIgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDRnVsbFllYXIpO1xudmFyIG9yaWdpbmFsR2V0VVRDTW9udGggPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTW9udGgpO1xudmFyIG9yaWdpbmFsR2V0VVRDRGF0ZSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENEYXRlKTtcbnZhciBvcmlnaW5hbEdldFVUQ0RheSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENEYXkpO1xudmFyIG9yaWdpbmFsR2V0VVRDSG91cnMgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDSG91cnMpO1xudmFyIG9yaWdpbmFsR2V0VVRDTWludXRlcyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENNaW51dGVzKTtcbnZhciBvcmlnaW5hbEdldFVUQ1NlY29uZHMgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDU2Vjb25kcyk7XG52YXIgb3JpZ2luYWxHZXRVVENNaWxsaXNlY29uZHMgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDTWlsbGlzZWNvbmRzKTtcbnZhciBkYXlOYW1lID0gWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXTtcbnZhciBtb250aE5hbWUgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107XG52YXIgZGF5c0luTW9udGggPSBmdW5jdGlvbiBkYXlzSW5Nb250aChtb250aCwgeWVhcikge1xuICAgIHJldHVybiBvcmlnaW5hbEdldERhdGUobmV3IERhdGUoeWVhciwgbW9udGgsIDApKTtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICBnZXRGdWxsWWVhcjogZnVuY3Rpb24gZ2V0RnVsbFllYXIoKSB7XG4gICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0RnVsbFllYXIodGhpcyk7XG4gICAgICAgIGlmICh5ZWFyIDwgMCAmJiBvcmlnaW5hbEdldE1vbnRoKHRoaXMpID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiB5ZWFyICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9LFxuICAgIGdldE1vbnRoOiBmdW5jdGlvbiBnZXRNb250aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRNb250aCh0aGlzKTtcbiAgICAgICAgaWYgKHllYXIgPCAwICYmIG1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb250aDtcbiAgICB9LFxuICAgIGdldERhdGU6IGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0RnVsbFllYXIodGhpcyk7XG4gICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0TW9udGgodGhpcyk7XG4gICAgICAgIHZhciBkYXRlID0gb3JpZ2luYWxHZXREYXRlKHRoaXMpO1xuICAgICAgICBpZiAoeWVhciA8IDAgJiYgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgaWYgKG1vbnRoID09PSAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheXMgPSBkYXlzSW5Nb250aCgwLCB5ZWFyICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gKGRheXMgLSBkYXRlKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSxcbiAgICBnZXRVVENGdWxsWWVhcjogZnVuY3Rpb24gZ2V0VVRDRnVsbFllYXIoKSB7XG4gICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgIGlmICh5ZWFyIDwgMCAmJiBvcmlnaW5hbEdldFVUQ01vbnRoKHRoaXMpID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiB5ZWFyICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9LFxuICAgIGdldFVUQ01vbnRoOiBmdW5jdGlvbiBnZXRVVENNb250aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRVVENNb250aCh0aGlzKTtcbiAgICAgICAgaWYgKHllYXIgPCAwICYmIG1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb250aDtcbiAgICB9LFxuICAgIGdldFVUQ0RhdGU6IGZ1bmN0aW9uIGdldFVUQ0RhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgIHZhciBkYXRlID0gb3JpZ2luYWxHZXRVVENEYXRlKHRoaXMpO1xuICAgICAgICBpZiAoeWVhciA8IDAgJiYgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgaWYgKG1vbnRoID09PSAxMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheXMgPSBkYXlzSW5Nb250aCgwLCB5ZWFyICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gKGRheXMgLSBkYXRlKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVNb250aFllYXJCdWcpO1xuXG5kZWZpbmVQcm9wZXJ0aWVzKERhdGUucHJvdG90eXBlLCB7XG4gICAgdG9VVENTdHJpbmc6IGZ1bmN0aW9uIHRvVVRDU3RyaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IG9yaWdpbmFsR2V0VVRDRGF5KHRoaXMpO1xuICAgICAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsR2V0VVRDRGF0ZSh0aGlzKTtcbiAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRVVENNb250aCh0aGlzKTtcbiAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldFVUQ0Z1bGxZZWFyKHRoaXMpO1xuICAgICAgICB2YXIgaG91ciA9IG9yaWdpbmFsR2V0VVRDSG91cnModGhpcyk7XG4gICAgICAgIHZhciBtaW51dGUgPSBvcmlnaW5hbEdldFVUQ01pbnV0ZXModGhpcyk7XG4gICAgICAgIHZhciBzZWNvbmQgPSBvcmlnaW5hbEdldFVUQ1NlY29uZHModGhpcyk7XG4gICAgICAgIHJldHVybiBkYXlOYW1lW2RheV0gKyAnLCAnICtcbiAgICAgICAgICAgIChkYXRlIDwgMTAgPyAnMCcgKyBkYXRlIDogZGF0ZSkgKyAnICcgK1xuICAgICAgICAgICAgbW9udGhOYW1lW21vbnRoXSArICcgJyArXG4gICAgICAgICAgICB5ZWFyICsgJyAnICtcbiAgICAgICAgICAgIChob3VyIDwgMTAgPyAnMCcgKyBob3VyIDogaG91cikgKyAnOicgK1xuICAgICAgICAgICAgKG1pbnV0ZSA8IDEwID8gJzAnICsgbWludXRlIDogbWludXRlKSArICc6JyArXG4gICAgICAgICAgICAoc2Vjb25kIDwgMTAgPyAnMCcgKyBzZWNvbmQgOiBzZWNvbmQpICsgJyBHTVQnO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlTW9udGhZZWFyQnVnIHx8IGhhc1RvVVRDU3RyaW5nRm9ybWF0QnVnKTtcblxuLy8gT3BlcmEgMTIgaGFzIGAsYFxuZGVmaW5lUHJvcGVydGllcyhEYXRlLnByb3RvdHlwZSwge1xuICAgIHRvRGF0ZVN0cmluZzogZnVuY3Rpb24gdG9EYXRlU3RyaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuZ2V0RGF5KCk7XG4gICAgICAgIHZhciBkYXRlID0gdGhpcy5nZXREYXRlKCk7XG4gICAgICAgIHZhciBtb250aCA9IHRoaXMuZ2V0TW9udGgoKTtcbiAgICAgICAgdmFyIHllYXIgPSB0aGlzLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHJldHVybiBkYXlOYW1lW2RheV0gKyAnICcgK1xuICAgICAgICAgICAgbW9udGhOYW1lW21vbnRoXSArICcgJyArXG4gICAgICAgICAgICAoZGF0ZSA8IDEwID8gJzAnICsgZGF0ZSA6IGRhdGUpICsgJyAnICtcbiAgICAgICAgICAgIHllYXI7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVNb250aFllYXJCdWcgfHwgaGFzVG9EYXRlU3RyaW5nRm9ybWF0QnVnKTtcblxuLy8gY2FuJ3QgdXNlIGRlZmluZVByb3BlcnRpZXMgaGVyZSBiZWNhdXNlIG9mIHRvU3RyaW5nIGVudW1lcmF0aW9uIGlzc3VlIGluIElFIDw9IDhcbmlmIChoYXNOZWdhdGl2ZU1vbnRoWWVhckJ1ZyB8fCBoYXNUb1N0cmluZ0Zvcm1hdEJ1Zykge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5nZXREYXkoKTtcbiAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmdldERhdGUoKTtcbiAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5nZXRNb250aCgpO1xuICAgICAgICB2YXIgeWVhciA9IHRoaXMuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgdmFyIGhvdXIgPSB0aGlzLmdldEhvdXJzKCk7XG4gICAgICAgIHZhciBtaW51dGUgPSB0aGlzLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgdmFyIHNlY29uZCA9IHRoaXMuZ2V0U2Vjb25kcygpO1xuICAgICAgICB2YXIgdGltZXpvbmVPZmZzZXQgPSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIHZhciBob3Vyc09mZnNldCA9IE1hdGguZmxvb3IoTWF0aC5hYnModGltZXpvbmVPZmZzZXQpIC8gNjApO1xuICAgICAgICB2YXIgbWludXRlc09mZnNldCA9IE1hdGguZmxvb3IoTWF0aC5hYnModGltZXpvbmVPZmZzZXQpICUgNjApO1xuICAgICAgICByZXR1cm4gZGF5TmFtZVtkYXldICsgJyAnICtcbiAgICAgICAgICAgIG1vbnRoTmFtZVttb250aF0gKyAnICcgK1xuICAgICAgICAgICAgKGRhdGUgPCAxMCA/ICcwJyArIGRhdGUgOiBkYXRlKSArICcgJyArXG4gICAgICAgICAgICB5ZWFyICsgJyAnICtcbiAgICAgICAgICAgIChob3VyIDwgMTAgPyAnMCcgKyBob3VyIDogaG91cikgKyAnOicgK1xuICAgICAgICAgICAgKG1pbnV0ZSA8IDEwID8gJzAnICsgbWludXRlIDogbWludXRlKSArICc6JyArXG4gICAgICAgICAgICAoc2Vjb25kIDwgMTAgPyAnMCcgKyBzZWNvbmQgOiBzZWNvbmQpICsgJyBHTVQnICtcbiAgICAgICAgICAgICh0aW1lem9uZU9mZnNldCA+IDAgPyAnLScgOiAnKycpICtcbiAgICAgICAgICAgIChob3Vyc09mZnNldCA8IDEwID8gJzAnICsgaG91cnNPZmZzZXQgOiBob3Vyc09mZnNldCkgK1xuICAgICAgICAgICAgKG1pbnV0ZXNPZmZzZXQgPCAxMCA/ICcwJyArIG1pbnV0ZXNPZmZzZXQgOiBtaW51dGVzT2Zmc2V0KTtcbiAgICB9O1xuICAgIGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZS5wcm90b3R5cGUsICd0b1N0cmluZycsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vLyBFUzUgMTUuOS41LjQzXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjUuNDNcbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIFN0cmluZyB2YWx1ZSByZXByZXNlbnQgdGhlIGluc3RhbmNlIGluIHRpbWVcbi8vIHJlcHJlc2VudGVkIGJ5IHRoaXMgRGF0ZSBvYmplY3QuIFRoZSBmb3JtYXQgb2YgdGhlIFN0cmluZyBpcyB0aGUgRGF0ZSBUaW1lXG4vLyBzdHJpbmcgZm9ybWF0IGRlZmluZWQgaW4gMTUuOS4xLjE1LiBBbGwgZmllbGRzIGFyZSBwcmVzZW50IGluIHRoZSBTdHJpbmcuXG4vLyBUaGUgdGltZSB6b25lIGlzIGFsd2F5cyBVVEMsIGRlbm90ZWQgYnkgdGhlIHN1ZmZpeCBaLiBJZiB0aGUgdGltZSB2YWx1ZSBvZlxuLy8gdGhpcyBvYmplY3QgaXMgbm90IGEgZmluaXRlIE51bWJlciBhIFJhbmdlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbnZhciBuZWdhdGl2ZURhdGUgPSAtNjIxOTg3NTUyMDAwMDA7XG52YXIgbmVnYXRpdmVZZWFyU3RyaW5nID0gJy0wMDAwMDEnO1xudmFyIGhhc05lZ2F0aXZlRGF0ZUJ1ZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmIG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9JU09TdHJpbmcoKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgPT09IC0xO1xudmFyIGhhc1NhZmFyaTUxRGF0ZUJ1ZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmIG5ldyBEYXRlKC0xKS50b0lTT1N0cmluZygpICE9PSAnMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaJztcblxuZGVmaW5lUHJvcGVydGllcyhEYXRlLnByb3RvdHlwZSwge1xuICAgIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh0aGlzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nIGNhbGxlZCBvbiBub24tZmluaXRlIHZhbHVlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldFVUQ0Z1bGxZZWFyKHRoaXMpO1xuXG4gICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzExMVxuICAgICAgICB5ZWFyICs9IE1hdGguZmxvb3IobW9udGggLyAxMik7XG4gICAgICAgIG1vbnRoID0gKG1vbnRoICUgMTIgKyAxMikgJSAxMjtcblxuICAgICAgICAvLyB0aGUgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQgaXMgc3BlY2lmaWVkIGluIDE1LjkuMS4xNS5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFttb250aCArIDEsIG9yaWdpbmFsR2V0VVRDRGF0ZSh0aGlzKSwgb3JpZ2luYWxHZXRVVENIb3Vycyh0aGlzKSwgb3JpZ2luYWxHZXRVVENNaW51dGVzKHRoaXMpLCBvcmlnaW5hbEdldFVUQ1NlY29uZHModGhpcyldO1xuICAgICAgICB5ZWFyID0gKFxuICAgICAgICAgICAgKHllYXIgPCAwID8gJy0nIDogKHllYXIgPiA5OTk5ID8gJysnIDogJycpKSArXG4gICAgICAgICAgICBzdHJTbGljZSgnMDAwMDAnICsgTWF0aC5hYnMoeWVhciksICgwIDw9IHllYXIgJiYgeWVhciA8PSA5OTk5KSA/IC00IDogLTYpXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAvLyBwYWQgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgdG8gaGF2ZSB0d28gZGlnaXRzLlxuICAgICAgICAgIHJlc3VsdFtpXSA9IHN0clNsaWNlKCcwMCcgKyByZXN1bHRbaV0sIC0yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWQgbWlsbGlzZWNvbmRzIHRvIGhhdmUgdGhyZWUgZGlnaXRzLlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgeWVhciArICctJyArIGFycmF5U2xpY2UocmVzdWx0LCAwLCAyKS5qb2luKCctJykgK1xuICAgICAgICAgICAgJ1QnICsgYXJyYXlTbGljZShyZXN1bHQsIDIpLmpvaW4oJzonKSArICcuJyArXG4gICAgICAgICAgICBzdHJTbGljZSgnMDAwJyArIG9yaWdpbmFsR2V0VVRDTWlsbGlzZWNvbmRzKHRoaXMpLCAtMykgKyAnWidcbiAgICAgICAgKTtcbiAgICB9XG59LCBoYXNOZWdhdGl2ZURhdGVCdWcgfHwgaGFzU2FmYXJpNTFEYXRlQnVnKTtcblxuLy8gRVM1IDE1LjkuNS40NFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS41LjQ0XG4vLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRGF0ZSBvYmplY3QgZm9yIHVzZSBieVxuLy8gSlNPTi5zdHJpbmdpZnkgKDE1LjEyLjMpLlxudmFyIGRhdGVUb0pTT05Jc1N1cHBvcnRlZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIERhdGUucHJvdG90eXBlLnRvSlNPTiAmJlxuICAgICAgICAgICAgbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgbmV3IERhdGUobmVnYXRpdmVEYXRlKS50b0pTT04oKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgIT09IC0xICYmXG4gICAgICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7IC8vIGdlbmVyaWNcbiAgICAgICAgICAgICAgICB0b0lTT1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcbmlmICghZGF0ZVRvSlNPTklzU3VwcG9ydGVkKSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgICAgICAvLyBXaGVuIHRoZSB0b0pTT04gbWV0aG9kIGlzIGNhbGxlZCB3aXRoIGFyZ3VtZW50IGtleSwgdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG5cbiAgICAgICAgLy8gMS4gIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCwgZ2l2aW5nIGl0IHRoZSB0aGlzXG4gICAgICAgIC8vIHZhbHVlIGFzIGl0cyBhcmd1bWVudC5cbiAgICAgICAgLy8gMi4gTGV0IHR2IGJlIEVTLlRvUHJpbWl0aXZlKE8sIGhpbnQgTnVtYmVyKS5cbiAgICAgICAgdmFyIE8gPSAkT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgdHYgPSBFUy5Ub1ByaW1pdGl2ZShPKTtcbiAgICAgICAgLy8gMy4gSWYgdHYgaXMgYSBOdW1iZXIgYW5kIGlzIG5vdCBmaW5pdGUsIHJldHVybiBudWxsLlxuICAgICAgICBpZiAodHlwZW9mIHR2ID09PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUodHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyA0LiBMZXQgdG9JU08gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0dldF1dIGludGVybmFsIG1ldGhvZCBvZlxuICAgICAgICAvLyBPIHdpdGggYXJndW1lbnQgXCJ0b0lTT1N0cmluZ1wiLlxuICAgICAgICB2YXIgdG9JU08gPSBPLnRvSVNPU3RyaW5nO1xuICAgICAgICAvLyA1LiBJZiBJc0NhbGxhYmxlKHRvSVNPKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUodG9JU08pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b0lTT1N0cmluZyBwcm9wZXJ0eSBpcyBub3QgY2FsbGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA2LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2ZcbiAgICAgICAgLy8gIHRvSVNPIHdpdGggTyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmQgYW4gZW1wdHkgYXJndW1lbnQgbGlzdC5cbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoTyk7XG5cbiAgICAgICAgLy8gTk9URSAxIFRoZSBhcmd1bWVudCBpcyBpZ25vcmVkLlxuXG4gICAgICAgIC8vIE5PVEUgMiBUaGUgdG9KU09OIGZ1bmN0aW9uIGlzIGludGVudGlvbmFsbHkgZ2VuZXJpYzsgaXQgZG9lcyBub3RcbiAgICAgICAgLy8gcmVxdWlyZSB0aGF0IGl0cyB0aGlzIHZhbHVlIGJlIGEgRGF0ZSBvYmplY3QuIFRoZXJlZm9yZSwgaXQgY2FuIGJlXG4gICAgICAgIC8vIHRyYW5zZmVycmVkIHRvIG90aGVyIGtpbmRzIG9mIG9iamVjdHMgZm9yIHVzZSBhcyBhIG1ldGhvZC4gSG93ZXZlcixcbiAgICAgICAgLy8gaXQgZG9lcyByZXF1aXJlIHRoYXQgYW55IHN1Y2ggb2JqZWN0IGhhdmUgYSB0b0lTT1N0cmluZyBtZXRob2QuIEFuXG4gICAgICAgIC8vIG9iamVjdCBpcyBmcmVlIHRvIHVzZSB0aGUgYXJndW1lbnQga2V5IHRvIGZpbHRlciBpdHNcbiAgICAgICAgLy8gc3RyaW5naWZpY2F0aW9uLlxuICAgIH07XG59XG5cbi8vIEVTNSAxNS45LjQuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS40LjJcbi8vIGJhc2VkIG9uIHdvcmsgc2hhcmVkIGJ5IERhbmllbCBGcmllc2VuIChkYW50bWFuKVxuLy8gaHR0cDovL2dpc3QuZ2l0aHViLmNvbS8zMDMyNDlcbnZhciBzdXBwb3J0c0V4dGVuZGVkWWVhcnMgPSBEYXRlLnBhcnNlKCcrMDMzNjU4LTA5LTI3VDAxOjQ2OjQwLjAwMFonKSA9PT0gMWUxNTtcbnZhciBhY2NlcHRzSW52YWxpZERhdGVzID0gIWlzTmFOKERhdGUucGFyc2UoJzIwMTItMDQtMDRUMjQ6MDA6MDAuNTAwWicpKSB8fCAhaXNOYU4oRGF0ZS5wYXJzZSgnMjAxMi0xMS0zMVQyMzo1OTo1OS4wMDBaJykpIHx8ICFpc05hTihEYXRlLnBhcnNlKCcyMDEyLTEyLTMxVDIzOjU5OjYwLjAwMFonKSk7XG52YXIgZG9lc05vdFBhcnNlWTJLTmV3WWVhciA9IGlzTmFOKERhdGUucGFyc2UoJzIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWicpKTtcbmlmIChkb2VzTm90UGFyc2VZMktOZXdZZWFyIHx8IGFjY2VwdHNJbnZhbGlkRGF0ZXMgfHwgIXN1cHBvcnRzRXh0ZW5kZWRZZWFycykge1xuICAgIC8vIFhYWCBnbG9iYWwgYXNzaWdubWVudCB3b24ndCB3b3JrIGluIGVtYmVkZGluZ3MgdGhhdCB1c2VcbiAgICAvLyBhbiBhbHRlcm5hdGUgb2JqZWN0IGZvciB0aGUgY29udGV4dC5cbiAgICAvKiBnbG9iYWwgRGF0ZTogdHJ1ZSAqL1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgdmFyIG1heFNhZmVVbnNpZ25lZDMyQml0ID0gTWF0aC5wb3coMiwgMzEpIC0gMTtcbiAgICB2YXIgaGFzU2FmYXJpU2lnbmVkSW50QnVnID0gaXNBY3R1YWxOYU4obmV3IERhdGUoMTk3MCwgMCwgMSwgMCwgMCwgMCwgbWF4U2FmZVVuc2lnbmVkMzJCaXQgKyAxKS5nZXRUaW1lKCkpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWltcGxpY2l0LWdsb2JhbHMgKi9cbiAgICBEYXRlID0gKGZ1bmN0aW9uIChOYXRpdmVEYXRlKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1pbXBsaWNpdC1nbG9iYWxzICovXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuICAgICAgICAvLyBEYXRlLmxlbmd0aCA9PT0gN1xuICAgICAgICB2YXIgRGF0ZVNoaW0gPSBmdW5jdGlvbiBEYXRlKFksIE0sIEQsIGgsIG0sIHMsIG1zKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkYXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBOYXRpdmVEYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBzO1xuICAgICAgICAgICAgICAgIHZhciBtaWxsaXMgPSBtcztcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2FmYXJpU2lnbmVkSW50QnVnICYmIGxlbmd0aCA+PSA3ICYmIG1zID4gbWF4U2FmZVVuc2lnbmVkMzJCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc1RvU2hpZnQgPSBNYXRoLmZsb29yKG1zIC8gbWF4U2FmZVVuc2lnbmVkMzJCaXQpICogbWF4U2FmZVVuc2lnbmVkMzJCaXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzVG9TaGlmdCA9IE1hdGguZmxvb3IobXNUb1NoaWZ0IC8gMWUzKTtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgbWlsbGlzIC09IHNUb1NoaWZ0ICogMWUzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRlID0gbGVuZ3RoID09PSAxICYmICRTdHJpbmcoWSkgPT09IFkgPyAvLyBpc1N0cmluZyhZKVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBleHBsaWNpdGx5IHBhc3MgaXQgdGhyb3VnaCBwYXJzZTpcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5hdGl2ZURhdGUoRGF0ZVNoaW0ucGFyc2UoWSkpIDpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBtYW51YWxseSBtYWtlIGNhbGxzIGRlcGVuZGluZyBvbiBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggaGVyZVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNyA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0sIHNlY29uZHMsIG1pbGxpcykgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNiA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0sIHNlY29uZHMpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDUgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA0ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCkgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gMyA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDIgPyBuZXcgTmF0aXZlRGF0ZShZLCBNKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSAxID8gbmV3IE5hdGl2ZURhdGUoWSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOYXRpdmVEYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBOYXRpdmVEYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUHJpbWl0aXZlKGRhdGUpKSB7XG4gICAgICAgICAgICAgIC8vIFByZXZlbnQgbWl4dXBzIHdpdGggdW5maXhlZCBEYXRlIG9iamVjdFxuICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKGRhdGUsIHsgY29uc3RydWN0b3I6IERhdGVTaGltIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuOS4xLjE1IERhdGUgVGltZSBTdHJpbmcgRm9ybWF0LlxuICAgICAgICB2YXIgaXNvRGF0ZUV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKCdeJyArXG4gICAgICAgICAgICAnKFxcXFxkezR9fFsrLV1cXFxcZHs2fSknICsgLy8gZm91ci1kaWdpdCB5ZWFyIGNhcHR1cmUgb3Igc2lnbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDYtZGlnaXQgZXh0ZW5kZWQgeWVhclxuICAgICAgICAgICAgJyg/Oi0oXFxcXGR7Mn0pJyArIC8vIG9wdGlvbmFsIG1vbnRoIGNhcHR1cmVcbiAgICAgICAgICAgICcoPzotKFxcXFxkezJ9KScgKyAvLyBvcHRpb25hbCBkYXkgY2FwdHVyZVxuICAgICAgICAgICAgJyg/OicgKyAvLyBjYXB0dXJlIGhvdXJzOm1pbnV0ZXM6c2Vjb25kcy5taWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICAnVChcXFxcZHsyfSknICsgLy8gaG91cnMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICc6KFxcXFxkezJ9KScgKyAvLyBtaW51dGVzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9wdGlvbmFsIDpzZWNvbmRzLm1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gc2Vjb25kcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICcoPzooXFxcXC5cXFxcZHsxLH0pKT8nICsgLy8gbWlsbGlzZWNvbmRzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKT8nICtcbiAgICAgICAgICAgICcoJyArIC8vIGNhcHR1cmUgVVRDIG9mZnNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAnWnwnICsgLy8gVVRDIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9mZnNldCBzcGVjaWZpZXIgKy8taG91cnM6bWludXRlc1xuICAgICAgICAgICAgICAgICAgICAnKFstK10pJyArIC8vIHNpZ24gY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKFxcXFxkezJ9KScgKyAvLyBob3VycyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gbWludXRlcyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgICcpJyArXG4gICAgICAgICAgICAnKT8pPyk/KT8nICtcbiAgICAgICAgJyQnKTtcblxuICAgICAgICB2YXIgbW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0LCAzNjVdO1xuXG4gICAgICAgIHZhciBkYXlGcm9tTW9udGggPSBmdW5jdGlvbiBkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gbW9udGggPiAxID8gMSA6IDA7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIG1vbnRoc1ttb250aF0gK1xuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxOTY5ICsgdCkgLyA0KSAtXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcigoeWVhciAtIDE5MDEgKyB0KSAvIDEwMCkgK1xuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxNjAxICsgdCkgLyA0MDApICtcbiAgICAgICAgICAgICAgICAzNjUgKiAoeWVhciAtIDE5NzApXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0b1VUQyA9IGZ1bmN0aW9uIHRvVVRDKHQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgICAgIHZhciBtcyA9IHQ7XG4gICAgICAgICAgICBpZiAoaGFzU2FmYXJpU2lnbmVkSW50QnVnICYmIG1zID4gbWF4U2FmZVVuc2lnbmVkMzJCaXQpIHtcbiAgICAgICAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBhIFNhZmFyaSA4LzkgYnVnIHdoZXJlIGl0IHRyZWF0cyB0aGUgc2Vjb25kcyBhcyBzaWduZWRcbiAgICAgICAgICAgICAgICB2YXIgbXNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtcyAvIG1heFNhZmVVbnNpZ25lZDMyQml0KSAqIG1heFNhZmVVbnNpZ25lZDMyQml0O1xuICAgICAgICAgICAgICAgIHZhciBzVG9TaGlmdCA9IE1hdGguZmxvb3IobXNUb1NoaWZ0IC8gMWUzKTtcbiAgICAgICAgICAgICAgICBzICs9IHNUb1NoaWZ0O1xuICAgICAgICAgICAgICAgIG1zIC09IHNUb1NoaWZ0ICogMWUzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICROdW1iZXIobmV3IE5hdGl2ZURhdGUoMTk3MCwgMCwgMSwgMCwgMCwgcywgbXMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDb3B5IGFueSBjdXN0b20gbWV0aG9kcyBhIDNyZCBwYXJ0eSBsaWJyYXJ5IG1heSBoYXZlIGFkZGVkXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBOYXRpdmVEYXRlKSB7XG4gICAgICAgICAgICBpZiAob3ducyhOYXRpdmVEYXRlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgRGF0ZVNoaW1ba2V5XSA9IE5hdGl2ZURhdGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvcHkgXCJuYXRpdmVcIiBtZXRob2RzIGV4cGxpY2l0bHk7IHRoZXkgbWF5IGJlIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZVNoaW0sIHtcbiAgICAgICAgICAgIG5vdzogTmF0aXZlRGF0ZS5ub3csXG4gICAgICAgICAgICBVVEM6IE5hdGl2ZURhdGUuVVRDXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBEYXRlU2hpbS5wcm90b3R5cGUgPSBOYXRpdmVEYXRlLnByb3RvdHlwZTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBEYXRlU2hpbVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICAvLyBVcGdyYWRlIERhdGUucGFyc2UgdG8gaGFuZGxlIHNpbXBsaWZpZWQgSVNPIDg2MDEgc3RyaW5nc1xuICAgICAgICB2YXIgcGFyc2VTaGltID0gZnVuY3Rpb24gcGFyc2Uoc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBpc29EYXRlRXhwcmVzc2lvbi5leGVjKHN0cmluZyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSBtb250aHMsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgLy8gcHJvdmlkZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgVVRDIG9mZnNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB2YXIgeWVhciA9ICROdW1iZXIobWF0Y2hbMV0pLFxuICAgICAgICAgICAgICAgICAgICBtb250aCA9ICROdW1iZXIobWF0Y2hbMl0gfHwgMSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBkYXkgPSAkTnVtYmVyKG1hdGNoWzNdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgaG91ciA9ICROdW1iZXIobWF0Y2hbNF0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZSA9ICROdW1iZXIobWF0Y2hbNV0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZCA9ICROdW1iZXIobWF0Y2hbNl0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gTWF0aC5mbG9vcigkTnVtYmVyKG1hdGNoWzddIHx8IDApICogMTAwMCksXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGltZSB6b25lIGlzIG1pc3NlZCwgbG9jYWwgb2Zmc2V0IHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIChFUyA1LjEgYnVnKVxuICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9idWdzLmVjbWFzY3JpcHQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTJcbiAgICAgICAgICAgICAgICAgICAgaXNMb2NhbFRpbWUgPSBCb29sZWFuKG1hdGNoWzRdICYmICFtYXRjaFs4XSksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25PZmZzZXQgPSBtYXRjaFs5XSA9PT0gJy0nID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICBob3VyT2Zmc2V0ID0gJE51bWJlcihtYXRjaFsxMF0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZU9mZnNldCA9ICROdW1iZXIobWF0Y2hbMTFdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIGhhc01pbnV0ZXNPclNlY29uZHNPck1pbGxpc2Vjb25kcyA9IG1pbnV0ZSA+IDAgfHwgc2Vjb25kID4gMCB8fCBtaWxsaXNlY29uZCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBob3VyIDwgKGhhc01pbnV0ZXNPclNlY29uZHNPck1pbGxpc2Vjb25kcyA/IDI0IDogMjUpICYmXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZSA8IDYwICYmIHNlY29uZCA8IDYwICYmIG1pbGxpc2Vjb25kIDwgMTAwMCAmJlxuICAgICAgICAgICAgICAgICAgICBtb250aCA+IC0xICYmIG1vbnRoIDwgMTIgJiYgaG91ck9mZnNldCA8IDI0ICYmXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZU9mZnNldCA8IDYwICYmIC8vIGRldGVjdCBpbnZhbGlkIG9mZnNldHNcbiAgICAgICAgICAgICAgICAgICAgZGF5ID4gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF5IDwgKGRheUZyb21Nb250aCh5ZWFyLCBtb250aCArIDEpIC0gZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkgKyBkYXkpICogMjQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaG91ciArXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VyT2Zmc2V0ICogc2lnbk9mZnNldFxuICAgICAgICAgICAgICAgICAgICApICogNjA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQgKyBtaW51dGUgKyBtaW51dGVPZmZzZXQgKiBzaWduT2Zmc2V0KSAqIDYwICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFxuICAgICAgICAgICAgICAgICAgICApICogMTAwMCArIG1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvVVRDKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKC04LjY0ZTE1IDw9IHJlc3VsdCAmJiByZXN1bHQgPD0gOC42NGUxNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5hdGl2ZURhdGUucGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbSwgeyBwYXJzZTogcGFyc2VTaGltIH0pO1xuXG4gICAgICAgIHJldHVybiBEYXRlU2hpbTtcbiAgICB9KERhdGUpKTtcbiAgICAvKiBnbG9iYWwgRGF0ZTogZmFsc2UgKi9cbn1cblxuLy8gRVM1IDE1LjkuNC40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuNFxuaWYgKCFEYXRlLm5vdykge1xuICAgIERhdGUubm93ID0gZnVuY3Rpb24gbm93KCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbn1cblxuLy9cbi8vIE51bWJlclxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUuMSAxNS43LjQuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNy40LjVcbnZhciBoYXNUb0ZpeGVkQnVncyA9IE51bWJlclByb3RvdHlwZS50b0ZpeGVkICYmIChcbiAgKDAuMDAwMDgpLnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHxcbiAgKDAuOSkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gICgxLjI1NSkudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gICgxMDAwMDAwMDAwMDAwMDAwMTI4KS50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbik7XG5cbnZhciB0b0ZpeGVkSGVscGVycyA9IHtcbiAgYmFzZTogMWU3LFxuICBzaXplOiA2LFxuICBkYXRhOiBbMCwgMCwgMCwgMCwgMCwgMF0sXG4gIG11bHRpcGx5OiBmdW5jdGlvbiBtdWx0aXBseShuLCBjKSB7XG4gICAgICB2YXIgaSA9IC0xO1xuICAgICAgdmFyIGMyID0gYztcbiAgICAgIHdoaWxlICgrK2kgPCB0b0ZpeGVkSGVscGVycy5zaXplKSB7XG4gICAgICAgICAgYzIgKz0gbiAqIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV07XG4gICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGF0YVtpXSA9IGMyICUgdG9GaXhlZEhlbHBlcnMuYmFzZTtcbiAgICAgICAgICBjMiA9IE1hdGguZmxvb3IoYzIgLyB0b0ZpeGVkSGVscGVycy5iYXNlKTtcbiAgICAgIH1cbiAgfSxcbiAgZGl2aWRlOiBmdW5jdGlvbiBkaXZpZGUobikge1xuICAgICAgdmFyIGkgPSB0b0ZpeGVkSGVscGVycy5zaXplO1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgYyArPSB0b0ZpeGVkSGVscGVycy5kYXRhW2ldO1xuICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gPSBNYXRoLmZsb29yKGMgLyBuKTtcbiAgICAgICAgICBjID0gKGMgJSBuKSAqIHRvRml4ZWRIZWxwZXJzLmJhc2U7XG4gICAgICB9XG4gIH0sXG4gIG51bVRvU3RyaW5nOiBmdW5jdGlvbiBudW1Ub1N0cmluZygpIHtcbiAgICAgIHZhciBpID0gdG9GaXhlZEhlbHBlcnMuc2l6ZTtcbiAgICAgIHZhciBzID0gJyc7XG4gICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCB0b0ZpeGVkSGVscGVycy5kYXRhW2ldICE9PSAwKSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gJFN0cmluZyh0b0ZpeGVkSGVscGVycy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgaWYgKHMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBzID0gdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMgKz0gc3RyU2xpY2UoJzAwMDAwMDAnLCAwLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICB9LFxuICBwb3c6IGZ1bmN0aW9uIHBvdyh4LCBuLCBhY2MpIHtcbiAgICAgIHJldHVybiAobiA9PT0gMCA/IGFjYyA6IChuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpKSk7XG4gIH0sXG4gIGxvZzogZnVuY3Rpb24gbG9nKHgpIHtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIHZhciB4MiA9IHg7XG4gICAgICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgICAgICAgIG4gKz0gMTI7XG4gICAgICAgICAgeDIgLz0gNDA5NjtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgICAgICAgbiArPSAxO1xuICAgICAgICAgIHgyIC89IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgfVxufTtcblxudmFyIHRvRml4ZWRTaGltID0gZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgIHZhciBmLCB4LCBzLCBtLCBlLCB6LCBqLCBrO1xuXG4gICAgLy8gVGVzdCBmb3IgTmFOIGFuZCByb3VuZCBmcmFjdGlvbkRpZ2l0cyBkb3duXG4gICAgZiA9ICROdW1iZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgIGYgPSBpc0FjdHVhbE5hTihmKSA/IDAgOiBNYXRoLmZsb29yKGYpO1xuXG4gICAgaWYgKGYgPCAwIHx8IGYgPiAyMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTnVtYmVyLnRvRml4ZWQgY2FsbGVkIHdpdGggaW52YWxpZCBudW1iZXIgb2YgZGVjaW1hbHMnKTtcbiAgICB9XG5cbiAgICB4ID0gJE51bWJlcih0aGlzKTtcblxuICAgIGlmIChpc0FjdHVhbE5hTih4KSkge1xuICAgICAgICByZXR1cm4gJ05hTic7XG4gICAgfVxuXG4gICAgLy8gSWYgaXQgaXMgdG9vIGJpZyBvciBzbWFsbCwgcmV0dXJuIHRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIG51bWJlclxuICAgIGlmICh4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSkge1xuICAgICAgICByZXR1cm4gJFN0cmluZyh4KTtcbiAgICB9XG5cbiAgICBzID0gJyc7XG5cbiAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgcyA9ICctJztcbiAgICAgICAgeCA9IC14O1xuICAgIH1cblxuICAgIG0gPSAnMCc7XG5cbiAgICBpZiAoeCA+IDFlLTIxKSB7XG4gICAgICAgIC8vIDFlLTIxIDwgeCA8IDFlMjFcbiAgICAgICAgLy8gLTcwIDwgbG9nMih4KSA8IDcwXG4gICAgICAgIGUgPSB0b0ZpeGVkSGVscGVycy5sb2coeCAqIHRvRml4ZWRIZWxwZXJzLnBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICAgIHogPSAoZSA8IDAgPyB4ICogdG9GaXhlZEhlbHBlcnMucG93KDIsIC1lLCAxKSA6IHggLyB0b0ZpeGVkSGVscGVycy5wb3coMiwgZSwgMSkpO1xuICAgICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7IC8vIE1hdGgucG93KDIsIDUyKTtcbiAgICAgICAgZSA9IDUyIC0gZTtcblxuICAgICAgICAvLyAtMTggPCBlIDwgMTIyXG4gICAgICAgIC8vIHggPSB6IC8gMiBeIGVcbiAgICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgwLCB6KTtcbiAgICAgICAgICAgIGogPSBmO1xuXG4gICAgICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICAgICAgICBqIC09IDc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KHRvRml4ZWRIZWxwZXJzLnBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICAgICAgaiA9IGUgLSAxO1xuXG4gICAgICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICAgICAgICBqIC09IDIzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDEsIDEpO1xuICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDIpO1xuICAgICAgICAgICAgbSA9IHRvRml4ZWRIZWxwZXJzLm51bVRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgwLCB6KTtcbiAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDEgPDwgKC1lKSwgMCk7XG4gICAgICAgICAgICBtID0gdG9GaXhlZEhlbHBlcnMubnVtVG9TdHJpbmcoKSArIHN0clNsaWNlKCcwLjAwMDAwMDAwMDAwMDAwMDAwMDAwJywgMiwgMiArIGYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGYgPiAwKSB7XG4gICAgICAgIGsgPSBtLmxlbmd0aDtcblxuICAgICAgICBpZiAoayA8PSBmKSB7XG4gICAgICAgICAgICBtID0gcyArIHN0clNsaWNlKCcwLjAwMDAwMDAwMDAwMDAwMDAwMDAnLCAwLCBmIC0gayArIDIpICsgbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0gPSBzICsgc3RyU2xpY2UobSwgMCwgayAtIGYpICsgJy4nICsgc3RyU2xpY2UobSwgayAtIGYpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IHMgKyBtO1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufTtcbmRlZmluZVByb3BlcnRpZXMoTnVtYmVyUHJvdG90eXBlLCB7IHRvRml4ZWQ6IHRvRml4ZWRTaGltIH0sIGhhc1RvRml4ZWRCdWdzKTtcblxudmFyIGhhc1RvUHJlY2lzaW9uVW5kZWZpbmVkQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gMS4wLnRvUHJlY2lzaW9uKHVuZGVmaW5lZCkgPT09ICcxJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0oKSk7XG52YXIgb3JpZ2luYWxUb1ByZWNpc2lvbiA9IE51bWJlclByb3RvdHlwZS50b1ByZWNpc2lvbjtcbmRlZmluZVByb3BlcnRpZXMoTnVtYmVyUHJvdG90eXBlLCB7XG4gICAgdG9QcmVjaXNpb246IGZ1bmN0aW9uIHRvUHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByZWNpc2lvbiA9PT0gJ3VuZGVmaW5lZCcgPyBvcmlnaW5hbFRvUHJlY2lzaW9uLmNhbGwodGhpcykgOiBvcmlnaW5hbFRvUHJlY2lzaW9uLmNhbGwodGhpcywgcHJlY2lzaW9uKTtcbiAgICB9XG59LCBoYXNUb1ByZWNpc2lvblVuZGVmaW5lZEJ1Zyk7XG5cbi8vXG4vLyBTdHJpbmdcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDE1LjUuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbi8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4vLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbmlmIChcbiAgICAnYWInLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9PSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPT0gNCB8fFxuICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPT0gNCB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aCB8fFxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcbikge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IHR5cGVvZiAoLygpPz8vKS5leGVjKCcnKVsxXSA9PT0gJ3VuZGVmaW5lZCc7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgIHZhciBtYXhTYWZlMzJCaXRJbnQgPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICAgICAgaWYgKCFpc1JlZ2V4KHNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyU3BsaXQodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgKyAvLyBpbiBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrIGFuZCBFUzZcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvckNvcHkuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBtYXhTYWZlMzJCaXRJbnRcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBzcGxpdExpbWl0ID0gdHlwZW9mIGxpbWl0ID09PSAndW5kZWZpbmVkJyA/IG1heFNhZmUzMkJpdEludCA6IEVTLlRvVWludDMyKGxpbWl0KTtcbiAgICAgICAgICAgIG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZyk7XG4gICAgICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwob3V0cHV0LCBzdHJTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlfcHVzaC5hcHBseShvdXRwdXQsIGFycmF5U2xpY2UobWF0Y2gsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBzcGxpdExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yQ29weS5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwob3V0cHV0LCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoQ2FsbChvdXRwdXQsIHN0clNsaWNlKHN0cmluZywgbGFzdExhc3RJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBzcGxpdExpbWl0ID8gYXJyYXlTbGljZShvdXRwdXQsIDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyAmJiBsaW1pdCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIHN0clNwbGl0KHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG59XG5cbnZhciBzdHJfcmVwbGFjZSA9IFN0cmluZ1Byb3RvdHlwZS5yZXBsYWNlO1xudmFyIHJlcGxhY2VSZXBvcnRzR3JvdXBzQ29ycmVjdGx5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtYXRjaCwgZ3JvdXApIHtcbiAgICAgICAgcHVzaENhbGwoZ3JvdXBzLCBncm91cCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdyb3Vwcy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGdyb3Vwc1swXSA9PT0gJ3VuZGVmaW5lZCc7XG59KCkpO1xuXG5pZiAoIXJlcGxhY2VSZXBvcnRzR3JvdXBzQ29ycmVjdGx5KSB7XG4gICAgU3RyaW5nUHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgdmFyIGlzRm4gPSBpc0NhbGxhYmxlKHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIHZhciBoYXNDYXB0dXJpbmdHcm91cHMgPSBpc1JlZ2V4KHNlYXJjaFZhbHVlKSAmJiAoL1xcKVsqP10vKS50ZXN0KHNlYXJjaFZhbHVlLnNvdXJjZSk7XG4gICAgICAgIGlmICghaXNGbiB8fCAhaGFzQ2FwdHVyaW5nR3JvdXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyX3JlcGxhY2UuY2FsbCh0aGlzLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkUmVwbGFjZVZhbHVlID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsTGFzdEluZGV4ID0gc2VhcmNoVmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBzZWFyY2hWYWx1ZS5leGVjKG1hdGNoKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBzZWFyY2hWYWx1ZS5sYXN0SW5kZXggPSBvcmlnaW5hbExhc3RJbmRleDtcbiAgICAgICAgICAgICAgICBwdXNoQ2FsbChhcmdzLCBhcmd1bWVudHNbbGVuZ3RoIC0gMl0sIGFyZ3VtZW50c1tsZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VWYWx1ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc3RyX3JlcGxhY2UuY2FsbCh0aGlzLCBzZWFyY2hWYWx1ZSwgd3JhcHBlZFJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxudmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xudmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkU3RhcnQgPSBzdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZFN0YXJ0ID0gbWF4KHRoaXMubGVuZ3RoICsgc3RhcnQsIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwodGhpcywgbm9ybWFsaXplZFN0YXJ0LCBsZW5ndGgpO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcblxuLy8gRVM1IDE1LjUuNC4yMFxuLy8gd2hpdGVzcGFjZSBmcm9tOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjUuNC4yMFxudmFyIHdzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4JyArXG4gICAgJ1xcdTIwMjlcXHVGRUZGJztcbnZhciB6ZXJvV2lkdGggPSAnXFx1MjAwYic7XG52YXIgd3NSZWdleENoYXJzID0gJ1snICsgd3MgKyAnXSc7XG52YXIgdHJpbUJlZ2luUmVnZXhwID0gbmV3IFJlZ0V4cCgnXicgKyB3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKicpO1xudmFyIHRyaW1FbmRSZWdleHAgPSBuZXcgUmVnRXhwKHdzUmVnZXhDaGFycyArIHdzUmVnZXhDaGFycyArICcqJCcpO1xudmFyIGhhc1RyaW1XaGl0ZXNwYWNlQnVnID0gU3RyaW5nUHJvdG90eXBlLnRyaW0gJiYgKHdzLnRyaW0oKSB8fCAhemVyb1dpZHRoLnRyaW0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIC8vIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9mYXN0ZXItdHJpbS1qYXZhc2NyaXB0XG4gICAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vd2hpdGVzcGFjZS1kZXZpYXRpb25zL1xuICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJFN0cmluZyh0aGlzKS5yZXBsYWNlKHRyaW1CZWdpblJlZ2V4cCwgJycpLnJlcGxhY2UodHJpbUVuZFJlZ2V4cCwgJycpO1xuICAgIH1cbn0sIGhhc1RyaW1XaGl0ZXNwYWNlQnVnKTtcbnZhciB0cmltID0gY2FsbC5iaW5kKFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG5cbnZhciBoYXNMYXN0SW5kZXhCdWcgPSBTdHJpbmdQcm90b3R5cGUubGFzdEluZGV4T2YgJiYgJ2FiY+OBguOBhCcubGFzdEluZGV4T2YoJ+OBguOBhCcsIDIpICE9PSAtMTtcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFN0cmluZykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFMgPSAkU3RyaW5nKHRoaXMpO1xuICAgICAgICB2YXIgc2VhcmNoU3RyID0gJFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgICAgICB2YXIgbnVtUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAkTnVtYmVyKGFyZ3VtZW50c1sxXSkgOiBOYU47XG4gICAgICAgIHZhciBwb3MgPSBpc0FjdHVhbE5hTihudW1Qb3MpID8gSW5maW5pdHkgOiBFUy5Ub0ludGVnZXIobnVtUG9zKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbWluKG1heChwb3MsIDApLCBTLmxlbmd0aCk7XG4gICAgICAgIHZhciBzZWFyY2hMZW4gPSBzZWFyY2hTdHIubGVuZ3RoO1xuICAgICAgICB2YXIgayA9IHN0YXJ0ICsgc2VhcmNoTGVuO1xuICAgICAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgICAgICAgIGsgPSBtYXgoMCwgayAtIHNlYXJjaExlbik7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzdHJJbmRleE9mKHN0clNsaWNlKFMsIGssIHN0YXJ0ICsgc2VhcmNoTGVuKSwgc2VhcmNoU3RyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gayArIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNMYXN0SW5kZXhCdWcpO1xuXG52YXIgb3JpZ2luYWxMYXN0SW5kZXhPZiA9IFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZjtcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFN0cmluZykge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxMYXN0SW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbn0sIFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZi5sZW5ndGggIT09IDEpO1xuXG4vLyBFUy01IDE1LjEuMi4yXG4vKiBlc2xpbnQtZGlzYWJsZSByYWRpeCAqL1xuaWYgKHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMikge1xuLyogZXNsaW50LWVuYWJsZSByYWRpeCAqL1xuICAgIC8qIGdsb2JhbCBwYXJzZUludDogdHJ1ZSAqL1xuICAgIHBhcnNlSW50ID0gKGZ1bmN0aW9uIChvcmlnUGFyc2VJbnQpIHtcbiAgICAgICAgdmFyIGhleFJlZ2V4ID0gL15bXFwtK10/MFt4WF0vO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRyaW0oc3RyKTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0ZWRSYWRpeCA9ICROdW1iZXIocmFkaXgpIHx8IChoZXhSZWdleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnUGFyc2VJbnQoc3RyaW5nLCBkZWZhdWx0ZWRSYWRpeCk7XG4gICAgICAgIH07XG4gICAgfShwYXJzZUludCkpO1xufVxuXG4vLyBodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuM1xuaWYgKDEgLyBwYXJzZUZsb2F0KCctMCcpICE9PSAtSW5maW5pdHkpIHtcbiAgICAvKiBnbG9iYWwgcGFyc2VGbG9hdDogdHJ1ZSAqL1xuICAgIHBhcnNlRmxvYXQgPSAoZnVuY3Rpb24gKG9yaWdQYXJzZUZsb2F0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RyaW5nID0gdHJpbShzdHJpbmcpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9yaWdQYXJzZUZsb2F0KGlucHV0U3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyU2xpY2UoaW5wdXRTdHJpbmcsIDAsIDEpID09PSAnLScgPyAtMCA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9KHBhcnNlRmxvYXQpKTtcbn1cblxuaWYgKFN0cmluZyhuZXcgUmFuZ2VFcnJvcigndGVzdCcpKSAhPT0gJ1JhbmdlRXJyb3I6IHRlc3QnKSB7XG4gICAgdmFyIGVycm9yVG9TdHJpbmdTaGltID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbmFtZSA9ICdFcnJvcic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lID0gJFN0cmluZyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXNnID0gdGhpcy5tZXNzYWdlO1xuICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1zZyA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtc2cgPSAkU3RyaW5nKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbXNnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZSArICc6ICcgKyBtc2c7XG4gICAgfTtcbiAgICAvLyBjYW4ndCB1c2UgZGVmaW5lUHJvcGVydGllcyBoZXJlIGJlY2F1c2Ugb2YgdG9TdHJpbmcgZW51bWVyYXRpb24gaXNzdWUgaW4gSUUgPD0gOFxuICAgIEVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGVycm9yVG9TdHJpbmdTaGltO1xufVxuXG5pZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgIHZhciBlbnN1cmVOb25FbnVtZXJhYmxlID0gZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuICAgICAgICBpZiAoaXNFbnVtKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICdtZXNzYWdlJyk7XG4gICAgaWYgKEVycm9yLnByb3RvdHlwZS5tZXNzYWdlICE9PSAnJykge1xuICAgICAgRXJyb3IucHJvdG90eXBlLm1lc3NhZ2UgPSAnJztcbiAgICB9XG4gICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICduYW1lJyk7XG59XG5cbmlmIChTdHJpbmcoL2EvbWlnKSAhPT0gJy9hL2dpbScpIHtcbiAgICB2YXIgcmVnZXhUb1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICB2YXIgc3RyID0gJy8nICsgdGhpcy5zb3VyY2UgKyAnLyc7XG4gICAgICAgIGlmICh0aGlzLmdsb2JhbCkge1xuICAgICAgICAgICAgc3RyICs9ICdnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ2knO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm11bHRpbGluZSkge1xuICAgICAgICAgICAgc3RyICs9ICdtJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgLy8gY2FuJ3QgdXNlIGRlZmluZVByb3BlcnRpZXMgaGVyZSBiZWNhdXNlIG9mIHRvU3RyaW5nIGVudW1lcmF0aW9uIGlzc3VlIGluIElFIDw9IDhcbiAgICBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nID0gcmVnZXhUb1N0cmluZztcbn1cblxufSkpO1xuIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pha2VhcmNoaWJhbGQvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4wLjJcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc01heWJlVGhlbmFibGUoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheSkge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5ID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm47XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuXSA9IGNhbGxiYWNrO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKyAxXSA9IGFyZztcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKz0gMjtcbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID09PSAyKSB7XG4gICAgICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAgICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAgICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgICAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0QXNhcChhc2FwRm4pIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwID0gYXNhcEZuO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgfHwge307XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbiAgICAvLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBub2RlXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCkge1xuICAgICAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB2ZXJ0eFxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcihsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB3ZWIgd29ya2VyXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2goKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW47IGkrPTIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldO1xuICAgICAgICB2YXIgYXJnID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2krMV07XG5cbiAgICAgICAgY2FsbGJhY2soYXJnKTtcblxuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnR4KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHIgPSByZXF1aXJlO1xuICAgICAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoO1xuICAgIC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG4gICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc05vZGUpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc1dvcmtlcikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCgpIHt9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAgID0gdm9pZCAwO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQgPSAxO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCAgPSAyO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SID0gbmV3IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzZWxmRnVsZmlsbG1lbnQoKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkY2Fubm90UmV0dXJuT3duKCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKHByb21pc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW47XG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB0aGVuYWJsZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICAgICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gICAgICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSkge1xuICAgICAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGhlbiA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4obWF5YmVUaGVuYWJsZSk7XG5cbiAgICAgICAgaWYgKHRoZW4gPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzZWxmRnVsZmlsbG1lbnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQ7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaCwgcHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRDtcbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIGxlbmd0aCA9IHN1YnNjcmliZXJzLmxlbmd0aDtcblxuICAgICAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRF0gID0gb25SZWplY3Rpb247XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSkge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gICAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdmFyIGhhc0NhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgICAgICB2YWx1ZSwgZXJyb3IsIHN1Y2NlZWRlZCwgZmFpbGVkO1xuXG4gICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgdmFsdWUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGV0YWlsO1xuICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgICAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKXtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICBlbnVtZXJhdG9yLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgICBlbnVtZXJhdG9yLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmIChlbnVtZXJhdG9yLl92YWxpZGF0ZUlucHV0KGlucHV0KSkge1xuICAgICAgICBlbnVtZXJhdG9yLl9pbnB1dCAgICAgPSBpbnB1dDtcbiAgICAgICAgZW51bWVyYXRvci5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBlbnVtZXJhdG9yLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgICAgZW51bWVyYXRvci5faW5pdCgpO1xuXG4gICAgICAgIGlmIChlbnVtZXJhdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwoZW51bWVyYXRvci5wcm9taXNlLCBlbnVtZXJhdG9yLl9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudW1lcmF0b3IubGVuZ3RoID0gZW51bWVyYXRvci5sZW5ndGggfHwgMDtcbiAgICAgICAgICBlbnVtZXJhdG9yLl9lbnVtZXJhdGUoKTtcbiAgICAgICAgICBpZiAoZW51bWVyYXRvci5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKGVudW1lcmF0b3IucHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChlbnVtZXJhdG9yLnByb21pc2UsIGVudW1lcmF0b3IuX3ZhbGlkYXRpb25FcnJvcigpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlSW5wdXQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShpbnB1dCk7XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvcjtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIHZhciBsZW5ndGggID0gZW51bWVyYXRvci5sZW5ndGg7XG4gICAgICB2YXIgcHJvbWlzZSA9IGVudW1lcmF0b3IucHJvbWlzZTtcbiAgICAgIHZhciBpbnB1dCAgID0gZW51bWVyYXRvci5faW5wdXQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW51bWVyYXRvci5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbihlbnRyeSwgaSkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuICAgICAgdmFyIGMgPSBlbnVtZXJhdG9yLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuXG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc01heWJlVGhlbmFibGUoZW50cnkpKSB7XG4gICAgICAgIGlmIChlbnRyeS5jb25zdHJ1Y3RvciA9PT0gYyAmJiBlbnRyeS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgICBlbnRyeS5fb25lcnJvciA9IG51bGw7XG4gICAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW51bWVyYXRvci5fd2lsbFNldHRsZUF0KGMucmVzb2x2ZShlbnRyeSksIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnVtZXJhdG9yLl9yZW1haW5pbmctLTtcbiAgICAgICAgZW51bWVyYXRvci5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24oc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG4gICAgICB2YXIgcHJvbWlzZSA9IGVudW1lcmF0b3IucHJvbWlzZTtcblxuICAgICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3JlbWFpbmluZy0tO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudW1lcmF0b3IuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnVtZXJhdG9yLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBlbnVtZXJhdG9yLl9yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uKHByb21pc2UsIGkpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRhbGwoZW50cmllcykge1xuICAgICAgcmV0dXJuIG5ldyBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkZGVmYXVsdCh0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRhbGw7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZShlbnRyaWVzKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmICghbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxtZW50KHZhbHVlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJlamVjdGlvbihyZWFzb24pIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSksIHVuZGVmaW5lZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRyYWNlO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmUob2JqZWN0KSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdChyZWFzb24pIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3Q7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGNvdW50ZXIgPSAwO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZTtcbiAgICAvKipcbiAgICAgIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgICAgIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gICAgICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgICAgIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gICAgICBUZXJtaW5vbG9neVxuICAgICAgLS0tLS0tLS0tLS1cblxuICAgICAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgICAgIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgICAgIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgICAgIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAgICAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAgICAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICAgICAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgICAgIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgICAgIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gICAgICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgICAgIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgICAgIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICAgICAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICAgICAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICAgICAgQmFzaWMgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS1cblxuICAgICAgYGBganNcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gb24gZmFpbHVyZVxuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFkdmFuY2VkIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgICAgIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICAgICAgYGBganNcbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gICAgICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICAgICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAY2xhc3MgUHJvbWlzZVxuICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZXJcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEBjb25zdHJ1Y3RvclxuICAgICovXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICAgIHRoaXMuX2lkID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGNvdW50ZXIrKztcbiAgICAgIHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3AgIT09IHJlc29sdmVyKSB7XG4gICAgICAgIGlmICghbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHJlc29sdmVyKSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UpKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuYWxsID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJhY2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlc29sdmUgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlamVjdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcjtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0QXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwO1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9hc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXA7XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBDaGFpbmluZ1xuICAgICAgLS0tLS0tLS1cblxuICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgICAgfSk7XG4gICAgICBgYGBcbiAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFzc2ltaWxhdGlvblxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBTaW1wbGUgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcblxuICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kQXV0aG9yKCkuXG4gICAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgdGhlblxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEICYmICFvbkZ1bGZpbGxtZW50IHx8IHN0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCAmJiAhb25SZWplY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyZW50Ll9yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW3N0YXRlIC0gMV07XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHN0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBzeW5jaHJvbm91c1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEF1dGhvcigpO1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH1cblxuICAgICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgICAgZmluZEF1dGhvcigpWydjYXRjaCddKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIGNhdGNoXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJHBvbHlmaWxsKCkge1xuICAgICAgdmFyIGxvY2FsO1xuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gICAgICBpZiAoUCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvY2FsLlByb21pc2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdDtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGw7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZSA9IHtcbiAgICAgICdQcm9taXNlJzogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQsXG4gICAgICAncG9seWZpbGwnOiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHRcbiAgICB9O1xuXG4gICAgLyogZ2xvYmFsIGRlZmluZTp0cnVlIG1vZHVsZTp0cnVlIHdpbmRvdzogdHJ1ZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlWydleHBvcnRzJ10pIHtcbiAgICAgIG1vZHVsZVsnZXhwb3J0cyddID0gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1snRVM2UHJvbWlzZSddID0gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHQoKTtcbn0pLmNhbGwodGhpcyk7XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIHByb21pc2VFeHRlbnNpb25zXzEgPSByZXF1aXJlKFwiLi8uLi9oZWxwZXJzL3Byb21pc2VFeHRlbnNpb25zXCIpO1xyXG52YXIgYWN0aXZpdHlNYW5hZ2VtZW50QVBJXzEgPSByZXF1aXJlKFwiLi9hY3Rpdml0eU1hbmFnZW1lbnRBUElcIik7XHJcbnZhciBhY3Rpdml0eUFHTV8xID0gcmVxdWlyZShcIi4uL2NvcmUvYWN0aXZpdHlBR01cIik7XHJcbnZhciBBY3Rpdml0eUFQSSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eUFQSShtYW5hZ2VyLCBteSkge1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFwiMi4xLjNcIjtcclxuICAgICAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9teSA9IG15O1xyXG4gICAgICAgIHRoaXMuYWxsID0gbmV3IGFjdGl2aXR5TWFuYWdlbWVudEFQSV8xLkFjdGl2aXR5TWFuYWdlbWVudEFQSShtYW5hZ2VyLCBteSk7XHJcbiAgICB9XHJcbiAgICBBY3Rpdml0eUFQSS5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fbWFuYWdlci5yZWFkeSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzKTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eUFQSS5wcm90b3R5cGUsIFwibXlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlBUEkucHJvdG90eXBlLCBcImF3YXJlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX215LndpbmRvdyAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5QVBJLnByb3RvdHlwZSwgXCJpbkFjdGl2aXR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXdhcmUgJiYgdGhpcy5fbXkuYWN0aXZpdHkgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eUFQSS5wcm90b3R5cGUsIFwiYWdtXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmF3YXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pbkFjdGl2aXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFjdGl2aXR5QUdNXzEuQWN0aXZpdHlBR00obnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX215LmFjdGl2aXR5LmFnbTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBBY3Rpdml0eUFQSTtcclxufSkoKTtcclxuZXhwb3J0cy5BY3Rpdml0eUFQSSA9IEFjdGl2aXR5QVBJO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eUFQSS5qcy5tYXAiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLy4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIEFjdGl2aXR5TWFuYWdlbWVudEFQSSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eU1hbmFnZW1lbnRBUEkobWFuYWdlciwgbXkpIHtcclxuICAgICAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9teSA9IG15O1xyXG4gICAgICAgIHRoaXMuYWN0aXZpdHlUeXBlcyA9IHtcclxuICAgICAgICAgICAgZ2V0OiB0aGlzLl9nZXRBY3Rpdml0eVR5cGVzV3JhcHBlci5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICByZWdpc3RlcjogdGhpcy5fbWFuYWdlci5yZWdpc3RlckFjdGl2aXR5VHlwZS5iaW5kKHRoaXMuX21hbmFnZXIpLFxyXG4gICAgICAgICAgICB1bnJlZ2lzdGVyOiB0aGlzLl9tYW5hZ2VyLnVucmVnaXN0ZXJBY3Rpdml0eVR5cGUuYmluZCh0aGlzLl9tYW5hZ2VyKSxcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiB0aGlzLl9tYW5hZ2VyLnN1YnNjcmliZUFjdGl2aXR5VHlwZUV2ZW50cy5iaW5kKHRoaXMuX21hbmFnZXIpLFxyXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBpbml0aWF0ZTogdGhpcy5fbWFuYWdlci5pbml0aWF0ZS5iaW5kKHRoaXMuX21hbmFnZXIpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLndpbmRvd1R5cGVzID0ge1xyXG4gICAgICAgICAgICBnZXQ6IHRoaXMuX2dldFdpbmRvd1R5cGVzV3JhcHBlci5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICByZWdpc3RlckZhY3Rvcnk6IHRoaXMuX21hbmFnZXIucmVnaXN0ZXJXaW5kb3dGYWN0b3J5LmJpbmQodGhpcy5fbWFuYWdlciksXHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJGYWN0b3J5OiB0aGlzLl9tYW5hZ2VyLnVucmVnaXN0ZXJXaW5kb3dGYWN0b3J5LmJpbmQodGhpcy5fbWFuYWdlciksXHJcbiAgICAgICAgICAgIHN1YnNjcmliZTogdGhpcy5fbWFuYWdlci5zdWJzY3JpYmVXaW5kb3dUeXBlRXZlbnRzLmJpbmQodGhpcy5fbWFuYWdlciksXHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiB1bmRlZmluZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMud2luZG93cyA9IHtcclxuICAgICAgICAgICAgZ2V0OiB0aGlzLl9tYW5hZ2VyLmdldFdpbmRvd3MuYmluZCh0aGlzLl9tYW5hZ2VyKSxcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiB0aGlzLl9tYW5hZ2VyLnN1YnNjcmliZVdpbmRvd0V2ZW50cy5iaW5kKHRoaXMuX21hbmFnZXIpLFxyXG4gICAgICAgICAgICBhbm5vdW5jZTogdGhpcy5fbWFuYWdlci5hbm5vdW5jZVdpbmRvdy5iaW5kKHRoaXMuX21hbmFnZXIpLFxyXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjcmVhdGU6IHRoaXMuX21hbmFnZXIuY3JlYXRlV2luZG93LmJpbmQodGhpcy5fbWFuYWdlcilcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0ge1xyXG4gICAgICAgICAgICBnZXQ6IHRoaXMuX21hbmFnZXIuZ2V0QWN0aXZpdGllcy5iaW5kKHRoaXMuX21hbmFnZXIpLFxyXG4gICAgICAgICAgICBzdWJzY3JpYmU6IHRoaXMuX21hbmFnZXIuc3Vic2NyaWJlQWN0aXZpdHlFdmVudHMuYmluZCh0aGlzLl9tYW5hZ2VyKSxcclxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6IHVuZGVmaW5lZFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBBY3Rpdml0eU1hbmFnZW1lbnRBUEkucHJvdG90eXBlLl9nZXRBY3Rpdml0eVR5cGVzV3JhcHBlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQobmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hbmFnZXIuZ2V0QWN0aXZpdHlUeXBlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFuYWdlci5nZXRBY3Rpdml0eVR5cGUobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VtZW50QVBJLnByb3RvdHlwZS5fZ2V0V2luZG93VHlwZXNXcmFwcGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFuYWdlci5nZXRXaW5kb3dUeXBlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFuYWdlci5nZXRXaW5kb3dUeXBlKG5hbWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eU1hbmFnZW1lbnRBUEk7XHJcbn0pKCk7XHJcbmV4cG9ydHMuQWN0aXZpdHlNYW5hZ2VtZW50QVBJID0gQWN0aXZpdHlNYW5hZ2VtZW50QVBJO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eU1hbmFnZW1lbnRBUEkuanMubWFwIiwidmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIi4vLi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgQWN0aXZpdHlNeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eU15KG1hbmFnZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX215QWN0aXZpdHlKb2luZWRDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9teUFjdGl2aXR5UmVtb3ZlZENhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX215Q29udGV4dFVwZGF0ZUNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlci5HZXQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XHJcbiAgICAgICAgbWFuYWdlci5yZWFkeSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhbSkge1xyXG4gICAgICAgICAgICBhbS5zdWJzY3JpYmVBY3Rpdml0eUNvbnRleHRDaGFuZ2VkKF90aGlzLl9zdWJzY3JpYmVNeUNvbnRleHRDaGFuZ2VkLmJpbmQoX3RoaXMpKTtcclxuICAgICAgICAgICAgYW0uc3Vic2NyaWJlV2luZG93RXZlbnRzKF90aGlzLl9zdWJzY3JpYmVNeVdpbmRvd0V2ZW50LmJpbmQoX3RoaXMpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eU15LnByb3RvdHlwZSwgXCJ3aW5kb3dcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLl93aW5kb3cpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3VuY2VkV2luZG93cyA9IHRoaXMuX21hbmFnZXIuYW5ub3VuY2VkV2luZG93cztcclxuICAgICAgICAgICAgICAgIGlmIChhbm5vdW5jZWRXaW5kb3dzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aW5kb3cgPSBhbm5vdW5jZWRXaW5kb3dzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aW5kb3c7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlNeS5wcm90b3R5cGUsIFwiYWN0aXZpdHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbXlXaW4gPSB0aGlzLndpbmRvdztcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwobXlXaW4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBteVdpbi5hY3Rpdml0eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLmNyZWF0ZVdpbmRvdyA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hbmFnZXIuY3JlYXRlV2luZG93KHRoaXMuYWN0aXZpdHksIHdpbmRvd1R5cGUpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eU15LnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFjdGl2aXR5ID0gdGhpcy5hY3Rpdml0eTtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2aXR5LmNvbnRleHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5vbkFjdGl2aXR5Sm9pbmVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fbXlBY3Rpdml0eUpvaW5lZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICB2YXIgbXlXaW4gPSB0aGlzLndpbmRvdztcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwobXlXaW4pICYmICF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG15V2luLmFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhteVdpbi5hY3Rpdml0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLm9uQWN0aXZpdHlMZWZ0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fbXlBY3Rpdml0eVJlbW92ZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNeS5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX215Q29udGV4dFVwZGF0ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICB2YXIgbXlXaW4gPSB0aGlzLndpbmRvdztcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChteVdpbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWN0aXZpdHkgPSBteVdpbi5hY3Rpdml0eTtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChhY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFjayhhY3Rpdml0eS5jb250ZXh0LCBhY3Rpdml0eS5jb250ZXh0LCBbXSwgYWN0aXZpdHkpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLl9zdWJzY3JpYmVNeUNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKGFjdGl2aXR5LCBjb250ZXh0LCBkZWx0YSwgcmVtb3ZlZCkge1xyXG4gICAgICAgIHZhciBteVdpbiA9IHRoaXMud2luZG93O1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG15V2luKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBteUFjdGl2aXR5ID0gbXlXaW4uYWN0aXZpdHk7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwobXlBY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0aXZpdHkuaWQgIT09IG15QWN0aXZpdHkuaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ub3RpZnlNeUNvbnRleHRDaGFuZ2VkKGFjdGl2aXR5LCBjb250ZXh0LCBkZWx0YSwgcmVtb3ZlZCk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNeS5wcm90b3R5cGUuX3N1YnNjcmliZU15V2luZG93RXZlbnQgPSBmdW5jdGlvbiAoYWN0aXZpdHksIHdpbmRvdywgZXZlbnQpIHtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLndpbmRvdykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy53aW5kb3cuaWQgIT09IHdpbmRvdy5pZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudCA9PT0gXCJqb2luZWRcIikge1xyXG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlPbkpvaW5lZChhY3Rpdml0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlNeVdpbmRvd0V2ZW50KGFjdGl2aXR5LCB0aGlzLl9teUFjdGl2aXR5UmVtb3ZlZENhbGxiYWNrcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLl9ub3RpZnlNeVdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCBjYWxsYmFja1N0b3JlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNhbGxiYWNrU3RvcmUubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY2FsbGJhY2tTdG9yZVtpbmRleF07XHJcbiAgICAgICAgICAgIGVsZW1lbnQoYWN0aXZpdHksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNeS5wcm90b3R5cGUuX25vdGlmeU15Q29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoYWN0aXZpdHksIGNvbnRleHQsIGRlbHRhLCByZW1vdmVkKSB7XHJcbiAgICAgICAgZGVsdGEgPSBkZWx0YSB8fCB7fTtcclxuICAgICAgICByZW1vdmVkID0gcmVtb3ZlZCB8fCBbXTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fbXlDb250ZXh0VXBkYXRlQ2FsbGJhY2tzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX215Q29udGV4dFVwZGF0ZUNhbGxiYWNrc1tpbmRleF07XHJcbiAgICAgICAgICAgIGVsZW1lbnQoY29udGV4dCwgZGVsdGEsIHJlbW92ZWQsIGFjdGl2aXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNeS5wcm90b3R5cGUuX25vdGlmeU9uSm9pbmVkID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XHJcbiAgICAgICAgLy8gd2hlbiBqb2luZWQgdG8gYWN0aXZpdHkgbm90aWZ5IGZvciA6XHJcbiAgICAgICAgLy8gKiBqb2luZWRcclxuICAgICAgICAvLyAqIGNvbnRleHQgY2hhbmdlXHJcbiAgICAgICAgdGhpcy5fbm90aWZ5TXlXaW5kb3dFdmVudChhY3Rpdml0eSwgdGhpcy5fbXlBY3Rpdml0eUpvaW5lZENhbGxiYWNrcyk7XHJcbiAgICAgICAgdGhpcy5fbm90aWZ5TXlDb250ZXh0Q2hhbmdlZChhY3Rpdml0eSwgYWN0aXZpdHkuY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5TXk7XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0c1snZGVmYXVsdCddPSBBY3Rpdml0eU15O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eU15QVBJLmpzLm1hcCIsInZhciBBY3Rpdml0eUNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eUNvbmZpZygpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBBY3Rpdml0eUNvbmZpZztcclxufSkoKTtcclxuZXhwb3J0cy5BY3Rpdml0eUNvbmZpZyA9IEFjdGl2aXR5Q29uZmlnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eUNvbmZpZy5qcy5tYXAiLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vdHlwaW5ncy9lczYtcHJvbWlzZS9lczYtcHJvbWlzZS5kLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vdHlwaW5ncy90aWNrNDItYWdtL2FnbS5kLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vdHlwaW5ncy90aWNrNDItbG9nZ2VyL2xvZ2dlci5kLnRzXCIvPlxyXG5yZXF1aXJlKFwiZXM2LXByb21pc2VcIik7XHJcbnZhciBoY0JyaWRnZV8xID0gcmVxdWlyZShcIi4vYnJpZGdlcy9oY0JyaWRnZVwiKTtcclxudmFyIGFjdGl2aXR5TWFuYWdlcl8xID0gcmVxdWlyZShcIi4vY29yZS9hY3Rpdml0eU1hbmFnZXJcIik7XHJcbnZhciBhY3Rpdml0eU15QVBJXzEgPSByZXF1aXJlKFwiLi9BUEkvYWN0aXZpdHlNeUFQSVwiKTtcclxudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgYWN0aXZpdHlDb25maWdfMSA9IHJlcXVpcmUoXCIuL2FjdGl2aXR5Q29uZmlnXCIpO1xyXG52YXIgYWN0aXZpdHlBUElfMSA9IHJlcXVpcmUoXCIuL0FQSS9hY3Rpdml0eUFQSVwiKTtcclxudmFyIGFjdGl2aXR5QUdNXzEgPSByZXF1aXJlKFwiLi9jb3JlL2FjdGl2aXR5QUdNXCIpO1xyXG5hY3Rpdml0eSA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCBuZXcgYWN0aXZpdHlDb25maWdfMS5BY3Rpdml0eUNvbmZpZztcclxuICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZChjb25maWcubG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgbG9nZ2VyXzEuTG9nZ2VyLkxldmVsID0gY29uZmlnLmxvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGNvbmZpZy5sb2dnZXIpKSB7XHJcbiAgICAgICAgbG9nZ2VyXzEuTG9nZ2VyLkdsdWVMb2dnZXIgPSBjb25maWcubG9nZ2VyO1xyXG4gICAgfVxyXG4gICAgdmFyIGJyaWRnZTtcclxuICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZCh3aW5kb3cuaHRtbENvbnRhaW5lcikpIHtcclxuICAgICAgICBicmlkZ2UgPSBuZXcgaGNCcmlkZ2VfMVsnZGVmYXVsdCddKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY3Rpdml0eSBub3Qgc3VwcG9ydGVkIGluIGluIGJyb3dzZXJcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoIWJyaWRnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgYnJpZGdlIHRvIG5hdGl2ZSBhY3Rpdml0eSBpcyBuZWVkZWQgdG8gY3JlYXRlIGFjdGl2aXR5IGxpYi5cIik7XHJcbiAgICB9XHJcbiAgICBhY3Rpdml0eUFHTV8xLkFjdGl2aXR5QUdNLkFHTSA9IGNvbmZpZy5hZ207XHJcbiAgICB2YXIgYWN0aXZpdHlNYW5hZ2VyID0gbmV3IGFjdGl2aXR5TWFuYWdlcl8xWydkZWZhdWx0J10oYnJpZGdlLCAhY29uZmlnLmRpc2FibGVBdXRvQW5ub3VuY2UpO1xyXG4gICAgdmFyIG15ID0gbmV3IGFjdGl2aXR5TXlBUElfMVsnZGVmYXVsdCddKGFjdGl2aXR5TWFuYWdlcik7XHJcbiAgICByZXR1cm4gbmV3IGFjdGl2aXR5QVBJXzEuQWN0aXZpdHlBUEkoYWN0aXZpdHlNYW5hZ2VyLCBteSk7XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gYWN0aXZpdHk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5TW9kdWxlLmpzLm1hcCIsInZhciBlbnRpdHlFdmVudF8xID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0cy9lbnRpdHlFdmVudFwiKTtcclxudmFyIGFjdGl2aXR5U3RhdHVzXzEgPSByZXF1aXJlKFwiLi4vY29udHJhY3RzL2FjdGl2aXR5U3RhdHVzXCIpO1xyXG52YXIgYWN0aXZpdHlUeXBlXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvYWN0aXZpdHlUeXBlXCIpO1xyXG52YXIgd2luZG93VHlwZV8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL3dpbmRvd1R5cGVcIik7XHJcbnZhciBhY3Rpdml0eV8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2FjdGl2aXR5XCIpO1xyXG52YXIgYWN0aXZpdHlXaW5kb3dfMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9hY3Rpdml0eVdpbmRvd1wiKTtcclxudmFyIHByb3h5V2luZG93RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL2NvcmUvcHJveHlXaW5kb3dGYWN0b3J5XCIpO1xyXG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciBlbnRpdHlFdmVudF8yID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0cy9lbnRpdHlFdmVudFwiKTtcclxudmFyIHJlYWR5TWFya2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9yZWFkeU1hcmtlclwiKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgZW50aXR5RXZlbnRfMyA9IHJlcXVpcmUoXCIuLi9jb250cmFjdHMvZW50aXR5RXZlbnRcIik7XHJcbnZhciBIQ0JyaWRnZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIQ0JyaWRnZShhZ20pIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eVR5cGVFbnRpdHlOYW1lID0gXCJhY3Rpdml0eVR5cGVcIjtcclxuICAgICAgICB0aGlzLl93aW5kb3dUeXBlRW50aXR5TmFtZSA9IFwid2luZG93VHlwZVwiO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5RW50aXR5TmFtZSA9IFwiYWN0aXZpdHlcIjtcclxuICAgICAgICB0aGlzLl93aW5kb3dFbnRpdHlOYW1lID0gXCJhY3Rpdml0eVdpbmRvd1wiO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlci5HZXQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNlcSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5VHlwZUNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1R5cGVDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eUNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd0NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FnbSA9IGFnbTtcclxuICAgIH1cclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fcmVhZHlNYXJrZXIgPSBuZXcgcmVhZHlNYXJrZXJfMS5SZWFkeU1hcmtlcihcIkhDIEJyaWRnZVwiLCAxKTtcclxuICAgICAgICB0aGlzLl9odG1sQ29udGFpbmVyID0gd2luZG93Lmh0bWxDb250YWluZXIuYWN0aXZpdHlGYWNhZGU7XHJcbiAgICAgICAgdGhpcy5faHRtbENvbnRhaW5lci5pbml0KHRoaXMuX2FnbSA/IHRoaXMuX2FnbS5pbnN0YW5jZSA6IHVuZGVmaW5lZCwgdGhpcy5faGNFdmVudEhhbmRsZXIuYmluZCh0aGlzKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuc2lnbmFsKFwiSW5pdCBkb25lIGZyb20gSENcIik7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZWFkeU1hcmtlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3JlYWR5TWFya2VyLnNldENhbGxiYWNrKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIEhDIGJyaWRnZSAtIFwiICsgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoX3RoaXMuX3JlYWR5TWFya2VyLmdldEVycm9yKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX2hjRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50SnNvbikge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShldmVudEpzb24pO1xyXG4gICAgICAgIHZhciBldmVudCA9IEpTT04ucGFyc2UoZXZlbnRKc29uKTtcclxuICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnRCeVNlcShldmVudCk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9wcm9jZXNzRXZlbnRCeVNlcSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBzZXEgPSBldmVudC5zZXF1ZW5jZTtcclxuICAgICAgICBpZiAoc2VxID09PSB0aGlzLl9sYXN0U2VxICsgMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0U2VxKys7XHJcbiAgICAgICAgICAgIHZhciBuZXh0RXZlbnQgPSB0aGlzLl9ldmVudFF1ZXVlW3NlcSArIDFdO1xyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQobmV4dEV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwicmVwbGF5aW5nIG1lc3NhZ2UgbnVtYmVyIFwiICsgc2VxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudEJ5U2VxKG5leHRFdmVudCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRRdWV1ZVtzZXEgKyAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZVtzZXFdID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIkdvdCBvdXQgb2Ygb3JkZXIgZXZlbnQgd2l0aCBudW1iZXIgXCIgKyBzZXEgKyBcIi4gV2lsbCB3YWl0IGZvciBwcmV2aW91cyBldmVudChzKSBiZWZvcmUgcmVwbGF5aW5nLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9wcm9jZXNzRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgZW50aXR5VHlwZSA9IGV2ZW50LmVudGl0eVR5cGU7XHJcbiAgICAgICAgdmFyIGV2ZW50Q29udGV4dCA9IHRoaXMuX2NvbnZlcnRDb250ZXh0KGV2ZW50LmNvbnRleHQpO1xyXG4gICAgICAgIHZhciBlbnRpdHk7XHJcbiAgICAgICAgc3dpdGNoIChlbnRpdHlUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgdGhpcy5fYWN0aXZpdHlUeXBlRW50aXR5TmFtZTpcclxuICAgICAgICAgICAgICAgIGVudGl0eSA9IEhDQnJpZGdlLl9oY1RvSnNBY3Rpdml0eVR5cGUoZXZlbnQuZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3B1Ymxpc2hBY3Rpdml0eVR5cGVTdGF0dXNDaGFuZ2UoZW50aXR5LCBldmVudENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgdGhpcy5fd2luZG93VHlwZUVudGl0eU5hbWU6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSB0aGlzLl9oY1RvSnNXaW5kb3dUeXBlKGV2ZW50LmVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoV2luZG93VHlwZVN0YXR1c0NoYW5nZShlbnRpdHksIGV2ZW50Q29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSB0aGlzLl9hY3Rpdml0eUVudGl0eU5hbWU6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSB0aGlzLl9oY1RvSnNBY3Rpdml0eShldmVudC5lbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHVibGlzaEFjdGl2aXR5U3RhdHVzQ2hhbmdlKGVudGl0eSwgZXZlbnRDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHRoaXMuX3dpbmRvd0VudGl0eU5hbWU6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSBIQ0JyaWRnZS5faGNUb0pzV2luZG93KGV2ZW50LmVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoQWN0aXZpdHlXaW5kb3dFdmVudChlbnRpdHksIGV2ZW50Q29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9jb252ZXJ0Q29udGV4dCA9IGZ1bmN0aW9uIChoY0NvbnRleHQpIHtcclxuICAgICAgICBpZiAoaGNDb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLlN0YXR1c0NoYW5nZSkge1xyXG4gICAgICAgICAgICB2YXIgb2xkU3RhdHVzID0gbmV3IGFjdGl2aXR5U3RhdHVzXzEuQWN0aXZpdHlTdGF0dXMoaGNDb250ZXh0Lm9sZFN0YXR1cy5zdGF0ZSwgaGNDb250ZXh0Lm9sZFN0YXR1cy5zdGF0dXNNZXNzYWdlLCBoY0NvbnRleHQub2xkU3RhdHVzLnN0YXR1c1RpbWUpO1xyXG4gICAgICAgICAgICB2YXIgbmV3U3RhdHVzID0gbmV3IGFjdGl2aXR5U3RhdHVzXzEuQWN0aXZpdHlTdGF0dXMoaGNDb250ZXh0Lm5ld1N0YXR1cy5zdGF0ZSwgaGNDb250ZXh0Lm5ld1N0YXR1cy5zdGF0dXNNZXNzYWdlLCBoY0NvbnRleHQubmV3U3RhdHVzLnN0YXR1c1RpbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGVudGl0eUV2ZW50XzEuRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0KG5ld1N0YXR1cywgb2xkU3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGNDb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5V2luZG93RXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGFjdCA9IHRoaXMuX2hjVG9Kc0FjdGl2aXR5KGhjQ29udGV4dC5hY3Rpdml0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgZW50aXR5RXZlbnRfMS5FbnRpdHlBY3Rpdml0eVdpbmRvd0V2ZW50Q29udGV4dChhY3QsIGhjQ29udGV4dC5ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhjQ29udGV4dC50eXBlID09PSBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eUNvbnRleHRDaGFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBlbnRpdHlFdmVudF8zLkFjdGl2aXR5Q29udGV4dENoYW5nZWRDb250ZXh0KGhjQ29udGV4dC5uZXdDb250ZXh0LCBoY0NvbnRleHQudXBkYXRlZCwgaGNDb250ZXh0LnJlbW92ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRDb250ZXh0KGhjQ29udGV4dC50eXBlKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5faGNUb0pzV2luZG93ID0gZnVuY3Rpb24gKGhjV2luZG93KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhY3Rpdml0eVdpbmRvd18xWydkZWZhdWx0J10oaGNXaW5kb3cuaWQsIGhjV2luZG93Lm5hbWUsIGhjV2luZG93LnR5cGUsIGhjV2luZG93LmFjdGl2aXR5SWQsIGhjV2luZG93Lmluc3RhbmNlLCBoY1dpbmRvdy5pc0luZGVwZW5kZW50KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX2hjVG9Kc0FjdGl2aXR5ID0gZnVuY3Rpb24gKGhjQWN0KSB7XHJcbiAgICAgICAgdmFyIHdpbmRvdyA9IGhjQWN0Lm93bmVyID8gSENCcmlkZ2UuX2hjVG9Kc1dpbmRvdyhoY0FjdC5vd25lcikgOiBudWxsO1xyXG4gICAgICAgIHZhciBzdGF0dXMgPSBuZXcgYWN0aXZpdHlTdGF0dXNfMS5BY3Rpdml0eVN0YXR1cyhoY0FjdC5zdGF0dXMuc3RhdGUsIGhjQWN0LnN0YXR1cy5zdGF0dXNNZXNzYWdlLCBoY0FjdC5zdGF0dXMuc3RhdHVzVGltZSk7XHJcbiAgICAgICAgdmFyIGhlbHBlcldpbmRvd3MgPSBoY0FjdC53aW5kb3dzID8gaGNBY3Qud2luZG93cy5tYXAoZnVuY3Rpb24gKHcpIHsgcmV0dXJuIEhDQnJpZGdlLl9oY1RvSnNXaW5kb3codyk7IH0pIDogW107XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBKU09OLnBhcnNlKGhjQWN0LmNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgYWN0aXZpdHlfMVsnZGVmYXVsdCddKGhjQWN0LmlkLCBoY0FjdC50eXBlLm5hbWUsIHN0YXR1cywgY29udGV4dCwgd2luZG93LCBoZWxwZXJXaW5kb3dzKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5faGNUb0pzQWN0aXZpdHlUeXBlID0gZnVuY3Rpb24gKGhjQWN0VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgYWN0aXZpdHlUeXBlXzFbJ2RlZmF1bHQnXShoY0FjdFR5cGUubmFtZSwgaGNBY3RUeXBlLm93bmVyV2luZG93VHlwZSwgaGNBY3RUeXBlLmhlbHBlcldpbmRvd1R5cGVzLCBoY0FjdFR5cGUuZGVzY3JpcHRpb24pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5faGNUb0pzV2luZG93VHlwZSA9IGZ1bmN0aW9uIChoY1dpblR5cGUpIHtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChoY1dpblR5cGUuZmFjdG9yaWVzKSkge1xyXG4gICAgICAgICAgICBoY1dpblR5cGUuZmFjdG9yaWVzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmYWN0b3JpZXMgPSBoY1dpblR5cGUuZmFjdG9yaWVzLm1hcChmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICByZXR1cm4gSENCcmlkZ2UuX2hjVG9Kc1dpbmRvd1R5cGVGYWN0b3J5KGYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgd2luZG93VHlwZV8xWydkZWZhdWx0J10oaGNXaW5UeXBlLm5hbWUsIGZhY3Rvcmllcyk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UuX2hjVG9Kc1dpbmRvd1R5cGVGYWN0b3J5ID0gZnVuY3Rpb24gKGhjV2luVHlwZUZhY3RvcnkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHByb3h5V2luZG93RmFjdG9yeV8xLlByb3h5V2luZG93RmFjdG9yeShoY1dpblR5cGVGYWN0b3J5LmRlc2NyaXB0aW9uKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5fZ2V0VVJMUGFyYW1ldGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KChuZXcgUmVnRXhwKCdbP3wmXScgKyBuYW1lICsgJz0nICsgJyhbXiY7XSs/KSgmfCN8O3wkKScpLmV4ZWMobG9jYXRpb24uc2VhcmNoKSB8fCBbLCBcIlwiXSlbMV0ucmVwbGFjZSgvXFwrL2csICclMjAnKSkgfHwgbnVsbDtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuZ2V0QWN0aXZpdHlUeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmdldEFjdGl2aXR5VHlwZXMoZnVuY3Rpb24gKGluZm9zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaW5mb3MubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBpbmZvc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0FjdGl2aXR5VHlwZSA9IEhDQnJpZGdlLl9oY1RvSnNBY3Rpdml0eVR5cGUoaW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3QWN0aXZpdHlUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUucmVnaXN0ZXJBY3Rpdml0eVR5cGUgPSBmdW5jdGlvbiAoYWN0aXZpdHlUeXBlTmFtZSwgb3duZXJXaW5kb3csIGhlbHBlcldpbmRvd3MsIGxheW91dENvbmZpZywgZGVzY3JpcHRpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChoZWxwZXJXaW5kb3dzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGhlbHBlcldpbmRvd3MgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29uZmlnID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogYWN0aXZpdHlUeXBlTmFtZSxcclxuICAgICAgICAgICAgICAgIG93bmVyV2luZG93VHlwZTogb3duZXJXaW5kb3csXHJcbiAgICAgICAgICAgICAgICBoZWxwZXJXaW5kb3dUeXBlczogaGVscGVyV2luZG93cyxcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICAgIGxheW91dENvbmZpZzogSlNPTi5zdHJpbmdpZnkobGF5b3V0Q29uZmlnKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5yZWdpc3RlckFjdGl2aXR5VHlwZShKU09OLnN0cmluZ2lmeShjb25maWcpLCBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0FjdGl2aXR5VHlwZSA9IEhDQnJpZGdlLl9oY1RvSnNBY3Rpdml0eVR5cGUoaW5mbyk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ld0FjdGl2aXR5VHlwZSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnVucmVnaXN0ZXJBY3Rpdml0eVR5cGUgPSBmdW5jdGlvbiAoYWN0aXZpdHlUeXBlTmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIudW5yZWdpc3RlckFjdGl2aXR5VHlwZShhY3Rpdml0eVR5cGVOYW1lLCBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuZ2V0V2luZG93VHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5nZXRXaW5kb3dUeXBlcyhmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbmZvcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IGluZm9zW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V2luZG93VHlwZSA9IF90aGlzLl9oY1RvSnNXaW5kb3dUeXBlKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1dpbmRvd1R5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5yZWdpc3RlcldpbmRvd0ZhY3RvcnkgPSBmdW5jdGlvbiAod2luZG93VHlwZU5hbWUsIGZhY3RvcnkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd1R5cGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwid2luZG93VHlwZU5hbWUgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnJlZ2lzdGVyV2luZG93RmFjdG9yeSh3aW5kb3dUeXBlTmFtZSwgZmFjdG9yeS5jcmVhdGUuYmluZChmYWN0b3J5KSwgZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmluaXRpYXRlQWN0aXZpdHkgPSBmdW5jdGlvbiAoYWN0aXZpdHlUeXBlLCBjb250ZXh0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0aXZpdHlUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwid2luZG93VHlwZU5hbWUgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuaW5pdGlhdGUoYWN0aXZpdHlUeXBlLCBKU09OLnN0cmluZ2lmeShjb250ZXh0KSwgZnVuY3Rpb24gKGFjdGl2aXR5SWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoYWN0aXZpdHlJZCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldEFubm91bmNlbWVudEluZm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhjID0gd2luZG93Lmh0bWxDb250YWluZXI7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBoYy5nZXRDb250ZXh0KCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgYWN0aXZpdHlXaW5kb3dJZDogXCJcIiwgYWN0aXZpdHlXaW5kb3dUeXBlOiBcIlwiLCBhY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50OiBmYWxzZSwgYWN0aXZpdHlXaW5kb3dOYW1lOiBcIlwiIH07XHJcbiAgICAgICAgcmVzdWx0LmFjdGl2aXR5V2luZG93VHlwZSA9IGNvbnRleHQuYWN0aXZpdHlXaW5kb3dUeXBlO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHJlc3VsdC5hY3Rpdml0eVdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hY3Rpdml0eVdpbmRvd1R5cGUgPSBIQ0JyaWRnZS5fZ2V0VVJMUGFyYW1ldGVyKFwiYWN0aXZpdHlXaW5kb3dUeXBlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuYWN0aXZpdHlXaW5kb3dJZCA9IGNvbnRleHQuYWN0aXZpdHlXaW5kb3dJZDtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChyZXN1bHQuYWN0aXZpdHlXaW5kb3dJZCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFjdGl2aXR5V2luZG93SWQgPSBIQ0JyaWRnZS5fZ2V0VVJMUGFyYW1ldGVyKFwiYWN0aXZpdHlXaW5kb3dJZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmFjdGl2aXR5V2luZG93SW5kZXBlbmRlbnQgPSBjb250ZXh0LmFjdGl2aXR5V2luZG93SW5kZXBlbmRlbnQ7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQocmVzdWx0LmFjdGl2aXR5V2luZG93SW5kZXBlbmRlbnQpKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5hY3Rpdml0eVdpbmRvd05hbWUgPSBjb250ZXh0LmFjdGl2aXR5V2luZG93TmFtZTtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChyZXN1bHQuYWN0aXZpdHlXaW5kb3dOYW1lKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuYWN0aXZpdHlXaW5kb3dOYW1lID0gSENCcmlkZ2UuX2dldFVSTFBhcmFtZXRlcihcImFjdGl2aXR5V2luZG93TmFtZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuYW5ub3VuY2VXaW5kb3cgPSBmdW5jdGlvbiAod2luZG93VHlwZSwgYWN0aXZpdHlXaW5kb3dJZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuIG5vdCBkZXRlcm1pbmUgd2luZG93IHR5cGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbiBub3QgZGV0ZXJtaW5lIHdpbmRvdyBhY3Rpdml0eVdpbmRvd0lkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9odG1sQ29udGFpbmVyLmFubm91bmNlV2luZG93KHdpbmRvd1R5cGUsIGFjdGl2aXR5V2luZG93SWQsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKFwiRXJyb3IgYW5ub3VuY2luZyBhY3Rpdml0eSB3aW5kb3cgd2l0aCBpZCAnXCIgKyBhY3Rpdml0eVdpbmRvd0lkICsgXCInLiBcIiArIGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuZ2V0QWN0aXZpdGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIudHJhY2UoXCJFeGVjdXRpbmcgZ2V0QWN0aXZpdGllcygpXCIpO1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5nZXRBY3Rpdml0aWVzKGZ1bmN0aW9uIChhY3Rpdml0aWVzU3RyKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLnRyYWNlKFwiR290IGdldEFjdGl2aXRpZXMoKSA6XCIgKyBhY3Rpdml0aWVzU3RyKTtcclxuICAgICAgICAgICAgICAgIHZhciBhY3Rpdml0aWVzID0gSlNPTi5wYXJzZShhY3Rpdml0aWVzU3RyKTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhY3Rpdml0aWVzLm1hcChmdW5jdGlvbiAoYWN0KSB7IHJldHVybiBfdGhpcy5faGNUb0pzQWN0aXZpdHkoYWN0KTsgfSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci50cmFjZShcIkVycm9yIGluIGdldEFjdGl2aXRpZXMoKSA6XCIgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUudXBkYXRlQWN0aXZpdHlDb250ZXh0ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCBjb250ZXh0LCBmdWxsUmVwbGFjZSwgcmVtb3ZlZEtleXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHJlbW92ZWRLZXlzKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIGZ1bGxSZXBsYWNlOiBmdWxsUmVwbGFjZSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRLZXlzOiByZW1vdmVkS2V5c1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5zZXRBY3Rpdml0eUNvbnRleHQoYWN0aXZpdHkuaWQsIEpTT04uc3RyaW5naWZ5KGNvbnRleHQpLCBKU09OLnN0cmluZ2lmeShvcHRpb25zKSwgZnVuY3Rpb24gKG5ld0NvbnRleHRTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdDb250ZXh0ID0gSlNPTi5wYXJzZShuZXdDb250ZXh0U3RyaW5nKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUobmV3Q29udGV4dCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gcmVqZWN0KGVycm9yKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldEFjdGl2aXR5V2luZG93cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmdldFdpbmRvd3MoZnVuY3Rpb24gKHdpbmRvd3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB3aW5kb3dzLm1hcChmdW5jdGlvbiAod2luZCkgeyByZXR1cm4gSENCcmlkZ2UuX2hjVG9Kc1dpbmRvdyh3aW5kKTsgfSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnN0b3BBY3Rpdml0eSA9IGZ1bmN0aW9uIChhY3Rpdml0eSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuc3RvcEFjdGl2aXR5KGFjdGl2aXR5LmlkLCBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnVucmVnaXN0ZXJXaW5kb3dGYWN0b3J5ID0gZnVuY3Rpb24gKHdpbmRvd1R5cGVOYW1lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5yZWdpc3RlcldpbmRvd0ZhY3Rvcnkod2luZG93VHlwZU5hbWUsIGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5jcmVhdGVXaW5kb3cgPSBmdW5jdGlvbiAoaWQsIHdpbmRvd0RlZmluaXRpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmNyZWF0ZVdpbmRvdyhpZCwgSlNPTi5zdHJpbmdpZnkod2luZG93RGVmaW5pdGlvbiksIGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpZCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLm9uQWN0aXZpdHlUeXBlU3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlUeXBlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5vbldpbmRvd1R5cGVTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl93aW5kb3dUeXBlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5vbkFjdGl2aXR5U3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLm9uQWN0aXZpdHlXaW5kb3dDaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl93aW5kb3dDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldFdpbmRvd0JvdW5kcyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuZ2V0V2luZG93Qm91bmRzKGlkLCBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGJvdW5kcyk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuc2V0V2luZG93Qm91bmRzID0gZnVuY3Rpb24gKGlkLCBib3VuZHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnNldFdpbmRvd0JvdW5kcyhpZCwgSlNPTi5zdHJpbmdpZnkoYm91bmRzKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnJlZ2lzdGVyV2luZG93ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIGluZGVwZW5kZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5yZWdpc3RlcldpbmRvdyh0eXBlLCBuYW1lLCBpbmRlcGVuZGVudCwgZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGlkKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuY2xvc2VXaW5kb3cgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmNsb3NlV2luZG93KGlkLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3B1Ymxpc2hTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoZW50aXR5LCBjb250ZXh0LCBjYWxsYmFja3MpIHtcclxuICAgICAgICB2YXIgZW50aXR5RXZlbnQgPSBuZXcgZW50aXR5RXZlbnRfMi5FbnRpdHlFdmVudChlbnRpdHksIGNvbnRleHQpO1xyXG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlbnRpdHlFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9wdWJsaXNoQWN0aXZpdHlUeXBlU3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGF0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fcHVibGlzaFN0YXR1c0NoYW5nZShhdCwgY29udGV4dCwgdGhpcy5fYWN0aXZpdHlUeXBlQ2FsbGJhY2tzKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3B1Ymxpc2hXaW5kb3dUeXBlU3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKHd0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fcHVibGlzaFN0YXR1c0NoYW5nZSh3dCwgY29udGV4dCwgdGhpcy5fd2luZG93VHlwZUNhbGxiYWNrcyk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9wdWJsaXNoQWN0aXZpdHlTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoYWN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fcHVibGlzaFN0YXR1c0NoYW5nZShhY3QsIGNvbnRleHQsIHRoaXMuX2FjdGl2aXR5Q2FsbGJhY2tzKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3B1Ymxpc2hBY3Rpdml0eVdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKHcsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9wdWJsaXNoU3RhdHVzQ2hhbmdlKHcsIGNvbnRleHQsIHRoaXMuX3dpbmRvd0NhbGxiYWNrcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhDQnJpZGdlO1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHNbJ2RlZmF1bHQnXT0gSENCcmlkZ2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhjQnJpZGdlLmpzLm1hcCIsInZhciBBY3Rpdml0eVN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eVN0YXR1cyhzdGF0ZSwgbWVzc2FnZSwgdGltZSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XHJcbiAgICB9XHJcbiAgICBBY3Rpdml0eVN0YXR1cy5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlTdGF0dXMucHJvdG90eXBlLmdldE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eVN0YXR1cy5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eVN0YXR1cztcclxufSkoKTtcclxuZXhwb3J0cy5BY3Rpdml0eVN0YXR1cyA9IEFjdGl2aXR5U3RhdHVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eVN0YXR1cy5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgRW50aXR5RXZlbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRW50aXR5RXZlbnQoZW50aXRpeSwgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuZW50aXR5ID0gZW50aXRpeTtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEVudGl0eUV2ZW50O1xyXG59KSgpO1xyXG5leHBvcnRzLkVudGl0eUV2ZW50ID0gRW50aXR5RXZlbnQ7XHJcbnZhciBFbnRpdHlFdmVudENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRW50aXR5RXZlbnRDb250ZXh0KGV2ZW50VHlwZSkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiBFbnRpdHlFdmVudENvbnRleHQ7XHJcbn0pKCk7XHJcbmV4cG9ydHMuRW50aXR5RXZlbnRDb250ZXh0ID0gRW50aXR5RXZlbnRDb250ZXh0O1xyXG52YXIgRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbnRpdHlTdGF0dXNDaGFuZ2VFdmVudENvbnRleHQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFbnRpdHlTdGF0dXNDaGFuZ2VFdmVudENvbnRleHQobmV3U3RhdHVzLCBvbGRTdGF0dXMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBFbnRpdHlFdmVudFR5cGUuU3RhdHVzQ2hhbmdlKTtcclxuICAgICAgICB0aGlzLm5ld1N0YXR1cyA9IG5ld1N0YXR1cztcclxuICAgICAgICB0aGlzLm9sZFN0YXR1cyA9IG9sZFN0YXR1cztcclxuICAgIH1cclxuICAgIHJldHVybiBFbnRpdHlTdGF0dXNDaGFuZ2VFdmVudENvbnRleHQ7XHJcbn0pKEVudGl0eUV2ZW50Q29udGV4dCk7XHJcbmV4cG9ydHMuRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0ID0gRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0O1xyXG52YXIgRW50aXR5QWN0aXZpdHlXaW5kb3dFdmVudENvbnRleHQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW50aXR5QWN0aXZpdHlXaW5kb3dFdmVudENvbnRleHQoYWN0aXZpdHksIGV2ZW50KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5V2luZG93RXZlbnQpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZpdHkgPSBhY3Rpdml0eTtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRW50aXR5QWN0aXZpdHlXaW5kb3dFdmVudENvbnRleHQ7XHJcbn0pKEVudGl0eUV2ZW50Q29udGV4dCk7XHJcbmV4cG9ydHMuRW50aXR5QWN0aXZpdHlXaW5kb3dFdmVudENvbnRleHQgPSBFbnRpdHlBY3Rpdml0eVdpbmRvd0V2ZW50Q29udGV4dDtcclxudmFyIEFjdGl2aXR5Q29udGV4dENoYW5nZWRDb250ZXh0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBY3Rpdml0eUNvbnRleHRDaGFuZ2VkQ29udGV4dCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5Q29udGV4dENoYW5nZWRDb250ZXh0KGNvbnRleHQsIHVwZGF0ZWQsIHJlbW92ZWQpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBFbnRpdHlFdmVudFR5cGUuQWN0aXZpdHlDb250ZXh0Q2hhbmdlKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZWQgPSB1cGRhdGVkO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gSlNPTi5wYXJzZShjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBBY3Rpdml0eUNvbnRleHRDaGFuZ2VkQ29udGV4dDtcclxufSkoRW50aXR5RXZlbnRDb250ZXh0KTtcclxuZXhwb3J0cy5BY3Rpdml0eUNvbnRleHRDaGFuZ2VkQ29udGV4dCA9IEFjdGl2aXR5Q29udGV4dENoYW5nZWRDb250ZXh0O1xyXG52YXIgRW50aXR5RXZlbnRUeXBlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVudGl0eUV2ZW50VHlwZSgpIHtcclxuICAgIH1cclxuICAgIEVudGl0eUV2ZW50VHlwZS5BZGRlZCA9IFwiYWRkZWRcIjtcclxuICAgIEVudGl0eUV2ZW50VHlwZS5SZW1vdmVkID0gXCJyZW1vdmVkXCI7XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuVXBkYXRlZCA9IFwidXBkYXRlZFwiO1xyXG4gICAgRW50aXR5RXZlbnRUeXBlLkZhY3RvcnlSZWdpc3RlcmVkID0gXCJmYWN0b3J5UmVnaXN0ZXJlZFwiO1xyXG4gICAgRW50aXR5RXZlbnRUeXBlLkZhY3RvcnlVbnJlZ2lzdGVyZWQgPSBcImZhY3RvcnlVbnJlZ2lzdGVyZWRcIjtcclxuICAgIEVudGl0eUV2ZW50VHlwZS5TdGF0dXNDaGFuZ2UgPSBcInN0YXR1c0NoYW5nZVwiO1xyXG4gICAgRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5Q29udGV4dENoYW5nZSA9IFwiYWN0aXZpdHlDb250ZXh0VXBkYXRlXCI7XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuQWN0aXZpdHlXaW5kb3dFdmVudCA9IFwiYWN0aXZpdHlXaW5kb3dFdmVudFwiO1xyXG4gICAgcmV0dXJuIEVudGl0eUV2ZW50VHlwZTtcclxufSkoKTtcclxuZXhwb3J0cy5FbnRpdHlFdmVudFR5cGUgPSBFbnRpdHlFdmVudFR5cGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudGl0eUV2ZW50LmpzLm1hcCIsInZhciB1dGlsID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIEFjdGl2aXR5QUdNID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5QUdNKGFjdGl2aXR5KSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHkgPSBhY3Rpdml0eTtcclxuICAgIH1cclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgQWN0aXZpdHlBR00uQUdNLnJlZ2lzdGVyKGRlZmluaXRpb24sIGhhbmRsZXIpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5zZXJ2ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuX2FjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpdml0eS53aW5kb3dzLm1hcChmdW5jdGlvbiAodykge1xyXG4gICAgICAgICAgICByZXR1cm4gdy5pbnN0YW5jZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUubWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVIYXNBZ20oKTtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLl9hY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMuX2FjdGl2aXR5LndpbmRvd3M7XHJcbiAgICAgICAgdmFyIG1ldGhvZE5hbWVzID0gW107XHJcbiAgICAgICAgdmFyIG1ldGhvZHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgd2luZG93cy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgdmFyIHdpbmRvd18xID0gd2luZG93c1tpbmRleF07XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dNZXRob2RzID0gdGhpcy5tZXRob2RzRm9yV2luZG93KHdpbmRvd18xKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbWV0aG9kSW5kZXggPSAwOyBtZXRob2RJbmRleCA8IHdpbmRvd01ldGhvZHMubGVuZ3RoOyBtZXRob2RJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFdpbmRvd01ldGhvZCA9IHdpbmRvd01ldGhvZHNbbWV0aG9kSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZE5hbWVzLmluZGV4T2YoY3VycmVudFdpbmRvd01ldGhvZC5uYW1lKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2ROYW1lcy5wdXNoKGN1cnJlbnRXaW5kb3dNZXRob2QubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kcy5wdXNoKGN1cnJlbnRXaW5kb3dNZXRob2QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXRob2RzO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5tZXRob2RzRm9yV2luZG93ID0gZnVuY3Rpb24gKHdpbmRvdykge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIGlmICghd2luZG93Lmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFjdGl2aXR5QUdNLkFHTS5tZXRob2RzRm9ySW5zdGFuY2Uod2luZG93Lmluc3RhbmNlKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGFyZywgdGFyZ2V0LCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIHZhciBhY3Rpdml0eVNlcnZlcnMgPSB0aGlzLnNlcnZlcnMoKTtcclxuICAgICAgICB2YXIgc2VydmVyc1RvSW52b2tlQWdhaW5zdCA9IFtdO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gXCJhY3Rpdml0eS5hbGxcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBcImFjdGl2aXR5LmFsbFwiKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gYWN0aXZpdHlTZXJ2ZXJzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PT0gXCJhY3Rpdml0eS5iZXN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3RlbnRpYWxUYXJnZXRzID0gYWN0aXZpdHlTZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAoc2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSBBY3Rpdml0eUFHTS5BR00ubWV0aG9kc0Zvckluc3RhbmNlKHNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLm5hbWUgPT09IG1ldGhvZE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbFRhcmdldHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlcnNUb0ludm9rZUFnYWluc3QgPSBbcG90ZW50aWFsVGFyZ2V0c1swXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBcImFsbFwiIHx8IHRhcmdldCA9PT0gXCJiZXN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBY3Rpdml0eUFHTS5BR00uaW52b2tlKG1ldGhvZE5hbWUsIGFyZywgdGFyZ2V0LCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludm9rZSB0YXJnZXQgXCIgKyB0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHV0aWwuaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdEVsZW0gPSB0YXJnZXRbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNBZ21JbnN0YW5jZShmaXJzdEVsZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyc1RvSW52b2tlQWdhaW5zdCA9IHRhcmdldC5tYXAoZnVuY3Rpb24gKGluc3RhbmNlKSB7IHJldHVybiBpbnN0YW5jZTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0FjdGl2aXR5V2luZG93KGZpcnN0RWxlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAod2luKSB7IHJldHVybiB3aW4uaW5zdGFuY2U7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0YXJnZXQgb2JqZWN0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNBZ21JbnN0YW5jZSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gW3RhcmdldF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNBY3Rpdml0eVdpbmRvdyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gW3RhcmdldC5pbnN0YW5jZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRhcmdldCBvYmplY3RcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFjdGl2aXR5QUdNLkFHTS5pbnZva2UobWV0aG9kTmFtZSwgYXJnLCBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0LCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIHJldHVybiBBY3Rpdml0eUFHTS5BR00udW5yZWdpc3RlcihkZWZpbml0aW9uKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUuY3JlYXRlU3RyZWFtID0gZnVuY3Rpb24gKG1ldGhvZERlZmluaXRpb24sIHN1YnNjcmliZXJBZGRlZEhhbmRsZXIsIHN1YnNjcmliZXJSZW1vdmVkRnVuY3Rpb24pIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVIYXNBZ20oKTtcclxuICAgICAgICBBY3Rpdml0eUFHTS5BR00uY3JlYXRlU3RyZWFtKG1ldGhvZERlZmluaXRpb24sIHN1YnNjcmliZXJBZGRlZEhhbmRsZXIsIHN1YnNjcmliZXJSZW1vdmVkRnVuY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobWV0aG9kRGVmaW5pdGlvbiwgcGFyYW1ldGVycywgdGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgdmFyIHNlcnZlcnMgPSB0aGlzLnNlcnZlcnMoKTtcclxuICAgICAgICByZXR1cm4gQWN0aXZpdHlBR00uQUdNLnN1YnNjcmliZShtZXRob2REZWZpbml0aW9uLCBwYXJhbWV0ZXJzLCBzZXJ2ZXJzKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUuX2Vuc3VyZUhhc0FnbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChBY3Rpdml0eUFHTS5BR00pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFnbSBzaG91bGQgYmUgY29uZmlndXJlZCB0byBiZSB1c2VkIGluIGFjdGl2aXR5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUuX2lzQWdtSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iai5hcHBsaWNhdGlvbiAhPSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLl9pc0FjdGl2aXR5V2luZG93ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmouaW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWN0aXZpdHlBR007XHJcbn0pKCk7XHJcbmV4cG9ydHMuQWN0aXZpdHlBR00gPSBBY3Rpdml0eUFHTTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlBR00uanMubWFwIiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvZXM2LXByb21pc2UvZXM2LXByb21pc2UuZC50c1wiLz5cclxudmFyIGVudGl0eUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vY29udHJhY3RzL2VudGl0eUV2ZW50XCIpO1xyXG52YXIgYWN0aXZpdHlUeXBlXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvYWN0aXZpdHlUeXBlXCIpO1xyXG52YXIgcHJvbWlzZUV4dGVuc2lvbnNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3Byb21pc2VFeHRlbnNpb25zXCIpO1xyXG52YXIgcmVhZHlNYXJrZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3JlYWR5TWFya2VyXCIpO1xyXG52YXIgZW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2VudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXCIpO1xyXG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIGxvY2FsV2luZG93RmFjdG9yeV8xID0gcmVxdWlyZShcIi4vbG9jYWxXaW5kb3dGYWN0b3J5XCIpO1xyXG52YXIgQWN0aXZpdHlNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5TWFuYWdlcihicmlkZ2UsIGF1dG9Bbm5vdW5jZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyXzEuTG9nZ2VyLkdldCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9hbm5vdW5jZWRXaW5kb3dzID0gW107XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlID0gYnJpZGdlO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5VHlwZXMgPSBuZXcgZW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb25fMS5FbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbihmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX2dyYWJFbnRpdHkoZSk7IH0pO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1R5cGVzID0gbmV3IGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9ncmFiRW50aXR5KGUpOyB9KTtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0aWVzID0gbmV3IGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9ncmFiRW50aXR5KGUpOyB9KTtcclxuICAgICAgICB0aGlzLl93aW5kb3dzID0gbmV3IGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9ncmFiRW50aXR5KGUpOyB9KTtcclxuICAgICAgICB0aGlzLl9kYXRhUmVhZHlNYXJrZXIgPSBuZXcgcmVhZHlNYXJrZXJfMS5SZWFkeU1hcmtlcihcIkFjdGl2aXR5IE1hbmFnZXIgRGF0YVwiLCBbXCJHZXRBY3Rpdml0eVR5cGVzXCIsIFwiR2V0V2luZG93VHlwZXNcIiwgXCJHZXRBY3Rpdml0aWVzXCIsIFwiR2V0V2luZG93c1wiXS5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChhdXRvQW5ub3VuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGFubm91bmNlTWFrZXIgPSBuZXcgcmVhZHlNYXJrZXJfMS5SZWFkeU1hcmtlcihcIkFjdGl2aXR5IE1hbmFnZXIgQW5ub3VuY2VcIiwgW1wiQW5ub3VuY2VtZW50XCJdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5TWFya2VyID0gYW5ub3VuY2VNYWtlcjtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YVJlYWR5TWFya2VyLnNldENhbGxiYWNrKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJBdXRvIGFubm91bmNpbmcgd2luZG93XCIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYW5ub3VuY2VXaW5kb3coKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Fubm91bmNlZFdpbmRvd3MucHVzaCh3KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuc2lnbmFsKFwiU3VjY2Vzc2Z1bGx5IGFubm91bmNlZCB3aW5kb3cgd2l0aCBpZCAnXCIgKyB3LmlkICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJXaWxsIG5vdCBhbm5vdW5jZSB3aW5kb3cgLSBcIiArIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlYWR5TWFya2VyLnNpZ25hbCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlNYXJrZXIgPSB0aGlzLl9kYXRhUmVhZHlNYXJrZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgIC5yZWFkeSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhdykge1xyXG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaWJlRm9yRGF0YSgpO1xyXG4gICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZSwgXCJhbm5vdW5jZWRXaW5kb3dzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fubm91bmNlZFdpbmRvd3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbGxvd2VkXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZWFkeU1hcmtlci5zZXRDYWxsYmFjayhmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF90aGlzLl9yZWFkeU1hcmtlci5nZXRFcnJvcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRBY3Rpdml0eVR5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpdml0eVR5cGVzLmdldCgpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuZ2V0QWN0aXZpdHlUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZpdHlUeXBlcy5nZXRCeU5hbWUobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlckFjdGl2aXR5VHlwZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVR5cGVOYW1lLCBvd25lcldpbmRvd1R5cGUsIGhlbHBlcldpbmRvd1R5cGVzLCBsYXlvdXRDb25maWcsIGRlc2NyaXB0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5VHlwZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJhY3Rpdml0eVR5cGVOYW1lIGFyZ3VtZW50IGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhhY3Rpdml0eVR5cGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiYWN0aXZpdHlUeXBlTmFtZSBzaG91bGQgYmUgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhY3RUeXBlID0gX3RoaXMuZ2V0QWN0aXZpdHlUeXBlKGFjdGl2aXR5VHlwZU5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIkFjdGl2aXR5IHR5cGUgJ1wiICsgYWN0aXZpdHlUeXBlTmFtZSArIFwiJyBhbHJlYWR5IGV4aXN0c1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb3duZXJEZWZpbml0aW9uO1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChvd25lcldpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJPd25lciB3aW5kb3cgdHlwZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhvd25lcldpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBvd25lckRlZmluaXRpb24gPSB7IHR5cGU6IG93bmVyV2luZG93VHlwZSwgbmFtZTogXCJcIiwgaXNJbmRlcGVuZGVudDogZmFsc2UsIGFyZ3VtZW50czoge30gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG93bmVyRGVmaW5pdGlvbiA9IG93bmVyV2luZG93VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaGVscGVyRGVmaW5pdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGhlbHBlcldpbmRvd1R5cGVzKSAmJiB1dGlsLmlzQXJyYXkoaGVscGVyV2luZG93VHlwZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCBpbiBoZWxwZXJXaW5kb3dUeXBlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaGVscGVyV2luZG93VHlwZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0geyB0eXBlOiBpdGVtLCBuYW1lOiBcIlwiLCBpc0luZGVwZW5kZW50OiBmYWxzZSwgYXJndW1lbnRzOiB7fSwgcmVsYXRpdmVUbzogXCJcIiwgcmVsYXRpdmVEaXJlY3Rpb246IFwiXCIsIHdpbmRvd1N0eWxlQXR0cmlidXRlczoge30gfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyRGVmaW5pdGlvbnMucHVzaChkZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlckRlZmluaXRpb25zLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2VcclxuICAgICAgICAgICAgICAgIC5yZWdpc3RlckFjdGl2aXR5VHlwZShhY3Rpdml0eVR5cGVOYW1lLCBvd25lckRlZmluaXRpb24sIGhlbHBlckRlZmluaXRpb25zLCBsYXlvdXRDb25maWcsIGRlc2NyaXB0aW9uKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFjdGl2aXR5VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2dyYWJFbnRpdHkoYWN0aXZpdHlUeXBlKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoYWN0aXZpdHlUeXBlKTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnVucmVnaXN0ZXJBY3Rpdml0eVR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgYWN0VHlwZSA9IF90aGlzLmdldEFjdGl2aXR5VHlwZSh0eXBlKTtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoYWN0VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIkFjdGl2aXR5IHR5cGUgJ1wiICsgdHlwZSArIFwiJyBkb2VzIG5vdCBleGlzdHNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9icmlkZ2UudW5yZWdpc3RlckFjdGl2aXR5VHlwZSh0eXBlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmluaXRpYXRlID0gZnVuY3Rpb24gKGFjdGl2aXR5VHlwZSwgY29udGV4dCwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgYWN0VHlwZSA9IF90aGlzLmdldEFjdGl2aXR5VHlwZShhY3Rpdml0eVR5cGUpO1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChhY3RUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiQWN0aXZpdHkgdHlwZSAnXCIgKyBhY3Rpdml0eVR5cGUgKyBcIicgZG9lcyBub3QgZXhpc3RzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2VcclxuICAgICAgICAgICAgICAgIC5pbml0aWF0ZUFjdGl2aXR5KGFjdGl2aXR5VHlwZSwgY29udGV4dClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhY3RJZCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2aXRpZXNcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0T3JXYWl0KGFjdElkKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGFjdCk7XHJcbiAgICAgICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfSk7XHJcbiAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnN1YnNjcmliZUFjdGl2aXR5VHlwZUV2ZW50cyA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlUeXBlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKGF0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIoYXQsIGNvbnRleHQudHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRXaW5kb3dUeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2luZG93VHlwZXMuZ2V0KCk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRXaW5kb3dUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2luZG93VHlwZXMuZ2V0QnlOYW1lKG5hbWUpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJXaW5kb3dGYWN0b3J5ID0gZnVuY3Rpb24gKHdpbmRvd1R5cGUsIGZhY3RvcnlNZXRob2QsIGRlc2NyaXB0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJubyB3aW5kb3dUeXBlIHNwZWNpZmllZFwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc09iamVjdCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93VHlwZSA9IHdpbmRvd1R5cGUuZ2V0TmFtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlsLmlzU3RyaW5nKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJ3aW5kb3dUeXBlIHNob3VsZCBiZSBzdHJpbmcgb3Igb2JqZWN0IHRoYXQgaGFzIGdldE5hbWUgbWV0aG9kXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gbmV3IGxvY2FsV2luZG93RmFjdG9yeV8xLkxvY2FsV2luZG93RmFjdG9yeShmYWN0b3J5TWV0aG9kLCBkZXNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2VcclxuICAgICAgICAgICAgICAgIC5yZWdpc3RlcldpbmRvd0ZhY3Rvcnkod2luZG93VHlwZSwgZmFjdG9yeSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHYpO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS51bnJlZ2lzdGVyV2luZG93RmFjdG9yeSA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJubyB3aW5kb3dUeXBlIHNwZWNpZmllZFwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIndpbmRvd1R5cGUgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2VcclxuICAgICAgICAgICAgICAgIC51bnJlZ2lzdGVyV2luZG93RmFjdG9yeSh3aW5kb3dUeXBlKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodik7XHJcbiAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldEFjdGl2aXRpZXMgPSBmdW5jdGlvbiAoYWN0aXZpdHlUeXBlKSB7XHJcbiAgICAgICAgdmFyIGFjdCA9IHRoaXMuX2FjdGl2aXRpZXMuZ2V0KCk7XHJcbiAgICAgICAgaWYgKCFhY3Rpdml0eVR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHR5cGVzID0gYWN0aXZpdHlUeXBlO1xyXG4gICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGFjdGl2aXR5VHlwZSkpIHtcclxuICAgICAgICAgICAgdHlwZXMgPSBbYWN0aXZpdHlUeXBlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aXZpdHlUeXBlIGluc3RhbmNlb2YgYWN0aXZpdHlUeXBlXzFbJ2RlZmF1bHQnXSkge1xyXG4gICAgICAgICAgICB0eXBlcyA9IFthY3Rpdml0eVR5cGUubmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGl2aXR5VHlwZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IGFyZ3VtZW50ICdhY3Rpdml0eVR5cGUnID0gXCIgKyBhY3Rpdml0eVR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWN0LmZpbHRlcihmdW5jdGlvbiAoYWN0KSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gYWN0LnR5cGU7XHJcbiAgICAgICAgICAgIHJldHVybiB1dGlsLnNvbWUodHlwZXMsIGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5pZCA9PSB0LmlkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldEFjdGl2aXR5QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpdml0aWVzLmdldEJ5TmFtZShpZCk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5hbm5vdW5jZVdpbmRvdyA9IGZ1bmN0aW9uIChhY3Rpdml0eVdpbmRvd0lkLCB3aW5kb3dUeXBlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFubm91bmNlbWVudEluZm8gPSBfdGhpcy5fYnJpZGdlLmdldEFubm91bmNlbWVudEluZm8oKTtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoYWN0aXZpdHlXaW5kb3dJZCkpIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2aXR5V2luZG93SWQgPSBhbm5vdW5jZW1lbnRJbmZvLmFjdGl2aXR5V2luZG93SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvd1R5cGUgPSBhbm5vdW5jZW1lbnRJbmZvLmFjdGl2aXR5V2luZG93VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhbm5vdW5jZSAtIHVua25vd24gd2luZG93VHlwZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChhY3Rpdml0eVdpbmRvd0lkKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZyhcIlJlZ2lzdGVyaW5nIHdpbmRvdyB3aXRoIHR5cGU6J1wiICsgd2luZG93VHlwZSArIFwiJywgbmFtZTonXCIgKyBhbm5vdW5jZW1lbnRJbmZvLmFjdGl2aXR5V2luZG93TmFtZSArIFwiJywgaW5kLjonXCIgKyBhbm5vdW5jZW1lbnRJbmZvLmFjdGl2aXR5V2luZG93SW5kZXBlbmRlbnQgKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYnJpZGdlLnJlZ2lzdGVyV2luZG93KHdpbmRvd1R5cGUsIGFubm91bmNlbWVudEluZm8uYWN0aXZpdHlXaW5kb3dOYW1lLCBhbm5vdW5jZW1lbnRJbmZvLmFjdGl2aXR5V2luZG93SW5kZXBlbmRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oX3RoaXMuX3dpbmRvd3MuZ2V0T3JXYWl0LmJpbmQoX3RoaXMuX3dpbmRvd3MpKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh3KTtcclxuICAgICAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJBbm5vdW5jaW5nIHdpbmRvdyB3aXRoIGlkICdcIiArIGFjdGl2aXR5V2luZG93SWQgKyBcIicgYW5kIHR5cGUgJ1wiICsgd2luZG93VHlwZSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50V2luZG93ID0gX3RoaXMuX3dpbmRvd3MuZ2V0QnlOYW1lKGFjdGl2aXR5V2luZG93SWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGN1cnJlbnRXaW5kb3cpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZyhcIldpbmRvdyB3aXRoIGlkICdcIiArIGFjdGl2aXR5V2luZG93SWQgKyBcIicgYWxyZWFkeSBhbm5vdW5jZWQgLSByZXVzaW5nIHRoZSB3aW5kb3dcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjdXJyZW50V2luZG93KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgd2luZG93RXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGEsIHcsIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZpdHlXaW5kb3dJZCA9PT0gdy5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSA9PT0gXCJqb2luZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2aXR5ID0gdy5hY3Rpdml0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChcIlVOREVGSU5FRCBBQ1RJVklUWVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIudHJhY2UoXCJHb3Qgam9pbmVkIGV2ZW50IGZvciBpZCAnXCIgKyBhY3Rpdml0eVdpbmRvd0lkICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVuc3Vic2NyaWJlV2luZG93RXZlbnRzKHdpbmRvd0V2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlV2luZG93RXZlbnRzKHdpbmRvd0V2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLnRyYWNlKFwiV2FpdGluZyBmb3Igam9pbmVkIGV2ZW50IGZvciBpZCAnXCIgKyBhY3Rpdml0eVdpbmRvd0lkICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2JyaWRnZS5hbm5vdW5jZVdpbmRvdyh3aW5kb3dUeXBlLCBhY3Rpdml0eVdpbmRvd0lkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuc3Vic2NyaWJlV2luZG93VHlwZUV2ZW50cyA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fd2luZG93VHlwZXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh3dCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyKHd0LCBjb250ZXh0LnR5cGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuc3Vic2NyaWJlQWN0aXZpdHlFdmVudHMgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXRpZXMuc3Vic2NyaWJlKGZ1bmN0aW9uIChhY3QsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQudHlwZSA9PT0gZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudFR5cGUuU3RhdHVzQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGFjdCwgcC5uZXdTdGF0dXMsIHAub2xkU3RhdHVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuc3Vic2NyaWJlV2luZG93RXZlbnRzID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl93aW5kb3dzLnN1YnNjcmliZShmdW5jdGlvbiAod2luZG93LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5V2luZG93RXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIod2luZG93LmFjdGl2aXR5LCB3aW5kb3csIHAuZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS51bnN1YnNjcmliZVdpbmRvd0V2ZW50cyA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVXaW5kb3cgPSBmdW5jdGlvbiAoYWN0aXZpdHksIHdpbmRvd1R5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJhY3Rpdml0eSBpcyB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIndpbmRvd1R5cGUgaXMgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dEZWZpbml0aW9uO1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93RGVmaW5pdGlvbiA9IHsgdHlwZTogd2luZG93VHlwZSwgbmFtZTogXCJcIiwgaXNJbmRlcGVuZGVudDogZmFsc2UsIGFyZ3VtZW50czoge30gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvd0RlZmluaXRpb24gPSB3aW5kb3dUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVRvV2luZG93O1xyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwod2luZG93RGVmaW5pdGlvbi5yZWxhdGl2ZVRvKSkge1xyXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUb1dpbmRvdyA9IHdpbmRvd0RlZmluaXRpb24ucmVsYXRpdmVUbztcclxuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlVG9XaW5kb3cpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd3MgPSBfdGhpcy5nZXRXaW5kb3dzKHsgdHlwZTogcmVsYXRpdmVUb1dpbmRvdyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwod2luZG93cykgJiYgd2luZG93cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0RlZmluaXRpb24ucmVsYXRpdmVUbyA9IHdpbmRvd3NbMF0uaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwocmVsYXRpdmVUb1dpbmRvdy50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5kb3dzID0gX3RoaXMuZ2V0V2luZG93cyh7IHR5cGU6IHJlbGF0aXZlVG9XaW5kb3cudHlwZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwod2luZG93cykgJiYgd2luZG93cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0RlZmluaXRpb24ucmVsYXRpdmVUbyA9IHdpbmRvd3NbMF0uaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwocmVsYXRpdmVUb1dpbmRvdy53aW5kb3dJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dEZWZpbml0aW9uLnJlbGF0aXZlVG8gPSByZWxhdGl2ZVRvV2luZG93LndpbmRvd0lkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2UuY3JlYXRlV2luZG93KGFjdGl2aXR5LmlkLCB3aW5kb3dEZWZpbml0aW9uKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHdpZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpbmRvdyA9IF90aGlzLl93aW5kb3dzLmdldEJ5TmFtZSh3aWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKHdpbmRvdykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKFwiV2luZG93IGNyZWF0ZWQsIHdhaXRpbmcgZm9yIHdpbmRvdyBlbnRpdHkgd2l0aCBpZCBcIiArIHdpZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uICh3aW5kb3csIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmlkID09PSB3aWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiR290IGVudGl0eSB3aW5kb3cgd2l0aCBpZCBcIiArIHdpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUod2luZG93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2luZG93cy51bnN1YnNjcmliZShoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3dpbmRvd3Muc3Vic2NyaWJlKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5qb2luV2luZG93VG9BY3Rpdml0eSA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgd2luZG93LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5sZWF2ZVdpbmRvd0Zyb21BY3Rpdml0eSA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgd2luZG93LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zZXRBY3Rpdml0eUNvbnRleHQgPSBmdW5jdGlvbiAoYWN0aXZpdHksIGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJhY3Rpdml0eSBjYW4gbm90IGJlIG51bGxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUFjdGl2aXR5Q29udGV4dChhY3Rpdml0eSwgY29udGV4dCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUob2JqKTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUudXBkYXRlQWN0aXZpdHlDb250ZXh0ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCBjb250ZXh0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiYWN0aXZpdHkgY2FuIG5vdCBiZSBudWxsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVkS2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjb250ZXh0W2tleV0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUFjdGl2aXR5Q29udGV4dChhY3Rpdml0eSwgY29udGV4dCwgZmFsc2UsIHJlbW92ZWRLZXlzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShvYmopO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpdml0eUNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0aWVzLnN1YnNjcmliZShmdW5jdGlvbiAoYWN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5Q29udGV4dENoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcihhY3QsIHVwZGF0ZUNvbnRleHQuY29udGV4dCwgdXBkYXRlQ29udGV4dC51cGRhdGVkLCB1cGRhdGVDb250ZXh0LnJlbW92ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wQWN0aXZpdHkgPSBmdW5jdGlvbiAoYWN0aXZpdHksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9icmlkZ2Uuc3RvcEFjdGl2aXR5KGFjdGl2aXR5KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldFdpbmRvd3MgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoZmlsdGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2luZG93cy5nZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGZpbHRlci5pZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl93aW5kb3dzLmdldEJ5TmFtZShmaWx0ZXIuaWQpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFsbFdpbmRvd3MgPSB0aGlzLl93aW5kb3dzLmdldCgpO1xyXG4gICAgICAgIHJldHVybiBhbGxXaW5kb3dzLmZpbHRlcihmdW5jdGlvbiAodykge1xyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZmlsdGVyLnR5cGUpICYmIHcudHlwZS5pZCAhPT0gZmlsdGVyLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZmlsdGVyLm5hbWUpICYmIHcubmFtZSAhPT0gZmlsdGVyLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZmlsdGVyLmFjdGl2aXR5SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3LmFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh3LmFjdGl2aXR5LmlkICE9PSBmaWx0ZXIuYWN0aXZpdHlJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLl9ncmFiRW50aXR5ID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgIGVudGl0eS5tYW5hZ2VyID0gdGhpcztcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLl9zdWJzY3JpYmVGb3JEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiU3RhcnQgZ2V0dGluZyBpbml0aWFsIGRhdGEuLi5cIik7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlLm9uQWN0aXZpdHlUeXBlU3RhdHVzQ2hhbmdlKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdHlUeXBlcy5wcm9jZXNzKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2UuZ2V0QWN0aXZpdHlUeXBlcygpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdHlUeXBlcy5hZGQoYXQpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLnNpZ25hbChcIkdvdCBhY3QgdHlwZXNcIik7XHJcbiAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLmVycm9yKFwiQ2FuIG5vdCBpbml0aWFsaXplIEFjdGl2aXR5TWFuYWdlciAtIGVycm9yIGdldHRpbmcgYWN0aXZpdHkgdHlwZXMgLVwiICsgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5vbldpbmRvd1R5cGVTdGF0dXNDaGFuZ2UoZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl93aW5kb3dUeXBlcy5wcm9jZXNzKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2UuZ2V0V2luZG93VHlwZXMoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAod3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3dpbmRvd1R5cGVzLmFkZCh3dCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuc2lnbmFsKFwiR290IHdpbmRvdyB0eXBlc1wiKTtcclxuICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpemUgQWN0aXZpdHlNYW5hZ2VyIC0gZXJyb3IgZ2V0dGluZyB3aW5kb3cgdHlwZXMgIFwiICsgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5vbkFjdGl2aXR5U3RhdHVzQ2hhbmdlKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdGllcy5wcm9jZXNzKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2UuZ2V0QWN0aXZpdGllcygpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhYykge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdGllcy5hZGQoYWMpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLnNpZ25hbChcIkdvdCBhY3Rpdml0aWVzXCIpO1xyXG4gICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgX3RoaXMuX2RhdGFSZWFkeU1hcmtlci5lcnJvcihcIkNhbiBub3QgaW5pdGlhbGl6ZSBBY3Rpdml0eU1hbmFnZXIgLSBlcnJvciBnZXR0aW5nIGFjdGl2aXR5IGluc3RhbmNlcyAtXCIgKyBlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlLm9uQWN0aXZpdHlXaW5kb3dDaGFuZ2UoZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl93aW5kb3dzLnByb2Nlc3MoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5nZXRBY3Rpdml0eVdpbmRvd3MoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYXcpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3dpbmRvd3MuYWRkKGF3KTtcclxuICAgICAgICAgICAgX3RoaXMuX2RhdGFSZWFkeU1hcmtlci5zaWduYWwoXCJHb3Qgd2luZG93c1wiKTtcclxuICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpemUgQWN0aXZpdHlNYW5hZ2VyIC0gZXJyb3IgZ2V0dGluZyBhY3Rpdml0eSB3aW5kb3dzIC1cIiArIGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldFdpbmRvd0JvdW5kcyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9icmlkZ2UuZ2V0V2luZG93Qm91bmRzKGlkKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnNldFdpbmRvd0JvdW5kcyA9IGZ1bmN0aW9uIChpZCwgYm91bmRzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2Uuc2V0V2luZG93Qm91bmRzKGlkLCBib3VuZHMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmNsb3NlV2luZG93ID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JyaWRnZS5jbG9zZVdpbmRvdyhpZCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5TWFuYWdlcjtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5TWFuYWdlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlNYW5hZ2VyLmpzLm1hcCIsInZhciBMb2NhbFdpbmRvd0ZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9jYWxXaW5kb3dGYWN0b3J5KGNyZWF0ZUZ1bmN0aW9uLCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUZ1bmN0aW9uID0gY3JlYXRlRnVuY3Rpb247XHJcbiAgICAgICAgdGhpcy5fZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcclxuICAgIH1cclxuICAgIExvY2FsV2luZG93RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGFjdGl2aXR5V2luZG93SWQsIGNvbnRleHQsIGxheW91dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVGdW5jdGlvbihhY3Rpdml0eVdpbmRvd0lkLCBjb250ZXh0LCBsYXlvdXQpO1xyXG4gICAgfTtcclxuICAgIExvY2FsV2luZG93RmFjdG9yeS5wcm90b3R5cGUuZGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2NyaXB0aW9uO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMb2NhbFdpbmRvd0ZhY3Rvcnk7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTG9jYWxXaW5kb3dGYWN0b3J5ID0gTG9jYWxXaW5kb3dGYWN0b3J5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbFdpbmRvd0ZhY3RvcnkuanMubWFwIiwidmFyIFByb3h5V2luZG93RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm94eVdpbmRvd0ZhY3RvcnkoZGVzY3JpcHRpb24pIHtcclxuICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG4gICAgfVxyXG4gICAgUHJveHlXaW5kb3dGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoYWN0aXZpdHlXaW5kb3dJZCwgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgUHJveHlXaW5kb3dGYWN0b3J5LnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVzY3JpcHRpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByb3h5V2luZG93RmFjdG9yeTtcclxufSkoKTtcclxuZXhwb3J0cy5Qcm94eVdpbmRvd0ZhY3RvcnkgPSBQcm94eVdpbmRvd0ZhY3Rvcnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3h5V2luZG93RmFjdG9yeS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYWN0aXZpdHlFbnRpdHlfMSA9IHJlcXVpcmUoXCIuL2FjdGl2aXR5RW50aXR5XCIpO1xyXG52YXIgYWN0aXZpdHlBR01fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2FjdGl2aXR5QUdNXCIpO1xyXG52YXIgQWN0aXZpdHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFjdGl2aXR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHkoaWQsIGFjdFR5cGUsIHN0YXR1cywgY29udGV4dCwgb3duZXIsIGhlbHBlcldpbmRvd3MpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBpZCk7XHJcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcclxuICAgICAgICB0aGlzLl9hY3RUeXBlID0gYWN0VHlwZTtcclxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fb3duZXIgPSBvd25lcjtcclxuICAgICAgICB0aGlzLl9oZWxwZXJXaW5kb3dzID0gaGVscGVyV2luZG93cztcclxuICAgICAgICB0aGlzLl9hZ20gPSBuZXcgYWN0aXZpdHlBR01fMS5BY3Rpdml0eUFHTSh0aGlzKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0QWN0aXZpdHlUeXBlKHRoaXMuX2FjdFR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHkucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwib3duZXJcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3duZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHkucHJvdG90eXBlLCBcIndpbmRvd3NcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldFdpbmRvd3MoeyBhY3Rpdml0eUlkOiB0aGlzLl9pZCB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwiYWdtXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FnbTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHdpbmRvdywgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmpvaW5XaW5kb3dUb0FjdGl2aXR5KHRoaXMsIHdpbmRvdywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5jcmVhdGVXaW5kb3cgPSBmdW5jdGlvbiAod2luZG93VHlwZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmNyZWF0ZVdpbmRvdyh0aGlzLCB3aW5kb3dUeXBlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKHdpbmRvdywgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmxlYXZlV2luZG93RnJvbUFjdGl2aXR5KHRoaXMsIHdpbmRvdywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5nZXRXaW5kb3dzQnlUeXBlID0gZnVuY3Rpb24gKHdpbmRvd1R5cGUpIHtcclxuICAgICAgICB2YXIgZmlsdGVyID0geyBhY3Rpdml0eUlkOiB0aGlzLl9pZCwgdHlwZTogd2luZG93VHlwZSB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93cyhmaWx0ZXIpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5zZXRBY3Rpdml0eUNvbnRleHQodGhpcywgY29udGV4dCwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci51cGRhdGVBY3Rpdml0eUNvbnRleHQodGhpcywgY29udGV4dCwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5vblN0YXR1c0NoYW5nZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc3Vic2NyaWJlQWN0aXZpdHlFdmVudHMoZnVuY3Rpb24gKGEsIG5zLCBvcykge1xyXG4gICAgICAgICAgICBpZiAoYS5pZCA9PT0gX3RoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoYSwgbnMsIG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5vbldpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5zdWJzY3JpYmVXaW5kb3dFdmVudHMoZnVuY3Rpb24gKGEsIHcsIGUpIHtcclxuICAgICAgICAgICAgaWYgKGEuaWQgPT09IF90aGlzLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGEsIHcsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnN1YnNjcmliZUFjdGl2aXR5Q29udGV4dENoYW5nZWQoZnVuY3Rpb24gKGFjdCwgY29udGV4dCwgZGVsdGEsIHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgaWYgKGFjdC5pZCA9PT0gX3RoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoY29udGV4dCwgZGVsdGEsIHJlbW92ZWQsIGFjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBoYW5kbGVyKHRoaXMuY29udGV4dCwgdGhpcy5jb250ZXh0LCBbXSwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnN0b3BBY3Rpdml0eSh0aGlzKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUudXBkYXRlQ29yZSA9IGZ1bmN0aW9uIChhY3Rpdml0eSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlQ29yZS5jYWxsKHRoaXMsIGFjdGl2aXR5KTtcclxuICAgICAgICB0aGlzLl9hY3RUeXBlID0gYWN0aXZpdHkuX2FjdFR5cGU7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGFjdGl2aXR5Ll9jb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IGFjdGl2aXR5Ll9zdGF0dXM7XHJcbiAgICAgICAgdGhpcy5faGVscGVyV2luZG93cyA9IGFjdGl2aXR5Ll9oZWxwZXJXaW5kb3dzO1xyXG4gICAgICAgIHRoaXMuX293bmVyID0gYWN0aXZpdHkuX293bmVyO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eTtcclxufSkoYWN0aXZpdHlFbnRpdHlfMVsnZGVmYXVsdCddKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eS5qcy5tYXAiLCJ2YXIgQWN0aXZpdHlFbnRpdHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlFbnRpdHkoaWQpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLCBcImlkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLm9uVXBkYXRlZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUVudGl0eS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyLl9pZCAhPSB0aGlzLl9pZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbiBub3QgdXBkYXRlIGZyb20gZW50aXR5IHdpdGggZGlmZmVyZW50IGlkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVDb3JlKG90aGVyKTtcclxuICAgICAgICB0aGlzLm5vdGlmeSgpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5RW50aXR5LnByb3RvdHlwZS51cGRhdGVDb3JlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMubGlzdGVuZXJzW2luZGV4XTtcclxuICAgICAgICAgICAgbGlzdGVuZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eUVudGl0eTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5RW50aXR5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eUVudGl0eS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYWN0aXZpdHlFbnRpdHlfMSA9IHJlcXVpcmUoXCIuL2FjdGl2aXR5RW50aXR5XCIpO1xyXG52YXIgQWN0aXZpdHlUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBY3Rpdml0eVR5cGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eVR5cGUobmFtZSwgb3duZXJXaW5kb3csIGhlbHBlcldpbmRvd3MsIGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbmFtZSk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5fZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcclxuICAgICAgICB0aGlzLl9vd25lcldpbmRvdyA9IG93bmVyV2luZG93O1xyXG4gICAgICAgIHRoaXMuX2hlbHBlcldpbmRvd3MgPSBoZWxwZXJXaW5kb3dzIHx8IFtdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5VHlwZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5VHlwZS5wcm90b3R5cGUsIFwiZGVzY3JpcHRpb25cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzY3JpcHRpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlUeXBlLnByb3RvdHlwZSwgXCJoZWxwZXJXaW5kb3dzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlbHBlcldpbmRvd3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlUeXBlLnByb3RvdHlwZSwgXCJvd25lcldpbmRvd1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vd25lcldpbmRvdztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFjdGl2aXR5VHlwZS5wcm90b3R5cGUuc3Vic2NyaWJlQWN0aXZpdHlTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlUeXBlLnByb3RvdHlwZS5pbml0aWF0ZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuaW5pdGlhdGUodGhpcy5fbmFtZSwgY29udGV4dCwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5VHlwZS5wcm90b3R5cGUudXBkYXRlQ29yZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVDb3JlLmNhbGwodGhpcywgdHlwZSk7XHJcbiAgICAgICAgdGhpcy5fZGVzY3JpcHRpb24gPSB0eXBlLl9kZXNjcmlwdGlvbjtcclxuICAgICAgICB0aGlzLl9vd25lcldpbmRvdyA9IHR5cGUuX293bmVyV2luZG93O1xyXG4gICAgICAgIHRoaXMuX2hlbHBlcldpbmRvd3MgPSB0eXBlLl9oZWxwZXJXaW5kb3dzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eVR5cGU7XHJcbn0pKGFjdGl2aXR5RW50aXR5XzFbJ2RlZmF1bHQnXSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0c1snZGVmYXVsdCddPSBBY3Rpdml0eVR5cGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5VHlwZS5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYWN0aXZpdHlFbnRpdHlfMSA9IHJlcXVpcmUoXCIuL2FjdGl2aXR5RW50aXR5XCIpO1xyXG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIEFjdGl2aXR5V2luZG93ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBY3Rpdml0eVdpbmRvdywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5V2luZG93KGlkLCBuYW1lLCB0eXBlLCBhY3Rpdml0eUlkLCBpbnN0YW5jZSwgaXNJbmRlcGVuZGVudCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGlkKTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXJfMS5Mb2dnZXIuR2V0KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5SWQgPSBhY3Rpdml0eUlkO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgdGhpcy5faXNJbmRlcGVuZGVudCA9IGlzSW5kZXBlbmRlbnQ7XHJcbiAgICB9XHJcbiAgICBBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93Qm91bmRzKHRoaXMuaWQpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUsIFwibmFtZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJpc0luZGVwZW5kZW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5kZXBlbmRlbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLCBcInR5cGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldFdpbmRvd1R5cGUodGhpcy5fdHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUsIFwiYWN0aXZpdHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZCh0aGlzLl9hY3Rpdml0eUlkKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldEFjdGl2aXR5QnlJZCh0aGlzLl9hY3Rpdml0eUlkKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUsIFwiaXNPd25lclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3QgPSB0aGlzLmFjdGl2aXR5O1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChhY3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFjdC5vd25lci5pZCA9PT0gdGhpcy5pZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5zZXRWaXNpYmxlID0gZnVuY3Rpb24gKGlzVmlzaWJsZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uICh0aXRsZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5zZXRCb3VuZHMgPSBmdW5jdGlvbiAoYm91bmRzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuc2V0V2luZG93Qm91bmRzKHRoaXMuaWQsIGJvdW5kcywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmNsb3NlV2luZG93KHRoaXMuaWQpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUsIFwiaW5zdGFuY2VcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUub25BY3Rpdml0eUpvaW5lZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZUZvckFjdGl2aXR5V2luZG93RXZlbnQoXCJqb2luZWRcIiwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5vbkFjdGl2aXR5UmVtb3ZlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZUZvckFjdGl2aXR5V2luZG93RXZlbnQoXCJyZW1vdmVkXCIsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUudXBkYXRlQ29yZSA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5SWQgPSBvdGhlci5fYWN0aXZpdHlJZDtcclxuICAgICAgICB0aGlzLl9pc0luZGVwZW5kZW50ID0gb3RoZXIuX2lzSW5kZXBlbmRlbnQ7XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG90aGVyLl9pbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBvdGhlci5faW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5fc3Vic2NyaWJlRm9yQWN0aXZpdHlXaW5kb3dFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc3Vic2NyaWJlV2luZG93RXZlbnRzKGZ1bmN0aW9uIChhY3Rpdml0eSwgd2luZG93LCBldmVudCkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmlkICE9PSBfdGhpcy5pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhhY3Rpdml0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWN0aXZpdHlXaW5kb3c7XHJcbn0pKGFjdGl2aXR5RW50aXR5XzFbJ2RlZmF1bHQnXSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0c1snZGVmYXVsdCddPSBBY3Rpdml0eVdpbmRvdztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlXaW5kb3cuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFjdGl2aXR5RW50aXR5XzEgPSByZXF1aXJlKFwiLi9hY3Rpdml0eUVudGl0eVwiKTtcclxudmFyIFdpbmRvd1R5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFdpbmRvd1R5cGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBXaW5kb3dUeXBlKG5hbWUsIGZhY3Rvcmllcykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2ZhY3RvcmllcyA9IGZhY3RvcmllcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaW5kb3dUeXBlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2luZG93VHlwZS5wcm90b3R5cGUsIFwiZmFjdG9yaWVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY3RvcmllcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaW5kb3dUeXBlLnByb3RvdHlwZSwgXCJ3aW5kb3dzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRXaW5kb3dzKHsgdHlwZTogdGhpcy5fbmFtZSB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFdpbmRvd1R5cGUucHJvdG90eXBlLnJlZ2lzdGVyRmFjdG9yeSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBmYWN0b3J5TWV0aG9kLCBkZXNjcmlwdGlvbiwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLnJlZ2lzdGVyV2luZG93RmFjdG9yeSh0aGlzLCBmYWN0b3J5TWV0aG9kLCBkZXNjcmlwdGlvbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdpbmRvd1R5cGU7XHJcbn0pKGFjdGl2aXR5RW50aXR5XzFbJ2RlZmF1bHQnXSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0c1snZGVmYXVsdCddPSBXaW5kb3dUeXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dUeXBlLmpzLm1hcCIsInZhciBlbnRpdHlFdmVudF8xID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0cy9lbnRpdHlFdmVudFwiKTtcclxudmFyIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uKHByb2Nlc3NOZXcpIHtcclxuICAgICAgICB0aGlzLl9pdGVtcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NOZXcgPSBwcm9jZXNzTmV3O1xyXG4gICAgfVxyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZE9uZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5hZGQoW2l0ZW1dKTtcclxuICAgIH07XHJcbiAgICBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW1zKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGl0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGl0ZW1zW2luZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKG5ldyBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50KGVsZW1lbnQsIG5ldyBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50Q29udGV4dChlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5BZGRlZCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IGV2ZW50LmNvbnRleHQ7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBjb250ZXh0LnR5cGU7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IGV2ZW50LmVudGl0eTtcclxuICAgICAgICB2YXIgaW50ZXJuYWxFbnRpdHkgPSB0aGlzLl91cGRhdGVJbnRlcm5hbENvbGxlY3Rpb25zKGVudGl0eSwgdHlwZSk7XHJcbiAgICAgICAgdGhpcy5fbm90aWZ5TGlzdGVuZXJzKGludGVybmFsRW50aXR5LCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5faXRlbXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5faXRlbXNba2V5XTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE9yV2FpdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgdmFyIGVudGl0eUFkZGVkSGFuZGxlciA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbnRpdHkuaWQgIT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy51bnN1YnNjcmliZShlbnRpdHlBZGRlZEhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5zdWJzY3JpYmUoZW50aXR5QWRkZWRIYW5kbGVyKTtcclxuICAgICAgICAgICAgdmFyIHdpbmRvdyA9IF90aGlzLmdldEJ5TmFtZShuYW1lKTtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh3aW5kb3cpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5faXRlbXNba2V5XTtcclxuICAgICAgICAgICAgaGFuZGxlcihlbGVtZW50LCBuZXcgZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudENvbnRleHQoZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudFR5cGUuQWRkZWQudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLl9ub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZW50aXR5LCBjb250ZXh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5fbGlzdGVuZXJzW2luZGV4XTtcclxuICAgICAgICAgICAgbGlzdGVuZXIoZW50aXR5LCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLl91cGRhdGVJbnRlcm5hbENvbGxlY3Rpb25zID0gZnVuY3Rpb24gKGVudGl0eSwgdHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlID09PSBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5SZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pdGVtc1tlbnRpdHkuaWRdO1xyXG4gICAgICAgICAgICByZXR1cm4gZW50aXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGVudGl0eS5pZDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzTmV3KGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtc1tlbnRpdHkuaWRdID0gZW50aXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXNbZW50aXR5LmlkXS51cGRhdGUoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbZW50aXR5LmlkXTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb247XHJcbn0pKCk7XHJcbmV4cG9ydHMuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24gPSBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24uanMubWFwIiwidmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xyXG52YXIgTG9nTGV2ZWwgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9nTGV2ZWwoKSB7XHJcbiAgICB9XHJcbiAgICBMb2dMZXZlbC5UcmFjZSA9IFwidHJhY2VcIjtcclxuICAgIExvZ0xldmVsLkRlYnVnID0gXCJkZWJ1Z1wiO1xyXG4gICAgTG9nTGV2ZWwuSW5mbyA9IFwiaW5mb1wiO1xyXG4gICAgTG9nTGV2ZWwuV2FybiA9IFwid2FyblwiO1xyXG4gICAgTG9nTGV2ZWwuRXJyb3IgPSBcImVycm9yXCI7XHJcbiAgICByZXR1cm4gTG9nTGV2ZWw7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTG9nTGV2ZWwgPSBMb2dMZXZlbDtcclxudmFyIExvZ2dlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSkge1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChMb2dnZXIuR2x1ZUxvZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2x1ZUxvZ2dlciA9IExvZ2dlci5HbHVlTG9nZ2VyLnN1YkxvZ2dlcihuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBMb2dnZXIuR2V0TmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKG5hbWUpO1xyXG4gICAgfTtcclxuICAgIExvZ2dlci5HZXQgPSBmdW5jdGlvbiAob3duZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcihMb2dnZXIuR2V0VHlwZU5hbWUob3duZXIpKTtcclxuICAgIH07XHJcbiAgICBMb2dnZXIucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fZ2x1ZUxvZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2x1ZUxvZ2dlci50cmFjZShtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLlRyYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8odGhpcy5fZ2V0TWVzc2FnZShtZXNzYWdlLCBMb2dMZXZlbC5UcmFjZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLl9nbHVlTG9nZ2VyKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbHVlTG9nZ2VyLmRlYnVnKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuRGVidWcgfHxcclxuICAgICAgICAgICAgICAgIExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuVHJhY2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyh0aGlzLl9nZXRNZXNzYWdlKG1lc3NhZ2UsIExvZ0xldmVsLkRlYnVnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9nZ2VyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fZ2x1ZUxvZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2x1ZUxvZ2dlci5pbmZvKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuRGVidWcgfHxcclxuICAgICAgICAgICAgICAgIExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuVHJhY2UgfHxcclxuICAgICAgICAgICAgICAgIExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuSW5mbykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKHRoaXMuX2dldE1lc3NhZ2UobWVzc2FnZSwgTG9nTGV2ZWwuSW5mbykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuX2dsdWVMb2dnZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsdWVMb2dnZXIud2FybihtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLkRlYnVnIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLlRyYWNlIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLkluZm8gfHxcclxuICAgICAgICAgICAgICAgIExvZ2dlci5MZXZlbCA9PT0gTG9nTGV2ZWwuV2Fybikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKHRoaXMuX2dldE1lc3NhZ2UobWVzc2FnZSwgTG9nTGV2ZWwuSW5mbykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLl9nbHVlTG9nZ2VyKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbHVlTG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLl9nZXRNZXNzYWdlKG1lc3NhZ2UsIExvZ0xldmVsLkVycm9yKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9nZ2VyLnByb3RvdHlwZS5fZ2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBsZXZlbCkge1xyXG4gICAgICAgIHJldHVybiBcIltcIiArIGxldmVsICsgXCJdIFwiICsgdGhpcy5fbmFtZSArIFwiIC0gXCIgKyBtZXNzYWdlO1xyXG4gICAgfTtcclxuICAgIExvZ2dlci5HZXRUeXBlTmFtZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcclxuICAgICAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvbiAoLnsxLH0pXFwoLztcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IChmdW5jTmFtZVJlZ2V4KS5leGVjKG9iamVjdC5jb25zdHJ1Y3Rvci50b1N0cmluZygpKTtcclxuICAgICAgICByZXR1cm4gKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGggPiAxKSA/IHJlc3VsdHNbMV0gOiBcIlwiO1xyXG4gICAgfTtcclxuICAgIExvZ2dlci5MZXZlbCA9IExvZ0xldmVsLkluZm87XHJcbiAgICByZXR1cm4gTG9nZ2VyO1xyXG59KSgpO1xyXG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLmpzLm1hcCIsInZhciB1dGlsID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIG5leHRUaWNrID0gZnVuY3Rpb24gKGNiKSB7IHNldFRpbWVvdXQoY2IsIDApOyB9O1xyXG5mdW5jdGlvbiBub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIXV0aWwuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzcCkge1xyXG4gICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzcCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5ub2RlaWZ5ID0gbm9kZWlmeTtcclxuO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlRXh0ZW5zaW9ucy5qcy5tYXAiLCJ2YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIFJlYWR5TWFya2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlYWR5TWFya2VyKG5hbWUsIHNpZ25hbHNUb1dhaXQpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXJfMS5Mb2dnZXIuR2V0TmFtZWQoXCJSZWFkeU1hcmtlciBbXCIgKyBuYW1lICsgXCJdXCIpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIkluaXRpYWxpemluZyByZWFkeSBtYXJrZXIgZm9yICdcIiArIG5hbWUgKyBcIicgd2l0aCBcIiArIHNpZ25hbHNUb1dhaXQgKyBcIiBzaWduYWxzIHRvIHdhaXRcIik7XHJcbiAgICAgICAgaWYgKHNpZ25hbHNUb1dhaXQgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hbCBudW1iZXIuIFNob3VsZCBiZSA+IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NpZ25hbHMgPSBzaWduYWxzVG9XYWl0O1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgfVxyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLnNldENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTZXQoKSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNFcnJvcigpKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuX2Vycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiU2lnbmFsZWQgLSBcIiArIG1lc3NhZ2UgKyBcIiAtIHNpZ25hbHMgbGVmdCBcIiArICh0aGlzLl9zaWduYWxzIC0gMSkpO1xyXG4gICAgICAgIHRoaXMuX3NpZ25hbHMtLTtcclxuICAgICAgICBpZiAodGhpcy5fc2lnbmFscyA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gcmVhZHkgbWFya2VyICdcIiArIHRoaXMuX25hbWUgKyBcIiAtIHNpZ25hbHMgYXJlIFwiICsgdGhpcy5fc2lnbmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzU2V0KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSZWFkeU1hcmtlci5wcm90b3R5cGUuaXNTZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFcnJvcigpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbHMgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF1dGlsLmlzVW5kZWZpbmVkKHRoaXMuX2Vycm9yKTtcclxuICAgIH07XHJcbiAgICBSZWFkeU1hcmtlci5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWFkeU1hcmtlcjtcclxufSkoKTtcclxuZXhwb3J0cy5SZWFkeU1hcmtlciA9IFJlYWR5TWFya2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkeU1hcmtlci5qcy5tYXAiLCIvLyBzb21lIHNtYWxsIHVzZWZ1bCBmdW5jdGlvbnMgKHNvIHdlIGRvbid0IHJlZmVyZW5jZSB1bmRlcnNjb3JlIG9yIGxvZGFzaClcclxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XHJcbn1cclxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xyXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcclxufVxyXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcclxufVxyXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XHJcbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG59XHJcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XHJcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xyXG59XHJcbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcclxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwoYXJnKSB7XHJcbiAgICByZXR1cm4gIWFyZyB8fCB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcclxufVxyXG5leHBvcnRzLmlzVW5kZWZpbmVkT3JOdWxsID0gaXNVbmRlZmluZWRPck51bGw7XHJcbmZ1bmN0aW9uIGlzRW1wdHkoYXJnKSB7XHJcbiAgICBmb3IgKHZhciBwcm9wIGluIGFyZykge1xyXG4gICAgICAgIGlmIChhcmcuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XHJcbiAgICByZXR1cm4gISEoYXJnICYmIGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY2FsbCAmJiBhcmcuYXBwbHkpO1xyXG59XHJcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XHJcbjtcclxuZnVuY3Rpb24gc29tZShhcnJheSwgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5zb21lID0gc29tZTtcclxuZnVuY3Rpb24gZmlyc3QoYXJyYXksIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmV4cG9ydHMuZmlyc3QgPSBmaXJzdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJ2YXIgY29ubmVjdGlvbiA9IHJlcXVpcmUoXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCIpO1xyXG52YXIgY2xpZW50ID0gcmVxdWlyZShcIi4vYWdtX2NsaWVudFwiKTtcclxudmFyIHNlcnZlciA9IHJlcXVpcmUoXCIuL2FnbV9zZXJ2ZXJcIik7IFxyXG52YXIgaW5zdGFuY2UgPSByZXF1aXJlKFwiLi9hZ21faW5zdGFuY2VcIik7XHJcbnZhciBuYXRpdmVfYWdtID0gcmVxdWlyZShcIi4vYWdtX25hdGl2ZVwiKTtcclxuLy92YXIgYWRkX3N1Z2FyPSByZXF1aXJlKFwiLi9hZ21fc3VnYXJcIik7XHJcbi8vSW5pdCBuYW1lc3BhY2UgaWYgbm90IGFscmVhZHkgdGhlcmUgXHJcblxyXG5cclxuXHJcbi8vQWRkIGEgZ2xvYmFsIGZ1bmN0aW9uIHRoYXQgbWFrZXMgYW4gQUdNIGluc3RhbmNlXHJcbmFnbSA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pe1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdFxyXG5cdC8vV2Ugd2lsbCBzdG9yZSB0aGUgbGlicmFyeSBoZXJlXHJcblx0dmFyIGFnbSA9IHt9O1xyXG4gICAgXHJcblx0YWdtLnZlcnNpb24gPSBcIjIuMS4xXCI7XHJcblx0XHJcblx0Ly9Jbml0IGRlYnVnXHJcblx0aWYodHlwZW9mIGNvbmZpZ3VyYXRpb24hPT1cIm9iamVjdFwiKXtjb25maWd1cmF0aW9uID0ge307fVxyXG4gICBcclxuICAgXHQvL0luaXQgY2hpbGQgY29uZmlndXJhdGlvbiBpZiBpdCBpcyBub3QgYWxyZWFkeSBwYXNzZWQgYnkgdXNlclxyXG4gICBcdHZhciBjaGlsZF9jb25maWd1cmF0aW9ucyA9IFtcImNvbm5lY3Rpb25cIiwgXCJjbGllbnRcIiwgXCJzZXJ2ZXJcIl07XHJcblx0Y2hpbGRfY29uZmlndXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihjb25mKXtcclxuXHRcdGlmKHR5cGVvZiBjb25maWd1cmF0aW9uW2NvbmZdIT09XCJvYmplY3RcIil7Y29uZmlndXJhdGlvbltjb25mXSA9IHt9O31cclxuXHRcdC8vU2V0IGRlYnVnIGlmIGdsb2JhbCBkZWJ1ZyBpcyBub3Qgc2V0OlxyXG5cdFx0aWYoY29uZmlndXJhdGlvbi5kZWJ1Zyl7Y29uZmlndXJhdGlvbltjb25mXS5kZWJ1ZyA9IHRydWU7fVxyXG5cdH0pO1xyXG5cdFxyXG5cdC8vSW5pdCBjb25uZWN0aW9uXHJcblx0dmFyIGMgPSBjb25maWd1cmF0aW9uLmNvbm5lY3Rpb247XHJcbiAgXHQvL0RldGVybWluZSBpZiB3ZSBhcmUgZ2l2ZW4gYSBjb25uZWN0aW9uIG9iamVjdC4gSWYgbm90LCBjcmVhdGUgaXQgb3Vyc2VsdmVzOlxyXG5cdGFnbS5jb25uZWN0aW9uID0odHlwZW9mIGM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgYy5zZW5kPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgYy5vbiA9PT1cImZ1bmN0aW9uXCIpP2M6Y29ubmVjdGlvbihjb25maWd1cmF0aW9uLmNvbm5lY3Rpb24pO1xyXG5cdFxyXG5cdC8vQ3JlYXRlIGEgY29ubmVjdGlvbiBwcm94eSB3aGljaCBzZXRzIHRoZSBwcm9kdWN0IG5hbWUgYXV0b21hdGljYWxseVxyXG5cdHZhciBwcm9kdWN0X25hbWUgPSBcImFnbVwiO1xyXG5cdHZhciBhZ21fZW5hYmxlZF9jb25uZWN0aW9uID0ge1xyXG4gICAgc2VuZDpmdW5jdGlvbih0eXBlLCBtZXNzYWdlKXtcclxuICAgICAgICBhZ20uY29ubmVjdGlvbi5zZW5kKHByb2R1Y3RfbmFtZSwgdHlwZSwgbWVzc2FnZSk7XHJcbiAgICB9LFxyXG4gICAgb246ZnVuY3Rpb24odHlwZSwgaGFuZGxlcil7XHJcbiAgICAgICAgYWdtLmNvbm5lY3Rpb24ub24ocHJvZHVjdF9uYW1lLCB0eXBlLCBoYW5kbGVyKTtcclxuICAgIH1cclxuXHRcclxuXHR9O1xyXG5cdCBcclxuXHQvL1NhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgc3lzdGVtIG9iamVjdCB0aGF0IHdlIGFyZSBnaXZlblxyXG5cdHZhciBtZXRyaWNzX3Jvb3QgPSBjb25maWd1cmF0aW9uLm1ldHJpY3M7XHJcblx0XHJcblx0Ly9DcmVhdGUgc3Vic3lzdGVtcyBmb3Igb3VyIG1vZHVsZXMgYW5kIHNhdmUgdGhlbSBpbiB0aGVpciBjb25maWd1cmF0aW9uLlxyXG5cdGlmKG1ldHJpY3Nfcm9vdCAhPT0gdW5kZWZpbmVkKXtcclxuXHRcdGNvbmZpZ3VyYXRpb24uY2xpZW50Lm1ldHJpY3MgPSBtZXRyaWNzX3Jvb3Quc3ViU3lzdGVtKFwiQ2xpZW50XCIpO1xyXG5cdFx0Y29uZmlndXJhdGlvbi5zZXJ2ZXIubWV0cmljcyA9IG1ldHJpY3Nfcm9vdC5zdWJTeXN0ZW0oXCJTZXJ2ZXJcIik7XHJcblx0fSBcclxuXHRcclxuICAgIC8vSW5pdGlhbGl6ZSBvdXIgbW9kdWxlc1xyXG4gIFx0YWdtLmluc3RhbmNlID0gaW5zdGFuY2UoY29uZmlndXJhdGlvbi5pbnN0YW5jZSwgYWdtX2VuYWJsZWRfY29ubmVjdGlvbik7XHJcblx0YWdtLmNsaWVudCA9IGNsaWVudChhZ21fZW5hYmxlZF9jb25uZWN0aW9uLCBhZ20uaW5zdGFuY2UsIGNvbmZpZ3VyYXRpb24uY2xpZW50KTtcclxuXHRhZ20uc2VydmVyID0gc2VydmVyKGFnbV9lbmFibGVkX2Nvbm5lY3Rpb24sIGFnbS5pbnN0YW5jZSwgY29uZmlndXJhdGlvbi5zZXJ2ZXIpO1xyXG5cclxuXHQvL0FkZCBtZXRob2QgYWxpYXNlc1xyXG5cdGFnbS5pbnZva2U9YWdtLmNsaWVudC5pbnZva2U7XHJcblx0YWdtLnJlZ2lzdGVyPWFnbS5zZXJ2ZXIucmVnaXN0ZXI7XHJcblx0YWdtLnVucmVnaXN0ZXI9YWdtLnNlcnZlci51bnJlZ2lzdGVyO1xyXG5cdGFnbS5zZXJ2ZXJzPWFnbS5jbGllbnQuc2VydmVycztcclxuXHRhZ20ubWV0aG9kcz1hZ20uY2xpZW50Lm1ldGhvZHM7XHJcblx0YWdtLm1ldGhvZHNfZm9yX2luc3RhbmNlPWFnbS5jbGllbnQubWV0aG9kc19mb3JfaW5zdGFuY2U7XHJcblx0YWdtLm1ldGhvZHNGb3JJbnN0YW5jZT1hZ20uY2xpZW50Lm1ldGhvZHNfZm9yX2luc3RhbmNlO1xyXG4gICAgYWdtLm1ldGhvZD1hZ20uY2xpZW50Lm1ldGhvZDtcclxuXHRhZ20ubWV0aG9kX2FkZGVkPWFnbS5jbGllbnQubWV0aG9kX2FkZGVkO1xyXG5cdGFnbS5tZXRob2RBZGRlZD1hZ20uY2xpZW50Lm1ldGhvZF9hZGRlZDtcclxuXHRhZ20ubWV0aG9kX3JlbW92ZWQ9YWdtLmNsaWVudC5tZXRob2RfcmVtb3ZlZDtcclxuXHRhZ20ubWV0aG9kUmVtb3ZlZD1hZ20uY2xpZW50Lm1ldGhvZF9yZW1vdmVkO1xyXG5cclxuXHRhZ20uc2VydmVyX21ldGhvZF9hZGRlZD1hZ20uY2xpZW50LnNlcnZlcl9tZXRob2RfYWRkZWQ7XHJcblx0YWdtLnNlcnZlck1ldGhvZEFkZGVkPWFnbS5jbGllbnQuc2VydmVyX21ldGhvZF9hZGRlZDtcclxuXHRhZ20uc2VydmVyX21ldGhvZF9yZW1vdmVkPWFnbS5jbGllbnQuc2VydmVyX21ldGhvZF9yZW1vdmVkO1xyXG5cdGFnbS5zZXJ2ZXJNZXRob2RSZW1vdmVkPWFnbS5jbGllbnQuc2VydmVyX21ldGhvZF9yZW1vdmVkO1xyXG5cclxuXHRhZ20uc2VydmVyX2FkZGVkPWFnbS5jbGllbnQuc2VydmVyX2FkZGVkO1xyXG5cdGFnbS5zZXJ2ZXJBZGRlZD1hZ20uY2xpZW50LnNlcnZlcl9hZGRlZDtcclxuXHRhZ20uc2VydmVyX3JlbW92ZWQ9YWdtLmNsaWVudC5zZXJ2ZXJfcmVtb3ZlZDtcclxuXHRhZ20uc2VydmVyUmVtb3ZlZD1hZ20uY2xpZW50LnNlcnZlcl9yZW1vdmVkO1xyXG5cclxuXHRhZ20uc3RhcnQgPSBhZ20uc2VydmVyLnN0YXJ0O1xyXG5cdGFnbS5zdG9wID0gYWdtLnNlcnZlci5zdG9wO1xyXG5cdFxyXG4gICAgaWYoZ2xvYmFsLmNvbnNvbGUhPT11bmRlZmluZWQgJiYgYWdtLmRlYnVnPT09dHJ1ZSl7XHJcblx0ICAgIGNvbnNvbGUubG9nKFwiQUdNIHN0YXJ0ZWQuXCIpO1xyXG4gICAgfVxyXG5cdFxyXG5cdHJldHVybiBhZ207XHJcbiAgICAvL3JldHVybiBhZGRfc3VnYXIoYWdtKTtcclxuXHJcbn07XHJcblxyXG5hZ20gPSBnbG9iYWwuaHRtbENvbnRhaW5lciE9PXVuZGVmaW5lZD9uYXRpdmVfYWdtOmFnbTtcclxuXHJcbi8vRXhwb3J0IGZvciBicm93c2Vyc1xyXG5pZihnbG9iYWwudGljazQyPT09dW5kZWZpbmVkKXtnbG9iYWwudGljazQyID0ge307fVxyXG5nbG9iYWwudGljazQyLmFnbSA9IGFnbTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gYWdtO1xyXG5cclxuIiwiLypcclxuIFRoZSBBR00gQ2xpZW50IGFuYWx5c2VzIHNlcnZlciBwcmVzZW5jZXMsIGNvbGxlY3RzIGluZm9ybWF0aW9uIGFib3V0IHRoZWlyIG1ldGhvZHMgYW5kIGFsbG93cyB1c2VycyB0byBpbnZva2UgdGhlc2UgbWV0aG9kcy5cclxuICovXHJcbnZhciBjbGllbnRfc2VydmVyc3RhdGUgPSByZXF1aXJlKCcuL2FnbV9jbGllbnRfc2VydmVyc3RhdGUnKTtcclxudmFyIGNsaWVudF9pbnZvY2F0aW9uc3N0YXRlID0gcmVxdWlyZSgnLi9hZ21fY2xpZW50X2ludm9jYXRpb25zc3RhdGUnKTtcclxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2FnbV9oZWxwZXJzJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGluc3RhbmNlLCBjb25maWd1cmF0aW9uKSB7XHJcbiAgICAvL1ZhbGlkYXRlIGNvbmZpZ3VyYXRpb25cclxuICAgIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25maWd1cmF0aW9uID0ge307XHJcbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgYW4gQUdNIGNsaWVudCB3aXRoIGRlZmF1bHQgY29uZmlndXJhdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24ucmVtb3ZlX3NlcnZlcl9vbl9uX21pc3NpbmdfaGVhcnRiZWF0cyAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICBjb25maWd1cmF0aW9uLnJlbW92ZV9zZXJ2ZXJfb25fbl9taXNzaW5nX2hlYXJ0YmVhdHMgPSAzO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGNvbmZpZ3VyYXRpb24ubWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXQgPSAzMDAwO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uLndhaXRfZm9yX21ldGhvZF90aW1lb3V0ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGNvbmZpZ3VyYXRpb24ud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQgPSAzMDAwO1xyXG4gICAgfVxyXG4gICAgLy9JbnN0YW50aWF0ZSB0aGUgbW9kdWxlIHdoaWNoIGtlZXBzIHRyYWNrIG9mIGFsbCBhdmFpbGFibGUgc2VydmVycyBhbmQgbWV0aG9kc1xyXG4gICAgdmFyIHNlcnZlcnMgPSBjbGllbnRfc2VydmVyc3RhdGUoY29uZmlndXJhdGlvbiwgaW5zdGFuY2UpO1xyXG4gICAgLy8uLmFuZCB3aGVuIHlvdSByZWNlaXZlIGEgaGVhcnRiZWF0L3ByZXNlbmNlIGZyb20gYSBzZXJ2ZXIsIGRlbGVnYXRlIGl0cyBwcm9jZXNzaW5nIHRvIHRoZSBtb2R1bGU6XHJcbiAgICBjb25uZWN0aW9uLm9uKCdTZXJ2ZXJQcmVzZW5jZU1lc3NhZ2UnLCBmdW5jdGlvbihtc2cpe3NlcnZlcnMucHJvY2Vzc19wcmVzZW5jZShtc2csIHRydWUpO30pO1xyXG4gICAgY29ubmVjdGlvbi5vbignU2VydmVySGVhcnRiZWF0TWVzc2FnZScsIGZ1bmN0aW9uKG1zZyl7c2VydmVycy5wcm9jZXNzX3ByZXNlbmNlKG1zZywgZmFsc2UpO30pO1xyXG4gICAgLy9JbnN0YW50aWF0ZSB0aGUgbW9kdWxlIHRoYXQgaGFuZGxlcyBtZXRob2QgZXhlY3V0aW9uIGFuZCByZXNwb25zZXNcclxuICAgIHZhciByZXNwb25zZSA9IGNsaWVudF9pbnZvY2F0aW9uc3N0YXRlKGNvbmZpZ3VyYXRpb24sIGluc3RhbmNlLCBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZCgnTWV0aG9kSW52b2NhdGlvblJlcXVlc3RNZXNzYWdlJywgbSk7XHJcbiAgICB9KTtcclxuICAgIC8vLi5hbmQgZGVsZWdhdGUgcmVzcG9uc2VzIHRvIGl0LlxyXG4gICAgY29ubmVjdGlvbi5vbignTWV0aG9kSW52b2NhdGlvblJlc3VsdE1lc3NhZ2UnLCByZXNwb25zZS5wcm9jZXNzX21ldGhvZF9yZXNwb25zZSk7XHJcblxyXG5cclxuXHJcblxyXG4vLyAgIC8vQWRkcyBjbGllbnQgY2FsbGJhY2tzIHdoaWNoIGFyZSBleGVjdXRlZCB3aGVuIGEgbmV3IG1ldGhvZCBpcyBhZGRlZCBvciBzdG9wcyBiZWluZyBhdmFpbGFibGVcclxuLy8gICBmdW5jdGlvbiBtZXRob2RfYWRkZWQoY2FsbGJhY2spIHtcclxuLy8gICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuLy8gICAgICAgLy9BZGQgdGhlIGNhbGxiYWNrXHJcbi8vICAgICAgIGNvbmZpZ3VyYXRpb24ub25fbWV0aG9kX2FkZGVkID0gY2FsbGJhY2s7XHJcbi8vICAgICAgIC8vQ2FsbCB0aGUgY2FsbGJhY2sgZm9yIGFsbCB0aGUgbWV0aG9kIHdoaWNoIHdlcmUgYWRkZWQgYmVmb3JlIHRoZSBjYWxsYmFjayB3YXMgcmVnaXN0ZXJlZC5cclxuLy8gICAgICAgc2VydmVycy5nZXRfbWV0aG9kcygpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4vLyAgICAgICAgIGNhbGxiYWNrKG1ldGhvZCk7XHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSBlbHNlIHtcclxuLy8gICAgICAgdGhyb3cgJ1xcJ21ldGhvZF9hZGRlZFxcJyBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgZnVuY3Rpb24gYXMgYW4gYXJndW1lbnQnO1xyXG4vLyAgICAgfVxyXG4vLyAgIH1cclxuLy8gICBmdW5jdGlvbiBtZXRob2RfcmVtb3ZlZChjYWxsYmFjaykge1xyXG4vLyAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4vLyAgICAgICAvL0FkZCB0aGUgY2FsbGJhY2tcclxuLy8gICAgICAgY29uZmlndXJhdGlvbi5vbl9tZXRob2RfcmVtb3ZlZCA9IGNhbGxiYWNrO1xyXG4vLyAgICAgfSBlbHNlIHtcclxuLy8gICAgICAgdGhyb3cgJ1xcJ21ldGhvZF9yZW1vdmVkXFwnIG11c3QgYmUgY2FsbGVkIHdpdGggYSBmdW5jdGlvbiBhcyBhbiBhcmd1bWVudCc7XHJcbi8vICAgICB9XHJcbi8vICAgfVxyXG5cclxuLy8gICAvL0FkZHMgY2xpZW50IGNhbGxiYWNrcyB3aGljaCBhcmUgZXhlY3V0ZWQgd2hlbiBhIG5ldyBtZXRob2QgaXMgYWRkZWQgb3Igc3RvcHMgYmVpbmcgYXZhaWxhYmxlXHJcbi8vICAgZnVuY3Rpb24gc2VydmVyX2FkZGVkKGNhbGxiYWNrKSB7XHJcbi8vICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbi8vICAgICAgIC8vQWRkIHRoZSBjYWxsYmFja1xyXG4vLyAgICAgICBjb25maWd1cmF0aW9uLm9uX3NlcnZlcl9hZGRlZCA9IGNhbGxiYWNrO1xyXG4vLyAgICAgICAvL0NhbGwgdGhlIGNhbGxiYWNrIGZvciBhbGwgdGhlIG1ldGhvZCB3aGljaCB3ZXJlIGFkZGVkIGJlZm9yZSB0aGUgY2FsbGJhY2sgd2FzIHJlZ2lzdGVyZWQuXHJcbi8vICAgICAgIHNlcnZlcnMuZ2V0X3NlcnZlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcclxuLy8gICAgICAgICBjYWxsYmFjayhzZXJ2ZXIpO1xyXG4vLyAgICAgICB9KTtcclxuLy8gICAgIH0gZWxzZSB7XHJcbi8vICAgICAgIHRocm93ICdcXCdzZXJ2ZXJfYWRkZWRcXCcgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50JztcclxuLy8gICAgIH1cclxuLy8gICB9XHJcbi8vICAgZnVuY3Rpb24gc2VydmVyX3JlbW92ZWQoY2FsbGJhY2spIHtcclxuLy8gICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuLy8gICAgICAgLy9BZGQgdGhlIGNhbGxiYWNrXHJcbi8vICAgICAgIGNvbmZpZ3VyYXRpb24ub25fc2VydmVyX3JlbW92ZWQgPSBjYWxsYmFjaztcclxuLy8gICAgIH0gZWxzZSB7XHJcbi8vICAgICAgIHRocm93ICdcXCdzZXJ2ZXJfcmVtb3ZlZFxcJyBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgZnVuY3Rpb24gYXMgYW4gYXJndW1lbnQnO1xyXG4vLyAgICAgfVxyXG4vLyAgIH1cclxuICAgIC8vQWJzdHJhY3QgZ2V0X21ldGhvZCBhbmQgZ2V0X3NlcnZlcnMgZnVuY3Rpb25zXHJcbiAgICAvL1RoZXkgcmVseSBvbiAgZ2V0X21ldGhvZCBhbmQgZ2V0X3NlcnZlcnMgZnJvbSB0aGUgXCJzZXJ2ZXJzXCIgbW9kdWxlXHJcbiAgICAvL0luIHRob3NlIG9uZXMgeW91IGRvbid0IG5lZWQgdG8gc3BlY2lmeSBhbGwgb2YgdGhlIG1ldGhvZCdzIHByb3BzIHRvIGZpbmQgaXQuXHJcbiAgICBmdW5jdGlvbiBnZXRfbWV0aG9kKG1ldGhvZF9maWx0ZXIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZF9maWx0ZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZF9maWx0ZXIgPSB7IG5hbWU6IG1ldGhvZF9maWx0ZXIgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9EbyBub3QgZXhlY3V0ZSBmb3IgZW1wdHkgZmlsdGVyXHJcbiAgICAgICAgaWYgKG1ldGhvZF9maWx0ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBleGFjdF9tYXRjaCA9IHNlcnZlcnMuZ2V0X21ldGhvZChtZXRob2RfZmlsdGVyKTtcclxuICAgICAgICAvL1RyeSBjYWxsaW5nIHRoZSBvcmlnaW5hbCBcImdldF9tZXRob2RcIiBmdW5jdGlvbiAoaXQgd2lsbCB3b3JrIGlmIGFsbCBtZXRob2QgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkKTpcclxuICAgICAgICBpZiAoZXhhY3RfbWF0Y2ggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhhY3RfbWF0Y2ggIC8vVGFrZSBhbGwgYXZhaWxhYmxlIG1ldGhvZHMgYW5kIGl0ZXJhdGUgdGhlbSB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hcclxuICAgICAgICAgICAgICA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRha2VXaGlsZShzZXJ2ZXJzLmdldF9tZXRob2RzKCksIGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2RfbWF0Y2gobWV0aG9kX2ZpbHRlciwgbWV0aG9kKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0X21ldGhvZHMobWV0aG9kX2ZpbHRlcikge1xyXG4gICAgICAgIGlmIChtZXRob2RfZmlsdGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlcnMuZ2V0X21ldGhvZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2RfZmlsdGVyID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBtZXRob2RfZmlsdGVyID0geyBuYW1lOiBtZXRob2RfZmlsdGVyIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZXJ2ZXJzLmdldF9tZXRob2RzKCkuZmlsdGVyKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZF9tYXRjaChtZXRob2RfZmlsdGVyLCBtZXRob2QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vUmV0cmlldmVzIGFsbCBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBhbnkgb2Ygc2V2ZXJhbCBtZXRob2RzLCBsaXN0ZWQgYXMgYW4gYXJyYXlcclxuICAgIGZ1bmN0aW9uIGdldF9tZXRob2RzX2Zvcl9pbnN0YW5jZShpbnN0YW5jZV9maWx0ZXIpIHtcclxuICAgICAgICB2YXIgZXhhY3RfbWF0Y2ggPSBzZXJ2ZXJzLmdldF9tZXRob2RzKGluc3RhbmNlX2ZpbHRlcik7XHJcbiAgICAgICAgLy9UcnkgY2FsbGluZyB0aGUgb3JpZ2luYWwgXCJnZXRfbWV0aG9kc1wiIGZ1bmN0aW9uIChpdCB3aWxsIHdvcmsgaWYgYWxsIGluc3RhbmNlIHByb3BlcnRpZXMgYXJlIHNwZWNpZmllZCk6XHJcbiAgICAgICAgaWYgKGV4YWN0X21hdGNoLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhhY3RfbWF0Y2g7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZF9pZHMgPSBnZXRfc2VydmVycygpLmZpbHRlcihmdW5jdGlvbiAoc2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VfbWF0Y2goaW5zdGFuY2VfZmlsdGVyLCBzZXJ2ZXIpO1xyXG4gICAgICAgICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG1ldGhvZHMsIHNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgc2VydmVycy5nZXRfbWV0aG9kX2lkcyhzZXJ2ZXIpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZF9pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHNbbWV0aG9kX2lkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2RzO1xyXG4gICAgICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtZXRob2RfaWRzKS5tYXAoZnVuY3Rpb24gKG1ldGhvZF9pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcnZlcnMuZ2V0X21ldGhvZChtZXRob2RfaWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9SZXRyaWV2ZXMgYWxsIHNlcnZlcnMgdGhhdCBzdXBwb3J0IGEgZ2l2ZW4gbWV0aG9kXHJcbiAgICBmdW5jdGlvbiBnZXRfc2VydmVycyhtZXRob2RfZmlsdGVyKSB7XHJcbiAgICAgICAgLy9ObyBtZXRob2QgLSBnZXQgYWxsIHNlcnZlcnNcclxuICAgICAgICBpZiAobWV0aG9kX2ZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJzLmdldF9zZXJ2ZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vTm9uLWV4aXN0aW5nIG1ldGhvZCAtIHJldHVybiBhbiBlbXB0eSBhcnJheVxyXG4gICAgICAgIHZhciBtZXRob2QgPSBnZXRfbWV0aG9kKG1ldGhvZF9maWx0ZXIpO1xyXG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRWxzZSwgcmV0dXJuIHNlcnZlcnMgZm9yIG1ldGhvZFxyXG4gICAgICAgIHJldHVybiBzZXJ2ZXJzLmdldF9zZXJ2ZXJzKG1ldGhvZCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vUmV0cmlldmVzIGFsbCBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBhbnkgb2Ygc2V2ZXJhbCBtZXRob2RzLCBsaXN0ZWQgYXMgYW4gYXJyYXlcclxuICAgIGZ1bmN0aW9uIHNlcnZlcnNfZm9yX21ldGhvZHMobWV0aG9kcyl7XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZHMucmVkdWNlKGZ1bmN0aW9uIChzb19mYXIsIG1ldGhvZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc29fZmFyLmNvbmNhdChzZXJ2ZXJzLmdldF9zZXJ2ZXJzKG1ldGhvZCwgdHJ1ZSkpOy8vKHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdGhlcmUgYmVjYXVzZSB3ZSBhbHNvIG5lZWQgdGhlIHJlcXVlc3Qgc3ViamVjdClcclxuICAgICAgICB9LCBbXSkuc29ydChzZXJ2ZXJzLmNvbXBhcmVfc2VydmVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2VydmVyc19mb3JfbWV0aG9kX2FuZF90YXJnZXQobWV0aG9kX2ZpbHRlciwgdGFyZ2V0KXtcclxuICAgICAgICAvL0dldCB0aGUgbWV0aG9kcyB3aGljaCBtYXRjaCB0aGUgZmlsdGVyXHJcbiAgICAgICAgdmFyIG1ldGhvZHMgPSBnZXRfbWV0aG9kcyhtZXRob2RfZmlsdGVyKTtcclxuICAgICAgICAvL0RldGVybWluZSB3aGVyZSB0byBleGVjdXRlIHRoZSBtZXRob2QocykgKHRoZSBcInRhcmdldFwiIGFyZ3VtZW50KVxyXG4gICAgICAgIC8vR2V0IGFsbCBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCB0aGUgbWV0aG9kKHMpIGFuZCBnZXQgdGhlIG9uZXMgdGhhdCBtYXRjaCB0aGUgdGFyZ2V0IGNyaXRlcmlhXHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcl9ieV90YXJnZXQodGFyZ2V0LCBzZXJ2ZXJzX2Zvcl9tZXRob2RzKG1ldGhvZHMpKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgLy9JbnZva2VzIGFuIEFHTSBtZXRob2QgKG1vc3RseSBpdCBkb2VzIGlucHV0IGNoZWNraW5nKSwgdGhlIGFjdHVhbCBqb2IgaXMgZG9uZSBieSBcInJlcXVlc3QuaW52b2tlXCJcclxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2RfZmlsdGVyLCBhcmd1bWVudF9vYmosIHRhcmdldCwgYWRkaXRpb25hbF9vcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5O1xyXG5cclxuICAgICAgICAgICAgc3VjY2Vzc1Byb3h5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIC8vdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UoYXJncyk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBlcnJvclByb3h5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIC8vdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UoYXJncyk7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoYXJncyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vQWRkIGRlZmF1bHQgcGFyYW1zXHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudF9vYmogPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgYXJndW1lbnRfb2JqID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSAnYmVzdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIgJiYgdGFyZ2V0ICE9PSBcImFsbFwiICYmIHRhcmdldCAhPT0gXCJiZXN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdCh7bWVzc2FnZTogJ1wiJyArIHRhcmdldCArICdcIiBpcyBub3QgYSB2YWxpZCB0YXJnZXQuIFZhbGlkIHRhcmdldHMgYXJlIFwiYWxsXCIgYW5kIFwiYmVzdFwiLid9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYWRkaXRpb25hbF9vcHRpb25zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYWRkaXRpb25hbF9vcHRpb25zLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxfb3B0aW9ucy5tZXRob2RfcmVzcG9uc2VfdGltZW91dCA9IGNvbmZpZ3VyYXRpb24ubWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxfb3B0aW9ucy53YWl0X2Zvcl9tZXRob2RfdGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsX29wdGlvbnMud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQgPSBjb25maWd1cmF0aW9uLndhaXRfZm9yX21ldGhvZF90aW1lb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgLy9DaGVjayBpZiB0aGUgYXJndW1lbnRzIGFyZSBhbiBvYmplY3RcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudF9vYmogIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3Qoe21lc3NhZ2U6ICdUaGUgbWV0aG9kIGFyZ3VtZW50cyBtdXN0IGJlIGFuIG9iamVjdC4nfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kX2ZpbHRlciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZF9maWx0ZXIgPSB7bmFtZTogbWV0aG9kX2ZpbHRlcn07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJzID0gc2VydmVyc19mb3JfbWV0aG9kX2FuZF90YXJnZXQobWV0aG9kX2ZpbHRlciwgdGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGludm9rZV91bmV4aXN0aW5nKG1ldGhvZF9maWx0ZXIsIGFyZ3VtZW50X29iaiwgdGFyZ2V0LCBhZGRpdGlvbmFsX29wdGlvbnMsIHN1Y2Nlc3NQcm94eSwgZXJyb3JQcm94eSk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZlcnMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJz4+PiBJbnZva2luZyBcIicgKyBtZXRob2RfZmlsdGVyLm5hbWUgKyAnXCIgb24gMSBzZXJ2ZXInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZS5pbnZva2UobWV0aG9kX2ZpbHRlciwgYXJndW1lbnRfb2JqLCBzZXJ2ZXJzWzBdLCBhZGRpdGlvbmFsX29wdGlvbnMsIHN1Y2Nlc3NQcm94eSwgZXJyb3JQcm94eSk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4gSW52b2tpbmcgXCInICsgbWV0aG9kX2ZpbHRlci5uYW1lICsgJ1wiIG9uICcgKyBzZXJ2ZXJzLmxlbmd0aCArICcgc2VydmVycycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGludm9rZV9vbl9hbGwobWV0aG9kX2ZpbHRlciwgYXJndW1lbnRfb2JqLCBzZXJ2ZXJzLCBhZGRpdGlvbmFsX29wdGlvbnMsIHN1Y2Nlc3NQcm94eSwgZXJyb3JQcm94eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhlbHBlcnMucHJvbWlzaWZ5KHByb21pc2UsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy9DYWxsZWQgd2hlbiB0aGUgdXNlciB0cmllcyB0byBpbnZva2UgYSBtZXRob2Qgd2hpY2ggZG9lcyBub3QgZXhpc3RcclxuICAgIGZ1bmN0aW9uIGludm9rZV91bmV4aXN0aW5nKG1ldGhvZF9maWx0ZXIsIGFyZ3VtZW50X29iaiwgdGFyZ2V0LCBhZGRpdGlvbmFsX29wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKXtcclxuICAgICAgICB2YXIgc2VydmVyX2ZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmKGFkZGl0aW9uYWxfb3B0aW9ucy53YWl0X2Zvcl9tZXRob2RfdGltZW91dCA9PT0gMCl7XHJcbiAgICAgICAgICAgIGNhbGxfZXJyb3IoKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5zZXJ2ZXJfbWV0aG9kX2FkZGVkID0gY29uZmlndXJhdGlvbi5zZXJ2ZXJfbWV0aG9kX2FkZGVkLmZpbHRlcihmdW5jdGlvbihjYWxsYmFjayl7cmV0dXJuIGNhbGxiYWNrICE9PSBuZXdfc2VydmVyO30pO1xyXG4gICAgICAgICAgICAgICAgaWYoIXNlcnZlcl9mb3VuZCl7Y2FsbF9lcnJvcigpO31cclxuICAgICAgICAgICAgfSxhZGRpdGlvbmFsX29wdGlvbnMud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQpO1xyXG5cclxuICAgICAgICAgICAgcmVnaXN0ZXJfY2FsbGJhY2soXCJzZXJ2ZXJfbWV0aG9kX2FkZGVkXCIsIGlkZW50aXR5LCBuZXdfc2VydmVyKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbmV3X3NlcnZlcigpe1xyXG4gICAgICAgICAgICBpZihzZXJ2ZXJfZm91bmQpe3JldHVybjt9XHJcbiAgICAgICAgICAgIHZhciBzZXJ2ZXIgPSBzZXJ2ZXJzX2Zvcl9tZXRob2RfYW5kX3RhcmdldChtZXRob2RfZmlsdGVyLCB0YXJnZXQpWzBdO1xyXG4gICAgICAgICAgICBpZihzZXJ2ZXIgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJfZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaW52b2tlKG1ldGhvZF9maWx0ZXIsIGFyZ3VtZW50X29iaiwgc2VydmVyLCBhZGRpdGlvbmFsX29wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjYWxsX2Vycm9yKCl7XHJcbiAgICAgICAgICAgIC8vQ2hlY2sgaWYgdGhlIG1ldGhvZCBleGlzdHMgYW5kIGlmIGl0IGRvZXNudCcsIHJldHVybiBhbiBlcnJvclxyXG4gICAgICAgICAgICBpZiAoZ2V0X21ldGhvZHMobWV0aG9kX2ZpbHRlcikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2RfZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOiBhcmd1bWVudF9vYmosXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0kgY291bGQgbm90IGZpbmQgYSBtZXRob2Qgd2l0aCB0aG9zZSBwcm9wZXJ0aWVzOiAnICsgSlNPTi5zdHJpbmdpZnkobWV0aG9kX2ZpbHRlcilcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kX2ZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBjYWxsZWRfd2l0aDogYXJndW1lbnRfb2JqLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdJIGNvdWxkIG5vdCBmaW5kIHNlcnZlcnMgd2l0aCB0aGVzZSBwcm9wZXJ0aWVzOiAnICsgSlNPTi5zdHJpbmdpZnkodGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvL0NhbGxlZCB3aGVuIHRoZSBpbnZva2VzIGEgbWV0aG9kIHdpdGggbXVsdGlwbGUgdGFyZ2V0c1xyXG4gICAgLy9DYWxscyBhIG1ldGhvZCBmb3IgYWxsIHNlcnZlcnMgYW5kIHVuaWZpZXMgdGhlIHJlc3VsdHMgdGhleSByZXR1cm4gaW50byBvbmU6XHJcbiAgICBmdW5jdGlvbiBpbnZva2Vfb25fYWxsKG1ldGhvZCwgYXJndW1lbnRfb2JqLCBzZXJ2ZXJzLCBhZGRpdGlvbmFsX29wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKXtcclxuICAgICAgICAvL0hlcmUgd2Ugd2lsbCBzdG9yZSB0aGUgcmVzdWx0cyB0aGF0IHRoZSBzZXJ2ZXJzIHJldHVyblxyXG4gICAgICAgIHZhciBzdWNjZXNzZXMgPSBbXTtcclxuICAgICAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICAgICAgLy9UaGVzZSBhcmUgdGhlIGNhbGxiYWNrc1xyXG4gICAgICAgIHZhciBzdWNjZXNzX2NhbGxiYWNrID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICBzdWNjZXNzZXMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICBzZW5kX3Jlc3BvbnNlKHN1Y2Nlc3NlcywgZXJyb3JzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBlcnJvcl9jYWxsYmFjayA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgc2VuZF9yZXNwb25zZShzdWNjZXNzZXMsIGVycm9ycyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL0NhbGwgdGhlIG1ldGhvZCBmb3IgYWxsIHRhcmdldHNcclxuICAgICAgICBzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlcikge1xyXG4gICAgICAgICAgICByZXNwb25zZS5pbnZva2UobWV0aG9kLCBhcmd1bWVudF9vYmosIHNlcnZlciwgYWRkaXRpb25hbF9vcHRpb25zLCBzdWNjZXNzX2NhbGxiYWNrLCBlcnJvcl9jYWxsYmFjayk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAvL0NhbGxzIHRoZSBtYWluIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcyB3aXRoIHRoZSBhZ2dyZWdhdGVkIHJlc3VsdHNcclxuICAgICAgICBmdW5jdGlvbiBzZW5kX3Jlc3BvbnNlKCkge1xyXG4gICAgICAgICAgICAvL3dhaXQgdGlsbCBldmVyeWJvZHkgaXMgZmluaXNoZWRcclxuICAgICAgICAgICAgaWYgKHN1Y2Nlc3Nlcy5sZW5ndGggKyBlcnJvcnMubGVuZ3RoIDwgc2VydmVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL0V4ZWN1dGUgdGhlIFwic3VjY2Vzc1wiIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc3VjY2Vzc2VzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLm1ldGhvZCA9IHN1Y2Nlc3MubWV0aG9kO1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai5jYWxsZWRfd2l0aCA9IHN1Y2Nlc3MuY2FsbGVkX3dpdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLnJldHVybmVkID0gc3VjY2Vzcy5yZXR1cm5lZDtcclxuICAgICAgICAgICAgICAgICAgICBvYmouYWxsX3JldHVybl92YWx1ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVkX2J5OiBzdWNjZXNzLmV4ZWN1dGVkX2J5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZDogc3VjY2Vzcy5yZXR1cm5lZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai5leGVjdXRlZF9ieSA9IHN1Y2Nlc3MuZXhlY3V0ZWRfYnk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgICAgIH0sIHsgYWxsX3JldHVybl92YWx1ZXM6IFtdIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vSWYgd2UgZ2V0IGVycm9ycyBmcm9tIG9uZSBvZiB0aGUgc2VydmVycyBhZGQgdGhlbSB0byB0aGUgc3VjY2VzcyBvYmplY3QgdGhhdCB3aWxsIGJlIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWxsX2Vycm9ycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFsbF9lcnJvcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2V4ZWN1dGVkX2J5IDogb2JqLmV4ZWN1dGVkX2J5LCAvLyB3ZSBkb24ndCBnZXQgZXhlY3V0ZWRfYnkgb2JqZWN0IGZyb20gdGhlIGVycm9yIHJlc3BvbnNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIDogb2JqLm1ldGhvZC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IG9iai5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MocmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgIH1lbHNlIGlmIChlcnJvcnMubGVuZ3RoICE9PSAwKSB7IC8vRXhlY3V0ZSB0aGUgXCJlcnJvclwiIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICBlcnJvcihlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLm1ldGhvZCA9IGVycm9yLm1ldGhvZDtcclxuICAgICAgICAgICAgICAgICAgICBvYmouY2FsbGVkX3dpdGggPSBlcnJvci5jYWxsZWRfd2l0aDtcclxuICAgICAgICAgICAgICAgICAgICBvYmoubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLmFsbF9lcnJvcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVkX2J5OiBlcnJvci5leGVjdXRlZF9ieSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vb2JqLmV4ZWN1dGVkX2J5ID0gc3VjY2Vzcy5leGVjdXRlZF9ieTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICAgICAgfSwgeyBhbGxfZXJyb3JzOiBbXSB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIHZhciByZWdpc3Rlcl9jYWxsYmFjayA9IGhlbHBlcnMuc2F2ZV9jYWxsYmFja19pbi5iaW5kKHRoaXMsIGNvbmZpZ3VyYXRpb24pO1xyXG5cclxuICAgIHZhciBhcHBseV9vbl9zZXJ2ZXJzID0gYXBwbHlfb24uYmluZChudWxsLCBzZXJ2ZXJzLmdldF9zZXJ2ZXJzKTtcclxuICAgIHZhciBhcHBseV9vbl9tZXRob2RzID0gYXBwbHlfb24uYmluZChudWxsLCBzZXJ2ZXJzLmdldF9tZXRob2RzKTtcclxuICAgIHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKGEpe3JldHVybiBhO307XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbnZva2U6IGludm9rZSxcclxuICAgICAgICBtZXRob2Q6IGdldF9tZXRob2QsXHJcbiAgICAgICAgc2VydmVyczogZ2V0X3NlcnZlcnMsXHJcbiAgICAgICAgbWV0aG9kczogZ2V0X21ldGhvZHMsXHJcbiAgICAgICAgbWV0aG9kc19mb3JfaW5zdGFuY2U6IGdldF9tZXRob2RzX2Zvcl9pbnN0YW5jZSxcclxuICAgICAgICBtZXRob2RfYWRkZWQ6IHJlZ2lzdGVyX2NhbGxiYWNrLmJpbmQobnVsbCwgXCJtZXRob2RfYWRkZWRcIiwgYXBwbHlfb25fbWV0aG9kcyksXHJcbiAgICAgICAgbWV0aG9kX3JlbW92ZWQ6IHJlZ2lzdGVyX2NhbGxiYWNrLmJpbmQobnVsbCwgXCJtZXRob2RfcmVtb3ZlZFwiLCBpZGVudGl0eSksXHJcbiAgICAgICAgc2VydmVyX2FkZGVkOiByZWdpc3Rlcl9jYWxsYmFjay5iaW5kKG51bGwsIFwic2VydmVyX2FkZGVkXCIsIGFwcGx5X29uX3NlcnZlcnMpLFxyXG4gICAgICAgIHNlcnZlcl9yZW1vdmVkOiByZWdpc3Rlcl9jYWxsYmFjay5iaW5kKG51bGwsIFwic2VydmVyX3JlbW92ZWRcIiwgaWRlbnRpdHkpLFxyXG4gICAgICAgIHNlcnZlcl9tZXRob2RfYWRkZWQ6IHJlZ2lzdGVyX2NhbGxiYWNrLmJpbmQobnVsbCwgXCJzZXJ2ZXJfbWV0aG9kX2FkZGVkXCIsIGlkZW50aXR5KSxcclxuICAgICAgICBzZXJ2ZXJfbWV0aG9kX3JlbW92ZWQ6IHJlZ2lzdGVyX2NhbGxiYWNrLmJpbmQobnVsbCwgXCJzZXJ2ZXJfbWV0aG9kX3JlbW92ZWRcIiwgaWRlbnRpdHkpLFxyXG4gICAgICAgIHBhcnNlX3NpZ25hdHVyZTogaGVscGVycy5zaWduYXR1cmVfcGFyc2VfZnJpZW5kbHlcclxuICAgIH07XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG4vL0ZpbHRlcnMgYW4gYXJyYXkgb2Ygc2VydmVycyBhbmQgcmV0dXJucyB0aGUgb25lcyB3aGljaCBtYXRjaCB0aGUgdGFyZ2V0IGNyaXRlcmlhXHJcbmZ1bmN0aW9uIGZpbHRlcl9ieV90YXJnZXQodGFyZ2V0LCBzZXJ2ZXJzKXtcclxuICAgIC8vSWYgdGhlIHVzZXIgc3BlY2lmaWVkIHRhcmdldCBhcyBzdHJpbmc6XHJcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSAnYWxsJykge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBzZXJ2ZXJzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSAnYmVzdCcpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gc2VydmVyc1swXSE9PXVuZGVmaW5lZD9bc2VydmVyc1swXV06W107ICAvL0lmIHRoZSB1c2VyIHNwZWNpZmllZCB0aGUgdGFyZ2V0IGFzIHNlcnZlciBmaWx0ZXJcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh0YXJnZXQuY29uc3RydWN0b3IubmFtZSAhPT0gJ0FycmF5Jykge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBbdGFyZ2V0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVuZXhpc3Rpbmdfc2VydmVycyA9IFtdO1xyXG4gICAgICAgIC8vUmV0cmlldmUgYWxsIHNlcnZlcnMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyc1xyXG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5yZWR1Y2UoZnVuY3Rpb24gKG1hdGNoZXMsIGZpbHRlcikge1xyXG4gICAgICAgICAgICAvL0FkZCBtYXRjaGVzIGZvciBlYWNoIGZpbHRlclxyXG4gICAgICAgICAgICB2YXIgbXlfbWF0Y2hlcyA9IHNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZV9tYXRjaChmaWx0ZXIsIHNlcnZlcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5jb25jYXQobXlfbWF0Y2hlcyk7XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxuXHJcblxyXG5cclxuLy9NYXRjaGVzIGEgc2VydmVyIGRlZmluaXRpb24gYWdhaW5zdCBhIHNlcnZlciBmaWx0ZXJcclxuZnVuY3Rpb24gaW5zdGFuY2VfbWF0Y2goaW5zdGFuY2VfZmlsdGVyLCBpbnN0YW5jZV9kZWZpbml0aW9uKSB7XHJcbiAgICByZXR1cm4gY29udGFpbnNfcHJvcHMoaW5zdGFuY2VfZmlsdGVyLCBpbnN0YW5jZV9kZWZpbml0aW9uKTtcclxufVxyXG5cclxuXHJcbi8vTWF0Y2hlcyBhIG1ldGhvZCBkZWZpbml0aW9uIGFnYWluc3QgYSBtZXRob2QgZmlsdGVyXHJcbmZ1bmN0aW9uIG1ldGhvZF9tYXRjaChtZXRob2RfZmlsdGVyLCBtZXRob2RfZGVmaW5pdGlvbikge1xyXG4gICAgW1xyXG4gICAgICAgICdhY2NlcHRzJyxcclxuICAgICAgICAncmV0dXJucydcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgIGlmIChtZXRob2RfZmlsdGVyW3Byb3BdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbWV0aG9kX2ZpbHRlcltwcm9wXSA9IGhlbHBlcnMuc2lnbmF0dXJlX25vcm1hbGl6ZShtZXRob2RfZmlsdGVyW3Byb3BdKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjb250YWluc19wcm9wcyhtZXRob2RfZmlsdGVyLCBtZXRob2RfZGVmaW5pdGlvbik7XHJcbn1cclxuXHJcblxyXG4vL0hlbHBlcnNcclxuXHJcbi8qXHJcbiBmdW5jdGlvbiBjb250YWluc19wcm9wcyhmaWx0ZXIsIG9iamVjdCkge1xyXG4gdmFyIG1hdGNoID0gdHJ1ZTtcclxuIE9iamVjdC5rZXlzKGZpbHRlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xyXG4gaWYgKFN0cmluZyhmaWx0ZXJbcHJvcF0pLnRvTG93ZXJDYXNlKCkgIT09IFN0cmluZyhvYmplY3RbcHJvcF0pLnRvTG93ZXJDYXNlKCkpIHtcclxuIG1hdGNoID0gZmFsc2U7XHJcbiB9XHJcbiB9KTtcclxuIHJldHVybiBtYXRjaDtcclxuIH1cclxuICovXHJcblxyXG5mdW5jdGlvbiBjb250YWluc19wcm9wcyhmaWx0ZXIsIG9iamVjdCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZpbHRlcikucmVkdWNlKGZ1bmN0aW9uIChtYXRjaCwgcHJvcCkge1xyXG4gICAgICAgIGlmIChmaWx0ZXJbcHJvcF0uY29uc3RydWN0b3IgPT09IFJlZ0V4cCl7XHJcbiAgICAgICAgICAgIGlmKCFmaWx0ZXJbcHJvcF0udGVzdChvYmplY3RbcHJvcF0pKSB7cmV0dXJuIGZhbHNlO31cclxuICAgICAgICAgICAgZWxzZXtyZXR1cm4gbWF0Y2g7fVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKFN0cmluZyhmaWx0ZXJbcHJvcF0pLnRvTG93ZXJDYXNlKCkgIT09IFN0cmluZyhvYmplY3RbcHJvcF0pLnRvTG93ZXJDYXNlKCkpe3JldHVybiBmYWxzZTt9XHJcbiAgICAgICAgICAgIGVsc2V7cmV0dXJuIG1hdGNoO31cclxuICAgICAgICB9XHJcbiAgICB9LCB0cnVlKTtcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWQpIHtcclxuICAgIHZhciBzeiA9IGFycmF5Lmxlbmd0aDtcclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzejsgaW5kZXgrKykge1xyXG4gICAgICAgIGlmIChwcmVkKGFycmF5W2luZGV4XSkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5W2luZGV4XTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGFwcGx5X29uKG9iamVjdHMsIGZ1bmMpe1xyXG4gICAgcmV0dXJuIG9iamVjdHMoKS5tYXAoZnVuYyk7XHJcbn1cclxuIiwiLypcclxuVGhlIEludmNhdGlvbnNzdGF0ZSBtb2R1bGUgaGFuZGxlcyBBR00gbWV0aG9kIGludm9jYXRpb25zLiB2aWEgdGhlICdpbnZva2UnIG1ldGhvZFxyXG5JdCBzZW5kcyBhbmQgcmVjZWl2ZXMgYWxsIGludm9jYXRpb24tcmVsYXRlZCBtZXNzYWdlcywgdmlhIHRoZSBcInByb2Nlc3NfcmVzcG9uc2VcIiBtZXRob2RcclxudGhhdCBpdCBleHBvc2VzIGFuZCB2aWEgdGhlIFwic2VuZF9yZXF1ZXN0XCIgY2FsbGJhY2sgXHJcblxyXG4qL1xyXG5cclxudmFyIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9hZ21faGVscGVyc1wiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbiwgaW5zdGFuY2UsIHNlbmRfcmVxdWVzdCl7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHRcclxuXHQvL0hlcmUgd2Ugc3RvcmUgYWxsIHBlbmRpbmcgY2FsbGJhY2tzXHJcbiAgICB2YXIgcGVuZGluZ19jYWxsYmFja3MgPSB7fTtcclxuXHRcclxuXHRcclxuXHQvL0ludm9rZXMgYW4gQUdNIG1ldGhvZCB0byBhIHNpbmdsZSBBR00gc2VydmVyLCBnaXZlbiB2YWxpZCBpbnB1dC5cclxuXHRmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmd1bWVudF9vYmosIHRhcmdldCwgc3R1ZmYsIHN1Y2Nlc3MsIGVycm9yKXtcclxuXHRcdCAvL0dlbmVyYXRlIGEgdW5pcXVlIGludm9jYXRpb24gSUQsIGZvciB0aGlzIGludm9jYXRpb25cclxuICAgICAgICAgdmFyIGludm9jYXRpb25faWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTAwMDAwMDAwMDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vUmVnaXN0ZXIgdGhlIHVzZXIncyBjYWxsYmFja3NcclxuICAgICAgICByZWdpc3Rlcl9pbnZvY2F0aW9uKGludm9jYXRpb25faWQsIHttZXRob2Q6bWV0aG9kLCBjYWxsZWRfd2l0aDphcmd1bWVudF9vYmp9LHN1Y2Nlc3MsIGVycm9yLCBzdHVmZi5tZXRob2RfcmVzcG9uc2VfdGltZW91dCk7XHJcblxyXG4gICAgICAgIC8vR2V0IGEgcmVzcG9uc2Ugc3ViamVjdCBmb3IgdGhpcyBpbnZvY2F0aW9uXHJcbiAgICAgICAgaW5zdGFuY2UucmVzcG9uc2Vfc3ViamVjdChtZXRob2QsIGZ1bmN0aW9uKHJlc3BvbnNlX3N1YmplY3Qpe1xyXG4gICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAvL0NvbnN0cnVjdCBhIG1lc3NhZ2VcclxuICAgICAgICAgICAgIHZhciBtZXNzYWdlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICBNZXRob2RSZXF1ZXN0U3ViamVjdDp0YXJnZXQucmVxdWVzdF9zdWJqZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgICBNZXRob2RSZXNwb25zZVN1YmplY3Q6cmVzcG9uc2Vfc3ViamVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgQ2xpZW50Omluc3RhbmNlLmluZm8oKSxcclxuICAgICAgICAgICAgICAgICAgICAgQ29udGV4dDp7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBBcmd1bWVudHM6IGhlbHBlcnMucGFyYW1ldGVyc19zdHJpbmdpZnkoYXJndW1lbnRfb2JqKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIEludm9jYXRpb25JZDppbnZvY2F0aW9uX2lkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0VHlwZTpzdHVmZi5vYmplY3RfdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIERpc3BsYXlDb250ZXh0OnN0dWZmLmRpc3BsYXlfY29udGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIE1ldGhvZE5hbWU6bWV0aG9kLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBFeGVjdXRpb25TZXJ2ZXI6dGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgVGltZW91dDpzdHVmZi5tZXRob2RfcmVzcG9uc2VfdGltZW91dFxyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgIC8vU2VuZCBpdFxyXG5cclxuICAgICAgICAgICAgIHNlbmRfcmVxdWVzdChtZXNzYWdlKTtcclxuXHRcdFx0IGlmKGdsb2JhbC5jb25zb2xlIT09dW5kZWZpbmVkJiYgY29uZmlndXJhdGlvbi5kZWJ1Zz09PXRydWUpe1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoXCIlYz4+PiBzZW5kaW5nIE1ldGhvZEludm9jYXRpb25SZXF1ZXN0TWVzc2FnZVwiLCBcImJhY2tncm91bmQtY29sb3I6aHNsYSgxOTgsIDUxJSwgNzklLCAwLjUpXCIpO1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoXCIlY1wiK0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLCBcImJhY2tncm91bmQtY29sb3I6aHNsYSgxOTgsIDUxJSwgNzklLCAwLjUpXCIpO1xyXG5cdFx0XHR9XHJcbiAgICAgICBcclxuICAgICAgICB9KTsgICAgXHJcblx0fVxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vQWRkcyBjYWxsYmFja3MgZm9yIGEgZ2l2ZW4gaW52b2NhdGlvbiBJRFxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJfaW52b2NhdGlvbihpbnZvY2F0aW9uX2lkLCByZXNwb25zZSwgc3VjY2VzcywgZXJyb3IsIHRpbWVvdXQpe1xyXG4gICAgICAgIC8vQWRkcyB0aGUgY2FsbGJhY2tzXHJcbiAgICAgICAgcGVuZGluZ19jYWxsYmFja3NbaW52b2NhdGlvbl9pZF0gPSB7cmVzcG9uc2U6cmVzcG9uc2UsIHN1Y2Nlc3M6c3VjY2VzcywgZXJyb3I6ZXJyb3J9O1xyXG4gICAgICAgIC8vU2NoZWR1bGVzIHRvIHRocm93IGEgdGltZW91dCBpZiBub2JvZHkgYW5zd2Vyc1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYocGVuZGluZ19jYWxsYmFja3NbaW52b2NhdGlvbl9pZF09PT11bmRlZmluZWQpe3JldHVybjt9XHJcbiAgICAgICAgICAgIGVycm9yKHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZDpyZXNwb25zZS5tZXRob2QsIGNhbGxlZF93aXRoOnJlc3BvbnNlLmFyZ3VtZW50X29iaixcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6XCJUaW1lb3V0IHJlYWNoZWRcIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdfY2FsbGJhY2tzW2ludm9jYXRpb25faWRdO1xyXG4gICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgXHJcblx0ZnVuY3Rpb24gcHJvY2Vzc19tZXRob2RfcmVzcG9uc2UobWVzc2FnZSl7XHJcblx0XHQvL0ZpbmRzIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja1xyXG4gICAgICAgIHZhciBjYWxsYmFjayA9IHBlbmRpbmdfY2FsbGJhY2tzW21lc3NhZ2UuSW52b2NhdGlvbklkXTtcclxuICAgICAgICBpZihjYWxsYmFjayE9PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGlmKGdsb2JhbC5jb25zb2xlIT09dW5kZWZpbmVkJiYgY29uZmlndXJhdGlvbi5kZWJ1Zz09PXRydWUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIiVjPDw8IHJlY2VpdmluZyBNZXRob2RJbnZvY2F0aW9uUmVzdWx0TWVzc2FnZVwiLCBcImJhY2tncm91bmQtY29sb3I6aHNsYSgxMTgsIDUxJSwgNzklLCAwLjUpXCIpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIiVjXCIrSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIFwiYmFja2dyb3VuZC1jb2xvcjpoc2xhKDExOCwgNTElLCA3OSUsIDAuNSlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9JZiB0aGUgc2VydmVyIHJldHVybmVkIHN1Y2Nlc3MsIGV4ZWN1dGUgdGhlIHN1Y2Nlc3MgY2FsbGJhY2tcclxuICAgICAgICAgICAgaWYobWVzc2FnZS5TdGF0dXMgPT09IDAmJnR5cGVvZiBjYWxsYmFjay5zdWNjZXNzPT09XCJmdW5jdGlvblwiKXtcclxuICAgICAgICAgICAgICAgIC8vcGFyc2UgdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhlbHBlcnMucGFyYW1ldGVyc19wYXJzZShtZXNzYWdlLlJlc3VsdENvbnRleHQpLmFyZ3VtZW50cztcclxuXHRcdFx0XHQvL0lmIHRoZSByZXN1bHQgaXMgYW4gZW1wdHkgb2JqZWN0LCB0aGVyZSBpcyBubyByZXN1bHRcclxuICAgICAgICAgICAgICAgIGlmKE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoPT09MCl7cmVzdWx0ID0gdW5kZWZpbmVkO31cclxuXHJcbiAgICAgICAgICAgICAgICAvL0xvZyB0aGF0IHdlIHJlY2VpdmVkIGEgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICBpZihnbG9iYWwuY29uc29sZSE9PXVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnPT09dHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJzw8PCAgXCInK2NhbGxiYWNrLnJlc3BvbnNlLm1ldGhvZC5uYW1lKydcIiB3YXMgZXhlY3V0ZWQgYnkgJytKU09OLnN0cmluZ2lmeShoZWxwZXJzLnByZXByb2Nlc3Nfc2VydmVyKG1lc3NhZ2UuU2VydmVyKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9FeGVjdXRlIHRoZSBzdWNjZXNzIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5zdWNjZXNzKHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6Y2FsbGJhY2sucmVzcG9uc2UubWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOmNhbGxiYWNrLnJlc3BvbnNlLmNhbGxlZF93aXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVkX2J5OmhlbHBlcnMucHJlcHJvY2Vzc19zZXJ2ZXIobWVzc2FnZS5TZXJ2ZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkOnJlc3VsdCxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOm1lc3NhZ2UuUmVzdWx0TWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICBsb2dfZGV0YWlsczptZXNzYWdlLlJlc3VsdExvZ0RldGFpbHNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgLy9FbHNlLCByZXR1cm4gYW4gZXJyb3JcclxuICAgICAgICAgICAgfWVsc2UgaWYodHlwZW9mIGNhbGxiYWNrLmVycm9yPT09XCJmdW5jdGlvblwiKXtcclxuICAgICAgICAgICAgICAgaWYoZ2xvYmFsLmNvbnNvbGUhPT11bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1Zz09PXRydWUpe1xyXG4gICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJzw8PCAgXCInK2NhbGxiYWNrLnJlc3BvbnNlLm1ldGhvZC5uYW1lKydcIiB3YXMgZXhlY3V0ZWQgd2l0aCBlcnJvciBieSAnK0pTT04uc3RyaW5naWZ5KGhlbHBlcnMucHJlcHJvY2Vzc19zZXJ2ZXIobWVzc2FnZS5TZXJ2ZXIpKSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgY2FsbGJhY2suZXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgbWV0aG9kOmNhbGxiYWNrLnJlc3BvbnNlLm1ldGhvZCxcclxuICAgICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOmNhbGxiYWNrLnJlc3BvbnNlLmNhbGxlZF93aXRoLFxyXG4gICAgICAgICAgICAgICAgICAgbWVzc2FnZTptZXNzYWdlLlJlc3VsdE1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICBsb2dfZGV0YWlsczptZXNzYWdlLlJlc3VsdExvZ0RldGFpbHMsXHJcbiAgICAgICAgICAgICAgICAgICBzdGF0dXM6bWVzc2FnZS5zdGF0dXNcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHRcdFx0Ly9GaW5hbGx5LCByZW1vdmUgdGhlIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICBkZWxldGUgcGVuZGluZ19jYWxsYmFja3NbbWVzc2FnZS5JbnZvY2F0aW9uSWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHRcclxuICAgIHJldHVybiB7cHJvY2Vzc19tZXRob2RfcmVzcG9uc2U6cHJvY2Vzc19tZXRob2RfcmVzcG9uc2UsIGludm9rZTppbnZva2V9O1xyXG59O1xyXG4iLCIvKlxyXG5UaGUgTWV0aG9kc3RhdGUgbW9kdWxlLCBrZWVwcyB0aGUgc3RhdGUgb2YgYXZhaWxhYmxlIEFHTSBtZXRob2RzIGluIHRoZSBuZXR3b3JrLlxyXG4qL1xyXG5cclxudmFyIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9hZ21faGVscGVyc1wiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbil7XHJcblx0Ly9BIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSBBR00gbWV0aG9kc1xyXG5cdHZhciBtZXRob2RzID0ge307XHJcblxyXG5cdC8vU2F2ZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBtZXRyaWMgZnVuY3Rpb24gaWYgaXQgZXhpc3RzXHJcblx0dmFyIG9iamVjdE1ldHJpYyA9IChjb25maWd1cmF0aW9uLm1ldHJpY3MhPT11bmRlZmluZWQpP2NvbmZpZ3VyYXRpb24ubWV0cmljcy5udW1iZXJNZXRyaWMuYmluZChjb25maWd1cmF0aW9uLm1ldHJpY3MpOmZ1bmN0aW9uKCl7fTtcclxuXHJcbiAgICAvL0FkZHMgYSBuZXcgc2VydmVyIHRvIGEgbWV0aG9kLiBDcmVhdGVzIHRoZSBtZXRob2QgaWYgaXQgaXMgbm90IGNyZWF0ZWQgcHJldmlvdXNseS5cclxuICAgIGZ1bmN0aW9uIGFkZF9zZXJ2ZXJfdG9fbWV0aG9kKG1ldGhvZF9pbmZvLCBzZXJ2ZXJfaWQsIHNlcnZlcl9pbmZvKXtcclxuICAgICAgICAvL0dldCB0aGUgbWV0aG9kIElEXHJcbiAgICAgICAgdmFyIG1ldGhvZF9pZCA9IGdldF9tZXRob2RfaWQobWV0aG9kX2luZm8pO1xyXG5cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy9PbmUgbWV0aG9kIGNhbiBoYXZlIHNldmVyYWwgcmVxdWVzdCBzdWJqZWN0cyBwZXIgc2VydmVyLlxyXG4gICAgICAgIC8vU28gdGhlIHJlcXVlc3Qgc3ViamVjdCBpcyBhY3R1YWxseSBub3QgYSBwcm9wZXJ0eSBvZiB0aGUgbWV0aG9kXHJcbiAgICAgICAgdmFyIHJlcXVlc3Rfc3ViamVjdCA9IG1ldGhvZF9pbmZvLnJlcXVlc3Rfc3ViamVjdDtcclxuICAgICAgICBkZWxldGUgIG1ldGhvZF9pbmZvLnJlcXVlc3Rfc3ViamVjdDtcclxuXHJcblxyXG5cdFx0Ly9Db3B5IHRoZSBtZXRob2QgYW5kIHNlcnZlciBvYmplY3RzIHRvIGEgZm9ybWF0IHN1aXRhYmxlIGZvciBzZW5kaW5nIHRvIHVzZXJzXHJcbiAgICAgICAgdmFyIG1ldGhvZF9pbmZvX2ZyaWVuZGx5ID0gaGVscGVycy5jbG9uZV9vYmplY3QobWV0aG9kX2luZm8pO1xyXG4gICAgXHR2YXIgc2VydmVyX2luZm9fZnJpZW5kbHkgPSBoZWxwZXJzLmNsb25lX29iamVjdChzZXJ2ZXJfaW5mbyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHNbbWV0aG9kX2lkXTtcclxuXHJcbiAgICAgICAgLy9JZiB0aGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0LCBjcmVhdGUgaXRcclxuICAgICAgICBpZihtZXRob2QgPT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgLy9TYXZlIHRoZSBpbmZvXHJcbiAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZHNbbWV0aG9kX2lkXSA9IHtpbmZvOm1ldGhvZF9pbmZvLCBzZXJ2ZXJzOnt9fTtcclxuXHRcdFx0Ly9BZGQgcmVxdWVzdF9zdWJqZWN0XHJcbiAgICAgICAgICBcdG1ldGhvZCA9IGFkZF9yZXF1ZXN0X3N1YmplY3QobWV0aG9kLCBzZXJ2ZXJfaWQsIHJlcXVlc3Rfc3ViamVjdCk7XHJcblxyXG4gICAgICAgICAgICAgLy9FeGVjdXRlIHVzZXIgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgIGhlbHBlcnMuZXhlY3V0ZV9hbGxfd2l0aChjb25maWd1cmF0aW9uLm1ldGhvZF9hZGRlZCwgbWV0aG9kX2luZm9fZnJpZW5kbHkpO1xyXG4gICAgICAgICAgICAvL0xvZyBhbmQgcHVibGlzaCBtZXRyaWNzXHJcbiAgICAgICAgICAgIGlmKGdsb2JhbC5jb25zb2xlIT09dW5kZWZpbmVkICYmIGNvbnNvbGUudGFibGUhPT11bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1Zz09PXRydWUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCI+Pj4+Pj4gTmV3IG1ldGhvZCBkZXRlY3RlZDogXCIrSlNPTi5zdHJpbmdpZnkobWV0aG9kX2luZm9fZnJpZW5kbHkpKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUudGFibGUoZ2V0X21ldGhvZHMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHRcdFx0b2JqZWN0TWV0cmljKFwiTWV0aG9kcyB0b3RhbCBjb3VudFwiLCBPYmplY3Qua2V5cyhtZXRob2RzKS5sZW5ndGgpO1xyXG4gICAgICAgIH1lbHNle1xyXG5cdFx0XHQvL0Vsc2UsIGp1c3QgYWRkIHRoZSByZXF1ZXN0IHN1YmplY3RcclxuICAgICAgICBcdG1ldGhvZCA9IGFkZF9yZXF1ZXN0X3N1YmplY3QobWV0aG9kLCBzZXJ2ZXJfaWQsIHJlcXVlc3Rfc3ViamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRXhlY3V0ZSB1c2VyIGNhbGxiYWNrc1xyXG4gICAgICAgIGhlbHBlcnMuZXhlY3V0ZV9hbGxfd2l0aChjb25maWd1cmF0aW9uLnNlcnZlcl9tZXRob2RfYWRkZWQsIHttZXRob2Q6bWV0aG9kX2luZm9fZnJpZW5kbHksIHNlcnZlcjpzZXJ2ZXJfaW5mb19mcmllbmRseX0pO1xyXG4gICAgfVxyXG5cclxuXHQvL0FkZHMgcmVxdWVzdCBzdWJqZWN0IGZvciBzZXJ2ZXIgYW5kIG1ldGhvZFxyXG4gICAgZnVuY3Rpb24gYWRkX3JlcXVlc3Rfc3ViamVjdChtZXRob2QsIHNlcnZlcl9pZCwgcmVxdWVzdF9zdWJqZWN0KXtcclxuICAgIFx0bWV0aG9kLnNlcnZlcnNbc2VydmVyX2lkXSA9IHJlcXVlc3Rfc3ViamVjdDtcclxuICAgIFx0cmV0dXJuIG1ldGhvZDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy9SZW1vdmVzIGEgc2VydmVyIGZyb20gYSBtZXRob2QuIERlbGV0ZXMgdGhlIG1ldGhvZCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBzZXJ2ZXJzIGxlZnQuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVfc2VydmVyX2Zyb21fbWV0aG9kKG1ldGhvZF9pZCwgc2VydmVyX2lkLCBzZXJ2ZXJfaW5mbykge1xyXG4gICAgICAvL09idGFpbiBpbmZvIGFib3V0IHRoZSBtZXRob2QgYmVmb3JlIHJlbW92aW5nIGl0LlxyXG4gICAgICB2YXIgbWV0aG9kX2luZm9fZnJpZW5kbHkgPSBnZXRfbWV0aG9kKG1ldGhvZF9pZCk7XHJcbiAgICAgIHZhciBzZXJ2ZXJfaW5mb19mcmllbmRseSA9IGhlbHBlcnMuY2xvbmVfb2JqZWN0KHNlcnZlcl9pbmZvKTtcclxuXHJcblxyXG4gICAgICAvL1JlbW92ZSB0aGUgc2VydmVyIGZyb20gdGhlIGxpc3RcclxuICAgICAgdmFyIHNlcnZlcnMgPSBtZXRob2RzW21ldGhvZF9pZF0uc2VydmVycztcclxuICAgICAgZGVsZXRlIHNlcnZlcnNbc2VydmVyX2lkXTtcclxuICAgICAgLy9SZW1vdmUgdGhlIG1ldGhvZCBpZiB0aGVyZSBhcmVuJ3QgYW55IHNlcnZlcnMgbGVmdFxyXG4gICAgICBpZiAoT2JqZWN0LmtleXMoc2VydmVycykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY29uZmlndXJhdGlvbi5vbl9tZXRob2RfcmVtb3ZlZDtcclxuICAgICAgICBoZWxwZXJzLmV4ZWN1dGVfYWxsX3dpdGgoY29uZmlndXJhdGlvbi5tZXRob2RfcmVtb3ZlZCwgbWV0aG9kX2luZm9fZnJpZW5kbHkpO1xyXG4gICAgICAgIC8vcmVtb3ZlIG1ldGhvZFxyXG4gICAgICAgIGRlbGV0ZSBtZXRob2RzW21ldGhvZF9pZF07XHJcbiAgICAgICAgLy9Mb2cgYW5kIG1ldHJpY3NcclxuICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25zb2xlLnRhYmxlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCI8PDw8PDwgTWV0aG9kIHN0b3BwZWQgYmVpbmcgYXZhaWxhYmxlOiBcIiArIEpTT04uc3RyaW5naWZ5KG1ldGhvZF9pbmZvX2ZyaWVuZGx5KSk7XHJcbiAgICAgICAgICBjb25zb2xlLnRhYmxlKGdldF9tZXRob2RzKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmplY3RNZXRyaWMoXCJNZXRob2RzIHRvdGFsIGNvdW50XCIsIE9iamVjdC5rZXlzKG1ldGhvZHMpLmxlbmd0aCk7XHJcbiAgICAgIH1cclxuICAgICAgLy9FeGVjdXRlIHVzZXIgY2FsbGJhY2tzXHJcbiAgICAgIGhlbHBlcnMuZXhlY3V0ZV9hbGxfd2l0aChjb25maWd1cmF0aW9uLnNlcnZlcl9tZXRob2RfcmVtb3ZlZCwge1xyXG4gICAgICAgIG1ldGhvZDogbWV0aG9kX2luZm9fZnJpZW5kbHksXHJcbiAgICAgICAgc2VydmVyOiBzZXJ2ZXJfaW5mb19mcmllbmRseVxyXG4gICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG5cdC8vR2VuZXJhdGVzIGEgdW5pcXVlIGlmIGZvciBhIG1ldGhvZFxyXG4gICAgZnVuY3Rpb24gZ2V0X21ldGhvZF9pZChtKXtcclxuXHRcdC8vU2V0dGluZyBwcm9wZXJpZXMgdG8gZGVmYXVsdHM6XHJcblx0XHR2YXIgYWNjZXB0cyA9IG0uYWNjZXB0cyAhPT11bmRlZmluZWQ/bS5hY2NlcHRzOlwiXCI7XHJcblx0XHR2YXIgcmV0dXJucyA9IG0ucmV0dXJucyAhPT11bmRlZmluZWQ/bS5yZXR1cm5zOlwiXCI7XHJcblx0XHR2YXIgdmVyc2lvbiA9ICBtLnZlcnNpb24gIT09dW5kZWZpbmVkP20udmVyc2lvbjowO1xyXG5cdFx0cmV0dXJuIChtLm5hbWUrYWNjZXB0cytyZXR1cm5zK3ZlcnNpb24pLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vUmV0cmlldmUgYWxsIG1ldGhvZHNcclxuICAgIGZ1bmN0aW9uIGdldF9tZXRob2RzKCl7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1ldGhvZHMpLm1hcChmdW5jdGlvbihtZXRob2Qpe1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5jbG9uZV9vYmplY3QobWV0aG9kc1ttZXRob2RdLmluZm8pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy9SZXRyaWV2ZSBhbiBhcnJheSBvZiB0aGUgSUQncyBvZiB0aGUgc2VydmVycyBmb3IgYSBtZXRob2RcclxuICAgIGZ1bmN0aW9uIGdldF9zZXJ2ZXJzX2Zvcl9tZXRob2QobWV0aG9kX2luZm8pe1xyXG4gICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzW2dldF9tZXRob2RfaWQobWV0aG9kX2luZm8pXTtcclxuICAgICAgICBpZihtZXRob2QgIT09dW5kZWZpbmVkKXtyZXR1cm4gbWV0aG9kLnNlcnZlcnM7fVxyXG4gICAgICAgIGVsc2V7cmV0dXJuIHt9O31cclxuICAgIH1cclxuXHJcbiAgICAvL1JldHJpZXZlcyBhIGNvcHkgb2YgdGhlIG1ldGhvZCwgYnkgaXRzIElEXHJcbiAgICBmdW5jdGlvbiBnZXRfbWV0aG9kKG1ldGhvZF9pZCl7XHJcbiAgICAgICAgaWYodHlwZW9mIG1ldGhvZF9pZCA9PT0gXCJvYmplY3RcIil7bWV0aG9kX2lkID0gZ2V0X21ldGhvZF9pZChtZXRob2RfaWQpO31cclxuICAgICAgICBpZihtZXRob2RzW21ldGhvZF9pZF0hPT11bmRlZmluZWQpXHJcbiAgICAgICAgLy9XZSBjbG9uZSB0aGUgbWV0aG9kIGRlZmluaXRpb24gc28gaXQgY2FuIGJlIG11dGF0ZWQgd2l0aG91dCBhZmZlY3RpbmcgdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgcmV0dXJuIGhlbHBlcnMuY2xvbmVfb2JqZWN0KG1ldGhvZHNbbWV0aG9kX2lkXS5pbmZvKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ2V0X21ldGhvZHM6Z2V0X21ldGhvZHMsXHJcbiAgICAgICAgICAgIGdldF9tZXRob2Q6Z2V0X21ldGhvZCxcclxuICAgICAgICAgICAgZ2V0X21ldGhvZF9pZDpnZXRfbWV0aG9kX2lkLFxyXG4gICAgICAgICAgICBhZGRfc2VydmVyX3RvX21ldGhvZDphZGRfc2VydmVyX3RvX21ldGhvZCxcclxuICAgICAgICAgICAgcmVtb3ZlX3NlcnZlcl9mcm9tX21ldGhvZDpyZW1vdmVfc2VydmVyX2Zyb21fbWV0aG9kLFxyXG4gICAgICAgICAgICBnZXRfc2VydmVyc19mb3JfbWV0aG9kOmdldF9zZXJ2ZXJzX2Zvcl9tZXRob2RcclxuICAgICAgICAgICAgfTtcclxuXHJcbn07XHJcbiIsIi8qXHJcblRoZSBTZXJ2ZXJzdGF0ZSBtb2R1bGUgcHJvY2Vzc2VzIHNlcnZlciBwcmVzZW5jZXMgYW5kIGtlZXBzIHRoZSBzdGF0ZSBvZiBhdmFpbGFibGUgQUdNIHNlcnZlcnMgaW4gdGhlIG5ldHdvcmsuXHJcbiovXHJcbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vYWdtX2hlbHBlcnNcIik7XHJcblxyXG52YXIgZ2V0X3NlcnZlcl9pZCA9IGhlbHBlcnMuZ2V0X3NlcnZlcl9pZDtcclxuXHJcbnZhciBjbGllbnRfbWV0aG9kc3RhdGUgPSByZXF1aXJlKFwiLi9hZ21fY2xpZW50X21ldGhvZHN0YXRlXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25maWd1cmF0aW9uLCBpbnN0YW5jZSl7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0Ly9BIGxpc3Qgb2YgYWxsIHRoZSBzZXJ2ZXJzIGluIHRoZSBuZXR3b3JrXHJcblx0dmFyIHNlcnZlcnMgPSB7fTtcclxuXHJcblx0Ly9JbnN0YW50aWF0ZXMgdGhlIFwibWV0aG9kc3RhdGVcIiBtb2R1bGVcclxuICAgIHZhciBtZXRob2RzID0gY2xpZW50X21ldGhvZHN0YXRlKGNvbmZpZ3VyYXRpb24pO1xyXG5cclxuXHJcblx0Ly9Qcm9jZXNzZXMgYSBwcmVzZW5jZSBtZXNzYWdlIGZyb20gYSBzZXJ2ZXJcclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NfcHJlc2VuY2UocHJlc2VuY2UsIGlzX3ByZXNlbmNlKXtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKHByZXNlbmNlLkluc3RhbmNlKVxyXG5cdFx0Ly9HZXQgc2VydmVyIGluZm8uXHJcblx0XHR2YXIgc2VydmVyaW5mbyA9IGhlbHBlcnMucHJlcHJvY2Vzc19zZXJ2ZXIocHJlc2VuY2UuSW5zdGFuY2UpO1xyXG5cclxuICAgICAgICAvL0lmIGl0IGlzIGEgbmV3IHNlcnZlciwgcmVnaXN0ZXIgaXQuXHJcblx0XHRpZighZXhpc3RzKHNlcnZlcmluZm8pKXtcclxuXHRcdFx0YWRkX3NlcnZlcihzZXJ2ZXJpbmZvKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYoIShpc19wcmVzZW5jZSAmJiBwcmVzZW5jZS5QdWJsaXNoaW5nSW50ZXJ2YWwgPT09IDApKXtcclxuXHRcdFx0Ly9EbyBub3RoaW5nIGZvciBwcmVzZW5jZSBtZXNzYWdlcyB3aXRoIGludGVydmFsIDBcclxuXHRcdFx0Ly9UYWtlIGNhcmUgb2YgdGhlIHRpbWVvdXRzXHJcblx0XHRcdHNldF90aW1lb3V0KHNlcnZlcmluZm8sIHByZXNlbmNlLlB1Ymxpc2hpbmdJbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblx0XHQvL0ZpbmFsbHksIHVwZGF0ZSB0aGUgbWV0aG9kc1xyXG5cdFx0aWYocHJlc2VuY2UuTWV0aG9kRGVmaW5pdGlvbnMhPT11bmRlZmluZWQpe1xyXG5cdFx0XHR1cGRhdGVfbWV0aG9kcyhzZXJ2ZXJpbmZvLCBwcmVzZW5jZS5NZXRob2REZWZpbml0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly9UaGlzIGZ1bmN0aW9uIHNldHMgYSB0aW1lb3V0IHdoaWNoIHJlbW92ZXMgdGhlIHNlcnZlciB1bmxlc3NcclxuXHQvL3RoZSBmdW5jdGlvbiBpcyBjYWxsZWQgYWdhaW4gYmVmb3JlIHRoZSB0aW1lb3V0IGlzIG92ZXJcclxuICAgIGZ1bmN0aW9uIHNldF90aW1lb3V0KHNlcnZlcmluZm8sIGR1cmF0aW9uKXtcclxuXHJcblx0XHRpZihkdXJhdGlvbiA9PT0tMSkgcmV0dXJuO1xyXG5cdFx0IC8vUmV0cmlldmUgdGhlIHNlcnZlclxyXG4gICAgICAgICB2YXIgc2VydmVyX2lkID0gZ2V0X3NlcnZlcl9pZChzZXJ2ZXJpbmZvKTtcclxuICAgICAgICAgdmFyIHNlcnZlciA9IHNlcnZlcnNbc2VydmVyX2lkXTtcclxuICAgICAgICAgLy9TdG9wIHRoZSBwcmV2aW91cyB0aW1lb3V0XHJcbiAgICAgICAgIGlmKHNlcnZlci5ib21iICE9PXVuZGVmaW5lZCl7XHJcblx0XHRcdGNsZWFyVGltZW91dChzZXJ2ZXIuYm9tYik7XHJcbiAgICAgICAgIH1cclxuXHRcdCAvL1NldCBhIG5ldyBvbmVcclxuXHRcdCBzZXJ2ZXIuYm9tYiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuXHRcdFx0cmVtb3ZlX3NlcnZlcihzZXJ2ZXJpbmZvKTtcclxuXHRcdCB9LCBkdXJhdGlvbipjb25maWd1cmF0aW9uLnJlbW92ZV9zZXJ2ZXJfb25fbl9taXNzaW5nX2hlYXJ0YmVhdHMrMSk7XHJcblxyXG4gICAgfVxyXG4gICAgLy9DaGVja3MgaWYgYSBzZXJ2ZXJzIGV4aXN0c1xyXG4gICAgZnVuY3Rpb24gZXhpc3RzKHNlcnZlcmluZm8pe1xyXG4gICAgICAgIHZhciBzZXJ2ZXJfaWQgPSBnZXRfc2VydmVyX2lkKHNlcnZlcmluZm8pO1xyXG4gICAgICAgIHJldHVybiBzZXJ2ZXJzW3NlcnZlcl9pZF0hPT11bmRlZmluZWQ7XHJcbiAgICB9XHJcblx0Ly9SZWdpc3RlciBhIHNlcnZlclxyXG5cdGZ1bmN0aW9uIGFkZF9zZXJ2ZXIoc2VydmVyaW5mbyl7XHJcbiAgICAgICAgLy9PYnRhaW4gYSBzZXJ2ZXIgSUQgYW5kIHN0b3JlIHRoZSBuZXcgc2VydmVyXHJcbiAgICAgICAgdmFyIHNlcnZlcl9pZCA9IGdldF9zZXJ2ZXJfaWQoc2VydmVyaW5mbyk7XHJcblx0XHRzZXJ2ZXJzW3NlcnZlcl9pZF0gPSB7aW5mbzpzZXJ2ZXJpbmZvLCBtZXRob2RzOltdLCBib21iOnVuZGVmaW5lZH07XHJcblxyXG5cdFx0Ly9Mb2cgaW4gY29uc29sZVxyXG4gICAgICAgIGlmKGdsb2JhbC5jb25zb2xlIT09dW5kZWZpbmVkICYmIGNvbnNvbGUudGFibGUhPT11bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1Zz09PXRydWUpe1xyXG4gICAgICAgIFx0Y29uc29sZS5sb2coXCI+Pj4+Pj4gTmV3IHNlcnZlciBkZXRlY3RlZDogXCIrSlNPTi5zdHJpbmdpZnkoc2VydmVyaW5mbykpO1xyXG4gICAgICAgICAgICBjb25zb2xlLnRhYmxlKGdldF9zZXJ2ZXJzKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9FeGVjdXRlIHVzZXIgY2FsbGJhY2tzXHJcbiAgICAgICAgaGVscGVycy5leGVjdXRlX2FsbF93aXRoKGNvbmZpZ3VyYXRpb24uc2VydmVyX2FkZGVkLCBzZXJ2ZXJpbmZvKTtcclxuXHJcblx0XHRyZXR1cm4gc2VydmVyX2lkO1xyXG5cdH1cclxuXHQvL1VucmVnaXN0ZXJzIGEgc2VydmVyXHJcblx0ZnVuY3Rpb24gcmVtb3ZlX3NlcnZlcihzZXJ2ZXJpbmZvKXtcclxuXHRcdC8vT2J0YWluIGEgc2VydmVyIElEXHJcbiAgICAgICAgdmFyIHNlcnZlcl9pZCA9IGdldF9zZXJ2ZXJfaWQoc2VydmVyaW5mbyk7XHJcbiAgICAgICAgLy9SZW1vdmUgdGhlIHNlcnZlcidzIG1ldGhvZHNcclxuICAgICAgICBzZXJ2ZXJzW3NlcnZlcl9pZF0ubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZF9pZCl7XHJcbiAgICAgICAgICAgIG1ldGhvZHMucmVtb3ZlX3NlcnZlcl9mcm9tX21ldGhvZChtZXRob2RfaWQsIHNlcnZlcl9pZCwgc2VydmVyaW5mbyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy9SZW1vdmUgdGhlIHNlcnZlciBpdHNlbGZcclxuICAgICAgICBkZWxldGUgc2VydmVyc1tzZXJ2ZXJfaWRdO1xyXG4gICAgICAgIC8vTG9nIGluIGNvbnNvbGVcclxuICAgICAgICAgaWYoZ2xvYmFsLmNvbnNvbGUhPT11bmRlZmluZWQgJiYgY29uc29sZS50YWJsZSE9PXVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnPT09dHJ1ZSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiPDw8PDw8IFNlcnZlciBzdG9wcGVkIGJlaW5nIGF2YWlsYWJsZTpcIitKU09OLnN0cmluZ2lmeShzZXJ2ZXJpbmZvKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUudGFibGUoZ2V0X3NlcnZlcnMoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy9FeGVjdXRlIHVzZXIgY2FsbGJhY2tzXHJcbiAgICAgICAgaGVscGVycy5leGVjdXRlX2FsbF93aXRoKGNvbmZpZ3VyYXRpb24uc2VydmVyX3JlbW92ZWQsIHNlcnZlcmluZm8pO1xyXG5cdH1cclxuXHJcbiAgICAvL1VwZGF0ZXMgdGhlIG1ldGhvZHMgb2YgYSBzZXJ2ZXJcclxuXHRmdW5jdGlvbiB1cGRhdGVfbWV0aG9kcyhzZXJ2ZXJpbmZvLCBuZXdfbWV0aG9kcyl7XHJcbiAgICAgICAgdmFyIHNlcnZlcl9pZCA9IGdldF9zZXJ2ZXJfaWQoc2VydmVyaW5mbyk7XHJcbiAgICAgICAgLy9HZXQgYW4gYXJyYXkgb2YgdGhlIG1ldGhvZHMgdGhlIHNlcnZlciBoYWQgYmVmb3JlIHdlIHN0YXJ0ZWQgdGhpc1xyXG5cdFx0dmFyIG9sZF9tZXRob2RzX2lkcyA9IHNlcnZlcnNbc2VydmVyX2lkXS5tZXRob2RzO1xyXG4gICAgICAgIC8vR2V0IGFuIGFycmF5IG9mIHRoZSBtZXRob2RzIHRoYXQgdGhlIHNlcnZlciBoYXMgbm93XHJcbiAgICAgICAgbmV3X21ldGhvZHMgPSBuZXdfbWV0aG9kcy5tYXAoaGVscGVycy5wcmVwcm9jZXNzX21ldGhvZCkucmVkdWNlKGZ1bmN0aW9uKG9iaiwgbWV0aG9kKXtcclxuICAgICAgICAgICBvYmpbbWV0aG9kcy5nZXRfbWV0aG9kX2lkKG1ldGhvZCldID0gbWV0aG9kO1xyXG4gICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgICAgIC8vRm9yIGVhY2ggb2YgdGhlIG9sZCBtZXRob2RzXHJcbiAgICAgICAgb2xkX21ldGhvZHNfaWRzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kX2lkKXtcclxuICAgICAgICAgICAgLy9DaGVjayBpZiBpdCBpcyBzdGlsbCB0aGVyZVxyXG4gICAgICAgICAgICBpZihuZXdfbWV0aG9kc1ttZXRob2RfaWRdPT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgLy9JZiBpdCBpc24ndCwgcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgICAgIG1ldGhvZHMucmVtb3ZlX3NlcnZlcl9mcm9tX21ldGhvZChtZXRob2RfaWQsIHNlcnZlcl9pZCwgc2VydmVyaW5mbyk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgLy9JZiBpdCBpcyB0aGVyZSBpbiBib3RoIHRoZSBvbGQgYXJyYXkgYW5kIHRoZSBuZXcgb25lLCB3ZSBkb24ndCBuZWVkIHRvIGFkZCBpdCBhZ2FpblxyXG4gICAgICAgICAgICAgICAgbmV3X21ldGhvZHNbbWV0aG9kX2lkXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vTm93IGFkZCB0aGUgbmV3IG1ldGhvZHNcclxuICAgICAgICB2YXIgbmV3X21ldGhvZHNfaWRzID0gT2JqZWN0LmtleXMobmV3X21ldGhvZHMpO1xyXG4gICAgICAgIG5ld19tZXRob2RzX2lkcy5mb3JFYWNoKGZ1bmN0aW9uKGlkKXtcclxuICAgICAgICAgICAgaWYobmV3X21ldGhvZHNbaWRdIT09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIG1ldGhvZHMuYWRkX3NlcnZlcl90b19tZXRob2QobmV3X21ldGhvZHNbaWRdLCBzZXJ2ZXJfaWQsIHNlcnZlcmluZm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy9Ob3cgYWxsIHdlIGhhdmUgdG8gZG8gaXMgcmVwbGFjZSB0aGUgbGlzdCBvZiBtZXRob2RzIHRoZSBzZXJ2ZXIgaGFzXHJcbiAgICAgICAgc2VydmVyc1tzZXJ2ZXJfaWRdLm1ldGhvZHMgPSBuZXdfbWV0aG9kc19pZHM7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vR2V0IGFsbCBzZXJ2ZXJzIGZvciBhIGdpdmVuIG1ldGhvZFxyXG4gICAgZnVuY3Rpb24gZ2V0X3NlcnZlcnMobWV0aG9kLCBpbmNsdWRlX3JlcXVlc3Rfc3ViamVjdCl7XHJcbiAgICAgICAgdmFyIHNlcnZlcl9pZHM7XHJcblx0XHQvL0lmIHRoZXJlIGlzbid0IGEgbWV0aG9kIGdldCB0aGUgSUQncyBvZiBhbGwgc2VydmVyc1xyXG4gICAgICAgIGlmKG1ldGhvZCA9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgIHNlcnZlcl9pZHMgPSBPYmplY3Qua2V5cyhzZXJ2ZXJzKTtcclxuXHRcdC8vRWxzZSwgZ2V0IGEgbGlzdCBvZiB0aGUgc2VydmVycyB0aGF0IGhhdmUgdGhlIG1ldGhvZFxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgIHZhciBpZHNfdG9fcmVxdWVzdF9zdWJqZWN0cyA9IG1ldGhvZHMuZ2V0X3NlcnZlcnNfZm9yX21ldGhvZChtZXRob2QpO1xyXG4gICAgICAgICAgIHNlcnZlcl9pZHMgPSBPYmplY3Qua2V5cyhpZHNfdG9fcmVxdWVzdF9zdWJqZWN0cyk7XHJcbiAgICAgICAgfVxyXG5cdFx0Ly9Gb3JtYXQgdGhlIGxpc3RcclxuICAgICAgICByZXR1cm4gc2VydmVyX2lkcy5tYXAoZnVuY3Rpb24oc2VydmVyX2lkKXtcclxuICAgICAgICAgICAgdmFyIHNlcnZlciA9ICBoZWxwZXJzLmNsb25lX29iamVjdChzZXJ2ZXJzW3NlcnZlcl9pZF0uaW5mbyk7XHJcbiAgICAgICAgICAgIC8vSW5jbHVkZSB0aGUgcmVxdWVzdCBzdWJqZWN0IGZvciBlYWNoIHNlcnZlciBmb3IgZWFjaCBtZXRob2Q6XHJcbiAgICAgICAgICAgIGlmKGluY2x1ZGVfcmVxdWVzdF9zdWJqZWN0KXtzZXJ2ZXIucmVxdWVzdF9zdWJqZWN0ID0gaWRzX3RvX3JlcXVlc3Rfc3ViamVjdHNbc2VydmVyX2lkXTt9XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXI7XHJcbiAgICAgICAgfSkuc29ydChjb21wYXJlX3NlcnZlcnMpO1xyXG4gICAgfVxyXG4gICAgLy9BIGNvbXBhcmVyIGZ1bmN0aW9uLiBTb3J0cyB0aGUgc2VydmVycyBiYXNlZCBvbiBhdmFpbGFiaWxpdHlcclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVfc2VydmVycyhzZXJ2ZXIxLCBzZXJ2ZXIyKXtcclxuXHRcdHZhciBzMSA9IDA7XHJcblx0XHR2YXIgczIgPSAwO1xyXG5cdFx0Ly8rMiBpZiB0aGUgc2VydmVyIGlzIG9uIHRoZSBzYW1lIG1hY2hpbmVcclxuXHRcdGlmKHNlcnZlcjEubWFjaGluZSA9PT1pbnN0YW5jZS5tYWNoaW5lKXtzMSA9IHMxKzI7fVxyXG5cdFx0aWYoc2VydmVyMi5tYWNoaW5lID09PWluc3RhbmNlLm1hY2hpbmUpe3MyID0gczIrMjt9XHJcblx0XHQvLysxIGlmIGl0IHJ1bnMgdW5kZXIgdGhlIHNhbWUgdXNlclxyXG5cdFx0aWYoc2VydmVyMS51c2VyID09PSBpbnN0YW5jZS51c2VyKXtzMSA9IHMxKzE7fVxyXG5cdFx0aWYoc2VydmVyMi51c2VyID09PSBpbnN0YW5jZS51c2VyKXtzMiA9IHMyKzE7fVxyXG5cdFx0cmV0dXJuIHMyIC0gczE7XHJcblx0fVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldF9tZXRob2RfaWRzKHNlcnZlcil7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZlcnNbZ2V0X3NlcnZlcl9pZChzZXJ2ZXIpXS5tZXRob2RzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvL0dldCBhbGwgbWV0aG9kcyBmb3IgYSBnaXZlbiBzZXJ2ZXJcclxuXHRmdW5jdGlvbiBnZXRfbWV0aG9kcyhzZXJ2ZXIpe1xyXG4gICAgICAgIC8vSWYgdGhlcmUgaXMgbm8gc2VydmVyIHNwZWNpZmllZCwgcmV0dXJuIGFsbFxyXG4gICAgICAgIGlmKHNlcnZlciA9PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5nZXRfbWV0aG9kcygpO1xyXG4gICAgICAgIC8vRWxzZSwgZ2V0IHRoZSBtZXRob2RzIGZyb20gdGhlIHNlcnZlciBvYmplY3RcclxuICAgICAgICB9ZWxzZSBpZihleGlzdHMoc2VydmVyKSl7XHJcbiAgICAgICAgICAgICByZXR1cm4gZ2V0X21ldGhvZF9pZHMoc2VydmVyKS5tYXAoZnVuY3Rpb24obWV0aG9kX2lkKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmdldF9tZXRob2QobWV0aG9kX2lkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgLy9JZiB0aGUgc2VydmVyIGlzIHNwZWNpZmllZCwgYnV0IGl0IGRvZXMgbm90IGV4aXN0LCByZXR1cm4gYW4gZW1wdHkgYXJyYXlcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuXHR9XHJcblxyXG4gICAgcmV0dXJuIHtwcm9jZXNzX3ByZXNlbmNlOnByb2Nlc3NfcHJlc2VuY2UsXHJcbiAgICAgICAgICAgIGdldF9tZXRob2RzOmdldF9tZXRob2RzLFxyXG4gICAgICAgICAgICBnZXRfbWV0aG9kX2lkczpnZXRfbWV0aG9kX2lkcyxcclxuICAgICAgICAgICAgZ2V0X3NlcnZlcnM6Z2V0X3NlcnZlcnMsXHJcbiAgICAgICAgICAgXHRnZXRfbWV0aG9kOm1ldGhvZHMuZ2V0X21ldGhvZCxcclxuICAgICAgICAgICAgZXhpc3RzOmV4aXN0cyxcclxuXHRcdFx0Y29tcGFyZV9zZXJ2ZXJzOmNvbXBhcmVfc2VydmVyc1xyXG4gICAgICAgICAgICB9O1xyXG59O1xyXG4iLCJcclxuLy9Db252ZXJ0cyBhcmd1bWVudHMgdG8gYW4gQUdNIGZyYW1lXHRcclxuZnVuY3Rpb24gcGFyYW1ldGVyc19zdHJpbmdpZnkoYXJndW1lbnRsaXN0LCBhcmd1bWVudF9kYXRhdHlwZXMpe1xyXG5cdC8vT3VyIGZpbmFsIHJlc3VsdCB3aWxsIGJlIGhlcmVcclxuXHR2YXIgZW5jb2RlZF9hcmd1bWVudHM9W107XHJcblx0Ly9ObyBkYXRhdHlwZXMsIG5vIHByb2JsZW0gKG1vc3Qgb2YgdGhlIHRpbWUgd2UgY2FuIGRlZHVjZSB0aGVtIGZyb20gdGhlIHZhbHVlcylcclxuXHRpZiAoYXJndW1lbnRfZGF0YXR5cGVzPT09dW5kZWZpbmVkKXthcmd1bWVudF9kYXRhdHlwZXMgPSB7fTt9XHJcblxyXG5cdGZvcih2YXIgaSBpbiBhcmd1bWVudGxpc3Qpe1xyXG5cdFx0aWYoYXJndW1lbnRsaXN0W2ldPT09dW5kZWZpbmVkKXticmVhazt9XHJcblx0XHRpZihhcmd1bWVudGxpc3RbaV0uY29uc3RydWN0b3IgIT09IE9iamVjdCl7XHJcblx0XHRcdGVuY29kZWRfYXJndW1lbnRzLnB1c2goe1xyXG5cdFx0XHRcdE5hbWU6aSxcclxuXHRcdFx0XHRjb21wb3NpdGU6ZmFsc2UsXHJcblx0XHRcdFx0Q29tcG9zaXRlVmFsdWU6bnVsbCxcclxuXHRcdFx0XHRWYWx1ZTogZW5jb2RlX2FyZ3VtZW50KGFyZ3VtZW50bGlzdFtpXSxhcmd1bWVudF9kYXRhdHlwZXNbaV0pXHJcblx0XHRcdH0pO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdC8vaWYgKGFyZ3VtZW50X2RhdGF0eXBlc1tpXT09PXVuZGVmaW5lZCl7YXJndW1lbnRfZGF0YXR5cGVzW2ldID0ge319XHJcblx0XHRcdGVuY29kZWRfYXJndW1lbnRzLnB1c2goe1xyXG5cdFx0XHRcdE5hbWU6aSxcclxuXHRcdFx0XHRjb21wb3NpdGU6dHJ1ZSxcclxuXHRcdFx0XHQvL1ZhbHVlOiBudWxsLFxyXG5cdFx0XHRcdENvbXBvc2l0ZVZhbHVlOnBhcmFtZXRlcnNfc3RyaW5naWZ5KGFyZ3VtZW50bGlzdFtpXSwgYXJndW1lbnRfZGF0YXR5cGVzW2ldKVxyXG5cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZW5jb2RlZF9hcmd1bWVudHM7XHRcclxuXHJcblx0IC8vRW5jb2RlcyBhIHNpbmdsZSBhcmd1bWVudCAoaW50LCBzdHJpbmcsIGJvb2xlYW4sIGRhdGUpIG9yIGFycmF5cyBvZiBhcmd1bWVudHNcclxuXHRmdW5jdGlvbiBlbmNvZGVfYXJndW1lbnQodmFsdWUsIGRhdGF0eXBlKXtcclxuXHRcdHZhciBhcnJheSA9IGZhbHNlO1xyXG5cdFx0dmFyIGVuY29kZWRfZGF0YXR5cGU7XHJcblx0XHRpZihkYXRhdHlwZSA9PT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0Ly9UcnkgdG8gZ2V0IHRoZSBkYXRhdHlwZSBmcm9tIHRoZSBhcmd1bWVudCBpdHNlbGZcclxuXHJcblx0XHRcdC8vVGVzdCBpZiBpdCBpcyBhcnJheVxyXG5cclxuXHRcdFx0Ly9teXZhbHVlIHBvaW50cyB0byB0aGUgdmFsdWUsIGlmIHdlIGFyZSBub3QgZGVhbGluZyB3aXRoIGFuIGFycmF5XHJcblx0XHRcdC8vaWYgd2UgZG8sIGl0IHBvaW50cyB0byB0aGUgaXRzIGZpcnN0IHZhbHVlLlxyXG5cdFx0XHR2YXIgbXl2YWx1ZTtcclxuXHRcdFx0aWYodmFsdWUgaW5zdGFuY2VvZiBBcnJheSl7XHJcblx0XHRcdFx0YXJyYXkgPSB0cnVlO215dmFsdWU9dmFsdWVbMF07XHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdG15dmFsdWUgPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vVHJ5IHRvIGd1ZXNzIHRoZSBhcmd1bWVudCB0eXBlXHJcblx0XHRcdGlmKHR5cGVvZiBteXZhbHVlID09ICdzdHJpbmcnIHx8IG15dmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpe2VuY29kZWRfZGF0YXR5cGU9NDt9XHJcblx0XHRcdGVsc2UgaWYobXl2YWx1ZSBpbnN0YW5jZW9mIERhdGUpe2VuY29kZWRfZGF0YXR5cGU9NTt9XHJcblx0XHRcdGVsc2UgaWYodHlwZW9mIG15dmFsdWUgPT09XCJib29sZWFuXCIpe2VuY29kZWRfZGF0YXR5cGU9MDt9XHJcblx0XHRcdGVsc2UgaWYoIWlzTmFOKG15dmFsdWUpKXtlbmNvZGVkX2RhdGF0eXBlPTI7fVxyXG5cclxuXHRcdH1lbHNlIGlmIChpc05hTihkYXRhdHlwZSkpe1xyXG5cdFx0XHQvL0NoZWNrIGlmIGl0IGlzIGFuIGFycmF5KCB0aGUgZGF0YXR5cGUgb2YgYXJyYXlzIGVuZHMgd2l0aCBbXSlcclxuXHRcdFx0ZGF0YXR5cGUgPSBkYXRhdHlwZS5zcGxpdChcIltdXCIpO1xyXG5cdFx0XHRpZiAoZGF0YXR5cGUubGVuZ3RoPT09Mil7YXJyYXk9dHJ1ZTt9XHJcblx0XHRcdGRhdGF0eXBlPWRhdGF0eXBlWzBdO1xyXG5cdFx0XHQvL0NvbnZlcnQgdGhlIGVsZW1lbnRhcnkgZGF0YXR5cGUgdG8gbnVtYmVyXHJcblx0XHRcdHZhciBkYXRhdHlwZXM9e0Jvb2xlYW46MCwgSW50ZWdlcjoxLCBEb3VibGU6MiwgTG9uZzozLCBTdHJpbmc6NCwgRGF0ZTo1fTtcclxuXHRcdFx0ZW5jb2RlZF9kYXRhdHlwZSA9IGRhdGF0eXBlc1tkYXRhdHlwZV07XHJcblx0XHRcdC8vQ29udmVydCBEYXRlIG9iamVjdHMgdG8gdGltZXN0YW1wcyBcclxuXHRcdFx0aWYgKGRhdGF0eXBlPT09XCJEYXRlVGltZVwiKXtcclxuXHRcdFx0XHQvL0ZvciBkYXRlIGFycmF5c1xyXG5cdFx0XHRcdGlmKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpe1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDtpPHZhbHVlLmxlbmd0aDtpKyspe1xyXG5cdFx0XHRcdFx0XHR2YWx1ZVtpXSA9IHZhbHVlW2ldLmdldFRpbWUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQvL0ZvciBkYXRlc1xyXG5cdFx0XHRcdH0gZWxzZXt2YWx1ZSA9IHZhbHVlLmdldFRpbWUoKTt9XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHt2YWx1ZTp2YWx1ZSwgdHlwZTplbmNvZGVkX2RhdGF0eXBlLCBpc0FycmF5OmFycmF5fTtcclxuXHR9XHJcbn1cclxuXHJcbi8vRGVjb2RlcyBhbiBBR00tc3R5bGUgb2JqZWN0IHRvIHB1cmUgSlNPTlxyXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX3BhcnNlKGFyZ3Mpe1xyXG5cdCB2YXIgZGVjb2RlZD17fTtcclxuICAgdmFyIHNpZ25hdHVyZT17fTtcclxuXHQgZm9yKHZhciBpID0gMDtpPGFyZ3MubGVuZ3RoOyBpKyspeyAgIFxyXG5cdFx0dmFyIGFyZ3VtZW50ID0gYXJnc1tpXTtcclxuXHJcblx0XHRpZiAoYXJndW1lbnQuY29tcG9zaXRlIHx8IChhcmd1bWVudC5Db21wb3NpdGVWYWx1ZSE9PSBudWxsICYmIGFyZ3VtZW50LkNvbXBvc2l0ZVZhbHVlICE9PSB1bmRlZmluZWQpKXtcclxuXHRcdFx0Ly9JZiB0aGUgYXJndW1lbnQgaXMgYSBjb21wb3NpdGUgb25lLCB3ZSBjYWxsIHRoZSBmdW5jdGlvbiByZWN1cnNpdmVseVxyXG5cdFx0XHRkZWNvZGVkW2FyZ3VtZW50Lk5hbWVdPXBhcmFtZXRlcnNfcGFyc2UoYXJndW1lbnQuQ29tcG9zaXRlVmFsdWUpLmFyZ3VtZW50cztcclxuXHRcdFx0c2lnbmF0dXJlW2FyZ3VtZW50Lk5hbWVdPXBhcmFtZXRlcnNfcGFyc2UoYXJndW1lbnQuQ29tcG9zaXRlVmFsdWUpLnNpZ25hdHVyZTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHQvL0lmIGl0IGlzIG5vdCwgd2UganVzdCBkZWNvZGUgdGhlIHZhbHVlXHJcblx0XHRcdGRlY29kZWRbYXJndW1lbnQuTmFtZV09ZGVjb2RlX2FyZ3VtZW50KGFyZ3VtZW50LlZhbHVlKTtcclxuXHRcdFx0c2lnbmF0dXJlW2FyZ3VtZW50Lk5hbWVdID0gZGVjb2RlX3NpZ25hdHVyZShhcmd1bWVudC5WYWx1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB7YXJndW1lbnRzOmRlY29kZWQsIHNpZ25hdHVyZTpzaWduYXR1cmV9O1xyXG5cdC8vRGVjb2RlcyBhIHNpbmdsZSBhcmd1bWVudCAoaW50LCBzdHJpbmcsIGJvb2xlYW4sIGRhdGUpIG9yIGFycmF5cyBvZiBhcmd1bWVudHNcclxuXHRmdW5jdGlvbiBkZWNvZGVfYXJndW1lbnQodmFsdWUpe1xyXG5cdCBpZiAodmFsdWUuaXNBcnJheSl7XHJcblx0XHRcdHZhciB0eXBlID0gdmFsdWUudHlwZTtcclxuXHRcdFx0dmFyIHZhbHVlcyA9IHZhbHVlLnZhbHVlO1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB2YWx1ZXMpe1xyXG5cdFx0XHRcdHZhbHVlc1tpXSA9IGRlY29kZV92YWx1ZSh2YWx1ZXNbaV0sIHR5cGUpO1xyXG5cdFx0ICAgfVxyXG5cdFx0XHRyZXR1cm4gdmFsdWVzOyBcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRyZXR1cm4gZGVjb2RlX3ZhbHVlKHZhbHVlLnZhbHVlLCB2YWx1ZS50eXBlKTtcclxuXHRcdH1cclxuXHQgICAvL0RlY29kZXMgYSBzaW5nbGUgYXJndW1lbnQgKGludCwgc3RyaW5nLCBib29sZWFuLCBkYXRlKVxyXG5cdCAgIGZ1bmN0aW9uIGRlY29kZV92YWx1ZSh2YWx1ZSwgdHlwZSl7XHJcblx0XHRcdC8vRGF0ZVxyXG5cdFx0ICAgaWYgKHR5cGUgPT09NSl7cmV0dXJuIG5ldyBEYXRlKHZhbHVlKTt9XHJcblx0XHQgICByZXR1cm4gdmFsdWU7XHJcblx0XHR9ICAgIFxyXG4gICB9XHJcbiAgIGZ1bmN0aW9uIGRlY29kZV9zaWduYXR1cmUodmFsdWUpe1xyXG5cdCAgIHZhciBkYXRhdHlwZXM9e1wiMFwiOlwiQm9vbFwiLCBcIjFcIjpcIkludFwiLCBcIjJcIjpcIkRvdWJsZVwiLCBcIjNcIjpcIkxvbmdcIiwgXCI0XCI6XCJTdHJpbmdcIiwgXCI1XCI6XCJEYXRlVGltZVwifTtcclxuXHQgICB2YXIgZGF0YXR5cGUgPSBkYXRhdHlwZXNbdmFsdWUudHlwZStcIlwiXTtcclxuXHQgICBpZiAodmFsdWUuaXNBcnJheSl7ZGF0YXR5cGUgPSBkYXRhdHlwZStcIltdXCI7fVxyXG5cdFx0cmV0dXJuIGRhdGF0eXBlO1xyXG4gICB9XHJcblxyXG59XHJcblxyXG52YXIgZGF0YXR5cGVzPVtcIkJvb2xcIiwgXCJJbnRcIiwgXCJEb3VibGVcIiwgXCJMb25nXCIsIFwiU3RyaW5nXCIsIFwiRGF0ZVRpbWVcIl07XHJcblxyXG5mdW5jdGlvbiBzaWduYXR1cmVfc3RyaW5naWZ5KGFycmF5KXtcclxuXHQvL05vIHNpZ25hdHVyZSAtIHJldHVybiB1bmRlZmluZWQgKHRoZSBkZWZhdWx0IHVuZGVmaW5lZCB2YWx1ZSBpbiBBR00gZm9yIHRoaXMgcHJvcGVydHkgaXMgZW1wdHkgc3RyaW5nKVxyXG5cdGlmKGFycmF5PT09dW5kZWZpbmVkfHxhcnJheSA9PT1cIlwiKXtyZXR1cm4gXCJcIjt9XHJcblx0dHJ5IHtcclxuXHRcdHJldHVybiBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xyXG5cdFx0XHRpZiAoYS5OYW1lID4gYi5OYW1lKVxyXG5cdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHRpZiAoYS5OYW1lIDwgYi5OYW1lKVxyXG5cdFx0XHRcdHJldHVybiAtMTtcclxuXHRcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9KVxyXG5cdFx0Lm1hcChmdW5jdGlvbihwYXIpe1xyXG5cdFx0XHR2YXIgcmVxID1cIj9cIjtcclxuXHRcdFx0aWYocGFyLklzUmVxdWlyZWQpe3JlcSA9XCJcIjt9XHJcblx0XHRcdHZhciBhcnIgPVwiXCI7XHJcblx0XHRcdGlmKHBhci5pc0FycmF5KXthcnIgPVwiW11cIjt9XHJcblx0XHJcblx0XHRcdHZhciBkYXRhX3R5cGUgPSBkYXRhdHlwZXNbcGFyc2VJbnQocGFyLlR5cGUpXTtcclxuXHRcdFx0aWYoZGF0YV90eXBlPT09dW5kZWZpbmVkKXt0aHJvdyBcIkludmFsaWQgZGF0YXR5cGUgXCIrcGFyLlR5cGU7fVxyXG5cdFxyXG5cdFx0XHRyZXR1cm4gZGF0YV90eXBlK3JlcSthcnIrXCIgXCIrcGFyLk5hbWU7XHJcblx0XHR9KS5qb2luKFwiLCBcIik7XHJcblx0fSBjYXRjaChlKSB7XHJcblx0XHRyZXR1cm4gXCJcIjtcclxuXHR9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBzaWduYXR1cmVfcGFyc2Uoc3RyaW5nKXtcclxuXHQgaWYoc3RyaW5nPT09dW5kZWZpbmVkfHxzdHJpbmcgPT09XCJcIil7cmV0dXJuIHVuZGVmaW5lZDt9XHJcblx0IHJldHVybiBzdHJpbmcuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbihhcmd1bWVudCl7XHJcblx0XHQgdmFyIGFyZyA9IHt9O1xyXG5cdFx0IHZhciBwID0gYXJndW1lbnQudHJpbSgpLnNwbGl0KFwiIFwiKTtcclxuXHRcdCBpZiAocC5sZW5ndGghPT0yKXt0aHJvdyBcIkludmFsaWQgYXJndW1lbnQ6IFwiK2FyZ3VtZW50K1wiLlwiO31cclxuXHJcblx0XHQgYXJnLk5hbWUgPSBwWzFdO1xyXG5cclxuXHRcdCB2YXIgZGF0YSA9IHBbMF07XHJcblxyXG5cdFx0IGFyZy5pc0FycmF5ID0gZmFsc2U7XHJcblxyXG5cdFx0IGlmKGRhdGEuaW5kZXhPZihcIltdXCIpIT09LTEpe1xyXG5cdFx0XHQgZGF0YSA9IGRhdGEucmVwbGFjZShcIltdXCIsIFwiXCIpO1xyXG5cdFx0XHQgYXJnLmlzQXJyYXkgPSB0cnVlO1xyXG5cdFx0IH1cclxuXHJcblx0XHQgYXJnLklzUmVxdWlyZWQgPSB0cnVlO1xyXG5cdFx0IGlmKGRhdGEuaW5kZXhPZihcIj9cIikhPT0tMSl7XHJcblx0XHRcdCBkYXRhID0gZGF0YS5yZXBsYWNlKFwiP1wiLCBcIlwiKTtcclxuXHRcdFx0IGFyZy5Jc1JlcXVpcmVkID0gZmFsc2U7XHJcblx0XHQgfVxyXG5cclxuXHRcdCB2YXIgYXJnX3R5cGUgPSBkYXRhdHlwZXMuaW5kZXhPZihkYXRhKTtcclxuXHRcdCBpZihhcmdfdHlwZSE9PS0xKXtcclxuXHRcdFx0YXJnLlR5cGUgPSBhcmdfdHlwZStcIlwiO1xyXG5cdFx0IH1lbHNle1xyXG5cdFx0XHQgdGhyb3cgXCJJbnZhbGlkIGRhdGF0eXBlOiBcIitkYXRhK1wiLiBUaGUgYWNjZXB0ZWQgZGF0YXR5cGVzIGFyZSBJbnQsIERvdWJsZSwgTG9uZywgRGF0ZVRpbWUsIEJvb2wgYW5kIFN0cmluZ1wiO1xyXG5cdFx0IH1cclxuXHJcblx0XHQgcmV0dXJuIGFyZztcclxuXHJcblx0IH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaWduYXR1cmVfcGFyc2VfZnJpZW5kbHkoc3RyaW5nKXtcclxuXHRyZXR1cm4gc2lnbmF0dXJlX3BhcnNlKHN0cmluZykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgYXJnKXtcclxuXHRcdG9ialthcmcuTmFtZV0gPSB7dHlwZTpkYXRhdHlwZXNbcGFyc2VJbnQoYXJnLlR5cGUpXSwgaXNfYXJyYXk6YXJnLmlzQXJyYXksIGlzX3JlcXVpcmVkOmFyZy5Jc1JlcXVpcmVkfTtcclxuXHRcdHJldHVybiBvYmo7XHJcblx0fSx7fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpZ25hdHVyZV9ub3JtYWxpemUoc3RyaW5nKXtcclxuXHRyZXR1cm4gc2lnbmF0dXJlX3N0cmluZ2lmeShzaWduYXR1cmVfcGFyc2Uoc3RyaW5nKSk7XHJcbn1cclxuXHJcblxyXG4vL0NvbnZlcnRzIHNlcnZlciBwcm9wZXJ0aWVzIGZyb20gY2FtZWwgdG8gc25ha2UgY2FzZVxyXG5mdW5jdGlvbiBwcmVwcm9jZXNzX3NlcnZlcihtKXtcclxuXHRyZXR1cm57XHJcblx0XHRtYWNoaW5lOm0uTWFjaGluZU5hbWUsXHJcblx0XHRwaWQ6bS5Qcm9jZXNzSWQsXHJcblx0XHRzdGFydGVkOm0uUHJvY2Vzc1N0YXJ0VGltZSxcclxuXHRcdHVzZXI6bS5Vc2VyTmFtZSxcclxuXHRcdGFwcGxpY2F0aW9uOm0uQXBwbGljYXRpb25OYW1lLFxyXG5cdFx0ZW52aXJvbm1lbnQ6bS5FbnZpcm9ubWVudCxcclxuXHRcdHJlZ2lvbjptLlJlZ2lvbixcclxuXHRcdHNlcnZpY2VfbmFtZTptLlNlcnZpY2VOYW1lLFxyXG5cdFx0bWV0cmljc19yZXBvc2l0b3J5X2lkOm0uTWV0cmljc1JlcG9zaXRvcnlJZCxcclxuXHRcdHN0YXRlOm0uU3RhdGVcclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbG9uZV9vYmplY3QobWV0aG9kKXtcclxuXHR2YXIgbmV3X21ldGhvZCA9e307XHJcblx0Zm9yKHZhciBpIGluIG1ldGhvZCl7XHJcblx0XHQvL1JlbW92ZSB1bmRlZmluZWQgdmFsdWVzIGZyb20gb2JqZWN0IGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSB1c2VyXHJcblx0XHRpZihtZXRob2RbaV0hPT11bmRlZmluZWQmJm1ldGhvZFtpXSE9PVwiXCImJm1ldGhvZFtpXSE9PTApe1xyXG5cdFx0XHRuZXdfbWV0aG9kW2ldID0gbWV0aG9kW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3X21ldGhvZDtcclxufSBcclxuXHJcblx0Ly9IZWxwZXI6IHByZXByb2Nlc3NlcyB0aGUgbWV0aG9kIGRlZmluaXRpb25cclxuZnVuY3Rpb24gcHJlcHJvY2Vzc19tZXRob2QobWV0aG9kX2luZm8pe1xyXG5cdHZhciBtZXRob2QgPSBtZXRob2RfaW5mby5NZXRob2Q7XHJcblx0cmV0dXJue1xyXG5cdFx0bmFtZTptZXRob2QuTmFtZSxcclxuXHRcdGFjY2VwdHM6bWV0aG9kLklucHV0U2lnbmF0dXJlLFxyXG5cdFx0cmV0dXJuczptZXRob2QuUmVzdWx0U2lnbmF0dXJlLFxyXG5cdFx0cmVxdWVzdF9zdWJqZWN0Om1ldGhvZF9pbmZvLk1ldGhvZFJlcXVlc3RTdWJqZWN0LCBcclxuXHRcdGRlc2NyaXB0aW9uOm1ldGhvZC5EZXNjcmlwdGlvbixcclxuXHRcdGRpc3BsYXlfbmFtZTptZXRob2QuRGlzcGxheU5hbWUsXHJcblx0XHR2ZXJzaW9uOm1ldGhvZC5WZXJzaW9uLFxyXG5cdFx0b2JqZWN0X3R5cGVzOm1ldGhvZC5PYmplY3RUeXBlUmVzdHJpY3Rpb25zXHJcblx0fTtcclxufSAgIFxyXG5cclxuXHJcbiAgZnVuY3Rpb24gc2F2ZV9jYWxsYmFja19pbihjYWxsYmFja19vYmosIGV2ZW50LCBvbl9jYWxsYmFja19hZGQsIGNhbGxiYWNrKXtcclxuXHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpe1xyXG5cdFx0XHRjYWxsYmFja19vYmpbZXZlbnRdID0gY2FsbGJhY2tfb2JqW2V2ZW50XXx8W107XHJcblx0XHRcdGNhbGxiYWNrX29ialtldmVudF0ucHVzaChjYWxsYmFjayk7XHJcblx0XHRcdG9uX2NhbGxiYWNrX2FkZChjYWxsYmFjayk7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0dGhyb3cgJ1wiJytldmVudCsnXCIgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50JztcclxuXHRcdH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV4ZWN1dGVfYWxsX3dpdGgoY2FsbGJhY2tzLCBpbnB1dCl7XHJcblx0aWYodHlwZW9mIGNhbGxiYWNrcyA9PT1cIm9iamVjdFwiKXtcclxuXHRcdGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuXHRcdFx0Y2FsbGJhY2soaW5wdXQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcblxyXG4vL0dlbmVyYXRlcyBhIHVuaXF1ZSBJRCBmb3IgYSBzZXJ2ZXJcclxuZnVuY3Rpb24gZ2V0X3NlcnZlcl9pZChzZXJ2ZXJpbmZvKXtcclxuXHRpZihzZXJ2ZXJpbmZvPT09dW5kZWZpbmVkKXtyZXR1cm4gdW5kZWZpbmVkO31cclxuXHQvL1RoZSBtYXRjaGluZyBpcyBjYXNlLWluc2Vuc2l0aXZlXHJcblx0cmV0dXJuIChzZXJ2ZXJpbmZvLmFwcGxpY2F0aW9uK3NlcnZlcmluZm8udXNlcikudG9Mb3dlckNhc2UoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJvbWlzaWZ5KHByb21pc2UsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayl7XHJcbiAgICBpZiAodHlwZW9mIHN1Y2Nlc3NDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZXJyb3JDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHR5cGVvZiBzdWNjZXNzQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uKGFyZ3Mpe1xyXG4gICAgICAgICAgICBpZihnbG9iYWwuY29uc29sZSE9PXVuZGVmaW5lZCAmJiBhZ20uZGVidWc9PT10cnVlKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3VjY2VzcyFcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfWVsc2UgaWYodHlwZW9mIGVycm9yQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgIGVycm9yQ2FsbGJhY2sgPSBmdW5jdGlvbihhcmdzKXtcclxuICAgICAgICAgICAgaWYoZ2xvYmFsLmNvbnNvbGUhPT11bmRlZmluZWQgJiYgYWdtLmRlYnVnPT09dHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFuIGVycm9yIG9jY3VycmVkLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdGdldF9zZXJ2ZXJfaWQ6Z2V0X3NlcnZlcl9pZCxcclxuXHRleGVjdXRlX2FsbF93aXRoOmV4ZWN1dGVfYWxsX3dpdGgsXHJcblx0c2F2ZV9jYWxsYmFja19pbjpzYXZlX2NhbGxiYWNrX2luLFxyXG5cdHBhcmFtZXRlcnNfc3RyaW5naWZ5OnBhcmFtZXRlcnNfc3RyaW5naWZ5LFxyXG5cdHBhcmFtZXRlcnNfcGFyc2U6cGFyYW1ldGVyc19wYXJzZSxcclxuXHRzaWduYXR1cmVfc3RyaW5naWZ5OnNpZ25hdHVyZV9zdHJpbmdpZnksXHJcblx0c2lnbmF0dXJlX3BhcnNlOnNpZ25hdHVyZV9wYXJzZSxcclxuXHRzaWduYXR1cmVfcGFyc2VfZnJpZW5kbHk6c2lnbmF0dXJlX3BhcnNlX2ZyaWVuZGx5LFxyXG5cdHNpZ25hdHVyZV9ub3JtYWxpemU6c2lnbmF0dXJlX25vcm1hbGl6ZSxcclxuXHRwcmVwcm9jZXNzX3NlcnZlcjpwcmVwcm9jZXNzX3NlcnZlcixcclxuXHRwcmVwcm9jZXNzX21ldGhvZDpwcmVwcm9jZXNzX21ldGhvZCxcclxuXHRjbG9uZV9vYmplY3Q6Y2xvbmVfb2JqZWN0LFxyXG5cdHByb21pc2lmeTpwcm9taXNpZnlcclxufTtcclxuIiwiLypcclxuVGhlIEFHTSBpbnN0YW5jZSBjb2xsZWN0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbWFjaGluZSB3ZSBhcmUgaW4sIFxyXG5hbmQgaW50ZXJhY3RzIHdpdGggdGhlIC5ORVQgZ2F0ZXdheSBpbiBvdGhlciB3YXlzLCBcclxudG8gZGVsaXZlciBmdWxsIEFHTSBjb21wYXRpYmlsaXR5IHRvIEFHTS5KUy5cclxuXHJcblRvIGRvIHNvLCBpdCByZWxpZXMgb24gdGhlIGRlZmF1bHQgQUdNIGNsaWVudC5cclxuKi9cclxuXHJcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudCB8fCBnbG9iYWwucHJvY2VzcztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYywgY29ubmVjdGlvbil7XHJcblx0dmFyIGluc3RhbmNlID0ge307XHJcblx0Ly9HZW5lcmF0ZSBkZWZhdWx0IGluc3RhbmNlIHByb3BlcnRpZXNcclxuXHRpbnN0YW5jZS5BcHBsaWNhdGlvbk5hbWUgPSBkb2N1bWVudC50aXRsZStNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTAwMDAwMDAwMCk7XHJcblx0aW5zdGFuY2UuUHJvY2Vzc0lkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjEwMDAwMDAwMDApO1xyXG5cdGluc3RhbmNlLlByb2Nlc3NTdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgXHJcbiAgICBcclxuXHQvL0FwcGx5IHVzZXItc3VibWl0dGVkIGluc3RhbmNlIHByb3BlcnRpZXMgXHJcblx0aWYodHlwZW9mIGMgPT09IFwib2JqZWN0XCIpe1xyXG4gICAgICAgIGlmKGMuYXBwbGljYXRpb24hPT11bmRlZmluZWQpe2luc3RhbmNlLkFwcGxpY2F0aW9uTmFtZSA9IGMuYXBwbGljYXRpb247fVxyXG5cdFx0aW5zdGFuY2UuTWFjaGluZU5hbWU9Yy5tYWNoaW5lO1xyXG5cdFx0aW5zdGFuY2UuVXNlck5hbWU9Yy51c2VyO1xyXG5cdFx0aW5zdGFuY2UuRW52aXJvbm1lbnQ9Yy5lbnZpcm9ubWVudDtcclxuXHRcdGluc3RhbmNlLlJlZ2lvbj1jLnJlZ2lvbjtcclxuXHRcdGluc3RhbmNlLlNlcnZpY2VOYW1lPWMuc2VydmljZV9uYW1lO1xyXG5cdFx0aW5zdGFuY2UuTWV0cmljc1JlcG9zaXRvcnlJZD1jLm1ldHJpY3NfcmVwb3NpdG9yeV9pZDtcclxuXHRcdGluc3RhbmNlLlN0YXRlPTE7XHJcblx0fVxyXG4gICAgdmFyIGlkZW50aXR5X3VwZGF0ZWQgPSBmYWxzZTtcclxuICAgIGNvbm5lY3Rpb24ub24oXCJJbnN0YW5jZVwiLCBmdW5jdGlvbihpKXtcclxuXHRcdGlmKGlkZW50aXR5X3VwZGF0ZWQpe3JldHVybjt9XHJcbiAgICAgICAgaWYoaW5zdGFuY2UuTWFjaGluZU5hbWU9PT11bmRlZmluZWQpe2luc3RhbmNlLk1hY2hpbmVOYW1lID0gaS5NYWNoaW5lTmFtZTt9XHJcbiAgICAgICAgaWYoaW5zdGFuY2UuVXNlck5hbWU9PT11bmRlZmluZWQpe2luc3RhbmNlLlVzZXJOYW1lID0gaS5Vc2VyTmFtZTt9XHJcbiAgICAgICAgaWYoaW5zdGFuY2UuRW52aXJvbm1lbnQ9PT11bmRlZmluZWQpe2luc3RhbmNlLkVudmlyb25tZW50ID0gaS5FbnZpcm9ubWVudDt9XHJcbiAgICAgICAgaWYoaW5zdGFuY2UuUmVnaW9uPT09dW5kZWZpbmVkKXtpbnN0YW5jZS5SZWdpb24gPSBpLlJlZ2lvbjt9XHJcbiAgICAgICAgaWYoaW5zdGFuY2UuU2VydmljZU5hbWU9PT11bmRlZmluZWQpe2luc3RhbmNlLlNlcnZpY2VOYW1lID0gaS5TZXJ2aWNlTmFtZTt9XHJcbiAgICAgICAgaWYoaW5zdGFuY2UuTWV0cmljc1JlcG9zaXRvcnlJZD09PXVuZGVmaW5lZCl7aW5zdGFuY2UuTWV0cmljc1JlcG9zaXRvcnlJZCA9IGkuTWV0cmljc1JlcG9zaXRvcnlJZDt9XHJcbiAgICAgICAgaWYoaW5zdGFuY2UuU3RhdGU9PT11bmRlZmluZWQpe2luc3RhbmNlLlN0YXRlID0gaS5TdGF0ZTt9XHJcbiAgICAgICAgaWYoZ2xvYmFsLmNvbnNvbGUhPT11bmRlZmluZWQmJiBnbG9iYWwuY29uc29sZS50YWJsZSE9PXVuZGVmaW5lZCAgJiYgYWdtLmRlYnVnPT09dHJ1ZSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVjZWl2ZWQgaW5zdGFuY2Ugd2l0aCBpbmZvIGZyb20gR2F0ZXdheS5cIik7XHJcbiAgICAgICAgfVxyXG5cdFx0aWRlbnRpdHlfdXBkYXRlZCA9IHRydWU7XHJcbiAgICB9KTtcclxuXHQvL0NyZWF0ZSBhIG1ldGhvZCBmb3IgYWNjZXNzaW5nIGEgcHJvcGVydHlcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9nZXR0ZXIocHJvcGVydHkpe1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZVtwcm9wZXJ0eV07XHJcbiAgICB9XHJcblx0Ly9HZW5lcmF0ZXMgYSByZXF1ZXN0IHN1YmplY3QgZm9yIGEgbWV0aG9kXHJcblx0Ly9EZWxlZ2F0ZXMgaXQgdG8gdGhlIC5ORVQgZ2F0ZXdheSBpZiBpdCBpcyBvbmxpbmUsIFxyXG5cdC8vdG8gY3JlYXRlIHN1YmplY3RzIHdoaWNoIGFyZSB2YWxpZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHRyYW5zcG9ydCB0aGF0IGlzIGJlaW5nIHVzZWQuXHJcbiAgICB2YXIgcmVxX3N1YmplY3QgPSAwO1xyXG5cdGZ1bmN0aW9uIHJlcXVlc3Rfc3ViamVjdChtZXRob2RfaWRlbnRpZmllciwgY2FsbGJhY2spe1xyXG4gICAgICAgIGNhbGxiYWNrKFwicmVxXCIrKHJlcV9zdWJqZWN0KyspK2luc3RhbmNlLlByb2Nlc3NJZCk7XHJcblx0fVxyXG4gICAgLy9HZW5lcmF0ZXMgYSByZXNwb25zZSBzdWJqZWN0IHN1YmplY3QgZm9yIGEgbWV0aG9kIGludm9jYXRpb25cclxuXHQvL0RlbGVnYXRlcyBpdCB0byB0aGUgLk5FVCBnYXRld2F5IGlmIGl0IGlzIG9ubGluZSwgXHJcblx0Ly90byBjcmVhdGUgc3ViamVjdHMgd2hpY2ggYXJlIHZhbGlkIGluIHRoZSBzY29wZSBvZiB0aGUgdHJhbnNwb3J0IHRoYXQgaXMgYmVpbmcgdXNlZC5cclxuICAgIHZhciByZXNwX3N1YmplY3QgPSAwO1xyXG5cdGZ1bmN0aW9uIHJlc3BvbnNlX3N1YmplY3QobWV0aG9kX2lkZW50aWZpZXIsIGNhbGxiYWNrKXtcclxuICAgICAgICBjYWxsYmFjayhcInJlc3BcIisocmVzcF9zdWJqZWN0KyspK2luc3RhbmNlLlByb2Nlc3NJZCk7XHRcclxuXHR9XHJcblx0Ly9SZXR1cm5zIGFsbCBpbnN0YW5jZSBwcm9wZXJ0aWVzXHJcbiAgICBmdW5jdGlvbiBpbmZvKCl7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7cmVxdWVzdF9zdWJqZWN0OnJlcXVlc3Rfc3ViamVjdCwgXHJcbiAgICAgICAgICAgIHJlc3BvbnNlX3N1YmplY3Q6cmVzcG9uc2Vfc3ViamVjdCxcclxuICAgICAgICAgICAgaW5mbzppbmZvLFxyXG4gICAgICAgICAgICBhcHBsaWNhdGlvbjpjcmVhdGVfZ2V0dGVyKFwiQXBwbGljYXRpb25OYW1lXCIpLFxyXG4gICAgICAgICAgICBwaWQ6Y3JlYXRlX2dldHRlcihcIlByb2Nlc3NJZFwiKSxcclxuXHRcdFx0dXNlcjpjcmVhdGVfZ2V0dGVyKFwiVXNlck5hbWVcIiksXHJcblx0XHRcdG1hY2hpbmU6Y3JlYXRlX2dldHRlcihcIk1hY2hpbmVOYW1lXCIpXHJcblxyXG4gICAgICAgICAgfTsgICBcclxuXHJcbn07XHJcbiIsInZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xyXG52YXIgaCA9IHJlcXVpcmUoXCIuL2FnbV9oZWxwZXJzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xyXG4gICAgZnVuY3Rpb24gcGFyYW1Ub0pzb24ocGFyYW0sIHN0cmluZ1Byb3BOYW1lLCBvYmplY3RQcm9wTmFtZSkge1xyXG4gICAgICAgIHZhciBvYmogPSB7fTtcclxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG9ialtzdHJpbmdQcm9wTmFtZV0gPSBwYXJhbTtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0UHJvcE5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmpbb2JqZWN0UHJvcE5hbWVdID0gcGFyYW07XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIHBhcnNpbmcgZGF0ZXMgcHJvcGVybHlcclxuICAgIGZ1bmN0aW9uIGFnbVBhcnNlKHN0cikge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0ciwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHByZS1zZWVkIC0gdGhpcyBzaG91bGQgYmUgYSBiaXQgZmFzdGVyIHRoYW4gaW5kZXhPZlxyXG4gICAgICAgICAgICBpZiAodlswXSAhPT0gZGF0ZVRpbWVJZGVudGlmaWVyWzBdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHYuaW5kZXhPZihkYXRlVGltZUlkZW50aWZpZXIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHVuaXhUaW1lc3RhbXBNcyA9IHYuc3Vic3RyKGxlbk9mSWRlbnRpdGlmaWVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodW5peFRpbWVzdGFtcE1zKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIHRhcmdldCBhcmd1bWVudCB0byBvYmplY3QgcmVhZHkgdG8gYmUgcGFzc2VkIHRvIEFnbSBmYWNhZGVcclxuICAgICAqIEBwYXJhbSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGFyZ2V0QXJnVG9PYmplY3QodGFyZ2V0KXtcclxuXHJcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8ICdiZXN0JztcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gXCJhbGxcIiAmJiB0YXJnZXQgIT09IFwiYmVzdFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIHRhcmdldCArICdcIiBpcyBub3QgYSB2YWxpZCB0YXJnZXQuIFZhbGlkIHRhcmdldHMgYXJlIFwiYWxsXCIgYW5kIFwiYmVzdFwiLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7dGFyZ2V0IDogdGFyZ2V0fTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWUgIT09ICdBcnJheScpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IFt0YXJnZXRdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQubWFwKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydEluc3RhbmNlVG9SZWdleChlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge3NlcnZlckZpbHRlcjogdGFyZ2V0fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29udmVydEluc3RhbmNlVG9SZWdleChpbnN0YW5jZSkge1xyXG4gICAgICAgIHZhciBpbnN0YW5jZV9jb252ZXJ0ZWQgPSB7fTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmtleXMoaW5zdGFuY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gaW5zdGFuY2Vba2V5XTtcclxuICAgICAgICAgICAgaW5zdGFuY2VfY29udmVydGVkW2tleV0gPSBwcm9wVmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvIGV4YWN0IG1hdGNoaW5nIGlmIHVzZXIgcGFzc2VkIGEgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZV9jb252ZXJ0ZWRba2V5XSA9IFwiXlwiICsgaW5zdGFuY2Vba2V5XSArIFwiJFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RhbmNlW2tleV0uY29uc3RydWN0b3IgPT09IFJlZ0V4cCkge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VfY29udmVydGVkW2tleV0gPSBpbnN0YW5jZVtrZXldLnNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlX2NvbnZlcnRlZFtrZXldID0gaW5zdGFuY2Vba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZV9jb252ZXJ0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IHtcclxuXHJcbiAgICAgICAgLy8gUmVnaXN0ZXJzIGEgSmF2YVNjcmlwdCBmdW5jdGlvbiBhcyBhbiBBR00gbWV0aG9kLCB0aHVzIG1ha2luZyBpdCBhdmFpbGFibGUgb3RoZXIgQUdNIGluc3RhbmNlcyBvbiB0aGUgc2FtZSB0cmFuc3BvcnQuXHJcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChtZXRob2RJbmZvLCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUucmVnaXN0ZXIocGFyYW1Ub0pzb24obWV0aG9kSW5mbywgXCJuYW1lXCIpLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhKU09OLnBhcnNlKGFyZykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gKG1ldGhvZEZpbHRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS51bnJlZ2lzdGVyKHBhcmFtVG9Kc29uKG1ldGhvZEZpbHRlciwgXCJuYW1lXCIpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBJbnZva2VzIGFuIEFHTSBtZXRob2QgYXN5bmNocm9ub3VzbHkuXHJcbiAgICAgICAgaW52b2tlOiBmdW5jdGlvbiAobWV0aG9kRmlsdGVyLCBhcmdzLCB0YXJnZXQsIG9wdGlvbnMsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5O1xyXG5cclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NQcm94eSA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UoYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYXJzZWQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGVycm9yUHJveHkgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBKU09OLnBhcnNlKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChwYXJzZWQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJncyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe21lc3NhZ2U6ICdUaGUgbWV0aG9kIGFyZ3VtZW50cyBtdXN0IGJlIGFuIG9iamVjdC4nfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0QXJnVG9PYmplY3QodGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5pbnZva2UoXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1Ub0pzb24obWV0aG9kRmlsdGVyLCBcIm5hbWVcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoYXJncyksXHJcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGFyZ2V0KSxcclxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShvcHRpb25zKSxcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUHJveHksXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JQcm94eVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBoLnByb21pc2lmeShwcm9taXNlLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJlZ2lzdGVycyBhIGhhbmRsZXIgd2hpY2ggbm90aWZpZXMgeW91IHdoZW4gYSBuZXcgQUdNIG1ldGhvZCBpcyBhdmFpbGFibGUuXHJcbiAgICAgICAgbWV0aG9kQWRkZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5tZXRob2RBZGRlZChjYWxsYmFjayk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmVnaXN0ZXJzIGEgaGFuZGxlciB3aGljaCBub3RpZmllcyB5b3Ugd2hlbiBhbiBBR00gbWV0aG9kIHN0b3BzIGJlaW5nIGF2YWlsYWJsZS5cclxuICAgICAgICBtZXRob2RSZW1vdmVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUubWV0aG9kUmVtb3ZlZChjYWxsYmFjayk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2VydmVyQWRkZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5zZXJ2ZXJBZGRlZChjYWxsYmFjayk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2VydmVyUmVtb3ZlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWdtRmFjYWRlLnNlcnZlclJlbW92ZWQoY2FsbGJhY2spO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNlcnZlck1ldGhvZEFkZGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUuc2VydmVyTWV0aG9kQWRkZWQoY2FsbGJhY2spO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNlcnZlck1ldGhvZFJlbW92ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5zZXJ2ZXJNZXRob2RSZW1vdmVkKGNhbGxiYWNrKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXRyaWV2ZXMgYSBsaXN0IG9mIEFHTSBzZXJ2ZXJzIChpbnN0YW5jZXMpIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgbWV0aG9kLlxyXG4gICAgICAgIHNlcnZlcnM6IGZ1bmN0aW9uIChtZXRob2RGaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGpzb25SZXN1bHQgPSB0aGlzLmFnbUZhY2FkZS5zZXJ2ZXJzKEpTT04uc3RyaW5naWZ5KG1ldGhvZEZpbHRlcikpO1xyXG4gICAgICAgICAgICByZXR1cm4gYWdtUGFyc2UoanNvblJlc3VsdCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0cmlldmVzIGEgbGlzdCBvZiBtZXRob2RzIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIGZpbHRlci4gWW91IGNhbiB1c2UgdGhpcyB0byBjaGVjayBpZiBhIGdpdmVuIG1ldGhvZCBleGlzdHMuXHJcbiAgICAgICAgbWV0aG9kczogZnVuY3Rpb24gKG1ldGhvZEZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIganNvblJlc3VsdCA9IHRoaXMuYWdtRmFjYWRlLm1ldGhvZHMoSlNPTi5zdHJpbmdpZnkobWV0aG9kRmlsdGVyKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhZ21QYXJzZShqc29uUmVzdWx0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtZXRob2RzRm9ySW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZUZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIganNvblJlc3VsdCA9IHRoaXMuYWdtRmFjYWRlLm1ldGhvZHNGb3JJbnN0YW5jZShKU09OLnN0cmluZ2lmeShpbnN0YW5jZUZpbHRlcikpO1xyXG4gICAgICAgICAgICByZXR1cm4gYWdtUGFyc2UoanNvblJlc3VsdCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gc3RyZWFtaW5nIHN1cHBvcnRcclxuICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hcmdzID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hcmd1bWVudHMgfHwge30pO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50YXJnZXQgPSB0YXJnZXRBcmdUb09iamVjdChvcHRpb25zLnRhcmdldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUuc3Vic2NyaWJlMihuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHN0cmVhbSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RyZWFtKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGgucHJvbWlzaWZ5KHByb21pc2UsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY3JlYXRlU3RyZWFtOiBmdW5jdGlvbihzdHJlYW1EZWYsIGNhbGxiYWNrcywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKXtcclxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0cmVhbURlZiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbURlZiA9IHtuYW1lOiBzdHJlYW1EZWZ9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2tzKXtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5jcmVhdGVTdHJlYW0yKFxyXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHN0cmVhbURlZiksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAtIHdyYXAgdG8gdHJhbnNmb3JtIHBhcmFtc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zdWJzY3JpcHRpb25SZXF1ZXN0SGFuZGxlcixcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0gd3JhcCB0byB0cmFuc2Zvcm0gcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnN1YnNjcmlwdGlvbkFkZGVkSGFuZGxlcixcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0gd3JhcCB0byB0cmFuc2Zvcm0gcGFyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnN1YnNjcmlwdGlvblJlbW92ZWRIYW5kbGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3MgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdHJlYW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdHJlYW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3IgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaC5wcm9taXNpZnkocHJvbWlzZSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJlc3VsdC52ZXJzaW9uID0gXCIyLjEuMVwiO1xyXG5cclxuICAgIC8vIGFkZCBtZXRyaWNzXHJcbiAgICBpZiAoY29uZmlndXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24ubWV0cmljcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29uZmlndXJhdGlvbi5tZXRyaWNzLm1ldHJpY3NJZGVudGl0eSA9IGNvbmZpZ3VyYXRpb24ubWV0cmljcy5pZGVudGl0eTtcclxuXHJcblxyXG4gICAgICAgIC8vIHF1aWNrIGFuZCBkaXJ0eSAtIHdlIG5lZWQgdG8gc3RyaW5naWZ5IHRoZSBjb25maWd1cmF0aW9uIHNvIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgbWV0cmljcyBvYmplY3QgKHdoaWNoIGhhcyBjaXJjdWxhciByZWZlcmVuY2VzKVxyXG4gICAgICAgIC8vIHdpdGggYW4gb2JqZWN0IHRoYXQgaG9sZHMgb25seSB0aGUgcHJvcGVydGllcyBuZWVkZWRcclxuICAgICAgICB2YXIgbWV0cmljc0NvbmZpZyA9IHtcclxuICAgICAgICAgICAgbWV0cmljc0lkZW50aXR5OiBjb25maWd1cmF0aW9uLm1ldHJpY3MubWV0cmljc0lkZW50aXR5LFxyXG4gICAgICAgICAgICBwYXRoOiBjb25maWd1cmF0aW9uLm1ldHJpY3MucGF0aFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uZmlndXJhdGlvbi5tZXRyaWNzID0gbWV0cmljc0NvbmZpZztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy9jcmVhdGUgbmV3IEFHTSBmYcOnYWRlIGZvciB0aGlzIGluc3RhbmNlXHJcbiAgICB2YXIgZmFjYWRlID0gZ2xvYmFsLmh0bWxDb250YWluZXIuanNBZ21GYWNhZGU7XHJcbiAgICByZXN1bHQuaW5zdGFuY2UgPSBmYWNhZGUuaW5pdChKU09OLnN0cmluZ2lmeShjb25maWd1cmF0aW9uKSk7XHJcbiAgICByZXN1bHQuYWdtRmFjYWRlID0gZmFjYWRlO1xyXG5cclxuICAgIC8vIGRhdGUgcGFyc2luZ1xyXG4gICAgdmFyIGRhdGVUaW1lSWRlbnRpZmllciA9IHJlc3VsdC5hZ21GYWNhZGUuanNvblZhbHVlRGF0ZVByZWZpeDtcclxuICAgIHZhciBsZW5PZklkZW50aXRpZmllciA9IGRhdGVUaW1lSWRlbnRpZmllci5sZW5ndGg7XHJcblxyXG4gICAgLy8gZGVwcmVjYXRlZCBBUElcclxuICAgIHJlc3VsdC5jcmVhdGVfc3RyZWFtID0gcmVzdWx0LmNyZWF0ZVN0cmVhbTtcclxuICAgIHJlc3VsdC5tZXRob2RzX2Zvcl9pbnN0YW5jZSA9IHJlc3VsdC5tZXRob2RzRm9ySW5zdGFuY2U7XHJcbiAgICByZXN1bHQubWV0aG9kX2FkZGVkID0gcmVzdWx0Lm1ldGhvZEFkZGVkO1xyXG4gICAgcmVzdWx0Lm1ldGhvZF9yZW1vdmVkID0gcmVzdWx0Lm1ldGhvZFJlbW92ZWQ7XHJcbiAgICByZXN1bHQuc2VydmVyX2FkZGVkID0gcmVzdWx0LnNlcnZlckFkZGVkO1xyXG4gICAgcmVzdWx0LnNlcnZlcl9yZW1vdmVkID0gcmVzdWx0LnNlcnZlclJlbW92ZWQ7XHJcbiAgICByZXN1bHQuc2VydmVyX21ldGhvZF9hZGRlZCA9IHJlc3VsdC5zZXJ2ZXJNZXRob2RBZGRlZDtcclxuICAgIHJlc3VsdC5zZXJ2ZXJfbWV0aG9kX3JlbW92ZWQgPSByZXN1bHQuc2VydmVyTWV0aG9kUmVtb3ZlZDtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG4iLCIvKlxyXG5UaGUgQUdNIFNlcnZlciBhbGxvd3MgdXNlcnMgcmVnaXN0ZXIgQUdNIG1ldGhvZHMuXHJcbkl0IGV4cG9zZXMgdGhlc2UgbWV0aG9kcyB0byBBR00gY2xpZW50cyAodXNpbmcgcHJlc2VuY2UgbWVzc2FnZXMpIGFuZCBsaXN0ZW5zIGZvciB0aGVpciBpbnZvY2F0aW9uXHJcbiovXHJcblxyXG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2FnbV9oZWxwZXJzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBpbnN0YW5jZSwgY29uZmlndXJhdGlvbil7XHJcbiBcclxuICAgIC8vVmFsaWRhdGUgY29uZmlndXJhdGlvblxyXG4gICAgaWYodHlwZW9mIGNvbmZpZ3VyYXRpb24hPT1cIm9iamVjdFwiKXtcclxuXHRcdGNvbmZpZ3VyYXRpb24gPSB7fTtcclxuXHJcblx0ICAgIGlmKGdsb2JhbC5jb25zb2xlIT09dW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24uZGVidWc9PT10cnVlKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGFuIEFHTSBzZXJ2ZXIgd2l0aCBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uJyk7XHJcbiAgICAgICAgfVxyXG5cdH1cclxuICAgIC8vQWRkIGRlZmF1bHRzXHJcbiAgICBpZih0eXBlb2YgY29uZmlndXJhdGlvbi5oZWFyYmVhdF9pbnRlcnZhbCE9PVwibnVtYmVyXCIpe1xyXG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaGVhcmJlYXRfaW50ZXJ2YWwgPSA1MDAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHR5cGVvZiBjb25maWd1cmF0aW9uLnByZXNlbmNlX2ludGVydmFsIT09XCJudW1iZXJcIil7XHJcbiAgICAgICAgY29uZmlndXJhdGlvbi5wcmVzZW5jZV9pbnRlcnZhbCA9IDEwMDAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vU2F2ZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBtZXRyaWMgZnVuY3Rpb24gaWYgaXQgZXhpc3RzXHJcbiAgICB2YXIgbWV0cmljID0gKGNvbmZpZ3VyYXRpb24ubWV0cmljcyE9PXVuZGVmaW5lZCk/Y29uZmlndXJhdGlvbi5tZXRyaWNzLm51bWJlck1ldHJpYy5iaW5kKGNvbmZpZ3VyYXRpb24ubWV0cmljcyk6ZnVuY3Rpb24oKXt9O1xyXG4gICAgLy9BbiBhcnJheSBvZiB0aGUgc2VydmVyJ3MgbWV0aG9kc1xyXG4gICAgdmFyIG1ldGhvZHMgPSBbXTtcclxuXHJcbiAgICB2YXIgcHJlc2VuY2VfdGltZXI7XHJcblxyXG4gICAgdmFyIGhlYXJ0YmVhdF90aW1lcjtcclxuXHJcbiAgICBpZihoZWFydGJlYXRfdGltZXI9PT11bmRlZmluZWQpe1xyXG4gICAgICAgIGhlYXJ0YmVhdF90aW1lciA9IHNldEludGVydmFsKHNlbmRfaGVhcnRiZWF0LCBjb25maWd1cmF0aW9uLmhlYXJiZWF0X2ludGVydmFsKTtcclxuICAgIH1cclxuXHJcblx0Ly9SZWdpc3RlcnMgYSBuZXcgbWV0aG9kIGluIEFHTVxyXG5cdGZ1bmN0aW9uIHJlZ2lzdGVyKG1ldGhvZF9kZWZpbml0aW9uLCB0aGVfZnVuY3Rpb24pe1xyXG5cdFx0aWYodHlwZW9mIG1ldGhvZF9kZWZpbml0aW9uID09PSBcInN0cmluZ1wiKXttZXRob2RfZGVmaW5pdGlvbiA9IHtuYW1lOm1ldGhvZF9kZWZpbml0aW9ufTt9XHJcblx0XHQvL0dldCBhIHJlcXVlc3Qgc3ViamVjdCBmb3IgdGhpcyBtZXRob2RcclxuXHRcdGluc3RhbmNlLnJlcXVlc3Rfc3ViamVjdChtZXRob2RfZGVmaW5pdGlvbiwgZnVuY3Rpb24ocmVxdWVzdF9zdWJqZWN0KXtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGNvbnZlcnRfbWV0aG9kKG1ldGhvZF9kZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgbWV0aG9kLk1ldGhvZFJlcXVlc3RTdWJqZWN0ID0gcmVxdWVzdF9zdWJqZWN0O1xyXG4gICAgICAgICAgICAvL0FkZCB0aGUgbWV0aG9kIChzdG9yZSB0aGUgdW5mb3JtYXR0ZWQgZGVmaW5pdGlvbiBpbiBvcmRlciB0byBkbyBjaGVja3VwcyBpbiB0aGUgdW5yZWdpc3RlciBtZXRob2QpXHJcbiAgICAgICAgICAgIG1ldGhvZHMucHVzaCh7bWV0aG9kOm1ldGhvZCwgZGVmaW5pdGlvbjptZXRob2RfZGVmaW5pdGlvbiwgdGhlX2Z1bmN0aW9uOnRoZV9mdW5jdGlvbn0pO1xyXG4gICAgICAgICAgICAvL1NlbmQgcHJlc2VuY2Ugc28gdGhlIGNsaWVudHMga25vdyB3ZSBoYXZlIGl0XHJcbiAgICAgICAgICAgIHNlbmRfcHJlc2VuY2UoKTtcclxuICAgICAgICAgICAgLy9TdGFydCBzZW5kaW5nIHByZXNlbmNlIHJlZ3VsYXJpbHkgKGlmIHdlIGFyZW4ndCBhbHJlYWR5IGRvaW5nIGl0KVxyXG4gICAgICAgICAgICBpZihwcmVzZW5jZV90aW1lcj09PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBwcmVzZW5jZV90aW1lciA9IHNldEludGVydmFsKHNlbmRfcHJlc2VuY2UsIGNvbmZpZ3VyYXRpb24ucHJlc2VuY2VfaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9XHJcblx0XHRcdFx0XHRcdG1ldHJpYyhcIlJlZ2lzdGVyZWQgbWV0aG9kc1wiLCBtZXRob2RzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuXHR9XHJcblx0dmFyIGludm9jYXRpb25zID0gMDtcclxuXHJcblx0Ly9MaXN0ZW5zIGZvciBtZXRob2QgaW52b2NhdGlvbnNcclxuXHRjb25uZWN0aW9uLm9uKFwiTWV0aG9kSW52b2NhdGlvblJlcXVlc3RNZXNzYWdlXCIsZnVuY3Rpb24obWVzc2FnZSl7XHJcbiAgICAgICAgLy9GaW5kIHRoZSBtZXRob2RcclxuICAgICAgICB2YXIgbWV0aG9kO1xyXG5cdFx0bWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG0pe1xyXG4gICAgICAgICAgICBpZihtLm1ldGhvZC5NZXRob2RSZXF1ZXN0U3ViamVjdCA9PT1tZXNzYWdlLk1ldGhvZFJlcXVlc3RTdWJqZWN0KXtcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHRpZihtZXRob2Q9PT11bmRlZmluZWQpe3JldHVybjt9XHJcbiAgICAgICAgaWYoZ2xvYmFsLmNvbnNvbGUhPT11bmRlZmluZWQmJiBjb25maWd1cmF0aW9uLmRlYnVnPT09dHJ1ZSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCIlYzw8PCByZWNlaXZpbmcgTWV0aG9kSW52b2NhdGlvblJlcXVlc3RNZXNzYWdlXCIsIFwiYmFja2dyb3VuZC1jb2xvcjpoc2xhKDE5OCwgNTElLCA3OSUsIDAuNSlcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCIlY1wiK0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLCBcImJhY2tncm91bmQtY29sb3I6aHNsYSgxOTgsIDUxJSwgNzklLCAwLjUpXCIpO1xyXG4gICAgICAgIH1cclxuXHRcdFx0XHRtZXRyaWMoXCJJbnZvY2F0aW9ucyBjb3VudFwiLCBpbnZvY2F0aW9ucysrKTtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICB2YXIgZXJyb3I7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgIFx0Ly9FeGVjdXRlIGl0IGFuZCBzYXZlIHRoZSByZXN1bHRcclxuICAgICAgICBcdHJlc3VsdCA9IG1ldGhvZC50aGVfZnVuY3Rpb24oaGVscGVycy5wYXJhbWV0ZXJzX3BhcnNlKG1lc3NhZ2UuQ29udGV4dC5Bcmd1bWVudHMpLmFyZ3VtZW50cyk7XHJcblx0XHR9Y2F0Y2goZSl7XHJcblx0XHRcdGlmKHR5cGVvZiBlID09PVwic3RyaW5nXCIpe1xyXG5cdFx0XHRcdGVycm9yID0gZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKHR5cGVvZiBlLm1lc3NhZ2UgPT0gJ3N0cmluZycpe1xyXG5cdFx0XHRcdGVycm9yID0gZS5tZXNzYWdlO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRlcnJvciA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdC8vVGhlIEFHTSBsaWJyYXJ5IG9ubHkgdHJhbnNmZXJzIG9iamVjdHMuIElmIHRoZSByZXN1bHQgaXMgbm90IGFuIG9iamVjdCwgcHV0IGl0IGluIG9uZVxyXG4gICAgICAgIGlmKHR5cGVvZiByZXN1bHQhPT1cIm9iamVjdFwifHxyZXN1bHQuY29uc3RydWN0b3IgPT09IEFycmF5KXtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge19yZXN1bHQ6cmVzdWx0fTtcclxuICAgICAgICB9XHJcblx0XHQvL0Rvbid0IHNlbmQgcmVzdWx0IGlmIHRoZSBjbGllbnQgZG9lcyBub3QgcmVxdWlyZSBpdFxyXG5cdFx0aWYobWVzc2FnZS5NZXRob2RSZXNwb25zZVN1YmplY3Q9PT1cIm51bGxcIil7cmV0dXJuO31cclxuXHJcblx0XHR2YXIgcmVzdWx0X21lc3NhZ2UgPSB7XHJcblx0XHRcdE1ldGhvZFJlcXVlc3RTdWJqZWN0Om1lc3NhZ2UuTWV0aG9kUmVxdWVzdFN1YmplY3QsXHJcblx0XHRcdE1ldGhvZFJlc3BvbnNlU3ViamVjdDptZXNzYWdlLk1ldGhvZFJlc3BvbnNlU3ViamVjdCxcclxuXHRcdFx0TWV0aG9kTmFtZTptZXRob2QubWV0aG9kLk1ldGhvZC5OYW1lLFxyXG4gICAgICAgICAgICBJbnZvY2F0aW9uSWQ6bWVzc2FnZS5Db250ZXh0Lkludm9jYXRpb25JZCxcclxuICAgICAgICAgICAgUmVzdWx0Q29udGV4dDpoZWxwZXJzLnBhcmFtZXRlcnNfc3RyaW5naWZ5KHJlc3VsdCksXHJcblx0XHRcdFNlcnZlcjppbnN0YW5jZS5pbmZvKCksXHJcblx0XHRcdFJlc3VsdE1lc3NhZ2U6ZXJyb3IsXHJcblx0XHRcdFN0YXR1czooZXJyb3IgPT09IHVuZGVmaW5lZCk/MDoxXHJcblx0XHR9O1xyXG5cdFx0Ly9TZW5kIHJlc3VsdFxyXG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZChcIk1ldGhvZEludm9jYXRpb25SZXN1bHRNZXNzYWdlXCIsIHJlc3VsdF9tZXNzYWdlKTtcclxuXHJcblx0XHRpZihnbG9iYWwuY29uc29sZSE9PXVuZGVmaW5lZCYmIGNvbmZpZ3VyYXRpb24uZGVidWc9PT10cnVlKXtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZyhcIiVjPj4+IHNlbmRpbmcgTWV0aG9kSW52b2NhdGlvblJlc3VsdE1lc3NhZ2VcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMTE4LCA1MSUsIDc5JSwgMC41KVwiKTtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZyhcIiVjXCIrSlNPTi5zdHJpbmdpZnkocmVzdWx0X21lc3NhZ2UpLCBcImJhY2tncm91bmQtY29sb3I6aHNsYSgxMTgsIDUxJSwgNzklLCAwLjUpXCIpO1xyXG5cdFx0fVxyXG5cclxuXHR9KTtcclxuXHJcblxyXG5cclxuXHQvL0NvbnN0cnVjdHMgYSBoZWFydGJlYXQgbWVzc2FnZVxyXG5cdGZ1bmN0aW9uIGNvbnN0cnVjdF9oZWFydGJlYXQoKXtcclxuXHRcdHJldHVybntcclxuXHRcdFx0UHVibGlzaGluZ0ludGVydmFsOmNvbmZpZ3VyYXRpb24uaGVhcmJlYXRfaW50ZXJ2YWwsXHJcblx0XHRcdEluc3RhbmNlOmluc3RhbmNlLmluZm8oKVxyXG5cdFx0fTtcclxuXHR9XHJcblx0Ly9Db25zdHJ1Y3RzIGEgcHJlc2VuY2UgbWVzc2FnZVxyXG5cdGZ1bmN0aW9uIGNvbnN0cnVjdF9wcmVzZW5jZSgpe1xyXG5cdFx0dmFyIHAgPSB7XHJcbiAgICAgICAgICAgIFB1Ymxpc2hpbmdJbnRlcnZhbDpjb25maWd1cmF0aW9uLnByZXNlbmNlX2ludGVydmFsLFxyXG4gICAgICAgICAgICBJbnN0YW5jZTppbnN0YW5jZS5pbmZvKClcclxuICAgICAgICB9O1xyXG5cdFx0cC5NZXRob2REZWZpbml0aW9ucyA9IG1ldGhvZHMubWFwKGZ1bmN0aW9uKG1ldGhvZCl7XHJcblx0XHRcdHJldHVybiBtZXRob2QubWV0aG9kO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gcDtcclxuXHR9XHJcblxyXG4gICAgLy9UcnVlIGlmIHdlIHNob3VsZCBiZSBicm9hZGNhc3RpbmcgcHJlc2VuY2VzIGFuZCBoZWFydGJlYXRzLCBmYWxzZSBvdGhlcndpc2VcclxuICAgIHZhciBicm9hZGNhc3RpbmcgPSB0cnVlO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBzdGFydCgpe1xyXG4gICAgICAgIGJyb2FkY2FzdGluZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3RvcCgpe1xyXG4gICAgICAgIGJyb2FkY2FzdGluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vU2VuZHMgYSBwcmVzZW5jZVxyXG4gICAgZnVuY3Rpb24gc2VuZF9wcmVzZW5jZSgpe1xyXG4gICAgICAgIGlmKGJyb2FkY2FzdGluZykge2Nvbm5lY3Rpb24uc2VuZChcIlNlcnZlclByZXNlbmNlTWVzc2FnZVwiLCBjb25zdHJ1Y3RfcHJlc2VuY2UoKSk7fVxyXG4gICAgfVxyXG5cclxuICAgIC8vU2VuZHMgYSBoZWFydGJlYXRcclxuICAgIGZ1bmN0aW9uIHNlbmRfaGVhcnRiZWF0KCl7XHJcbiAgICAgICAgaWYoYnJvYWRjYXN0aW5nKXtjb25uZWN0aW9uLnNlbmQoXCJTZXJ2ZXJIZWFydGJlYXRNZXNzYWdlXCIsIGNvbnN0cnVjdF9oZWFydGJlYXQoKSk7fVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuXHQvL0NvbnZlcnRzIHRoZSBtZXRob2QgZGVmaW5pdGlvbiBmcm9tIGNhbWVsIGNhc2UgdG8gc25ha2UgY2FzZVxyXG4gICAgZnVuY3Rpb24gY29udmVydF9tZXRob2QobWV0aG9kX2lkZW50aWZpZXIpe1xyXG4gICAgICAgIC8vSWYgd2UgYXJlIGdpdmVuIGEgc3RyaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0LCB3ZSBwcmVzdW1lIHRoYXQgaXMgdGhlIG1ldGhvZCdzIG5hbWU6XHJcbiAgICAgICAgaWYodHlwZW9mIG1ldGhvZF9pZGVudGlmaWVyID09PSBcInN0cmluZ1wiKXttZXRob2RfaWRlbnRpZmllciA9IHtuYW1lOm1ldGhvZF9pZGVudGlmaWVyfTt9XHJcblxyXG4gICAgICAgIC8vU2V0IGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgICAgaWYodHlwZW9mIG1ldGhvZF9pZGVudGlmaWVyLnZlcnNpb24hPT1cIm51bWJlclwiKXttZXRob2RfaWRlbnRpZmllci52ZXJzaW9uPTA7fVxyXG5cclxuXHJcbiAgICAgICAgLy9Db252ZXJ0IHRoZSBtZXRob2QgZGVmaW5pdGlvbiB0byB0aGUgZm9ybWF0IHRoYXQgQUdNIHJlcXVpcmVzXHJcbiAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBNZXRob2Q6IHtcclxuICAgICAgICAgICAgICBOYW1lOiBtZXRob2RfaWRlbnRpZmllci5uYW1lLFxyXG4gICAgICAgICAgICAgIElucHV0U2lnbmF0dXJlOiBtZXRob2RfaWRlbnRpZmllci5hY2NlcHRzLFxyXG4gICAgICAgICAgICAgIFJlc3VsdFNpZ25hdHVyZTogbWV0aG9kX2lkZW50aWZpZXIucmV0dXJucyxcclxuICAgICAgICAgICAgICBEZXNjcmlwdGlvbjogbWV0aG9kX2lkZW50aWZpZXIuZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgRGlzcGxheU5hbWU6IG1ldGhvZF9pZGVudGlmaWVyLmRpc3BsYXlfbmFtZSxcclxuICAgICAgICAgICAgICBWZXJzaW9uOiBtZXRob2RfaWRlbnRpZmllci52ZXJzaW9uLFxyXG4gICAgICAgICAgICAgIE9iamVjdFR5cGVSZXN0cmljdGlvbnM6IG1ldGhvZF9pZGVudGlmaWVyLm9iamVjdF90eXBlc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb250YWluc19wcm9wcyhmaWx0ZXIsIG9iamVjdCl7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gdHJ1ZTtcclxuICAgICAgICBPYmplY3Qua2V5cyhmaWx0ZXIpLmZvckVhY2goZnVuY3Rpb24ocHJvcCl7XHJcbiAgICAgICAgICAgIGlmKGZpbHRlcltwcm9wXSE9PW9iamVjdFtwcm9wXSl7bWF0Y2ggPSBmYWxzZTt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG5cdH1cclxuXHJcbiAgICAvL1VucmVnaXN0ZXJzIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIEFHTSBtZXRob2RcclxuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXIobWV0aG9kX2ZpbHRlcil7XHJcbiAgICBcdGlmKHR5cGVvZiBtZXRob2RfZmlsdGVyID09PSBcInN0cmluZ1wiKXttZXRob2RfZmlsdGVyID0ge25hbWU6bWV0aG9kX2ZpbHRlcn07fVxyXG4gICAgICAgIG1ldGhvZHMgPSBtZXRob2RzLmZpbHRlcihmdW5jdGlvbihtZXRob2Qpe1xyXG4gICAgICAgICAgICAgcmV0dXJuICFjb250YWluc19wcm9wcyhtZXRob2RfZmlsdGVyLCBtZXRob2QuZGVmaW5pdGlvbik7XHJcbiAgICAgICAgfSk7XHJcblx0XHRcdFx0bWV0cmljKFwiUmVnaXN0ZXJlZCBtZXRob2RzXCIsIG1ldGhvZHMubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcblxyXG5cdHJldHVybiB7cmVnaXN0ZXI6cmVnaXN0ZXIsIHVucmVnaXN0ZXI6dW5yZWdpc3Rlciwgc3RhcnQ6c3RhcnQsIHN0b3A6c3RvcH07XHJcbn07XHJcbiIsInZhciBhcHBsaWNhdGlvbiA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0aW9uXCIpO1xyXG52YXIgaW5zdGFuY2UgPSByZXF1aXJlKFwiLi9pbnN0YW5jZVwiKTtcclxudmFyIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuYXBwX21hbmFnZXIgPSBmdW5jdGlvbiBhcHBfbWFuYWdlcihhZ20sIHdpbmRvd3Mpe1xyXG5cdHZhciBhcHBzID0gYXBwbGljYXRpb24oYWdtLCBmdW5jdGlvbigpe3JldHVybiBpbnN0YW5jZXM7fSk7XHJcblx0dmFyIGluc3RhbmNlcyA9IGluc3RhbmNlKGFnbSwgYXBwcyk7XHJcblx0dmFyIG1hbmFnZXIgPSB7XHJcblx0XHRhcHBsaWNhdGlvbnM6IGFwcHMuYWxsLFxyXG5cdFx0YXBwbGljYXRpb246YXBwcy5nZXRfYnlfaWQsXHJcblx0XHRvbl9hcHBfYWRkZWQ6IGhlbHBlcnMuYWRkX2NhbGxiYWNrKFwiYWRkZWRcIikuYmluZChhcHBzKSxcclxuXHRcdG9uX2FwcF9hdmFpbGFibGU6IGhlbHBlcnMuYWRkX2NhbGxiYWNrKFwiYXZhaWxhYmxlXCIpLmJpbmQoYXBwcyksXHJcblx0XHRvbl9hcHBfcmVtb3ZlZDogaGVscGVycy5hZGRfY2FsbGJhY2soXCJyZW1vdmVkXCIpLmJpbmQoYXBwcyksXHJcblx0XHRvbl9hcHBfdW5hdmFpbGFibGU6IGhlbHBlcnMuYWRkX2NhbGxiYWNrKFwidW5hdmFpbGFibGVcIikuYmluZChhcHBzKSxcclxuXHRcdFxyXG5cdFx0aW5zdGFuY2VzOiBpbnN0YW5jZXMuYWxsLFxyXG5cdFx0b25faW5zdGFuY2Vfc3RhcnRlZDogaGVscGVycy5hZGRfY2FsbGJhY2soXCJzdGFydGVkXCIpLmJpbmQoaW5zdGFuY2VzKSxcclxuXHRcdG9uX2luc3RhbmNlX3N0b3BwZWQ6IGhlbHBlcnMuYWRkX2NhbGxiYWNrKFwic3RvcHBlZFwiKS5iaW5kKGluc3RhbmNlcyksXHJcblxyXG5cdFx0Z2V0X2JyYW5jaGVzOmZ1bmN0aW9uKHN1Y2Nlc3MsIGVycm9yKXtcclxuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0QnJhbmNoZXNcIiwge30sIFwiYmVzdFwiLCB7fSwgZnVuY3Rpb24oZSl7XHJcblx0XHRcdFx0aWYoc3VjY2Vzcyl7XHJcblx0XHRcdFx0XHRzdWNjZXNzKGhlbHBlcnMudmFscyhlLnJldHVybmVkLkJyYW5jaGVzKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCBlcnJvcik7XHJcblx0XHR9LFxyXG5cdFx0Z2V0X2N1cnJlbnRfYnJhbmNoOmZ1bmN0aW9uKHN1Y2Nlc3MsIGVycm9yKXtcclxuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0Q3VycmVudEJyYW5jaFwiLCB7fSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbihlKXtcclxuXHRcdFx0XHRpZihzdWNjZXNzKXtcclxuXHRcdFx0XHRcdHN1Y2Nlc3MoZS5yZXR1cm5lZC5CcmFuY2gpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgZXJyb3IpOyBcclxuXHRcdH0sXHJcblx0XHRzZXRfY3VycmVudF9icmFuY2g6ZnVuY3Rpb24oYnJhbmNoLCBzdWNjZXNzLCBlcnJvcil7XHJcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLlNldEN1cnJlbnRCcmFuY2hcIiwge0JyYW5jaDpicmFuY2h9LCBcImJlc3RcIiwge30sIHN1Y2Nlc3MsIGVycm9yKTtcclxuXHRcdH0sXHJcblx0XHRjdXJyZW50X3VzZXI6ZnVuY3Rpb24oc3VjY2VzcywgZXJyb3IpIHtcclxuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0VXNlclwiLCB7fSwgXCJiZXN0XCIsIHt9LCBzdWNjZXNzLCBlcnJvcik7XHJcblx0XHR9LFxyXG5cdFx0Z2V0X2Z1bmN0aW9uYWxfZW50aXRsZW1lbnQ6ZnVuY3Rpb24oZm4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkdldEZ1bmN0aW9uYWxFbnRpdGxlbWVudFwiLCB7RnVuY3Rpb246Zm59LCBcImJlc3RcIiwge30sIGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0XHRpZihzdWNjZXNzKSB7XHJcblx0XHRcdFx0XHRzdWNjZXNzKGUucmV0dXJuZWQuRW50aXRsZW1lbnQpOyBcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIGVycm9yKTtcclxuXHRcdH0sXHJcblx0XHRjYW5faTpmdW5jdGlvbihmbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuQ2FuSVwiLCB7RnVuY3Rpb246Zm59LCBcImJlc3RcIiwge30sIHN1Y2Nlc3MsIGVycm9yKTtcclxuXHRcdH0sXHJcblx0XHRleGl0OmZ1bmN0aW9uKCkge1xyXG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5TaHV0ZG93blwiLCB7fSwgXCJhbGxcIiwge30sIFxyXG5cdFx0XHRcdGZ1bmN0aW9uKGEpIHsgY29uc29sZS5sb2coYSk7IH0sIFxyXG5cdFx0XHRcdGZ1bmN0aW9uKGUpIHsgY29uc29sZS5sb2coZSk7IH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfdHJpZ2dlcl9hcHBfZXZlbnQ6YXBwcy5fdHJpZ2dlcixcclxuXHRcdF90cmlnZ2VyX2luc3RhbmNlX2V2ZW50Omluc3RhbmNlcy5fdHJpZ2dlclxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjYWxsX3dpdGgocHJvcCwgZnVuYyApe1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHJlc3VsdCl7XHJcblx0XHRcdGZ1bmMocmVzdWx0W3Byb3BdKTsgXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblx0XHJcblx0Ly9DcmVhdGUgZXZlbnQgYmluZGluZ3NcclxuXHRcclxuXHQvL1RlbGwgdGhlIGFwcCB3aGVuIGl0cyBpbnN0YW5jZXMgYXJlIGFkZGVkL3JlbW92ZWRcclxuXHRcclxuXHRtYW5hZ2VyLm9uX2luc3RhbmNlX3N0YXJ0ZWQoZnVuY3Rpb24oaW5zdGFuY2Upe1xyXG5cdFx0aWYoaW5zdGFuY2UuYXBwbGljYXRpb24pe1xyXG5cdFx0XHQvL1RyaWdnZXIgXCJpbnN0YW5jZV9zdGFydGVkXCIgZXZlbnQgb24gYXBwbGljYXRpb25cclxuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9hcHBfZXZlbnQoXCJpbnN0YW5jZV9zdGFydGVkXCIsIGluc3RhbmNlLCBpbnN0YW5jZS5hcHBsaWNhdGlvbi5uYW1lKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vVHJpZ2dlciBcIndpbmRvd19vcGVuZWRcIiBldmVudCBvbiBpbnN0YW5jZVxyXG5cdFx0XHR2YXIgY29udGFpbmVyO1xyXG5cdFx0XHRpZih3aW5kb3dzKXtcclxuXHRcdFx0XHR2YXIgaWQgPSAoaW5zdGFuY2UuY29udGV4dCAmJiBpbnN0YW5jZS5jb250ZXh0Lmd1aWQpID8gaW5zdGFuY2UuY29udGV4dC5ndWlkIDogaW5zdGFuY2UuaWQ7XHJcblx0XHRcdFx0Y29udGFpbmVyID0gaW5zdGFuY2UuYXBwbGljYXRpb24uY29uZmlndXJhdGlvbi5jb250YWluZXIuc3BsaXQoXCIuXCIpWzFdO1xyXG5cdFx0XHRcdGdsdWUuYWdtLmludm9rZShcIlQ0Mi5XbmQuRmluZEJ5SWRcIiwge3dpbmRvd0lkOiBpbnN0YW5jZS5pZH0sIHthcHBsaWNhdGlvbjogaW5zdGFuY2UuYXBwbGljYXRpb24uY29uZmlndXJhdGlvbi5jb250YWluZXJ9LCB7fSwgd2luZG93X29wZW5lZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblx0XHRmdW5jdGlvbiB3aW5kb3dfb3BlbmVkKGEpe1xyXG5cdFx0XHQvL1dyYXAgdGhlIHdpbmRvdyBpbiBhIHdpbmRvdyBvYmplY3QsIHVzaW5nIHRoZSBnbHVlIHdpbmRvd3MgbGliXHJcblx0XHRcdHZhciB3ID0gYS5yZXR1cm5lZCBbIE9iamVjdC5rZXlzKGEucmV0dXJuZWQpWzBdIF07XHJcblx0XHRcdHZhciB3aW4gPSBnbHVlLndpbmRvd3MuX2Zyb21fZXZlbnQody53aW5kb3dOYW1lLCBjb250YWluZXIsIHcudXJsLCB3LndpbmRvd0lkICk7XHJcblx0XHRcdFxyXG5cdFx0XHQvL1RyaWdnZXIgdGhlIHdpbmRvdyBvcGVuZWQgZXZlbnRcclxuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9pbnN0YW5jZV9ldmVudChcIndpbmRvd19hZGRlZFwiLCB3aW4sIGlkKTtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHR9KTtcclxuXHRcclxuXHRtYW5hZ2VyLm9uX2luc3RhbmNlX3N0b3BwZWQoZnVuY3Rpb24oaW5zdGFuY2Upe1xyXG5cdFx0aWYoaW5zdGFuY2UuYXBwbGljYXRpb24pe1xyXG5cdFx0XHRtYW5hZ2VyLl90cmlnZ2VyX2FwcF9ldmVudChcImluc3RhbmNlX3N0b3BwZWRcIiwgaW5zdGFuY2UsIGluc3RhbmNlLmFwcGxpY2F0aW9uLm5hbWUpO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIGlkID0gKGluc3RhbmNlLmNvbnRleHQgJiYgaW5zdGFuY2UuY29udGV4dC5ndWlkKSA/IGluc3RhbmNlLmNvbnRleHQuZ3VpZCA6IGluc3RhbmNlLmlkO1xyXG5cdFx0XHRtYW5hZ2VyLl90cmlnZ2VyX2luc3RhbmNlX2V2ZW50KFwid2luZG93X3JlbW92ZWRcIiwge30sIGlkKTtcclxuXHRcdFx0XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdFxyXG5cclxuXHR9KTtcclxuXHJcblx0Ly9XaGVuIGFuIGFwcCBpcyByZW1vdmVkLCByZW1vdmUgYWxzbyBpdHMgaW5zdGFuY2VzXHJcblx0XHJcblx0bWFuYWdlci5vbl9hcHBfcmVtb3ZlZChmdW5jdGlvbihhcHApe1xyXG5cdFx0YXBwLmluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKGluc3RhbmNlKXtcclxuXHRcdFx0dmFyIGlkID0gIChpbnN0YW5jZS5jb250ZXh0ICYmIGluc3RhbmNlLmNvbnRleHQuZ3VpZCkgPyBpbnN0YW5jZS5jb250ZXh0Lmd1aWQgOiBpbnN0YW5jZS5pZDtcclxuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9pbnN0YW5jZV9ldmVudChcInN0b3BwZWRcIiwge30sIGlkKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cdHZhciBicmFuY2hfY2hhbmdlZF9jYWxsYmFjaztcclxuXHRtYW5hZ2VyLm9uX2JyYW5jaGVzX2NoYW5nZWQgPSBmdW5jdGlvbihjYWxsYmFjayl7XHJcblx0XHRicmFuY2hfY2hhbmdlZF9jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIG9uX2JyYW5jaF9jaGFuZ2VkKGUpe1xyXG5cdFx0aWYgKHR5cGVvZiBicmFuY2hfY2hhbmdlZF9jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdGJyYW5jaF9jaGFuZ2VkX2NhbGxiYWNrKCBoZWxwZXJzLnZhbHMoZSkgKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZV9hcHBfcmVhZHkoYXBwKXtcclxuXHRcdGlmKGFwcC5Jc1JlYWR5KXtcclxuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9hcHBfZXZlbnQoXCJhdmFpbGFibGVcIiwgYXBwKTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRcclxuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9hcHBfZXZlbnQoXCJ1bmF2YWlsYWJsZVwiLCBhcHApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYXBwX2ZhaWxlZChlKXtcclxuXHRcdG1hbmFnZXIuX3RyaWdnZXJfaW5zdGFuY2VfZXZlbnQoXCJlcnJvclwiLCBlLCBlLkNvbnRleHQuZ3VpZCk7XHJcblx0fVxyXG5cclxuXHJcblx0aWYoYWdtICYmIGFnbS5zdWJzY3JpYmUpe1xyXG5cdFxyXG5cdFx0bWFuYWdlci5hZ20gPSBhZ207XHJcblx0XHR2YXIgaGFuZGxlcnMgPVtcclxuXHRcdFx0e2V2ZW50OlwiT25BcHBsaWNhdGlvbkFkZGVkXCIsIHRyaWdnZXI6XCJhZGRlZFwiLCBvbjphcHBzfSxcclxuXHRcdFx0e2V2ZW50OlwiT25BcHBsaWNhdGlvblJlbW92ZWRcIiwgdHJpZ2dlcjpcInJlbW92ZWRcIiwgb246YXBwc30sXHJcblx0XHRcdHtldmVudDpcIk9uQXBwbGljYXRpb25DaGFuZ2VkXCIsIHRyaWdnZXI6XCJjaGFuZ2VkXCIsIG9uOmFwcHN9LFxyXG5cdFx0XHR7ZXZlbnQ6XCJPbkFwcGxpY2F0aW9uU3RhcnRlZFwiLCB0cmlnZ2VyOlwic3RhcnRlZFwiLCBvbjppbnN0YW5jZXN9LFxyXG5cdFx0XHR7ZXZlbnQ6XCJPbkFwcGxpY2F0aW9uU3RvcHBlZFwiLCB0cmlnZ2VyOlwic3RvcHBlZFwiLCBvbjppbnN0YW5jZXN9LFxyXG5cdFx0XHR7ZXZlbnQ6XCJPbkFwcGxpY2F0aW9uQWdtU2VydmVyUmVhZHlcIiwgdHJpZ2dlcjpcImFnbV9yZWFkeVwiLCBvbjppbnN0YW5jZXN9LFxyXG5cdFx0XHR7ZXZlbnQ6XCJPbkFwcGxpY2F0aW9uUmVhZHlcIiwgZnVuYzpoYW5kbGVfYXBwX3JlYWR5fSxcclxuXHRcdFx0e2V2ZW50OlwiT25CcmFuY2hlc01vZGlmaWVkXCIsIGZ1bmM6b25fYnJhbmNoX2NoYW5nZWR9LFxyXG5cdFx0XHR7ZXZlbnQ6XCJPbkFwcGxpY2F0aW9uU3RhcnRGYWlsZWRcIiwgcmF3X2Z1bmM6YXBwX2ZhaWxlZH1cclxuXHRcdF07XHJcblxyXG5cdFx0XHJcblx0XHRhZ20uc3Vic2NyaWJlKFwiVDQyLkFDUy5PbkV2ZW50XCIsIHt0YXJnZXQ6XCJhbGxcIn0pXHJcblx0XHRcdC50aGVuKGZ1bmN0aW9uKHN1YnNjcmlwdGlvbikge1xyXG5cclxuXHRcdFx0XHRzdWJzY3JpcHRpb24ub25EYXRhKHN0cmVhbURhdGEpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dmFyIGV2ZW50cyA9IHN0cmVhbURhdGEuZGF0YTtcclxuXHRcdFx0XHRcdGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG9iamVjdHMgPSBldmVudHNbaGFuZGxlci5ldmVudF07XHJcblx0XHRcdFx0XHRcdGlmIChvYmplY3RzKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmIChoYW5kbGVyLnJhd19mdW5jICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGhhbmRsZXIucmF3X2Z1bmMob2JqZWN0cyk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRoZWxwZXJzLnZhbHMob2JqZWN0cykuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoaGFuZGxlci5vbiAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGhhbmRsZXIub24uX3RyaWdnZXIoaGFuZGxlci50cmlnZ2VyLCBvYmplY3QpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aGFuZGxlci5mdW5jKG9iamVjdCk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fVxyXG5cdFxyXG5cdG1hbmFnZXIudmVyc2lvbiA9IFwiMi4wLjBcIjtcclxuXHRcclxuXHRyZXR1cm4gbWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5nbG9iYWwudGljazQyID0gZ2xvYmFsLnRpY2s0MiB8fHt9O1xyXG5nbG9iYWwudGljazQyLmFwcF9tYW5hZ2VyID0gZ2xvYmFsLmFwcF9tYW5hZ2VyO1xyXG4iLCJ2YXIgZXZlbnRfbWFuYWdlciA9IHJlcXVpcmUoXCIuL2V2ZW50X21hbmFnZXJcIik7XHJcbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYWdtLCBpbnN0YW5jZXMpe1xyXG5cdHZhciBhcHBfcHJvdG8gPSBoZWxwZXJzLmFkZF9jYWxsYmFja3MoIHtcclxuXHJcblx0XHRzdGFydDpmdW5jdGlvbihwYXJhbXMsIHN1Y2Nlc3MsIGVycm9yKXtcclxuXHRcdFx0cGFyYW1zID0gcGFyYW1zIHx8e307XHJcblx0XHRcdHBhcmFtcy5ndWlkID0gcGFyYW1zLmd1aWQgfHwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjEwMDAwMDAwKTtcclxuXHRcdFx0aWYoYWdtKXtcclxuXHRcdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5TdGFydEFwcGxpY2F0aW9uXCIsIHtOYW1lOnRoaXMubmFtZSwgQ29udGV4dDogcGFyYW1zfSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbihlKXtcclxuXHRcdFx0XHR9LCBlcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGluc3RhbmNlcygpLl90cmlnZ2VyKFwiY3JlYXRlXCIsIHtDb250ZXh0OnBhcmFtc30pO1xyXG5cdFx0XHJcblx0XHR9XHRcdFxyXG5cclxuXHR9LCBbXCJhZGRlZFwiLCBcInJlbW92ZWRcIiwgXCJhdmFpbGFibGVcIiwgXCJ1bmF2YWlsYWJsZVwiLCBcImluc3RhbmNlX3N0YXJ0ZWRcIiwgXCJpbnN0YW5jZV9zdG9wcGVkXCIsIFwiY2hhbmdlZFwiIF0sIFwib25fXCIgKTtcclxuXHJcbi8vY29uc3RydWN0b3IsIGluaXRfZXZlbnQsIGlkX2ZpZWxkXHJcblx0XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZV9hcHAocHJvcHMsIG9iaiApe1xyXG5cdFx0b2JqLm5hbWUgPSBwcm9wcy5OYW1lO1xyXG5cdFx0b2JqLnRpdGxlID0gcHJvcHMuVGl0bGU7XHJcblx0XHRvYmoudmVyc2lvbiA9IHByb3BzLlZlcnNpb247XHJcblx0XHRvYmouaW5zdGFuY2VzID0gW107XHJcblx0XHRvYmouY29uZmlndXJhdGlvbiA9IHt9O1xyXG5cdFx0b2JqLmNvbmZpZ3VyYXRpb24uYXV0b19zdGFydCA9IHByb3BzLkF1dG9TdGFydDtcclxuXHRcdG9iai5jb25maWd1cmF0aW9uLmNhcHRpb24gPSBwcm9wcy5DYXB0aW9uO1xyXG5cdFx0b2JqLmNvbmZpZ3VyYXRpb24uaGlkZGVuID0gcHJvcHMuSXNIaWRkZW47XHJcblx0XHRvYmouY29uZmlndXJhdGlvbi5jb250YWluZXIgPSBwcm9wcy5BcHBsaWNhdGlvbk5hbWU7XHJcblx0XHQvL29iai5kaXNhYmxlZCA9IHByb3BzLklzRGlzYWJsZWQ7XHJcblx0XHRvYmouY29uZmlndXJhdGlvbi5hbGxvd19tdWx0aXBsZSA9IHByb3BzLkFsbG93TXVsdGlwbGU7XHJcblx0XHRvYmouYXZhaWxhYmxlID0gcHJvcHMuSXNSZWFkeSB8fCBmYWxzZTtcclxuXHRcdG9iai5pY29uID0gcHJvcHMuSWNvbjtcclxuXHRcdHJldHVybiBvYmo7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZXZlbnRfbWFuYWdlcih7XHJcblx0XHRjcmVhdGU6ZnVuY3Rpb24gY3JlYXRlX2FwcChwcm9wcyl7XHJcblx0XHRcdHJldHVybiB1cGRhdGVfYXBwKCBwcm9wcywgT2JqZWN0LmNyZWF0ZShhcHBfcHJvdG8pKTtcclxuXHRcdH0sXHJcblx0ICAgICAgIFx0dXBkYXRlOnVwZGF0ZV9hcHAsXHJcblx0XHRpbml0X2V2ZW50OlwiYWRkZWRcIiwgXHJcblx0XHRleGl0X2V2ZW50OlwicmVtb3ZlZFwiLFxyXG5cdFx0aWRfZmllbGQ6XCJOYW1lXCIsXHJcblx0XHRjYWxsYmFja3M6e1xyXG5cdFx0XHRhdmFpbGFibGU6ZnVuY3Rpb24oKXtcclxuXHRcdFx0XHR0aGlzLmF2YWlsYWJsZSA9IHRydWU7XHJcblx0XHRcdH0sXHJcblx0XHRcdGNoYW5nZWQ6ZnVuY3Rpb24ocHJvcHMpe1xyXG5cdFx0XHRcdHRoaXMuaWNvbiA9IHByb3BzLkljb247XHJcblx0XHRcdFx0dGhpcy50aXRsZSA9IHByb3BzLlRpdGxlO1xyXG5cdFx0XHRcdHRoaXMuY29uZmlndXJhdGlvbi5jYXB0aW9uID0gcHJvcHMuQ2FwdGlvbjtcclxuXHRcdFx0fSxcclxuXHRcdFx0dW5hdmFpbGFibGU6ZnVuY3Rpb24oKXtcclxuXHRcdFx0XHR0aGlzLmF2YWlsYWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRpbnN0YW5jZV9zdGFydGVkOmZ1bmN0aW9uKGluc3RhbmNlKXtcclxuXHRcdFx0XHR0aGlzLmluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0aW5zdGFuY2Vfc3RvcHBlZDpmdW5jdGlvbihpbnN0YW5jZSl7XHJcblx0XHRcdFx0dGhpcy5pbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24obXlfaW5zdGFuY2UpeyByZXR1cm4gbXlfaW5zdGFuY2UgIT09IGluc3RhbmNlO30pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSk7XHJcblx0XHJcbn07XHJcbiIsInZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxuXHJcbmZ1bmN0aW9uIGV4ZWNfY2FsbGJhY2tzKG9iaiwgYXJyLCB2YWwpIHtcclxuICBpZiAoYXJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICBjYWxsYmFjay5jYWxsKG9iaiwgdmFsKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVfZW52aXJvbm1lbnQoc2V0dGluZ3MpIHtcclxuICB2YXIgb2JqZWN0cyA9IHt9O1xyXG4gIHZhciBnbG9iYWxfY2FsbGJhY2tzID0ge307XHJcbiAgcmV0dXJuIHtcclxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gaGVscGVycy52YWxzKG9iamVjdHMpO1xyXG4gICAgfSwgXHJcbiAgICBnZXRfYnlfaWQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICByZXR1cm4gb2JqZWN0c1tpZF07XHJcbiAgICB9LFxyXG4gICAgX3RyaWdnZXI6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgaWQpIHtcclxuICAgICAgaWQgPSBpZCB8fCAoIHR5cGVvZiBzZXR0aW5ncy5pZF9maWVsZCA9PT0gXCJmdW5jdGlvblwiID8gc2V0dGluZ3MuaWRfZmllbGQocHJvcHMpIDogcHJvcHNbc2V0dGluZ3MuaWRfZmllbGRdKTtcclxuXHJcbiAgICAgIC8vUXVpdCBpZiB3ZSByZWNlaXZlIGFuIGV2ZW50IGZvciBhbiBvYmplY3QgYmVmb3JlIGluaXRpYXRpbmcgaXQuXHJcbiAgICAgIGlmKCBvYmplY3RzW2lkXSA9PT0gdW5kZWZpbmVkICYmKCB0eXBlICE9PSBzZXR0aW5ncy5pbml0X2V2ZW50ICYmIHR5cGUgIT09IHNldHRpbmdzLmNyZWF0ZV9ldmVudCkpe1xyXG4gICAgICAgIC8vY29uc29sZS5sb2cgKFwiUmVjZWl2ZWQgJ1wiK3R5cGUrXCInIGV2ZW50IGJlZm9yZSAnXCIrc2V0dGluZ3MuaW5pdF9ldmVudCtcIidcIik7XHJcbiAgICAgICByZXR1cm47fVxyXG5cclxuICAgICAgXHJcbiAgICAgIC8vQ3JlYXRlIG9yIHJldHJpZXZlIGFuIG9iamVjdCwgcmVwcmVzZW50aW5nIHRoZSBlbnRpdHlcclxuICAgICAgdmFyIG9iaiA9IG9iamVjdHNbaWRdID0gb2JqZWN0c1tpZF0gfHwgaW5pdF9vYmplY3Qoc2V0dGluZ3MuY3JlYXRlKHByb3BzKSk7XHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gc2V0dGluZ3MuaW5pdF9ldmVudCl7XHJcbiAgICAgICAgIC8vUXVpdCBpZiB3ZSByZWNlaXZlIGEgaW5pdCBldmVudCBmb3IgYW4gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeSBhY3RpdmVcclxuXHRpZihvYmouYWN0aXZlKXtcclxuICAgICAgICAgIC8vY29uc29sZS5sb2cgKFwiUmVjZWl2ZWQgc2Vjb25kICdcIitzZXR0aW5ncy5pbml0X2V2ZW50K1wiJyBmb3IgYXBwIFwiK2lkKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvL0Vsc2UsIG1ha2UgaXQgYWN0aXZlXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICBvYmouYWN0aXZlID0gdHJ1ZTtcclxuXHQgIHNldHRpbmdzLnVwZGF0ZShwcm9wcywgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIC8vV2hlbiB0aGUgZW50aXR5IGlzIHJlbW92ZWQsIHNldCBpdCB0byBub24tYWN0aXZlXHJcbiAgICAgIH0gZWxzZSBpZih0eXBlID09PSBzZXR0aW5ncy5leGl0X2V2ZW50KXtcclxuXHRvYmouYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgIFxyXG4gICAgICAvL1doZW4gYSBjcmVhdGUgZXZlbnQgaXMgcmVjZWl2ZWQsIGp1c3QgcmV0dXJuIHRoZSBvYmplY3Qgd2l0aG91dCBkb2luZyBhbnl0aGluZyBlbHNlXHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gc2V0dGluZ3MuY3JlYXRlX2V2ZW50KXtcclxuICAgICAgXHRyZXR1cm4gb2JqO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy9FeGVjdXRlIHN5c3RlbSBjYWxsYmFja3NcclxuICAgICAgaWYoc2V0dGluZ3MuY2FsbGJhY2tzW3R5cGVdICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICBcdHNldHRpbmdzLmNhbGxiYWNrc1t0eXBlXS5jYWxsKG9iaiwgcHJvcHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL0V4ZWN1dGUgZ2xvYmFsIGNhbGxiYWNrc1xyXG4gICAgICBleGVjX2NhbGxiYWNrcyh1bmRlZmluZWQsIGdsb2JhbF9jYWxsYmFja3NbdHlwZV0sIG9iaik7XHJcbiAgICAgIFxyXG4gICAgICAvL0V4ZWN1dGUgdXNlci1kZWZpbmVkIGNhbGxiYWNrcyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGUgb2JqZWN0XHJcbiAgICAgIGV4ZWNfY2FsbGJhY2tzKG9iaiwgb2JqLmNhbGxiYWNrc1t0eXBlXSwgcHJvcHMpO1xyXG5cclxuICAgICAgLy9XaGVuIHRoZSBlbnRpdHkgaXMgcmVtb3ZlZCwgcmVtb3ZlIGFsbCBjYWxsYmFja3MgKGFmdGVyIHlvdSBleGVjdXRlIHRoZW0pXHJcbiAgICAgIGlmKHR5cGUgPT09IHNldHRpbmdzLmV4aXRfZXZlbnQpe1xyXG4gICAgICBcdG9iai5jYWxsYmFja3MgPSB7fTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb2JqO1xyXG5cclxuICAgIH0sXHJcbiAgICAvL0V4cG9zZSB0aGUgZ2xvYmFsIGNhbGxiYWNrcyBvYmplY3Qgc28gdGhhdCB1c2VyIGNhbiByZWdpc3RlciBzb21lXHJcbiAgICBjYWxsYmFja3M6IGdsb2JhbF9jYWxsYmFja3NcclxuICB9O1xyXG59O1xyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBpbml0X29iamVjdChvYmplY3Qpe1xyXG5cdG9iamVjdC5jYWxsYmFja3MgPSB7fTtcclxuXHRvYmplY3QuYWN0aXZlID0gZmFsc2U7XHJcblx0cmV0dXJuIG9iamVjdDtcclxufVxyXG4iLCJmdW5jdGlvbiBub29wKCl7fVxyXG5cclxuZnVuY3Rpb24gZXhlY19pZihjb25kaXRpb24pe1xyXG5cdHJldHVybiBmdW5jdGlvbihhcHAsIGNhbGxiYWNrKXtcclxuXHRcdGlmKGNvbmRpdGlvbihhcHApKXtjYWxsYmFjay5jYWxsKGFwcCk7fVxyXG5cdH07XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0cy5hZGRfY2FsbGJhY2tzID0gZnVuY3Rpb24gYWRkX2NhbGxiYWNrcyhvYmplY3QsIGV2ZW50cywgcHJlZml4KXtcclxuXHRldmVudHMuZm9yRWFjaChmdW5jdGlvbiggZXZlbnQpe1xyXG5cdFx0aWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIil7XHJcblx0XHRcdGV2ZW50ID0ge25hbWU6ZXZlbnQsIHRyaWdnZXJfd2hlbjpub29wfTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0b2JqZWN0WyBwcmVmaXggKyBldmVudC5uYW1lIF0gPSBleHBvcnRzLmFkZF9jYWxsYmFjayggZXZlbnQubmFtZSwgZXhlY19pZihldmVudC50cmlnZ2VyX3doZW4pICk7XHJcblx0fSk7XHJcblx0cmV0dXJuIG9iamVjdDtcclxuXHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnRzLmFkZF9jYWxsYmFjayA9IGZ1bmN0aW9uIGFkZF9jYWxsYmFjaygga2V5LCBvbl9hZGQgKXtcclxuXHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spe1xyXG5cdFx0dmFyIG9iaiA9IHRoaXMuY2FsbGJhY2tzO1xyXG5cdFx0aWYob2JqW2tleV09PT11bmRlZmluZWQpe29ialtrZXldID0gW2NhbGxiYWNrXTt9XHJcblx0XHRlbHNlIHtvYmpba2V5XS5wdXNoKGNhbGxiYWNrKTt9XHJcblx0XHRpZih0eXBlb2Ygb25fYWRkID09PSBcImZ1bmN0aW9uXCIpe29uX2FkZCh0aGlzLCBjYWxsYmFjayk7fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxufTtcclxuZXhwb3J0cy52YWxzID0gZnVuY3Rpb24gdmFscyhvYmope1xyXG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbihhcnIsIGtleSl7YXJyLnB1c2gob2JqW2tleV0pO3JldHVybiBhcnI7fSwgW10pO1xyXG59O1xyXG4iLCJ2YXIgZXZlbnRfbWFuYWdlciA9IHJlcXVpcmUoXCIuL2V2ZW50X21hbmFnZXJcIik7XHJcbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhZ20sIGFwcHMpe1xyXG5cdHZhciBpbnN0YW5jZV9wcm90byA9IGhlbHBlcnMuYWRkX2NhbGxiYWNrcygge1xyXG5cdFx0c3RvcDpmdW5jdGlvbihwYXJhbXMsIHN1Y2Nlc3MsIGVycm9yKXtcclxuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuU3RvcEFwcGxpY2F0aW9uXCIsIHtOYW1lOnRoaXMuYXBwbGljYXRpb24ubmFtZSwgSWQ6dGhpcy5pZH0sIFwiYmVzdFwiLCB7fSwgZnVuY3Rpb24oZSl7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coZSk7XHJcblx0XHRcdH0sIGVycm9yKTtcclxuXHRcdH0sXHJcblx0XHRhY3RpdmF0ZTpmdW5jdGlvbihwYXJhbXMsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkFjdGl2YXRlQXBwbGljYXRpb25cIiwge05hbWU6dGhpcy5hcHBsaWNhdGlvbi5uYW1lLCBJZDp0aGlzLmlkfSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbihlKXtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhlKTtcclxuXHRcdFx0fSwgZXJyb3IpO1xyXG5cdFx0fVxyXG5cdH0sIFtcclxuXHRcdHtuYW1lOlwid2luZG93X2FkZGVkXCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24oYXBwKXtyZXR1cm4gYXBwLmFjdGl2ZSAmJiBhcHAubWFpbl93aW5kb3cgIT09IHVuZGVmaW5lZDt9fSwgXHJcblx0XHR7bmFtZTpcIndpbmRvd19yZW1vdmVkXCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24oYXBwKXtyZXR1cm4gYXBwLm1haW5fd2luZG93ID09PSB1bmRlZmluZWQ7fX0sIFxyXG5cdFx0e25hbWU6XCJzdGFydGVkXCIsIHRyaWdnZXJfd2hlbjpmdW5jdGlvbihhcHApe3JldHVybiBhcHAuaWQgIT09IHVuZGVmaW5lZCAmJiBhcHAuYWN0aXZlO319LCBcclxuXHRcdHtuYW1lOlwic3RvcHBlZFwiLCB0cmlnZ2VyX3doZW46ZnVuY3Rpb24oYXBwKXtyZXR1cm4gYXBwLmlkICE9PSB1bmRlZmluZWQgJiYgIWFwcC5hY3RpdmU7fX0sIFxyXG5cdFx0e25hbWU6XCJhZ21fcmVhZHlcIiwgdHJpZ2dlcl93aGVuOmZ1bmN0aW9uKGFwcCl7cmV0dXJuIGFwcC5hY3RpdmUgJiYgYXBwLmFnbSAhPT0gdW5kZWZpbmVkO319LFxyXG5cdFx0e25hbWU6XCJlcnJvclwiLCB0cmlnZ2VyX3doZW46ZnVuY3Rpb24oYXBwKXtyZXR1cm4gYXBwLmVycm9yICE9PSB1bmRlZmluZWQ7fX0sXHJcblx0XSwgXCJvbl9cIiApOyBcclxuXHRcclxuXHRmdW5jdGlvbiB1cGRhdGVfaW5zdGFuY2UocHJvcHMsIG9iail7XHJcblx0XHRvYmouaWQgPSBwcm9wcy5JZDtcclxuXHRcdG9iai5hcHBsaWNhdGlvbiA9IGFwcHMuZ2V0X2J5X2lkKHByb3BzLk5hbWUpO1xyXG5cdFx0b2JqLmNvbnRleHQgPSBwcm9wcy5Db250ZXh0O1xyXG5cdFx0cmV0dXJuIG9iajtcclxuXHRcclxuXHR9XHJcblxyXG5cdHJldHVybiBldmVudF9tYW5hZ2VyKHtcclxuXHRcdGNyZWF0ZTpmdW5jdGlvbihwcm9wcyl7XHJcblx0XHRcdHJldHVybiB1cGRhdGVfaW5zdGFuY2UocHJvcHMsIE9iamVjdC5jcmVhdGUoaW5zdGFuY2VfcHJvdG8pKTtcclxuXHRcdH0sXHJcblx0XHR1cGRhdGU6dXBkYXRlX2luc3RhbmNlLCBcclxuXHRcdGNyZWF0ZV9ldmVudDpcImNyZWF0ZVwiLCBcclxuXHRcdGluaXRfZXZlbnQ6XCJzdGFydGVkXCIsIFxyXG5cdFx0ZXhpdF9ldmVudDpcInN0b3BwZWRcIixcclxuXHRcdGlkX2ZpZWxkOmZ1bmN0aW9uKGUpe3JldHVybiBlLkNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiBlLkNvbnRleHQuZ3VpZCE9PSB1bmRlZmluZWQ/IGUuQ29udGV4dC5ndWlkOiBlLklkO30sXHJcblx0XHRjYWxsYmFja3M6e1xyXG5cdFx0XHRhZ21fcmVhZHk6ZnVuY3Rpb24oZSl7XHJcblx0XHRcdFx0Ly9nZXQgdGhlIGZpcnN0IEFHTVxyXG5cdFx0XHRcdHZhciBzZXJ2ZXJfbmFtZSA9IE9iamVjdC5rZXlzKGUuQWdtU2VydmVycylbMF07XHJcblx0XHRcdFx0Ly9BdHRhY2ggaXQgdG8gdGhlIG9iamVjdFxyXG5cdFx0XHRcdHRoaXMuYWdtID0gY29udmVydF9hZ21faW5zdGFuY2UoZS5BZ21TZXJ2ZXJzW3NlcnZlcl9uYW1lXSk7XHJcblx0XHRcdH0sXHJcblx0ICAgICAgIFx0XHRlcnJvcjpmdW5jdGlvbihlKXtcclxuXHRcdFx0XHR0aGlzLmVycm9yID0gZTtcclxuXHRcdFx0fSxcclxuXHRcdFx0d2luZG93X2FkZGVkOmZ1bmN0aW9uKHdpbil7XHJcblx0XHRcdFx0dGhpcy5tYWluX3dpbmRvdyA9IHdpbjtcclxuXHRcdFx0XHR0aGlzLndpbmRvd3MgPSB0aGlzLndpbmRvd3N8fFtdO1xyXG5cdFx0XHRcdHRoaXMud2luZG93cy5wdXNoKHdpbik7XHJcblx0XHRcdH0sXHJcblx0XHRcdHdpbmRvd19yZW1vdmVkOmZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0dGhpcy5tYWluX3dpbmRvdyA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHR0aGlzLndpbmRvd3MgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRcclxuXHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gY29udmVydF9hZ21faW5zdGFuY2UoYWdtKXtcclxuXHRyZXR1cm4ge1xyXG5cdFx0bWFjaGluZTphZ20ubWFjaGluZU5hbWUsXHJcblx0XHR1c2VyOmFnbS51c2VyTmFtZSxcclxuXHRcdGVudmlyb25tZW50OmFnbS5lbnZpcm9ubWVudCxcclxuXHRcdGFwcGxpY2F0aW9uOmFnbS5hcHBsaWNhdGlvbk5hbWVcclxuXHJcblx0fTtcclxufVxyXG4iLCIvKipcclxuICogQG1vZHVsZSBhcHBjb25maWdcclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnLi91dGlsJyk7XHJcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwnKTtcclxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcclxuXHJcbnZhciBldmVudHMgPSB7XHJcbiAgY29ubmVjdDogJ2Nvbm5lY3QnLFxyXG4gIGRpc2Nvbm5lY3Q6ICdkaXNjb25uZWN0JyxcclxuICB1cGRhdGU6ICd1cGRhdGUnLFxyXG4gIHN0YXR1czogJ3N0YXR1cydcclxufTtcclxuXHJcbnZhciBFdmVudEJ1cyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc3Vic2NyaXB0aW9uc0J5VHlwZTtcclxuICB2YXIgb24gPSBmdW5jdGlvbiAodHlwZSwgb25jZSwgY2FsbGJhY2ssIHNjb3BlKSB7XHJcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdWJzY3JpcHRpb24gPSB7XHJcbiAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgIG9uY2U6IG9uY2UsXHJcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcclxuICAgICAgc2NvcGU6IHNjb3BlXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9uc0J5VHlwZVt0eXBlXTtcclxuICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbdHlwZV0gPSBbXTtcclxuICAgIH1cclxuICAgIHN1YnNjcmlwdGlvbi5pZCA9IHN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pIC0gMTtcclxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XHJcbiAgfTtcclxuXHJcbiAgdmFyIGVtaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgIHZhciB0eXBlID0gYXJncy5zcGxpY2UoMCwgMSlbMF07XHJcbiAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbdHlwZV07XHJcbiAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zQnlUeXBlW3R5cGVdID0gW107XHJcbiAgICB9XHJcbiAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xyXG4gICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2suYXBwbHkoc3Vic2NyaXB0aW9uLnNjb3BlLCBhcmdzKTtcclxuICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgIF8ud2FybignRXhjZXB0aW9uIGR1cmluZyBleGVjdXRpb24gb2YgY2FsbGJhY2snLCBzdWJzY3JpcHRpb24sIGFyZ3MsIHgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdWJzY3JpcHRpb24ub25jZSkge1xyXG4gICAgICAgIG9mZihzdWJzY3JpcHRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG4gIHZhciBvZmYgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XHJcbiAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbc3Vic2NyaXB0aW9uLnR5cGVdO1xyXG4gICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBkZWxldGUgc3Vic2NyaXB0aW9uc1tzdWJzY3JpcHRpb24uaWRdO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciByZXN1bWUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XHJcbiAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbi5pZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIG9uKHN1YnNjcmlwdGlvbi50eXBlLCBzdWJzY3JpcHRpb24ub25jZSwgc3Vic2NyaXB0aW9uLmNhbGxiYWNrLCBzdWJzY3JpcHRpb24uc2NvcGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zQnlUeXBlW3N1YnNjcmlwdGlvbi50eXBlXTtcclxuICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb25zID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zQnlUeXBlW3N1YnNjcmlwdGlvbi50eXBlXSA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHN1YnNjcmlwdGlvbnNbc3Vic2NyaXB0aW9uLmlkXSA9IHN1YnNjcmlwdGlvbjtcclxuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgcmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnNCeVR5cGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKHN1YnNjcmlwdGlvbnNCeVR5cGUpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbdHlwZV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgZGVsZXRlIHN1YnNjcmlwdGlvbi5pZDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdWJzY3JpcHRpb25zQnlUeXBlID0ge307XHJcbiAgfTtcclxuICByZXNldCgpO1xyXG4gIHJldHVybiB7XHJcbiAgICBvbjogb24sXHJcbiAgICBlbWl0OiBlbWl0LFxyXG4gICAgb2ZmOiBvZmYsXHJcbiAgICByZXN1bWU6IHJlc3VtZSxcclxuICAgIHJlc2V0OiByZXNldFxyXG5cclxuICB9O1xyXG59O1xyXG5cclxudmFyIEFwcENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgdmFyIGRlZmF1bHRMaXN0ZW4gID0gdHJ1ZTtcclxuICB2YXIgZ2F0ZXdheTtcclxuICB2YXIgaW5pdEdhdGV3YXk7XHJcbiAgdmFyIGJ1cyA9IG5ldyBFdmVudEJ1cygpO1xyXG4gIHZhciBtb2RlbCA9IG5ldyBNb2RlbChidXMpO1xyXG5cclxuICB2YXIgcm9vdCA9IHJlcXVpcmUoJy4vcHJvcHMnKShtb2RlbC5yb290KTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIHZhciBnYXRld2F5Q29ubmVjdGlvbjtcclxuICB2YXIgcG9sbGluZ0ludGVydmFsSWQ7XHJcbiAgdmFyIGNsZWFyUG9sbGluZ0ludGVydmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBwb2xsaW5nSW50ZXJ2YWxJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbChwb2xsaW5nSW50ZXJ2YWxJZCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gUHVibGljIEFQSVxyXG4gIHNlbGYuaW5pdCA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuICAgIHZhciBpc0lkZW50aXR5VmFsaWQgPSB0eXBlb2Ygc2V0dGluZ3MuaWRlbnRpdHkgPT09ICdvYmplY3QnICYmXHJcbiAgICAgIE9iamVjdC5rZXlzKHNldHRpbmdzLmlkZW50aXR5KS5sZW5ndGggPiAwO1xyXG5cclxuICAgIGlmIChpc0lkZW50aXR5VmFsaWQpIHtcclxuICAgICAgc2VsZi5pZGVudGl0eSA9IHNldHRpbmdzLmlkZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZGVmYXVsdExpc3RlbiA9IHNldHRpbmdzLmRlZmF1bHRMaXN0ZW4gfHwgZGVmYXVsdExpc3RlbjtcclxuICAgIGlmICghc2VsZi5pZGVudGl0eSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZGVudGl0eSBtdXN0IGJlIG5vbiBlbXB0eSBvYmplY3QuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbW9kZWwuc2VwYXJhdG9yID0gc2V0dGluZ3MuZGVmYXVsdFNlcGFyYXRvciB8fCBtb2RlbC5zZXBhcmF0b3I7XHJcblxyXG4gICAgc2VsZi5zY2hlbWEgPSBzZXR0aW5ncy5zY2hlbWEgfHwgc2VsZi5zY2hlbWEgfHwgJ0FwcGxpY2F0aW9uQ29uZmlndXJhdGlvbic7XHJcblxyXG4gICAgaW5pdEdhdGV3YXkgPSBfLmlzRnVuY3Rpb24oc2V0dGluZ3MuZ2F0ZXdheSkgP1xyXG4gICAgICBzZXR0aW5ncy5nYXRld2F5IDpcclxuICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZ2F0ZXdheSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHNldHRpbmdzLmdhdGV3YXkgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5nYXRld2F5Lmluc3RhbmNlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgc2V0dGluZ3MuZ2F0ZXdheS5pbnN0YW5jZSA9IF8udXVpZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi9nYXRld2F5Jykoc2V0dGluZ3MuZ2F0ZXdheSk7XHJcbiAgICAgIH07XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5jb25uZWN0ID0gZnVuY3Rpb24gKGxpc3RlbiwgY2FsbGJhY2ssIHNjb3BlKSB7XHJcbiAgICBjbGVhclBvbGxpbmdJbnRlcnZhbCgpO1xyXG4gICAgdmFyIHN1YnNjcmlwdGlvbjtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGxpc3RlbikpIHtcclxuICAgICAgICBjYWxsYmFjayA9IGxpc3RlbjtcclxuICAgICAgICBzY29wZSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGxpc3RlbiA9IGRlZmF1bHRMaXN0ZW47XHJcbiAgICAgIH1cclxuICAgICAgc3Vic2NyaXB0aW9uID0gYnVzLm9uKGV2ZW50cy5jb25uZWN0LCB0cnVlLCBjYWxsYmFjaywgc2NvcGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlcnJvcjtcclxuICAgIGlmICghc2VsZi5pZGVudGl0eSkge1xyXG4gICAgICBlcnJvciA9ICdpZGVudGl0eSBpcyBub3Qgc3BlY2lmaWVkLiBkaWQgeW91IGZvcmdldCB0byBjYWxsIGluaXQoKT8nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCFnYXRld2F5KSB7XHJcbiAgICAgICAgZ2F0ZXdheSA9IGluaXRHYXRld2F5KCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFsaXN0ZW4pIHtcclxuICAgICAgICBnYXRld2F5Q29ubmVjdGlvbiA9XHJcbiAgICAgICAgICBnYXRld2F5LmNvbm5lY3QoXHJcbiAgICAgICAgICAgIHNlbGYuc2NoZW1hLFxyXG4gICAgICAgICAgICBzZWxmLmlkZW50aXR5LFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yLCBzbmFwc2hvdCwgdXBkYXRlcykge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBtb2RlbC5hcHBseVNuYXBzaG90KHNuYXBzaG90KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnVzLmVtaXQoZXZlbnRzLmNvbm5lY3QsIGVycm9yKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yLCBzdGF0dXMpIHtcclxuICAgICAgICAgICAgICBidXMuZW1pdChldmVudHMuc3RhdHVzLCBlcnJvciwgc3RhdHVzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RFbWl0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgZ2F0ZXdheUNvbm5lY3Rpb24gPSBnYXRld2F5LmNvbm5lY3QoXHJcbiAgICAgICAgICBzZWxmLnNjaGVtYSxcclxuICAgICAgICAgIHNlbGYuaWRlbnRpdHksXHJcbiAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgZnVuY3Rpb24gKGVycm9yLCBzbmFwc2hvdCwgdXBkYXRlcykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNuYXBzaG90ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgIG1vZGVsLmFwcGx5U25hcHNob3Qoc25hcHNob3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXBkYXRlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICBtb2RlbC5hcHBseVVwZGF0ZXModXBkYXRlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjb25uZWN0RW1pdHRlZCkge1xyXG4gICAgICAgICAgICAgIGNvbm5lY3RFbWl0dGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBidXMuZW1pdChldmVudHMuY29ubmVjdCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZnVuY3Rpb24gKGVycm9yLCBzdGF0dXMpIHtcclxuICAgICAgICAgICAgdmFyIExJU1RFTl9OT1RfU1VQUE9SVEVEID0gODtcclxuICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBMSVNURU5fTk9UX1NVUFBPUlRFRCkge1xyXG4gICAgICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZ2F0ZXdheS5kaXNjb25uZWN0KGdhdGV3YXlDb25uZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdhdGV3YXlDb25uZWN0aW9uID0gZ2F0ZXdheS5jb25uZWN0KHNlbGYuc2NoZW1hLCBzZWxmLmlkZW50aXR5LCBmYWxzZSwgZnVuY3Rpb24gKGVycm9yLCBzbmFwc2hvdCkge1xyXG4gICAgICAgICAgICAgICAgICBtb2RlbC5hcHBseVNuYXBzaG90KHNuYXBzaG90LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9LCAyMDAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgc2V0VGltZW91dChidXMuZW1pdCwgMCwgZXZlbnRzLmNvbm5lY3QsIGVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xyXG5cclxuICB9O1xyXG5cclxuICBzZWxmLnByb3BzID0gZnVuY3Rpb24gKHNlY3Rpb24sIHNlcGFyYXRvcikge1xyXG4gICAgcmV0dXJuIHJvb3QucHJvcHMoc2VjdGlvbiwgc2VwYXJhdG9yKTtcclxuICB9O1xyXG5cclxuICBzZWxmLm1vZGlmeSA9IGZ1bmN0aW9uIChtb2RpZmljYXRpb25zLCBjYWxsYmFjaywgc2NvcGUpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kaWZpY2F0aW9ucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgbW9kaWZpY2F0aW9ucyA9IFttb2RpZmljYXRpb25zXTtcclxuICAgIH1cclxuICAgIHZhciBzdWJzY3JpcHRpb24gPSBidXMub24oZXZlbnRzLnVwZGF0ZSwgdHJ1ZSwgY2FsbGJhY2ssIHNjb3BlKTtcclxuXHJcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xyXG4gIH07XHJcblxyXG4gIHNlbGYub25Db25uZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xyXG4gICAgcmV0dXJuIGJ1cy5vbihldmVudHMuY29ubmVjdCwgZmFsc2UsIGNhbGxiYWNrLCBzY29wZSk7XHJcblxyXG4gIH07XHJcblxyXG4gIHNlbGYub25EaXNjb25uZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xyXG4gICAgcmV0dXJuIGJ1cy5vbihldmVudHMuZGlzY29ubmVjdCwgZmFsc2UsIGNhbGxiYWNrLCBzY29wZSk7XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5vZmYgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XHJcbiAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgIGJ1cy5vZmYoc3Vic2NyaXB0aW9uKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBzZWxmLm9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xyXG4gICAgaWYgKHN1YnNjcmlwdGlvbikge1xyXG4gICAgICBidXMucmVzdW1lKHN1YnNjcmlwdGlvbik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xyXG4gICAgaWYgKF8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgYnVzLm9uKGV2ZW50cy5kaXNjb25uZWN0LCB0cnVlLCBjYWxsYmFjaywgc2NvcGUpO1xyXG4gICAgfVxyXG4gICAgY2xlYXJQb2xsaW5nSW50ZXJ2YWwoKTtcclxuICAgIGlmICh0eXBlb2YgZ2F0ZXdheSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgZ2F0ZXdheS5kaXNjb25uZWN0KGdhdGV3YXlDb25uZWN0aW9uLCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICBidXMuZW1pdChldmVudHMuZGlzY29ubmVjdCwgZXJyb3IpO1xyXG4gICAgICB9KTtcclxuICAgICAgZ2F0ZXdheSA9IHVuZGVmaW5lZDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJ1cy5lbWl0KGV2ZW50cy5kaXNjb25uZWN0LCAnbm90IGNvbm5lY3RlZCcpO1xyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcblxyXG5BcHBDb25maWcucHJvdG90eXBlLmlkZW50aXR5RXF1YWwgPSBoZWxwZXJzLmlkZW50aXR5RXF1YWw7XHJcbkFwcENvbmZpZy5wcm90b3R5cGUuaWRlbnRpdHlUb1N0cmluZyA9IGhlbHBlcnMuaWRlbnRpdHlUb1N0cmluZztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBuZXcgQXBwQ29uZmlnKCk7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBnYXRld2F5Q29ubmVjdGlvbiA9IHJlcXVpcmUoJ3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24nKTtcclxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcclxudmFyIGlkZW50aXR5VG9TdHJpbmcgPSBoZWxwZXJzLmlkZW50aXR5VG9TdHJpbmc7XHJcbnZhciBQUk9EVUNUID0gJ2FwcGNvbmZpZyc7XHJcblxyXG52YXIgR2F0ZXdheVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgdmFyIGNvbm5lY3Rpb247XHJcbiAgdmFyIGRhdGFIYW5kbGVycyA9IHt9O1xyXG4gIHZhciBzdGF0dXNIYW5kbGVycyA9IHt9O1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBmdW5jdGlvbiBoYW5kbGVTdGF0dXNNZXNzYWdlKG1zZykge1xyXG4gICAgdmFyIGhhbmRsZXIgPSBzdGF0dXNIYW5kbGVyc1ttc2cuaW5zdGFuY2VdO1xyXG4gICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgaGFuZGxlcihtc2cuZXJyb3IsIG1zZy5zdGF0dXMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBoYW5kbGVEYXRhTWVzc2FnZShtc2cpIHtcclxuICAgIHZhciBzY2hlbWEgPSBtc2cuc2NoZW1hO1xyXG4gICAgdmFyIHNjaGVtYUhhbmRsZXJzID0gZGF0YUhhbmRsZXJzW3NjaGVtYV07XHJcbiAgICBpZiAodHlwZW9mIHNjaGVtYUhhbmRsZXJzID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgaWRlbnRpdHlLZXkgPSBpZGVudGl0eVRvU3RyaW5nKG1zZy5pZGVudGl0eSwgdHJ1ZSk7XHJcbiAgICB2YXIgaWRlbnRpdHlIYW5kbGVycyA9IHNjaGVtYUhhbmRsZXJzW2lkZW50aXR5S2V5XTtcclxuICAgIGlmICh0eXBlb2YgaWRlbnRpdHlIYW5kbGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWRlbnRpdHlIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgICAgaGFuZGxlcihtc2cuZXJyb3IsIG1zZy5zbmFwc2hvdCwgbXNnLnVwZGF0ZXMpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZW5zdXJlQ29ubmVjdGlvbigpIHtcclxuICAgIGlmICh0eXBlb2YoY29ubmVjdGlvbikgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25uZWN0aW9uICE9PSAndW5kZWZpbmVkJylcclxuICAgICAge1xyXG4gICAgICAgIGNvbm5lY3Rpb24gPSBvcHRpb25zLmNvbm5lY3Rpb247XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY29ubmVjdGlvbiA9IGdhdGV3YXlDb25uZWN0aW9uKG9wdGlvbnMuc2V0dGluZ3MsIG9wdGlvbnMuY3VzdG9tX2Nvbm5lY3Rpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBkYXRhU3Vic2NyaXB0aW9uO1xyXG4gIHZhciBzdGF0dXNTdWJzY3JpcHRpb247XHJcbiAgdmFyIGNvbm5lY3QgPSBmdW5jdGlvbiAoc2NoZW1hLCBpZGVudGl0eSwgbGlzdGVuLCBoYW5kbGVyLCBzdGF0dXNIYW5kbGVyKSB7XHJcbiAgICBlbnN1cmVDb25uZWN0aW9uKCk7XHJcbiAgICB2YXIgc2NoZW1hSGFuZGxlcnMgPSBkYXRhSGFuZGxlcnNbc2NoZW1hXTtcclxuICAgIGlmICh0eXBlb2Ygc2NoZW1hSGFuZGxlcnMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHNjaGVtYUhhbmRsZXJzID0gZGF0YUhhbmRsZXJzW3NjaGVtYV0gPSB7fTtcclxuICAgIH1cclxuICAgIHZhciBpZGVudGl0eUtleSA9IGlkZW50aXR5VG9TdHJpbmcoaWRlbnRpdHksIHRydWUpO1xyXG4gICAgdmFyIGlkZW50aXR5SGFuZGxlcnMgPSBzY2hlbWFIYW5kbGVyc1tpZGVudGl0eUtleV07XHJcbiAgICBpZiAodHlwZW9mIGlkZW50aXR5SGFuZGxlcnMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGlkZW50aXR5SGFuZGxlcnMgPSBzY2hlbWFIYW5kbGVyc1tpZGVudGl0eUtleV0gPSBbXTtcclxuICAgIH1cclxuICAgIHZhciBoYW5kbGVyVG9SZWdpc3RlcjtcclxuICAgIHZhciBpbmRleDtcclxuICAgIGlmIChsaXN0ZW4pIHtcclxuICAgICAgaGFuZGxlclRvUmVnaXN0ZXIgPSBoYW5kbGVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGFuZGxlclRvUmVnaXN0ZXIgPSBmdW5jdGlvbiAoZXJyb3IsIHNuYXBzaG90LCB1cGRhdGVzKSB7XHJcbiAgICAgICAgaGFuZGxlcihlcnJvciwgc25hcHNob3QsIHVwZGF0ZXMpO1xyXG4gICAgICAgIGRlbGV0ZSBpZGVudGl0eUhhbmRsZXJzW2luZGV4XTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpbmRleCA9IGlkZW50aXR5SGFuZGxlcnMucHVzaChoYW5kbGVyVG9SZWdpc3RlcikgLSAxO1xyXG5cclxuICAgIGlmICh0eXBlb2YgKGRhdGFTdWJzY3JpcHRpb24pID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBkYXRhU3Vic2NyaXB0aW9uID0gY29ubmVjdGlvbi5vbihQUk9EVUNULCBHYXRld2F5VHJhbnNwb3J0Lk1lc3NhZ2VUeXBlLkRBVEEsIGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICBoYW5kbGVEYXRhTWVzc2FnZShtc2cpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHZhciBpbnN0YW5jZSA9IG9wdGlvbnMuaW5zdGFuY2U7XHJcbiAgICBzdGF0dXNIYW5kbGVyc1tpbnN0YW5jZV0gPSBzdGF0dXNIYW5kbGVyO1xyXG4gICAgaWYgKHR5cGVvZiAoc3RhdHVzU3Vic2NyaXB0aW9uKSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgc3RhdHVzU3Vic2NyaXB0aW9uID0gY29ubmVjdGlvbi5vbihQUk9EVUNULCBHYXRld2F5VHJhbnNwb3J0Lk1lc3NhZ2VUeXBlLlNUQVRVUywgZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgIGhhbmRsZVN0YXR1c01lc3NhZ2UobXNnKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1zZyA9IHtcclxuICAgICAgc2NoZW1hOiBzY2hlbWEsXHJcbiAgICAgIGlkZW50aXR5OiBpZGVudGl0eSxcclxuICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxyXG4gICAgICBsaXN0ZW46IGxpc3RlblxyXG4gICAgfTtcclxuICAgIGNvbm5lY3Rpb24uc2VuZChQUk9EVUNULCBHYXRld2F5VHJhbnNwb3J0Lk1lc3NhZ2VUeXBlLkNPTk5FQ1QsIG1zZyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzY2hlbWE6IHNjaGVtYSxcclxuICAgICAgaWRlbnRpdHk6IGlkZW50aXR5LFxyXG4gICAgICBsaXN0ZW46IGxpc3RlbixcclxuICAgICAgaGFuZGxlcjogaGFuZGxlcixcclxuICAgICAgaW5kZXggOiBpbmRleFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICB2YXIgbW9kaWZ5ID0gZnVuY3Rpb24gKHNjaGVtYSwgaWRlbnRpdHksIG1vZGlmaWNhdGlvbnMpIHtcclxuICAgIGVuc3VyZUNvbm5lY3Rpb24oKTtcclxuICAgIGNvbm5lY3Rpb24uc2VuZChQUk9EVUNULCBHYXRld2F5VHJhbnNwb3J0Lk1lc3NhZ2VUeXBlLk1PRElGWSwgbW9kaWZpY2F0aW9ucyk7XHJcbiAgfTtcclxuICB2YXIgZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChkZXNjcmlwdG9yKSB7XHJcbiAgICB2YXIgc2NoZW1hSGFuZGxlcnMgPSBkYXRhSGFuZGxlcnNbZGVzY3JpcHRvci5zY2hlbWFdO1xyXG4gICAgaWYgKHR5cGVvZiBzY2hlbWFIYW5kbGVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdmFyIGlkZW50aXR5S2V5ID0gaWRlbnRpdHlUb1N0cmluZyhkZXNjcmlwdG9yLmlkZW50aXR5LCB0cnVlKTtcclxuICAgICAgdmFyIGlkZW50aXR5SGFuZGxlcnMgPSBzY2hlbWFIYW5kbGVyc1tpZGVudGl0eUtleV07XHJcbiAgICAgIGlmICh0eXBlb2YgaWRlbnRpdHlIYW5kbGVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB2YXIgaGFuZGxlciA9IGlkZW50aXR5SGFuZGxlcnNbZGVzY3JpcHRvci5pbmRleF07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgdmFyIG1zZyA9IHtcclxuICAgICAgICAgICAgc2NoZW1hOiBkZXNjcmlwdG9yLnNjaGVtYSxcclxuICAgICAgICAgICAgaWRlbnRpdHk6IGRlc2NyaXB0b3IuaWRlbnRpdHksXHJcbiAgICAgICAgICAgIGluc3RhbmNlOiBvcHRpb25zLmluc3RhbmNlXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgY29ubmVjdGlvbi5zZW5kKEdhdGV3YXlUcmFuc3BvcnQuTWVzc2FnZVR5cGUuRElTQ09OTkVDVCwgbXNnKTtcclxuICAgICAgICAgIGRlbGV0ZSBpZGVudGl0eUhhbmRsZXJzW2Rlc2NyaXB0b3IuaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaWRlbnRpdHlIYW5kbGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGRlbGV0ZSBzY2hlbWFIYW5kbGVyc1tpZGVudGl0eUtleV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWFIYW5kbGVycykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgZGVsZXRlIGRhdGFIYW5kbGVyc1tkZXNjcmlwdG9yLnNjaGVtYV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChPYmplY3Qua2V5cyhkYXRhSGFuZGxlcnMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBpZiAodHlwZW9mIChkYXRhU3Vic2NyaXB0aW9uKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBjb25uZWN0aW9uLm9mZihkYXRhU3Vic2NyaXB0aW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVsZXRlIHN0YXR1c0hhbmRsZXJzW2Rlc2NyaXB0b3IuaW5zdGFuY2VdO1xyXG4gICAgaWYgKE9iamVjdC5rZXlzKHN0YXR1c0hhbmRsZXJzKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgaWYgKHR5cGVvZiBzdGF0dXNTdWJzY3JpcHRpb24gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29ubmVjdGlvbi5vZmYoc3RhdHVzU3Vic2NyaXB0aW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIGNvbm5lY3Q6IGNvbm5lY3QsXHJcbiAgICBtb2RpZnk6IG1vZGlmeSxcclxuICAgIGRpc2Nvbm5lY3Q6IGRpc2Nvbm5lY3RcclxuICB9O1xyXG59O1xyXG5cclxuR2F0ZXdheVRyYW5zcG9ydC5NZXNzYWdlVHlwZSA9IHtcclxuICAvLyB7IHNjaGVtYTogJ0FwcGxpY2F0aW9uQ29uZmlndXJhdGlvbicsIGlkZW50aXR5OiB7fSwgbGlzdGVuOiB0cnVlLCBpbnN0YW5jZTogJycgfVxyXG4gIENPTk5FQ1Q6ICdjb25uZWN0JyxcclxuICAvLyB7IHNjaGVtYTogJ0FwcGxpY2F0aW9uQ29uZmlndXJhdGlvbicsIGlkZW50aXR5OiB7fSwgaW5zdGFuY2U6ICcnIH1cclxuICBESVNDT05ORUNUOiAnZGlzY29ubmVjdCcsXHJcbiAgLy8geyBzY2hlbWE6ICdBcHBsaWNhdGlvbkNvbmZpZ3VyYXRpb24nLCBpZGVudGl0eToge30sIHVwZGF0ZXM6IFtdLCBpbnN0YW5jZTogJycgfVxyXG4gIE1PRElGWTogJ21vZGlmeScsXHJcbiAgLy8geyBzY2hlbWE6ICdBcHBsaWNhdGlvbkNvbmZpZ3VyYXRpb24nLCBpZGVudGl0eToge30sIGVycm9yOiAnJywgc25hcHNob3Q6IHtkZWZhdWx0S2V5VmFsdWU6ICcnLCBrZXlzOiBbXSwgcHJvcHM6IHt9fSwgdXBkYXRlczogW10gfVxyXG4gIERBVEE6ICdkYXRhJyxcclxuICAvLyB7IHNjaGVtYTogJ0FwcGxpY2F0aW9uQ29uZmlndXJhdGlvbicsIGlkZW50aXR5OiB7fSwgaW5zdGFuY2U6ICcnLCBzdGF0dXM6ICcnLCBlcnJvcjogJycgfVxyXG4gIFNUQVRVUzogJ3N0YXR1cydcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2F0ZXdheVRyYW5zcG9ydDtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gZXNjYXBlSWRlbnRpdHlUZXh0KHRleHQpIHtcclxuICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bXFxcXF0vZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvWzpdL2csICdcXFxcOicpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdGV4dDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlkZW50aXR5VG9TdHJpbmcoaWRlbnRpdHksIGluY2x1ZGVLZXlzLCBzZXBhcmF0b3IsIG9yZGVyKSB7XHJcbiAgaWYgKHR5cGVvZihpZGVudGl0eSkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8ICcvJztcclxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGlkZW50aXR5KTtcclxuICBpZiAodHlwZW9mKG9yZGVyKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAga2V5cy5zb3J0KG9yZGVyKTtcclxuICB9IGVsc2Uge1xyXG4gICAga2V5cy5zb3J0KCk7XHJcbiAgfVxyXG4gIHJldHVybiBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICByZXR1cm4gaW5jbHVkZUtleXMgPyAoZXNjYXBlSWRlbnRpdHlUZXh0KGtleSkgKyAnOicgKyBlc2NhcGVJZGVudGl0eVRleHQoaWRlbnRpdHlba2V5XSkpIDogaWRlbnRpdHlba2V5XTtcclxuICB9KS5qb2luKHNlcGFyYXRvcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlkZW50aXR5RXF1YWwoaWRlbnRpdHkxLCBpZGVudGl0eTIpIHtcclxuICByZXR1cm4gaWRlbnRpdHlUb1N0cmluZyhpZGVudGl0eTEsIHRydWUpID09PSBpZGVudGl0eVRvU3RyaW5nKGlkZW50aXR5MiwgdHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZsYXR0ZW4ocHJvcHMsIHNlcGFyYXRvciwgbmFtZSkge1xyXG4gIHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCAnLic7XHJcbiAgdmFyIHByZWZpeCA9IG5hbWUgPyBuYW1lICsgc2VwYXJhdG9yIDogJyc7XHJcbiAgdmFyIHZhbCA9IHt9O1xyXG4gIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIGlmIChrZXkuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBwYXRoID0ga2V5LnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKTtcclxuICAgIHZhciB0YXJnZXQgPSB2YWw7XHJcbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KHNlcGFyYXRvcik7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgaWYgKCF0YXJnZXRbcGFydHNbaV1dKSB7XHJcbiAgICAgICAgdGFyZ2V0W3BhcnRzW2ldXSA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIHRhcmdldCA9IHRhcmdldFtwYXJ0c1tpXV07XHJcbiAgICB9XHJcbiAgICB0YXJnZXRbcGFydHNbaV1dID0gcHJvcHNba2V5XS52YWx1ZTtcclxuICB9KTtcclxuICByZXR1cm4gdmFsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9wRXF1YWwobGhzLCByaHMpIHtcclxuICBpZiAobGhzLnZhbHVlICE9PSByaHMudmFsdWUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaHMudW5kZXJseWluZy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGxoc1VuZGVybHlpbmcgPSBsaHMudW5kZXJseWluZ1tpXTtcclxuICAgIHZhciByaHNVbmRlcmx5aW5nID0gcmhzLnVuZGVybHlpbmdbaV0gfHwge307XHJcbiAgICBpZiAobGhzVW5kZXJseWluZy52YWx1ZSAhPT0gcmhzVW5kZXJseWluZy52YWx1ZSB8fCAhaWRlbnRpdHlFcXVhbChsaHNVbmRlcmx5aW5nLnBhcmVudCwgcmhzVW5kZXJseWluZy5wYXJlbnQpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGZsYXR0ZW46IGZsYXR0ZW4sXHJcbiAgcHJvcEVxdWFsOiBwcm9wRXF1YWwsXHJcbiAgaWRlbnRpdHlUb1N0cmluZzogaWRlbnRpdHlUb1N0cmluZyxcclxuICBpZGVudGl0eUVxdWFsOiBpZGVudGl0eUVxdWFsXHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBwcm9wRXF1YWwgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wcm9wRXF1YWw7XHJcblxyXG52YXIgVXBkYXRlVHlwZSA9IHtcclxuICBBZGRlZDogJ0FkZGVkJyxcclxuICBDaGFuZ2VkOiAnQ2hhbmdlZCcsXHJcbiAgUmVtb3ZlZDogJ1JlbW92ZWQnXHJcbn07XHJcblxyXG52YXIgTW9kZWwgPSBmdW5jdGlvbiAoYnVzLCBzZXBhcmF0b3IpIHtcclxuICB0aGlzLmJ1cyA9IGJ1cztcclxuICB0aGlzLnJvb3QgPSBuZXcgVmlld01vZGVsKHRoaXMsICcnLCBzZXBhcmF0b3IgfHwgJy4nKTtcclxuICB0aGlzLnZpZXdzID0ge307XHJcbn07XHJcblxyXG52YXIgVmlld01vZGVsID0gZnVuY3Rpb24gKG1vZGVsLCBwYXRoLCBzZXBhcmF0b3IpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgc2VsZi5tb2RlbCA9IG1vZGVsO1xyXG4gIHNlbGYucHJvcHMgPSB7fTtcclxuICBzZWxmLnNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCBtb2RlbC5zZXBhcmF0b3I7XHJcbiAgc2VsZi5wYXRoID0gcGF0aDtcclxufTtcclxuXHJcblZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0Vmlld01vZGVsID0gZnVuY3Rpb24gKG5hbWUsIHNlcGFyYXRvcikge1xyXG4gIHZhciBwYXRoID0gdGhpcy5wYXRoICsgbmFtZSArIChzZXBhcmF0b3IgPyBzZXBhcmF0b3IgOiAnLicpO1xyXG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XHJcbiAgaWYgKHBhdGggPT09ICcnKSB7XHJcbiAgICByZXR1cm4gbW9kZWwucm9vdDtcclxuICB9XHJcbiAgaWYgKCFtb2RlbC52aWV3c1twYXRoXSkge1xyXG4gICAgdmFyIGJlc3RQYXJlbnQgPSAnJztcclxuICAgIC8vIGZpbGwgc3VidmlldyByZWZlcmVuY2VzIGFuZCBjaG9vc2UgYmVzdCBwYXJlbnQgcHJvcHMgdG8gY29weSBmcm9tLlxyXG4gICAgT2JqZWN0LmtleXMobW9kZWwudmlld3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICBpZiAocGF0aC5pbmRleE9mKGtleSkgPT09IDApIHtcclxuICAgICAgICBpZiAoYmVzdFBhcmVudC5sZW5ndGggPCBrZXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICBiZXN0UGFyZW50ID0ga2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBrZWVwIHN1YnZpZXdzIHNvcnRlZC5cclxuICAgICAgICB2YXIgc3Vidmlld3MgPSBtb2RlbC52aWV3c1trZXldLnN1YnZpZXdzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vidmlld3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChzdWJ2aWV3c1tpXS5pbmRleE9mKHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHN1YnZpZXdzLnNwbGljZShpLCAwLCBwYXRoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdWJ2aWV3cy5wdXNoKHBhdGgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciB2aWV3TW9kZWwgPSBuZXcgVmlld01vZGVsKG1vZGVsLCBwYXRoLCBzZXBhcmF0b3IpO1xyXG5cclxuICAgIHZhciBwYXJlbnRQcm9wcyA9IGJlc3RQYXJlbnQgPT09ICcnID8gbW9kZWwucm9vdC5wcm9wcyA6IG1vZGVsLnZpZXdzW2Jlc3RQYXJlbnRdLm1vZGVsLnByb3BzO1xyXG4gICAgT2JqZWN0LmtleXMocGFyZW50UHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICB2YXIgcHJvcCA9IHBhcmVudFByb3BzW2tleV07XHJcbiAgICAgIGlmIChwcm9wLm5hbWUuaW5kZXhPZihwYXRoKSA9PT0gMCkge1xyXG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lLnN1YnN0cmluZyhwYXRoLmxlbmd0aCk7XHJcbiAgICAgICAgdmlld01vZGVsLnByb3BzW25hbWVdID0gcHJvcDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbW9kZWwudmlld3NbcGF0aF0gPSB7XHJcbiAgICAgIHN1YnZpZXdzOiBbXSxcclxuICAgICAgbW9kZWw6IHZpZXdNb2RlbFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIG1vZGVsLnZpZXdzW3BhdGhdLm1vZGVsO1xyXG59O1xyXG5cclxuVmlld01vZGVsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChjYWxsYmFjaywgc2NvcGUpIHtcclxuICByZXR1cm4gdGhpcy5tb2RlbC5vbih0aGlzLnBhdGgsIGNhbGxiYWNrLCBzY29wZSk7XHJcbn07XHJcblxyXG5Nb2RlbC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAocGF0aCwgY2FsbGJhY2ssIHNjb3BlKSB7XHJcbiAgdmFyIHR5cGUgPSB1cGRhdGVUeXBlRm9yUGF0aChwYXRoKTtcclxuICByZXR1cm4gdGhpcy5idXMub24odHlwZSwgZmFsc2UsIGNhbGxiYWNrLCBzY29wZSk7XHJcbn07XHJcblxyXG5Nb2RlbC5wcm90b3R5cGUuYXBwbHlTbmFwc2hvdCA9IGZ1bmN0aW9uIChzbmFwc2hvdCwgaXNTbmFwc2hvdCkge1xyXG4gIGlzU25hcHNob3QgPSB0eXBlb2YgaXNTbmFwc2hvdCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogaXNTbmFwc2hvdDtcclxuXHJcbiAgdmFyIHVwZGF0ZXMgPSB0b1VwZGF0ZXMoaXNTbmFwc2hvdCA/IHt9IDogdGhpcy5yb290LnByb3BzLCBzbmFwc2hvdC5wcm9wcyk7XHJcbiAgYXBwbHlVcGRhdGVzQW5kRW1pdEV2ZW50cyh0aGlzLCB1cGRhdGVzLCBpc1NuYXBzaG90KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVR5cGVGb3JQYXRoKHBhdGgpIHtcclxuICB2YXIgdHlwZSA9ICd1cGRhdGUnO1xyXG4gIGlmIChwYXRoICE9PSAnJykge1xyXG4gICAgdHlwZSA9IHR5cGUgKyAnfCcgKyBwYXRoO1xyXG4gIH1cclxuICByZXR1cm4gdHlwZTtcclxufVxyXG5cclxuLy8gc2hhbGxvdyBjb3B5XHJcbmZ1bmN0aW9uIGNsb25lVXBkYXRlRm9yUGF0aCh1cGRhdGUsIHBhdGgpIHtcclxuICB2YXIgY2xvbmUgPSB7XHJcbiAgICB0eXBlOiB1cGRhdGUudHlwZSxcclxuICAgIG5hbWU6IHVwZGF0ZS5uYW1lLnN1YnN0cmluZyhwYXRoLmxlbmd0aClcclxuICB9O1xyXG5cclxuICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XHJcbiAgICBjYXNlIFVwZGF0ZVR5cGUuQ2hhbmdlZDpcclxuICAgICAgY2xvbmUub2xkVmFsdWUgPSB1cGRhdGUub2xkVmFsdWU7XHJcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgIGNhc2UgVXBkYXRlVHlwZS5BZGRlZDpcclxuICAgICAgY2xvbmUudmFsdWUgPSB1cGRhdGUudmFsdWU7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBVcGRhdGVUeXBlLlJlbW92ZWQ6XHJcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICByZXR1cm4gY2xvbmU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VXBkYXRlc0FuZEVtaXRFdmVudHMobW9kZWwsIHVwZGF0ZXMsIGlzU25hcHNob3QpIHtcclxuICB2YXIgdmlld3MgPSBPYmplY3Qua2V5cyhtb2RlbC52aWV3cyk7XHJcbiAgdmFyIGVmZmVjdGl2ZVVwZGF0ZXMgPSB7XHJcbiAgICAnJzogdXBkYXRlc1xyXG4gIH07XHJcbiAgaWYgKHZpZXdzLmxlbmd0aCA+IDApIHtcclxuICAgIC8vIHNvcnQgdmlld3MgZm9yIHByZWZpeCBzZWFyY2hcclxuICAgIGlmICh2aWV3cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHZpZXdzLnNvcnQoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld3MubGVuZ3RoOyB2aWV3cysrKSB7XHJcbiAgICAgICAgaWYgKHVwZGF0ZS5uYW1lLmluZGV4T2Yodmlld3NbaV0pID09PSAwKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHZpZXcgPSB2aWV3c1tpXTtcclxuICAgICAgaWYgKHR5cGVvZiB2aWV3ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBlZmZlY3RpdmVVcGRhdGVzW3ZpZXddLnB1c2goY2xvbmVVcGRhdGVGb3JQYXRoKHVwZGF0ZSwgdmlldykpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB2YXIgYWZmZWN0ZWRQYXRocyA9IE9iamVjdC5rZXlzKGVmZmVjdGl2ZVVwZGF0ZXMpO1xyXG4gIGlmIChhZmZlY3RlZFBhdGhzLmxlbmd0aCA+IDEpIHtcclxuICAgIGFmZmVjdGVkUGF0aHMuc29ydCgpO1xyXG4gIH1cclxuICBhZmZlY3RlZFBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgIHZhciB2aWV3TW9kZWwgPSBwYXRoID09PSAnJyA/IG1vZGVsLnJvb3QgOiBtb2RlbC52aWV3c1twYXRoXS5tb2RlbDtcclxuICAgIGlmIChpc1NuYXBzaG90KSB7XHJcbiAgICAgIHZpZXdNb2RlbC5wcm9wcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgZWZmZWN0aXZlVXBkYXRlc1twYXRoXS5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcclxuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgVXBkYXRlVHlwZS5BZGRlZDpcclxuICAgICAgICAgIC8vIGZhbGwtdGhyb3VnaFxyXG4gICAgICAgIGNhc2UgVXBkYXRlVHlwZS5DaGFuZ2VkOlxyXG4gICAgICAgICAgLy8gY2hhbmdlZCB3b3JrcyBldmVuIGZvciBtaXNzaW5nIHByb3BlcnRpZXNcclxuICAgICAgICAgIHZpZXdNb2RlbC5wcm9wc1t1cGRhdGUubmFtZV0gPSB1cGRhdGUudmFsdWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFVwZGF0ZVR5cGUuUmVtb3ZlZDpcclxuICAgICAgICAgIGRlbGV0ZSB2aWV3TW9kZWwucHJvcHNbdXBkYXRlLm5hbWVdO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxuICBhZmZlY3RlZFBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgIHZhciB0eXBlID0gdXBkYXRlVHlwZUZvclBhdGgocGF0aCk7XHJcbiAgICBtb2RlbC5idXMuZW1pdCh0eXBlLCBpc1NuYXBzaG90LCB1cGRhdGVzKTtcclxuICB9KTtcclxufVxyXG5Nb2RlbC5wcm90b3R5cGUuYXBwbHlVcGRhdGVzID0gZnVuY3Rpb24gKHVwZGF0ZXMpIHtcclxuICBhcHBseVVwZGF0ZXNBbmRFbWl0RXZlbnRzKHRoaXMsIHVwZGF0ZXMsIGZhbHNlKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRvVXBkYXRlcyhpbWFnZSwgc25hcHNob3QpIHtcclxuICBzbmFwc2hvdCA9IHNuYXBzaG90IHx8IHt9O1xyXG4gIHZhciB1cGRhdGVzID0gW107XHJcbiAgdmFyIHRvRGVsZXRlID0gT2JqZWN0LmtleXMoaW1hZ2UpO1xyXG4gIE9iamVjdC5rZXlzKHNuYXBzaG90KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHZhciB1cGRhdGUgPSB7fTtcclxuICAgIGlmICh0eXBlb2YgaW1hZ2Vba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdXBkYXRlLnR5cGUgPSBVcGRhdGVUeXBlLkFkZGVkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCFwcm9wRXF1YWwoaW1hZ2Vba2V5XSwgc25hcHNob3Rba2V5XSkpIHtcclxuICAgICAgICB1cGRhdGUudHlwZSA9IFVwZGF0ZVR5cGUuQ2hhbmdlZDtcclxuICAgICAgICB1cGRhdGUub2xkVmFsdWUgPSBpbWFnZVtrZXldO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9EZWxldGUubGVuZ3RoOyB0b0RlbGV0ZSsrKSB7XHJcbiAgICAgICAgaWYgKHRvRGVsZXRlW2ldID09PSBrZXkpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIHRvRGVsZXRlW2ldICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRvRGVsZXRlLnNwbGljZShpLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHVwZGF0ZS50eXBlKSB7XHJcbiAgICAgIHVwZGF0ZS52YWx1ZSA9IHNuYXBzaG90W2tleV07XHJcbiAgICAgIHVwZGF0ZS5uYW1lID0ga2V5O1xyXG4gICAgICB1cGRhdGVzLnB1c2godXBkYXRlKTtcclxuICAgIH1cclxuICB9KTtcclxuICB0b0RlbGV0ZS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHVwZGF0ZXMucHVzaCh7XHJcbiAgICAgIHR5cGU6IFVwZGF0ZVR5cGUuUmVtb3ZlZCxcclxuICAgICAgbmFtZToga2V5XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gdXBkYXRlcztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vaGVscGVycycpLmZsYXR0ZW47XHJcblxyXG52YXIgUHJvcHMgPSBmdW5jdGlvbiAobW9kZWwpIHtcclxuICB2YXIgcHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICByZXR1cm4gbW9kZWwucHJvcHNbbmFtZV07XHJcbiAgfTtcclxuICB2YXIgdmFsID0gZnVuY3Rpb24gdmFsKG5hbWUpIHtcclxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIG1vZGVsLnByb3BzW25hbWVdID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gZmxhdHRlbihtb2RlbC5wcm9wcywgbW9kZWwuc2VwYXJhdG9yLCBuYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb2RlbC5wcm9wc1tuYW1lXS52YWx1ZTtcclxuICB9O1xyXG5cclxuICB2YXIgcHJvcHMgPSBmdW5jdGlvbiAoc2VjdGlvbiwgc2VwYXJhdG9yKSB7XHJcbiAgICBzZWN0aW9uID0gc2VjdGlvbiB8fCAnJztcclxuICAgIGlmIChzZWN0aW9uID09PSAnJykge1xyXG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IHNlcGFyYXRvciBjaGFuZ2UgZm9yICcnIChzYW1lKSBzZWN0aW9uLlxyXG4gICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCBtb2RlbC5zZXBhcmF0b3I7XHJcbiAgICByZXR1cm4gbmV3IFByb3BzKG1vZGVsLmdldFZpZXdNb2RlbChzZWN0aW9uLCBzZXBhcmF0b3IpKTtcclxuICB9O1xyXG4gIHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xyXG4gICAgT2JqZWN0LmtleXMobW9kZWwucHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICBjYWxsYmFjay5jYWxsKHNjb3BlLCBtb2RlbC5wcm9wc1trZXldKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbiAgdmFyIG9uVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xyXG4gICAgbW9kZWwub24oY2FsbGJhY2ssIHNjb3BlKTtcclxuICB9O1xyXG4gIHZhciBzZWxmID0ge1xyXG4gICAgcHJvcDogcHJvcCxcclxuICAgIHZhbDogdmFsLFxyXG4gICAgcHJvcHM6IHByb3BzLFxyXG4gICAgZm9yRWFjaDogZm9yRWFjaCxcclxuICAgIG9uVXBkYXRlOiBvblVwZGF0ZVxyXG4gIH07XHJcbiAgcmV0dXJuIHNlbGY7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb3BzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXVpZCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xyXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xyXG4gICAgdmFyIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xyXG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gIH0pO1xyXG59O1xyXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XHJcbn07XHJcblxyXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcclxufTtcclxuXHJcbnZhciBsZXZlbHMgPSB7XHJcbiAgZGVidWc6ICdkZWJ1ZycsXHJcbiAgaW5mbzogJ2luZm8nLFxyXG4gIHdhcm46ICd3YXJuJyxcclxuICBlcnJvcjogJ2Vycm9yJ1xyXG59O1xyXG52YXIgbG9nID0gZnVuY3Rpb24gKGxldmVsLCBhcmdzKSB7XHJcbiAgaWYgKGNvbnNvbGUpIHtcclxuICAgIHZhciBsb2dnZXIgPSBjb25zb2xlW2xldmVsXTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGxvZ2dlcikpIHtcclxuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIFtdLnNwbGljZS5jYWxsKGFyZ3MsIDAsIDAsIG5vdy5nZXRIb3VycygpICsgJzonICsgbm93LmdldE1pbnV0ZXMoKSArICc6JyArIG5vdy5nZXRTZWNvbmRzKCkpO1xyXG4gICAgICBsb2dnZXIuYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG52YXIgaW5mbyA9IGZ1bmN0aW9uICgpIHtcclxuICBsb2cobGV2ZWxzLmluZm8sIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgd2FybiA9IGZ1bmN0aW9uICgpIHtcclxuICBsb2cobGV2ZWxzLndhcm4sIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgbG9nKGxldmVscy5kZWJ1ZywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIHV1aWQ6IHV1aWQsXHJcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcclxuICBpc1N0cmluZzogaXNTdHJpbmcsXHJcbiAgbG9nOiBsb2csXHJcbiAgd2Fybjogd2FybixcclxuICBpbmZvOiBpbmZvLFxyXG4gIGRlYnVnOiBkZWJ1Z1xyXG59O1xyXG4iLCJ2YXIgY29ubmVjdGlvbiA9IGZ1bmN0aW9uIChzZXR0aW5ncywgY3VzdG9tX2Nvbm5lY3Rpb24pe1xyXG5cdHNldHRpbmdzID0gc2V0dGluZ3N8fHt9O1xyXG5cdC8vVGhlIG1lc3NhZ2UgaGFuZGxlcnMgdGhhdCBoYXZlIHRvIGJlIGV4ZWN1dGVkIGZvciBlYWNoIHJlY2VpdmVkIG1lc3NhZ2VcclxuXHR2YXIgbWVzc2FnZV9oYW5kbGVycyA9IHt9O1xyXG5cdFxyXG5cdHZhciBpZHMgPSAwO1xyXG5cdFxyXG5cdHZhciBjb25uZWN0aW9uID0ge1xyXG5cdFx0Ly9FeGVjdXRlcyBhcHByb3ByaWF0ZSBtZXNzYWdlIGhhbmRsZXJzIGZvciB0aGUgbWVzc2FnZSB0eXBlLlxyXG5cdFx0X2hhbmRsZV9tZXNzYWdlOiBmdW5jdGlvbiAobWVzc2FnZSl7XHJcblx0XHRcdCAvL1JldHJpZXZlIGhhbmRsZXJzIGZvciB0aGUgbWVzc2FnZSB0eXBlXHJcblx0XHRcdCB2YXIgaGFuZGxlcnMgPSBtZXNzYWdlX2hhbmRsZXJzW21lc3NhZ2UudHlwZV07XHJcblx0XHRcdCBpZihoYW5kbGVycyAhPT11bmRlZmluZWQpe1xyXG5cdFx0XHRcdCAvL0V4ZWN1dGUgdGhlbVxyXG5cdFx0XHRcdCBPYmplY3Qua2V5cyhoYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyX2lkKXtcclxuXHRcdFx0XHRcdHZhciBoYW5kbGVyID0gaGFuZGxlcnNbaGFuZGxlcl9pZF07XHJcblx0XHRcdFx0XHRpZihoYW5kbGVyIT09dW5kZWZpbmVkKXtoYW5kbGVyKG1lc3NhZ2UubWVzc2FnZSk7fVxyXG5cdFx0XHRcdCB9KTtcclxuXHRcdFx0IH1cclxuXHRcdH0sXHJcblx0XHQvL0F0dGFjaGVzIGEgaGFuZGxlclxyXG5cdFx0b246IGZ1bmN0aW9uKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2VfaGFuZGxlcil7XHJcblx0XHQgICBpZihtZXNzYWdlX2hhbmRsZXJzW3R5cGVdID09PSB1bmRlZmluZWQpe21lc3NhZ2VfaGFuZGxlcnNbdHlwZV0gPSB7fTt9XHJcblx0XHQgICB2YXIgaWQgPSBpZHMrKztcclxuXHRcdCAgIG1lc3NhZ2VfaGFuZGxlcnNbdHlwZV1baWRdPSBtZXNzYWdlX2hhbmRsZXI7XHJcblx0XHQgICByZXR1cm4ge3R5cGU6dHlwZSwgaWQ6aWR9O1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly9SZW1vdmUgYSBoYW5kbGVyIFxyXG5cdFx0b2ZmOiBmdW5jdGlvbihpbmZvKXtcclxuXHRcdFx0ZGVsZXRlIG1lc3NhZ2VfaGFuZGxlcnNbaW5mby50eXBlXVtpbmZvLmlkXTtcclxuXHRcdH0sXHJcblx0XHQvL0R1bW15IGZ1bmN0aW9ucyBmb3IgdHJhbnNwb3J0cyB0aGF0IGFyZSBhbHdheXMgY29ubmVjdGVkXHJcblx0XHRjb25uZWN0ZWQ6ZnVuY3Rpb24oYSl7YSgpO30sXHJcblx0XHRkaXNjb25uZWN0ZWQ6ZnVuY3Rpb24oKXt9LFxyXG5cdFx0dmVyc2lvbjogXCIxLjMuMVwiXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlX2N1c3RvbV9jb25uZWN0aW9uKGNvbm5lY3Rpb24pe1xyXG5cdFx0Y29ubmVjdGlvbi5zZW5kID0gZnVuY3Rpb24ocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSl7XHJcblx0XHRcdGN1c3RvbV9jb25uZWN0aW9uLnB1Ymxpc2goe3R5cGU6dHlwZSwgbWVzc2FnZTptZXNzYWdlfSk7XHJcblx0XHR9O1xyXG5cdFx0Y3VzdG9tX2Nvbm5lY3Rpb24uc3Vic2NyaWJlKGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlKTtcclxuXHRcdHJldHVybiBjb25uZWN0aW9uO1xyXG5cdH1cclxuXHJcblx0aWYoc2V0dGluZ3Mud2Vic29ja2V0X3VybCE9PXVuZGVmaW5lZCl7XHJcblx0XHRyZXR1cm4gcmVxdWlyZShcIi4vd3NcIikoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xyXG4gIH1lbHNlIGlmKHNldHRpbmdzLmh0dHBfdXJsICE9PSB1bmRlZmluZWQpe1xyXG4gICAgcmV0dXJuIHJlcXVpcmUoXCIuL2h0dHBcIikoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xyXG4gIH1lbHNlIGlmKGdsb2JhbC5maW4gIT09dW5kZWZpbmVkKXtcclxuXHRcdHJldHVybiByZXF1aXJlKFwiLi9maW5cIikoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xyXG5cdH1lbHNlIGlmKGN1c3RvbV9jb25uZWN0aW9uIT09dW5kZWZpbmVkKXtcclxuXHRcdHJldHVybiBjcmVhdGVfY3VzdG9tX2Nvbm5lY3Rpb24oY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xyXG5cdC8vQ29ubmVjdCB2aWEgSFRNTCBDb250YWluZXIgZmFjYWRlXHJcblx0fWVsc2UgaWYgKGdsb2JhbC5odG1sQ29udGFpbmVyIT09dW5kZWZpbmVkKXtcclxuXHRcdHJldHVybiByZXF1aXJlKFwiLi9jb250XCIpKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcclxuXHR9ZWxzZSB7XHJcblx0XHR0aHJvdyBcIk5vIGNvbm5lY3Rpb24uIE1ha2Ugc3VyZSB5b3UgYXJlIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uIGZyb20gT3BlbkZpbiwgb3IgVGljazQyIEhUTUwgQ29udGFpbmVyIG9yIGZpbGwgdGhlICdjb25uZWN0aW9uLndlYnNvY2tldF91cmwnIHByb3BlcnR5LlwiO1xyXG5cdH1cclxufTtcclxuXHJcbmlmKGdsb2JhbC50aWNrNDI9PT11bmRlZmluZWQpe2dsb2JhbC50aWNrNDIgPSB7fTt9XHJcbmdsb2JhbC50aWNrNDIuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3Rpb247XHJcblxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pe1xyXG5cdHZhciBjb25uZWN0aW9uX2lkID0gIE1hdGguZmxvb3IoMWUxMCAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCk7XHJcblx0Ly9Sb3V0ZSBtZXNzYWdlcyB0byBmYWNhZGUocylcclxuXHRjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbiAocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSl7XHJcblx0XHRpZihwcm9kdWN0ID09PVwibWV0cmljc1wiKXtcclxuXHRcdFx0Z2xvYmFsLmh0bWxDb250YWluZXIubWV0cmljc0ZhY2FkZS5zZW5kKHR5cGUsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcclxuXHRcdH1lbHNlIGlmKHByb2R1Y3QgPT09XCJsb2dcIil7XHJcblx0XHRcdGdsb2JhbC5odG1sQ29udGFpbmVyLmxvZ2dpbmdGYWNhZGUuc2VuZCh0eXBlLCBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XHJcblx0XHR9ZWxzZSBpZiAocHJvZHVjdCA9PSBcImFwcGNvbmZpZ1wiKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbC5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZS5zZW5kKHR5cGUsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLCBjb25uZWN0aW9uX2lkKTtcclxuICAgICAgICB9XHJcblx0fTtcclxuXHRpZiAoZ2xvYmFsLmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBnbG9iYWwuaHRtbENvbnRhaW5lci5hcHBDb25maWdGYWNhZGUuaW5pdENvbm5lY3Rpb24oXHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25faWQsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChtZXNzYWdlQXNKc29uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5faGFuZGxlX21lc3NhZ2UoSlNPTi5wYXJzZShtZXNzYWdlQXNKc29uKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cdGdsb2JhbC5jb25uZWN0aW9ucyA9IGdsb2JhbC5jb25uZWN0aW9uc3x8e307IFxyXG5cdC8vRXhwb3NlIGZ1bmN0aW9uIGZvciBzZW5kaW5nIG1lc3NhZ2VzOlxyXG5cdGdsb2JhbC5jb25uZWN0aW9uc1snY29ubmVjdGlvbicrY29ubmVjdGlvbl9pZF0gPSBjb25uZWN0aW9uLl9oYW5kbGVfbWVzc2FnZTtcclxuXHJcblx0cmV0dXJuIGNvbm5lY3Rpb247XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgc2V0dGluZ3Mpe1xyXG5cdGlmKGdsb2JhbC5jb25zb2xlIT09dW5kZWZpbmVkJiYgc2V0dGluZ3MuZGVidWc9PT10cnVlKXtcclxuXHRcdGNvbnNvbGUubG9nKFwiQXR0ZW1waW5nIHRvIGNvbm5lY3QgdG8gR2F0ZXdheSB2aWEgT3BlbkZpbiBJbnRlciBBcHBsaWNhdGlvbiBCdXMuXCIpO1xyXG5cdH1cclxuXHJcblx0Ly9BIGZ1bmN0aW9uIGZvciBzZW5kaW5nIGEgbWVzc2FnZSBcclxuXHRjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbihwcm9kdWN0LCB0eXBlLCBtZXNzYWdlKXtcclxuXHRcdGZpbi5kZXNrdG9wLkludGVyQXBwbGljYXRpb25CdXMucHVibGlzaChcIkFHTVwiLCB7dHlwZTp0eXBlLCBtZXNzYWdlOm1lc3NhZ2V9KTtcclxuXHR9O1xyXG5cdC8vQSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIG1lc3NhZ2VzXHJcblx0ZmluLmRlc2t0b3AuSW50ZXJBcHBsaWNhdGlvbkJ1cy5zdWJzY3JpYmUoJyonLCdBR00nLCBjb25uZWN0aW9uLl9oYW5kbGVfbWVzc2FnZSk7XHJcblx0aWYoZ2xvYmFsLmNvbnNvbGUhPT11bmRlZmluZWQmJiBzZXR0aW5ncy5kZWJ1Zz09PXRydWUpe1xyXG5cdFx0Y29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gT3BlbkZpbiB0cmFuc3BvcnQuXCIpO1xyXG5cdH1cclxuXHRcclxuXHRyZXR1cm4gY29ubmVjdGlvbjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29ubmVjdGlvbiwgc2V0dGluZ3MpIHtcclxuICB2YXIgdXJsID0gc2V0dGluZ3MuaHR0cF91cmw7XHJcbiAgLy8gcG9sbGluZyBpbnRlcnZhbCBpbiBtcywgZGVmYXVsdCBpcyAxIHNlY29uZFxyXG4gIHZhciBpbnRlcnZhbCA9IHNldHRpbmdzLmh0dHBfaW50ZXJ2YWxfbXM7XHJcbiAgaWYgKCFpbnRlcnZhbCkgaW50ZXJ2YWwgPSAxMDAwO1xyXG5cclxuICBmdW5jdGlvbiBsb2dfZGVidWcobWVzc2FnZSkge1xyXG4gICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgKHNldHRpbmdzLmRlYnVnID09PSB0cnVlIHx8IHNldHRpbmdzLnRyYWNlID09PSB0cnVlKSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxvZ190cmFjZShtZXNzYWdlKSB7XHJcbiAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBzZXR0aW5ncy50cmFjZSA9PT0gdHJ1ZSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxvZ19kZWJ1ZyhcIkF0dGVtcGluZyB0byBjb25uZWN0IHRvIEdhdGV3YXkgdmlhIEhUVFAgd2l0aCB1cmwgJ1wiICsgdXJsICsgXCInIGFuZCBwb2xsaW5nIGludGVydmFsIFwiICsgaW50ZXJ2YWwgKyBcIiBtc1wiKTtcclxuXHJcbiAgcG9sbCh1cmwsIGludGVydmFsLCAwLCBmdW5jdGlvbiAoaXRlbXMpIHtcclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpdGVtcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgY29ubmVjdGlvbi5faGFuZGxlX21lc3NhZ2UoaXRlbXNbaW5kZXhdKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgY29ubmVjdGlvbi5zZW5kID0gZnVuY3Rpb24gKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2UsIGlkKSB7XHJcbiAgICB2YXIgbXNnID0gSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiB0eXBlLCBtZXNzYWdlOiBtZXNzYWdlLCBpZDogaWQgfSk7XHJcbiAgICBodHRwX3Bvc3QodXJsLCBtc2cpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFBvbGxzIGRhdGEgZnJvbSBhIGdpdmVuIHVybCBvbiBzb21lIGludGVydmFsXHJcbiAgICogQHBhcmFtIHVybCAgICAgICBCYXNlIHNlcnZlciB1cmwuIEEgc2VxdWVuY2UgdXJsIHBhcmFtIG1heSBiZSBhZGRlZCBiYXNlZCBvbiB0aGUgc2VxIHBhcmFtXHJcbiAgICogQHBhcmFtIGludGVydmFsICBJbnRlcnZhbCAoaW4gbXMpIGJldHdlZW4gcG9sbGluZyByZXF1ZXN0dHNcclxuICAgKiBAcGFyYW0gc2VxICAgICAgIE5leHQgc2VxdWVuY2UgbnVtYmVyIHdlIHNob3VsZCBhc2sgZm9yIChpZiAwIHRoZSBzZXJ2ZXIgd2lsbCByZXR1cm4gdGhlIGxhc3Qga25vd24gbWVzc2FnZSlcclxuICAgKiBAcGFyYW0gb25kYXRhICAgIERhdGEgY2FsbGJhY2sgICAgXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcG9sbCh1cmwsIGludGVydmFsLCBzZXEsIG9uZGF0YSkge1xyXG4gICAgLy8gY29uc3RydWN0IHRoZSBnZXQgVXJsIC0gaWYgc2VxICE9IDAgYWRkIGFzIHVybCBwYXJhbSB0byBnZXQgXHJcbiAgICAvLyBvbmx5IG1lc3NhZ2VzIGFmdGVyIHRoaXMgc2VxdWVuY2VcclxuICAgIHZhciBnZXRVcmwgPSB1cmw7XHJcblxyXG4gICAgaWYgKHNlcSAhPT0gMCkge1xyXG4gICAgICBnZXRVcmwgPSB1cmwgKyBcIj9zZXF1ZW5jZT1cIiArIHNlcSArIFwiJm5vLWNhY2hlPVwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICB9ICAgIFxyXG4gICAgICAgIFxyXG4gICAgLy8gY3JlYXRlIGEgcmVxdWVzdCAgICBcclxuICAgIHZhciB4bWxodHRwID0gY3JlYXRlQ09SU1JlcXVlc3QoXCJHRVRcIiwgZ2V0VXJsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChzZXEgPT09IDApe1xyXG4gICAgICAgIGxvZ19kZWJ1ZyhcIkNvbm5lY3RlZCB0byBHYXRld2F5IG9uIFwiICsgdXJsKTtcclxuICAgICAgfVxyXG4gICAgICBsb2dfdHJhY2UoXCJSZXNwb25zZSBmcm9tICdcIiArIGdldFVybCArIFwiJyBpcyBcIiArIHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcclxuICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcclxuICAgICAgLy8gdGhlIHNlcnZlciByZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIG5leHQgc2VxdWVuY2UgdGhhdCB3ZSBtdXN0IHF1ZXJ5IGZvclxyXG4gICAgICB2YXIgbmV4dFNlcSA9IG1lc3NhZ2UubmV4dFNlcXVlbmNlO1xyXG4gICAgICAvLyBjYWxsIHVzZXIgY2FsbGJhY2tlICAgIFxyXG4gICAgICBvbmRhdGEobWVzc2FnZS5kYXRhKTtcclxuICAgICAgLy8gcmUtc2NoZWR1bGVcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcG9sbCh1cmwsIGludGVydmFsLCBuZXh0U2VxLCBvbmRhdGEpO1xyXG4gICAgICB9LCBpbnRlcnZhbCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB4bWxodHRwLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJFcnJvciBwb2xsaW5nIGRhdGEgZnJvbSBodHRwIHNlcnZlciAnXCIgKyBnZXRVcmwgKyBcIicgLSBcIiArIGV2KTtcclxuICAgICAgLy8gcmUtc2NoZWR1bGVcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcG9sbCh1cmwsIGludGVydmFsLCBzZXEsIG9uZGF0YSk7XHJcbiAgICAgIH0sIGludGVydmFsKTtcclxuICAgIH07XHJcblxyXG4gICAgbG9nX3RyYWNlKFwiU2VuZGluZyBHRVQgdG8gJ1wiICsgZ2V0VXJsICsgXCInXCIpO1xyXG4gICAgeG1saHR0cC5zZW5kKCk7XHJcbiAgfVxyXG5cclxuICAvKiogXHJcbiAgICogUE9TVHMgYSBtZXNzYWdlIHRvIGEgZ2l2ZW4gdXJsIFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGh0dHBfcG9zdCh1cmwsIG1lc3NhZ2UpIHtcclxuICAgIC8vIGNyZWF0ZSBhIHJlcXVlc3QgICAgXHJcbiAgICB2YXIgeG1saHR0cCA9IGNyZWF0ZUNPUlNSZXF1ZXN0KFwiUE9TVFwiLCB1cmwpO1xyXG4gICAgbG9nX3RyYWNlKFwiU2VuZGluZyBQT1NUIHRvICdcIiArIHVybCArIFwiJyA6IFwiICsgbWVzc2FnZSk7XHJcbiAgICB4bWxodHRwLnNlbmQobWVzc2FnZSk7XHJcbiAgfVxyXG5cclxuICAvKiogXHJcbiAgICogQ3JlYXRlcyBDT1JTIHJlcXVlc3QgKGNyb3NzIGRvbWFpbiByZXF1ZXN0cykgZm9yIGRpZmZlcmVudCBicm93c2VycyAtIFhNTEh0dHBSZXF1ZXN0IHdpdGhDcmVkZW50aWFsc1xyXG4gICAqIGZvciBDaHJvbWUgYW5kIEZGIGFuZCBYRG9tYWluUmVxdWVzdCBmb3IgSUVcclxuICAgKi9cclxuICBmdW5jdGlvbiBjcmVhdGVDT1JTUmVxdWVzdChtZXRob2QsIHVybCwgcmVzdWx0X2NhbGxiYWNrKSB7XHJcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7ICAgIFxyXG4gICAgXHJcbiAgICBpZiAoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHIpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIFhNTEh0dHBSZXF1ZXN0IG9iamVjdCBoYXMgYSBcIndpdGhDcmVkZW50aWFsc1wiIHByb3BlcnR5LlxyXG4gICAgICAvLyBcIndpdGhDcmVkZW50aWFsc1wiIG9ubHkgZXhpc3RzIG9uIFhNTEhUVFBSZXF1ZXN0MiBvYmplY3RzLlxyXG4gICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XHJcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0X2NhbGxiYWNrICE9PSBcInVuZGVmaW5lZFwiKXtcclxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQgJiYgeGhyLnN0YXR1cyA9PSAyMDApIHtcclxuICAgICAgICAgICAgcmVzdWx0X2NhbGxiYWNrKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgWERvbWFpblJlcXVlc3QgIT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAvLyBPdGhlcndpc2UsIGNoZWNrIGlmIFhEb21haW5SZXF1ZXN0LlxyXG4gICAgICAvLyBYRG9tYWluUmVxdWVzdCBvbmx5IGV4aXN0cyBpbiBJRSwgYW5kIGlzIElFJ3Mgd2F5IG9mIG1ha2luZyBDT1JTIHJlcXVlc3RzLlxyXG4gICAgICB4aHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcclxuICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwpO1xyXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdF9jYWxsYmFjayAhPT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgeGhyLm9ubG9hZCA9IHJlc3VsdF9jYWxsYmFjaztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gT3RoZXJ3aXNlLCBDT1JTIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXHJcbiAgICAgIHhociA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geGhyO1xyXG4gIH1cclxuIFxyXG4gIHJldHVybiBjb25uZWN0aW9uO1xyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgc2V0dGluZ3Mpe1xyXG5cdHZhciBjb25uZWN0ZWQgPSBmYWxzZTtcclxuXHRcclxuXHQvL0xvYWQgdGhlICd3cycgbGlicmFyeSwgYnV0IG9ubHkgaWYgd2UgYXJlIHJ1bm5pbmcgdW5kZXIgbm9kZSBqc1xyXG5cdHZhciBXZWJTb2NrZXQgPSByZXF1aXJlKFwiZGV0ZWN0LW5vZGVcIik/cmVxdWlyZShcIndzXCIpOmdsb2JhbC5XZWJTb2NrZXQ7XHJcblx0XHJcblx0ZnVuY3Rpb24gaW5pdGlhdGVfc29ja2V0KCl7XHJcblx0XHRpZihnbG9iYWwuY29uc29sZSE9PXVuZGVmaW5lZCYmIHNldHRpbmdzLmRlYnVnPT09dHJ1ZSl7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiQXR0ZW1waW5nIHRvIGNvbm5lY3QgdG8gR2F0ZXdheSB2aWEgV2ViU29ja2V0LlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgd3MgPSBuZXcgV2ViU29ja2V0KHNldHRpbmdzLndlYnNvY2tldF91cmwpO1xyXG5cdFx0Ly9BZGQgdXNlciBjYWxsYmFja3NcclxuXHRcdHdzLm9uY2xvc2UgPSBmdW5jdGlvbihldmVudCl7XHJcblx0XHRcdGlmKHR5cGVvZiBzZXR0aW5ncy5kaXNjb25uZWN0ZWQ9PT1cImZ1bmN0aW9uXCIpe3NldHRpbmdzLmRpc2Nvbm5lY3RlZChzZXR0aW5ncy53ZWJzb2NrZXRfdXJsLCBldmVudCk7fVxyXG5cdFx0XHRjb25uZWN0ZWQgPSBmYWxzZTtcclxuXHRcdH07XHJcblx0XHQvL0xvZyBvbiBjb25uZWN0aW9uXHJcblx0XHR3cy5vbm9wZW4gPSBmdW5jdGlvbigpe1xyXG5cdFx0XHRpZih0eXBlb2Ygc2V0dGluZ3MuY29ubmVjdGVkPT09XCJmdW5jdGlvblwiKXtzZXR0aW5ncy5jb25uZWN0ZWQoc2V0dGluZ3Mud2Vic29ja2V0X3VybCk7fVxyXG5cdFx0XHRpZihnbG9iYWwuY29uc29sZSE9PXVuZGVmaW5lZCAmJiBzZXR0aW5ncy5kZWJ1Zz09PXRydWUpe1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiQ29ubmVjdGVkIHRvIFdTIFVSTCBcIitzZXR0aW5ncy53ZWJzb2NrZXRfdXJsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb25uZWN0ZWQgPSB0cnVlO1xyXG5cdFx0fTtcclxuXHRcdC8vQXR0YWNoIGhhbmRsZXJcclxuXHRcdHdzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2Upe1xyXG5cdFx0XHRjb25uZWN0aW9uLl9oYW5kbGVfbWVzc2FnZShKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSkpO1xyXG5cdFx0fTtcclxuXHRcdHJldHVybiB3cztcclxuXHR9XHJcblx0XHJcblx0Ly9Jbml0aWF0ZSBhIG5ldyBzb2NrZXQgKHRoaXMgZ2V0cyByZS1leGVjdXRlZCBvbiByZWNvbm5lY3QpXHJcblx0dmFyIHNvY2tldCA9IGluaXRpYXRlX3NvY2tldCgpO1xyXG5cdFxyXG5cdC8vQ3JlYXRlIGEgZnVuY3Rpb24gZm9yIHNlbmRpbmcgYSBtZXNzYWdlXHJcblx0Y29ubmVjdGlvbi5zZW5kID0gZnVuY3Rpb24ocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSwgaWQpe1xyXG5cdFx0Ly9JZiB3ZSBhcmUgY29ubmVjdGVkIHNlbmQgdGhlIG1lc3NhZ2VcclxuXHRcdGlmKHNvY2tldC5yZWFkeVN0YXRlID09PTEpe1xyXG5cdFx0XHRzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7dHlwZTp0eXBlLCBtZXNzYWdlOm1lc3NhZ2UsIGlkOmlkfSkpO1xyXG5cdFx0Ly9JZiB3ZSBhcmUgbm90IGNvbm5lY3RlZCBhbmQgd2UgYXJlIG5vdCBhdHRlbXB0aW5nIHRvIGNvbm5lY3QgcmlnaHQgbm93LCBhdHRlbXB0IHRvIGNvbm5lY3RcclxuXHRcdH1lbHNlIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0wKXtcclxuXHRcdFx0c29ja2V0ID0gaW5pdGlhdGVfc29ja2V0KCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRjb25uZWN0aW9uLndlYnNvY2tldF91cmwgPSBmdW5jdGlvbihhKXtcclxuXHRcdHNldHRpbmdzLndlYnNvY2tldF91cmwgPSBhO1xyXG5cdFx0c29ja2V0LmNsb3NlKCk7XHJcblx0XHRzb2NrZXQgPSBpbml0aWF0ZV9zb2NrZXQoKTtcclxuXHR9O1xyXG5cdFxyXG5cdGNvbm5lY3Rpb24uY29ubmVjdGVkID0gZnVuY3Rpb24oYSl7XHJcblx0XHRpZihjb25uZWN0ZWQpe2Eoc2V0dGluZ3Mud2Vic29ja2V0X3VybCk7fVxyXG5cdFx0c2V0dGluZ3MuY29ubmVjdGVkID0gYTtcclxuXHR9O1xyXG5cdGNvbm5lY3Rpb24uZGlzY29ubmVjdGVkID0gZnVuY3Rpb24oYSl7XHJcblx0XHRzZXR0aW5ncy5kaXNjb25uZWN0ZWQgPSBhO1xyXG5cdH07XHJcblx0XHJcblx0cmV0dXJuIGNvbm5lY3Rpb247XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cbi8vIE9ubHkgTm9kZS5KUyBoYXMgYSBwcm9jZXNzIHZhcmlhYmxlIHRoYXQgaXMgb2YgW1tDbGFzc11dIHByb2Nlc3NcbnRyeSB7XG4gbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScgXG59IGNhdGNoKGUpIHt9XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcblxuLyoqXG4gKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldCA/IHdzIDogbnVsbDtcblxuLyoqXG4gKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogVGhlIHRoaXJkIGBvcHRzYCBvcHRpb25zIG9iamVjdCBnZXRzIGlnbm9yZWQgaW4gd2ViIGJyb3dzZXJzLCBzaW5jZSBpdCdzXG4gKiBub24tc3RhbmRhcmQsIGFuZCB0aHJvd3MgYSBUeXBlRXJyb3IgaWYgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2VpbmFyb3Mvd3MvaXNzdWVzLzIyN1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3RvY29scyAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge09iamVjdCkgb3B0cyAob3B0aW9uYWwpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHdzKHVyaSwgcHJvdG9jb2xzLCBvcHRzKSB7XG4gIHZhciBpbnN0YW5jZTtcbiAgaWYgKHByb3RvY29scykge1xuICAgIGluc3RhbmNlID0gbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scyk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgV2ViU29ja2V0KHVyaSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5pZiAoV2ViU29ja2V0KSB3cy5wcm90b3R5cGUgPSBXZWJTb2NrZXQucHJvdG90eXBlO1xuIiwidmFyIGFzY2lpVGFibGUgPSByZXF1aXJlKFwiYXNjaWktdGFibGVcIik7XG52YXIgdGljazQyQ29ubmVjdGlvbiA9IHJlcXVpcmUoXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCIpO1xuXG52YXIgbGV2ZWxzID0gWyAndHJhY2UnLCAnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJywgJ29mZicgXTtcblxuZnVuY3Rpb24gc2VyaWFsaXplUGF0aChwYXRoKSB7XG5cdHJldHVybiBwYXRoLmxlbmd0aCA9PT0gMCA/IFwiXCIgOiBwYXRoLmpvaW4oXCIuXCIpO1xufVxuXG52YXIgaXNDb25uZWN0aW9uID0gZnVuY3Rpb24oYykge1xuXHRyZXR1cm4gdHlwZW9mIGMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGMuc2VuZCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjLm9uID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG5mdW5jdGlvbiBnZXRMZXZlbChsb2dnZXIsIGxldmVsKSB7XG5cdC8vUmV0cmlldmVzIHRoZSBjb25zb2xlIG9yIHB1Ymxpc2ggbGV2ZWwgb2YgYSBsb2dnZXJcblx0Ly9sb2dnZXIgLSB0aGUgbG9nZ2VyIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGV2ZWxcblx0Ly9sZXZlbCAtIGEgc3RyaW5nIHdoaWNoIGNhbiBlaXRoZXIgYmUgXCJwdWJsaXNoTGV2ZWxcIiBmb3IgcmV0cmlldmluZyB0aGUgcHVibGlzaCBsZXZlbCBvciBcImNfbGV2ZWxcIiBmb3IgcmV0cmlldmluZyB0aGUgY29uc29sZSBsZXZlbC5cblx0aWYgKGxvZ2dlcltsZXZlbF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBsb2dnZXJbbGV2ZWxdO1xuXHR9IGVsc2UgaWYgKGxvZ2dlci5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBnZXRMZXZlbChsb2dnZXIucGFyZW50LCBsZXZlbCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gbWVzc2FnZVRvVGFibGUodGl0bGUsIHJvd3MpIHtcblx0Ly9EaXNwbGF5IG1lc3NhZ2UgYXMgdGFibGUgaW4gZmlsZVxuXHR2YXIga2V5cyA9IGdldEFsbEtleXMocm93cyk7XG5cdC8vZmlsbCByb3dzIHdpdGggbWVzc2FnZSBwcm9wZXJ0aWVzXG5cdHZhciB0YWJsZVJvd3MgPSByb3dzLm1hcChmdW5jdGlvbiAob2JqKSB7XG5cdFx0cmV0dXJuIGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiBvYmpba2V5XTtcblx0XHR9KTtcblx0fSk7XG5cblx0dmFyIHRhYmxlX21lc3NhZ2UgPSBhc2NpaVRhYmxlLmZhY3Rvcnkoe1xuXHRcdHRpdGxlOiB0aXRsZSxcblx0XHRoZWFkaW5nOiBrZXlzLFxuXHRcdHJvd3M6IHRhYmxlUm93c1xuXHR9KTtcblx0cmV0dXJuIHRhYmxlX21lc3NhZ2UudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxsS2V5cyhkYXRhKSB7XG5cdC8vQWNjZXB0cyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUga2V5cyBmcm9tIGFsbCBvYmplY3RzXG5cdHZhciBhbGxLZXlzID0gW107XG5cblx0ZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0XHRPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKGFsbEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuXHRcdFx0XHRhbGxLZXlzLnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdHJldHVybiBhbGxLZXlzO1xufVxuXG5mdW5jdGlvbiBsb2dnZXIoY29uZmlndXJhdGlvbikge1xuXHRpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiAhPT0gXCJvYmplY3RcIikge1xuXHRcdGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiA9IHt9O1xuXHR9XG5cblx0Ly9TZXQgZGVidWcgZm9yIHRoZSBjb25uZWN0aW9uIG1vZHVsZSBpZiBnbG9iYWwgZGVidWcgaXMgc2V0XG5cdGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbi5kZWJ1ZyA9IGNvbmZpZ3VyYXRpb24uZGVidWc7XG5cblx0Ly9Jbml0IGNvbm5lY3Rpb25cblx0Ly9EZXRlcm1pbmUgaWYgd2UgYXJlIGdpdmVuIGEgcmVhZHkgJ2Nvbm5lY3Rpb24nIG9iamVjdCBvciBhIGNvbmZpZ3VyYXRpb24uXG5cdHZhciBjb25uZWN0aW9uID0gaXNDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbikgPyBjb25maWd1cmF0aW9uLmNvbm5lY3Rpb24gOiB0aWNrNDJDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbik7XG5cblx0dmFyIGlkS2V5cyA9IFtcInN5c3RlbVwiLCBcInNlcnZpY2VcIiwgXCJpbnN0YW5jZVwiXTtcblxuXHQvL0NvbnZlcnQgaW5zdGFuY2UgdG8gc3RyaW5nLCB0aHJvdyBleGNlcHRpb25zIGlmIGl0IGlzIG5vdCBmdWxsXG5cdHZhciBpbnN0YW5jZV9zdHIgPSBpZEtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgcHJvcCA9IGNvbmZpZ3VyYXRpb24uaWRlbnRpdHlba2V5XTtcblx0XHRpZiAodHlwZW9mIHByb3AgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHRocm93ICdQbGVhc2Ugc3BlY2lmeSBcIicgKyBrZXkgKyAnXCIgaW4geW91ciBpZGVudGl0eSc7XG5cdFx0fVxuXHRcdHJldHVybiBwcm9wO1xuXHR9KS5qb2luKFwiL1wiKTtcblxuXHR2YXIgbG9nZ2VyUHJvdG8gPSB7XG5cdFx0c3ViTG9nZ2VyOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0Ly9DaGVjayBpZiB0aGUgc3VibG9nZ2VyIGlzIGFscmVhZHkgY3JlYXRlZFxuXHRcdFx0dmFyIGV4aXN0aW5nU3VibG9nZ2VyID0gdGhpcy5zdWJsb2dnZXJzLmZpbHRlcihmdW5jdGlvbiAoc3ViTG9nZ2VyKSB7XG5cdFx0XHRcdHJldHVybiBzdWJMb2dnZXIubmFtZSA9PT0gbmFtZTtcblx0XHRcdH0pWzBdO1xuXG5cdFx0XHRpZiAoZXhpc3RpbmdTdWJsb2dnZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdTdWJsb2dnZXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vQ2hlY2sgaWYgdGhlIG5hbWUgaXNuJ3QgdGhlIHNhbWUgYXMgb25lIG9mIHRoZSBwYXJlbnQgcHJvcGVydGllc1xuXHRcdFx0T2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGlmIChrZXkgPT09IG5hbWUpIHtcblx0XHRcdFx0XHR0aHJvdyAnVGhpcyBzdWIgbG9nZ2VyIG5hbWUgaXMgbm90IGFsbG93ZWQuJztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHQvL0NoZWNrIGlmIHRoZSBuYW1lIGlzbid0IHRoZSBzYW1lIGFzIG9uZSBvZiB0aGUgcGFyZW50IG1ldGhvZHNcblx0XHRcdE9iamVjdC5rZXlzKGxvZ2dlclByb3RvKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0aWYgKGtleSA9PT0gbmFtZSkge1xuXHRcdFx0XHRcdHRocm93ICdUaGlzIHN1YiBsb2dnZXIgbmFtZSBpcyBub3QgYWxsb3dlZC4nO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIHBhdGggPSB0aGlzLnBhdGguc2xpY2UoMCk7XG5cdFx0XHRwYXRoLnB1c2godGhpcy5uYW1lKTtcblx0XHRcdHJldHVybiBjcmVhdGVMb2dnZXIobmFtZSwgcGF0aCwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdHB1Ymxpc2hMZXZlbDogZnVuY3Rpb24gKGxldmVsKSB7XG5cdFx0XHRpZiAobGV2ZWwgIT09IG51bGwgJiYgbGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9wdWJsaXNoTGV2ZWwgPSBsZXZlbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZXRMZXZlbCh0aGlzLCBcIl9wdWJsaXNoTGV2ZWxcIik7XG5cdFx0fSxcblxuXHRcdGNvbnNvbGVMZXZlbDogZnVuY3Rpb24gKGxldmVsKSB7XG5cdFx0XHRpZiAobGV2ZWwgIT09IG51bGwgJiYgbGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9jb25zb2xlTGV2ZWwgPSBsZXZlbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZXRMZXZlbCh0aGlzLCBcIl9jb25zb2xlTGV2ZWxcIik7XG5cdFx0fSxcblxuXHRcdG1ldHJpY3NMZXZlbDogZnVuY3Rpb24gKGxldmVsLCBtZXRyaWNzU3lzdGVtKSB7XG5cdFx0XHRpZiAobGV2ZWwgIT09IG51bGwgJiYgbGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9tZXRyaWNMZXZlbCA9IGxldmVsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWV0cmljc1N5c3RlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgbWV0cmljc1N5c3RlbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbWV0cmljc1N5c3RlbS5vYmplY3RNZXRyaWMgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHRoaXMubWV0cmljU3lzdGVtID0gbWV0cmljc1N5c3RlbTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBcIlBsZWFzZSBzcGVjaWZ5IG1ldHJpYyBzeXN0ZW0gXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dGFibGU6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdFx0XHQvL21lc3NhZ2UgbXVzdCBiZSBpbiBhbiBhcnJheSwgdG8gYmUgZGlzcGxheWVkIGFzIHRhYmxlXG5cdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcblx0XHRcdFx0dGhyb3cgJ1RoZSBtZXNzYWdlIG11c3QgYmUgaW4gYW4gYXJyYXknO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1JldHJpZXZlIGxvZ2dlciBuYW1lIGFuZCBsZXZlbHNcblx0XHRcdHZhciBsb2dnZXJOYW1lID0gZ2V0TG9nZ2VyTmFtZSh0aGlzKTtcblxuXHRcdFx0Ly9QdWJsaXNoIGluIGNvbnNvbGVcblx0XHRcdGlmIChzaG91bGRQdWJsaXNoKGdldExldmVsKHRoaXMsICdfY29uc29sZUxldmVsJyksICdpbmZvJykpIHtcblx0XHRcdFx0Y29uc29sZS5pbmZvKGxvZ2dlck5hbWUgKyAnOicpO1xuXHRcdFx0XHRjb25zb2xlLnRhYmxlKG1lc3NhZ2UpO1xuXHRcdFx0fVxuXHRcdFx0Ly9QdWJsaXNoIGluIGZpbGVcblx0XHRcdGlmIChzaG91bGRQdWJsaXNoKGdldExldmVsKHRoaXMsICdfcHVibGlzaExldmVsJyksICdpbmZvJykpIHtcblx0XHRcdFx0Y29ubmVjdGlvbi5zZW5kKCdsb2cnLCAnTG9nTWVzc2FnZScsIHtcblx0XHRcdFx0XHRpbnN0YW5jZTogaW5zdGFuY2Vfc3RyLFxuXHRcdFx0XHRcdGxldmVsOiBsZXZlbHMuaW5kZXhPZignaW5mbycpLFxuXHRcdFx0XHRcdGxvZ2dlcjogbG9nZ2VyTmFtZSxcblx0XHRcdFx0XHRtZXNzYWdlOiBtZXNzYWdlVG9UYWJsZShsb2dnZXJOYW1lLCBtZXNzYWdlKVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bG9nOiBmdW5jdGlvbiAobWVzc2FnZSwgbGV2ZWwpIHtcblx0XHRcdHB1Ymxpc2hNZXNzYWdlKHRoaXMsIGxldmVsIHx8IFwiaW5mb1wiLCBtZXNzYWdlKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKG5hbWUsIHBhdGgsIHBhcmVudCkge1xuXHRcdHZhciBsb2dnZXIgPSBPYmplY3QuY3JlYXRlKGxvZ2dlclByb3RvKTtcblx0XHRsb2dnZXIubmFtZSA9IG5hbWU7XG5cdFx0bG9nZ2VyLnBhdGggPSBwYXRoO1xuXHRcdGxvZ2dlci5zdWJsb2dnZXJzID0gW107XG5cdFx0bG9nZ2VyLnBhcmVudCA9IHBhcmVudDtcblx0XHRpZiAocGFyZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vYWRkIHN1YmxvZ2dlciB0byBzdWJsb2dnZXJzIGFycmF5XG5cdFx0XHRwYXJlbnQuc3VibG9nZ2Vycy5wdXNoKGxvZ2dlcik7XG5cdFx0XHQvL2FkZCBlYXN5IGFjY2VzcyB0byBzdWJsb2dnZXJcblx0XHRcdHBhcmVudFtsb2dnZXIubmFtZV0gPSBsb2dnZXI7XG5cdFx0XHQvL2NyZWF0ZSBtZXRyaWMgc3lzdGVtXG5cdFx0XHRpZiAocGFyZW50Lm1ldHJpY1N5c3RlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGxvZ2dlci5tZXRyaWNzTGV2ZWwoJ3dhcm4nLCBwYXJlbnQubWV0cmljU3lzdGVtLnN1YlN5c3RlbShsb2dnZXIubmFtZSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcblx0XHRcdGxvZ2dlcltsZXZlbF0gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHRcdFx0XHRwdWJsaXNoTWVzc2FnZShsb2dnZXIsIGxldmVsLCBtZXNzYWdlKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRsb2dnZXIub2ZmID0gZnVuY3Rpb24oKXt9O1xuXG5cdFx0bG9nZ2VyLnZlcnNpb24gPSBcIjIuMC4xXCI7XG5cblx0XHRyZXR1cm4gbG9nZ2VyO1xuXHR9XG5cblx0ZnVuY3Rpb24gcHVibGlzaE1lc3NhZ2UobG9nZ2VyLCBsZXZlbCwgbWVzc2FnZSkge1xuXHRcdC8vUmV0cmlldmUgbG9nZ2VyIG5hbWUgYW5kIGxldmVsc1xuXHRcdHZhciBsb2dnZXJfbmFtZSA9IGdldExvZ2dlck5hbWUobG9nZ2VyKTtcblxuXHRcdC8vQWRkIHN0YWNrIHRyYWNlIGlmIHRoZSBtZXNzYWdlIGlzIGFuIGVycm9yXG5cdFx0aWYgKGxldmVsID09PSAnZXJyb3InKSB7XG5cdFx0XHR2YXIgZSA9IG5ldyBFcnJvcigpO1xuXHRcdFx0aWYgKGUuc3RhY2spIHtcblx0XHRcdFx0bWVzc2FnZSA9IG1lc3NhZ2UgKyBcIlxcblwiICsgKGUuc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMykuam9pbihcIlxcblwiKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9QdWJsaXNoIGluIGNvbnNvbGVcblx0XHRpZiAoc2hvdWxkUHVibGlzaChnZXRMZXZlbChsb2dnZXIsICdfY29uc29sZUxldmVsJyksIGxldmVsKSkge1xuXHRcdFx0Y29uc29sZVtsZXZlbF0obG9nZ2VyX25hbWUgKyBcIjogXCIgKyBtZXNzYWdlKTtcblx0XHR9XG5cdFx0Ly9QdWJsaXNoIGluIGZpbGVcblx0XHRpZiAoc2hvdWxkUHVibGlzaChnZXRMZXZlbChsb2dnZXIsICdfcHVibGlzaExldmVsJyksIGxldmVsKSkge1xuXHRcdFx0Y29ubmVjdGlvbi5zZW5kKCdsb2cnLCAnTG9nTWVzc2FnZScsIHtcblx0XHRcdFx0aW5zdGFuY2U6IGluc3RhbmNlX3N0cixcblx0XHRcdFx0bGV2ZWw6IGxldmVscy5pbmRleE9mKGxldmVsKSxcblx0XHRcdFx0bG9nZ2VyOiBsb2dnZXJfbmFtZSxcblx0XHRcdFx0bWVzc2FnZTogbWVzc2FnZVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly9QdWJsaXNoIGluIG1ldHJpY3Ncblx0XHRpZiAoc2hvdWxkUHVibGlzaChnZXRMZXZlbChsb2dnZXIsICdfbWV0cmljTGV2ZWwnKSwgbGV2ZWwpKSB7XG5cdFx0XHRpZiAobG9nZ2VyLm1ldHJpY1N5c3RlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGxvZ2dlci5tZXRyaWNTeXN0ZW0ub2JqZWN0TWV0cmljKCdMb2dNZXNzYWdlJywge1xuXHRcdFx0XHRcdFRpbWU6IG5ldyBEYXRlKCksXG5cdFx0XHRcdFx0TG9nZ2VyOiBsb2dnZXJfbmFtZSxcblx0XHRcdFx0XHRMZXZlbDogbGV2ZWwsXG5cdFx0XHRcdFx0TWVzc2FnZTogbWVzc2FnZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgc2hvdWxkUHVibGlzaCA9IGZ1bmN0aW9uIChwdWJsaXNoTGV2ZWwsIG1lc3NhZ2VMZXZlbCkge1xuXHRcdHJldHVybiAoIXB1Ymxpc2hMZXZlbCB8fCBsZXZlbHMuaW5kZXhPZihwdWJsaXNoTGV2ZWwpIDw9IGxldmVscy5pbmRleE9mKG1lc3NhZ2VMZXZlbCkpO1xuXHR9O1xuXG5cdHZhciBnZXRMb2dnZXJOYW1lID0gZnVuY3Rpb24gKGxvZ2dlcikge1xuXHRcdHZhciBsb2dnZXJQYXRoQW5kTmFtZSA9IGxvZ2dlci5wYXRoLnNsaWNlKCk7XG5cdFx0bG9nZ2VyUGF0aEFuZE5hbWUucHVzaChsb2dnZXIubmFtZSk7XG5cdFx0cmV0dXJuIFwiW1wiICsgc2VyaWFsaXplUGF0aChsb2dnZXJQYXRoQW5kTmFtZSkgKyBcIl1cIjtcblx0fTtcblxuXHR2YXIgbWFpbkxvZ2dlciA9IGNyZWF0ZUxvZ2dlcihcIm1haW5cIiwgW10sIHVuZGVmaW5lZCk7XG5cdG1haW5Mb2dnZXIucHVibGlzaExldmVsKFwid2FyblwiKTtcblx0bWFpbkxvZ2dlci5jb25zb2xlTGV2ZWwoXCJpbmZvXCIpO1xuXHRtYWluTG9nZ2VyLm1ldHJpY3NMZXZlbChcIndhcm5cIik7XG5cblx0cmV0dXJuIG1haW5Mb2dnZXI7XG59XG5cbmlmKHdpbmRvdy50aWNrNDI9PT11bmRlZmluZWQpeyB3aW5kb3cudGljazQyID0ge307IH1cbndpbmRvdy50aWNrNDIubG9nID0gbG9nZ2VyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2dlcjtcbiIsInZhciBvYmplY3RNZXRyaWNfMSA9IHJlcXVpcmUoXCIuLi9tZXRyaWNzL29iamVjdE1ldHJpY1wiKTtcclxudmFyIHN0cmluZ01ldHJpY18xID0gcmVxdWlyZShcIi4uL21ldHJpY3Mvc3RyaW5nTWV0cmljXCIpO1xyXG52YXIgbnVtYmVyTWV0cmljXzEgPSByZXF1aXJlKFwiLi4vbWV0cmljcy9udW1iZXJNZXRyaWNcIik7XHJcbnZhciB0aW1lc3RhbXBNZXRyaWNfMSA9IHJlcXVpcmUoXCIuLi9tZXRyaWNzL3RpbWVzdGFtcE1ldHJpY1wiKTtcclxudmFyIE1ldHJpY1NlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWV0cmljU2VyaWFsaXplcigpIHtcclxuICAgIH1cclxuICAgIE1ldHJpY1NlcmlhbGl6ZXIubWV0cmljVG9NZXNzYWdlID0gZnVuY3Rpb24gKG1ldHJpYykge1xyXG4gICAgICAgIHZhciBkZWYgPSBNZXRyaWNTZXJpYWxpemVyLl9nZXRNZXRyaWNEZWZpbml0aW9uKG1ldHJpYy5uYW1lLCBtZXRyaWMudmFsdWUsIG1ldHJpYy5wYXRoLCBtZXRyaWMudHlwZSwgbWV0cmljLmRlc2NyaXB0aW9uLCBtZXRyaWMucGVyaW9kLCBtZXRyaWMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IG1ldHJpYy5pZCxcclxuICAgICAgICAgICAgaW5zdGFuY2U6IG1ldHJpYy5yZXBvLmluc3RhbmNlLFxyXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBkZWYsXHJcbiAgICAgICAgICAgIHZhbHVlOiBNZXRyaWNTZXJpYWxpemVyLl9zZXJpYWxpemVWYWx1ZShtZXRyaWMudmFsdWUpLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgTWV0cmljU2VyaWFsaXplci5fZ2V0TWV0cmljRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcGF0aCwgdHlwZSwgZGVzY3JpcHRpb24sIHJlc29sdXRpb24sIHBlcmlvZCkge1xyXG4gICAgICAgIHZhciBkZWYgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgdHlwZTogdHlwZSA/IHR5cGUgOiBNZXRyaWNTZXJpYWxpemVyLl9nZXRUeXBlRnJvbVZhbHVlKHZhbHVlKSxcclxuICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcclxuICAgICAgICAgICAgcGVyaW9kOiBwZXJpb2RcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChkZWYudHlwZSA9PT0gb2JqZWN0TWV0cmljXzEuT2JqZWN0TWV0cmljLnR5cGUpIHtcclxuICAgICAgICAgICAgZGVmLkNvbXBvc2l0ZSA9IE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoZnVuY3Rpb24gKGFyciwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gdmFsdWVba2V5XTtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKE1ldHJpY1NlcmlhbGl6ZXIuX2dldE1ldHJpY0RlZmluaXRpb24oa2V5LCB2YWwsIHBhdGgpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgICAgIH0sIFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZjtcclxuICAgIH07XHJcbiAgICBNZXRyaWNTZXJpYWxpemVyLl9zZXJpYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLl92YWx1ZVR5cGVzLmluZGV4T2YoXCJkYXRlXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS52YWx1ZU9mKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheTogZmFsc2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBDb21wb3NpdGVWYWx1ZTogT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gTWV0cmljU2VyaWFsaXplci5fc2VyaWFsaXplVmFsdWUodmFsdWVba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsLklubmVyTWV0cmljTmFtZSA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgICAgICAgICB9LCBbXSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB7IHR5cGU6IHRoaXMuX3ZhbHVlVHlwZXMuaW5kZXhPZih0eXBlb2YgdmFsdWUpLCB2YWx1ZTogdmFsdWUsIGlzQXJyYXk6IGZhbHNlIH0gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWV0cmljU2VyaWFsaXplci5fZ2V0VHlwZUZyb21WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciB0eXBlQXNTdHJpbmcgPSB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSA/ICd0aW1lc3RhbXAnIDogdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZUFzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nTWV0cmljXzEuU3RyaW5nTWV0cmljLnR5cGU7XHJcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyTWV0cmljXzEuTnVtYmVyTWV0cmljLnR5cGU7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wTWV0cmljXzEuVGltZXN0YW1wTWV0cmljLnR5cGU7XHJcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0TWV0cmljXzEuT2JqZWN0TWV0cmljLnR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY1NlcmlhbGl6ZXIuX3ZhbHVlVHlwZXMgPSBbXHJcbiAgICAgICAgXCJib29sZWFuXCIsXHJcbiAgICAgICAgXCJpbnRcIixcclxuICAgICAgICBcIm51bWJlclwiLFxyXG4gICAgICAgIFwibG9uZ1wiLFxyXG4gICAgICAgIFwic3RyaW5nXCIsXHJcbiAgICAgICAgXCJkYXRlXCIsXHJcbiAgICAgICAgXCJvYmplY3RcIl07XHJcbiAgICByZXR1cm4gTWV0cmljU2VyaWFsaXplcjtcclxufSkoKTtcclxuZXhwb3J0cy5NZXRyaWNTZXJpYWxpemVyID0gTWV0cmljU2VyaWFsaXplcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0cmljU2VyaWFsaXplci5qcy5tYXAiLCJ2YXIgbWV0cmljU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vbWV0cmljU2VyaWFsaXplclwiKTtcclxudmFyIE1ldHJpY3NCcmlkZ2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWV0cmljc0JyaWRnZShyZXBvLCBjb25uZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9yZXBvID0gcmVwbztcclxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcclxuICAgICAgICBjb25uZWN0aW9uLm9uKCdtZXRyaWNzJywgXCJNZXRyaWNzU25hcHNob3RSZXF1ZXN0XCIsIGZ1bmN0aW9uIChpbnN0YW5jZUluZm8pIHtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlSW5mby5JbnN0YW5jZSAhPT0gcmVwby5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnNlbmRGdWxsKF90aGlzLl9yZXBvKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLnNlbmRGdWxsID0gZnVuY3Rpb24gKHJlcG8pIHtcclxuICAgICAgICB2YXIgcm9vdFN5c3RlbSA9IHJlcG8ucm9vdDtcclxuICAgICAgICBpZiAoIXJvb3RTeXN0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm9vdFN5c3RlbS5zdWJTeXN0ZW1zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW5kRnVsbFN5c3RlbShyb290U3lzdGVtKTtcclxuICAgIH07XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS5zZW5kRnVsbFN5c3RlbSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNyZWF0ZVN5c3RlbShzKTtcclxuICAgICAgICBzLnN1YlN5c3RlbXMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNlbmRGdWxsU3lzdGVtKChzdWIpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzLm1ldHJpY3MuZm9yRWFjaChmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICBfdGhpcy5jcmVhdGVNZXRyaWMobSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljc0JyaWRnZS5wcm90b3R5cGUuY3JlYXRlTWV0cmljID0gZnVuY3Rpb24gKG1ldHJpYykge1xyXG4gICAgICAgIHRoaXMuX3NlbmQoXCJDcmVhdGVNZXRyaWNcIiwgbWV0cmljU2VyaWFsaXplcl8xLk1ldHJpY1NlcmlhbGl6ZXIubWV0cmljVG9NZXNzYWdlKG1ldHJpYykpO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLnVwZGF0ZU1ldHJpYyA9IGZ1bmN0aW9uIChtZXRyaWMpIHtcclxuICAgICAgICB0aGlzLl9zZW5kKFwiVXBkYXRlTWV0cmljXCIsIG1ldHJpY1NlcmlhbGl6ZXJfMS5NZXRyaWNTZXJpYWxpemVyLm1ldHJpY1RvTWVzc2FnZShtZXRyaWMpKTtcclxuICAgIH07XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS5jcmVhdGVTeXN0ZW0gPSBmdW5jdGlvbiAoc3lzdGVtKSB7XHJcbiAgICAgICAgaWYgKHN5c3RlbS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZW5kKFwiQ3JlYXRlTWV0cmljU3lzdGVtXCIsIHtcclxuICAgICAgICAgICAgICAgIGlkOiBzeXN0ZW0uaWQsXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogc3lzdGVtLnJlcG8uaW5zdGFuY2UsXHJcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiB7IG5hbWU6IHN5c3RlbS5uYW1lLCBkZXNjcmlwdGlvbjogc3lzdGVtLmRlc2NyaXB0aW9uLCBwYXRoOiBzeXN0ZW0ucGF0aCB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS51cGRhdGVTeXN0ZW0gPSBmdW5jdGlvbiAoc3lzdGVtLCBzdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuX3NlbmQoXCJVcGRhdGVNZXRyaWNTeXN0ZW1cIiwge1xyXG4gICAgICAgICAgICBpZDogc3lzdGVtLmlkLFxyXG4gICAgICAgICAgICBpbnN0YW5jZTogc3lzdGVtLnJlcG8uaW5zdGFuY2UsXHJcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLmhlYXJ0YmVhdCA9IGZ1bmN0aW9uIChyZXBvLCBpbnRlcnZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NlbmQoXCJIZWFydGJlYXRNZXRyaWNzXCIsIHsgcHVibGlzaGluZ0ludGVydmFsOiBpbnRlcnZhbCwgaW5zdGFuY2U6IHJlcG8uaW5zdGFuY2UgfSk7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljc0JyaWRnZS5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZChcIm1ldHJpY3NcIiwgdHlwZSwgbWVzc2FnZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1ldHJpY3NCcmlkZ2U7XHJcbn0pKCk7XHJcbmV4cG9ydHMuTWV0cmljc0JyaWRnZSA9IE1ldHJpY3NCcmlkZ2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9ydC5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBBZGRyZXNzTWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBZGRyZXNzTWV0cmljLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWRkcmVzc01ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIEFkZHJlc3NNZXRyaWMudHlwZSwgdmFsdWUgfHwgJycpO1xyXG4gICAgfVxyXG4gICAgQWRkcmVzc01ldHJpYy50eXBlID0gODtcclxuICAgIHJldHVybiBBZGRyZXNzTWV0cmljO1xyXG59KShtZXRyaWNfMS5NZXRyaWMpO1xyXG5leHBvcnRzLkFkZHJlc3NNZXRyaWMgPSBBZGRyZXNzTWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzTWV0cmljLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIENvdW50TWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDb3VudE1ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvdW50TWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgQ291bnRNZXRyaWMudHlwZSwgdmFsdWUgfHwgMCk7XHJcbiAgICB9XHJcbiAgICBDb3VudE1ldHJpYy5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaW5jcmVtZW50QnkoMSk7XHJcbiAgICB9O1xyXG4gICAgQ291bnRNZXRyaWMucHJvdG90eXBlLmRlY3JlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRlY3JlbWVudEJ5KDEpO1xyXG4gICAgfTtcclxuICAgIENvdW50TWV0cmljLnByb3RvdHlwZS5pbmNyZW1lbnRCeSA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKHRoaXMudmFsdWUgfHwgMCkgKyBuKTtcclxuICAgIH07XHJcbiAgICBDb3VudE1ldHJpYy5wcm90b3R5cGUuZGVjcmVtZW50QnkgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCh0aGlzLnZhbHVlIHx8IDApIC0gbik7XHJcbiAgICB9O1xyXG4gICAgQ291bnRNZXRyaWMudHlwZSA9IDM7XHJcbiAgICByZXR1cm4gQ291bnRNZXRyaWM7XHJcbn0pKG1ldHJpY18xLk1ldHJpYyk7XHJcbmV4cG9ydHMuQ291bnRNZXRyaWMgPSBDb3VudE1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y291bnRNZXRyaWMuanMubWFwIiwidmFyIE1ldHJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdHlwZSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBkZWYubmFtZTtcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVmLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMucmVwbyA9IHBhcmVudC5yZXBvO1xyXG4gICAgICAgIHRoaXMuaWQgPSBwYXJlbnQucGF0aCArIFwiL1wiICsgdGhpcy5uYW1lO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhcmVudC5wYXRoLnNsaWNlKDApO1xyXG4gICAgICAgIHRoaXMucGF0aC5wdXNoKHBhcmVudC5uYW1lKTtcclxuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmNyZWF0ZU1ldHJpYyh0aGlzKTtcclxuICAgIH1cclxuICAgIE1ldHJpYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC51cGRhdGVNZXRyaWModGhpcyk7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljLnR5cGUgPSAwO1xyXG4gICAgcmV0dXJuIE1ldHJpYztcclxufSkoKTtcclxuZXhwb3J0cy5NZXRyaWMgPSBNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldHJpYy5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBOdW1iZXJNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE51bWJlck1ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE51bWJlck1ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIE51bWJlck1ldHJpYy50eXBlLCB2YWx1ZSB8fCAwKTtcclxuICAgIH1cclxuICAgIE51bWJlck1ldHJpYy5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaW5jcmVtZW50QnkoMSk7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVyTWV0cmljLnByb3RvdHlwZS5kZWNyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kZWNyZW1lbnRCeSgxKTtcclxuICAgIH07XHJcbiAgICBOdW1iZXJNZXRyaWMucHJvdG90eXBlLmluY3JlbWVudEJ5ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgodGhpcy52YWx1ZSB8fCAwKSArIG4pO1xyXG4gICAgfTtcclxuICAgIE51bWJlck1ldHJpYy5wcm90b3R5cGUuZGVjcmVtZW50QnkgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCh0aGlzLnZhbHVlIHx8IDApIC0gbik7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVyTWV0cmljLnR5cGUgPSAyO1xyXG4gICAgcmV0dXJuIE51bWJlck1ldHJpYztcclxufSkobWV0cmljXzEuTWV0cmljKTtcclxuZXhwb3J0cy5OdW1iZXJNZXRyaWMgPSBOdW1iZXJNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlck1ldHJpYy5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBPYmplY3RNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE9iamVjdE1ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE9iamVjdE1ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIE9iamVjdE1ldHJpYy50eXBlLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3RNZXRyaWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdE1ldHJpYy50eXBlID0gMTE7XHJcbiAgICByZXR1cm4gT2JqZWN0TWV0cmljO1xyXG59KShtZXRyaWNfMS5NZXRyaWMpO1xyXG5leHBvcnRzLk9iamVjdE1ldHJpYyA9IE9iamVjdE1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0TWV0cmljLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIFJhdGVNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJhdGVNZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSYXRlTWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wZXJpb2QgPSBkZWYucGVyaW9kO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IGRlZi5yZXNvbHV0aW9uO1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIFJhdGVNZXRyaWMudHlwZSwgdmFsdWUgfHwgMCk7XHJcbiAgICB9XHJcbiAgICBSYXRlTWV0cmljLnR5cGUgPSA0O1xyXG4gICAgcmV0dXJuIFJhdGVNZXRyaWM7XHJcbn0pKG1ldHJpY18xLk1ldHJpYyk7XHJcbmV4cG9ydHMuUmF0ZU1ldHJpYyA9IFJhdGVNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhdGVNZXRyaWMuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgU3RhdGlzdGljc01ldHJpYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU3RhdGlzdGljc01ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0YXRpc3RpY3NNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLnBlcmlvZCA9IGRlZi5wZXJpb2Q7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gZGVmLnJlc29sdXRpb247XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgU3RhdGlzdGljc01ldHJpYy50eXBlLCB2YWx1ZSB8fCAwKTtcclxuICAgIH1cclxuICAgIFN0YXRpc3RpY3NNZXRyaWMudHlwZSA9IDY7XHJcbiAgICByZXR1cm4gU3RhdGlzdGljc01ldHJpYztcclxufSkobWV0cmljXzEuTWV0cmljKTtcclxuZXhwb3J0cy5TdGF0aXN0aWNzTWV0cmljID0gU3RhdGlzdGljc01ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGlzdGljc01ldHJpYy5qcy5tYXAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBTdHJpbmdNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFN0cmluZ01ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0cmluZ01ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIFN0cmluZ01ldHJpYy50eXBlLCB2YWx1ZSB8fCAnJyk7XHJcbiAgICB9XHJcbiAgICBTdHJpbmdNZXRyaWMudHlwZSA9IDE7XHJcbiAgICByZXR1cm4gU3RyaW5nTWV0cmljO1xyXG59KShtZXRyaWNfMS5NZXRyaWMpO1xyXG5leHBvcnRzLlN0cmluZ01ldHJpYyA9IFN0cmluZ01ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nTWV0cmljLmpzLm1hcCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIFRpbWVzcGFuTWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUaW1lc3Bhbk1ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVzcGFuTWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgVGltZXNwYW5NZXRyaWMudHlwZSwgdmFsdWUgfHwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgVGltZXNwYW5NZXRyaWMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xyXG4gICAgfTtcclxuICAgIFRpbWVzcGFuTWV0cmljLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBUaW1lc3Bhbk1ldHJpYy50eXBlID0gMTA7XHJcbiAgICByZXR1cm4gVGltZXNwYW5NZXRyaWM7XHJcbn0pKG1ldHJpY18xLk1ldHJpYyk7XHJcbmV4cG9ydHMuVGltZXNwYW5NZXRyaWMgPSBUaW1lc3Bhbk1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXNwYW5NZXRyaWMuanMubWFwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgVGltZXN0YW1wTWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUaW1lc3RhbXBNZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lc3RhbXBNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCBUaW1lc3RhbXBNZXRyaWMudHlwZSwgdmFsdWUgfHwgbmV3IERhdGUoKSk7XHJcbiAgICB9XHJcbiAgICBUaW1lc3RhbXBNZXRyaWMucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZShuZXcgRGF0ZSgpKTtcclxuICAgIH07XHJcbiAgICBUaW1lc3RhbXBNZXRyaWMudHlwZSA9IDc7XHJcbiAgICByZXR1cm4gVGltZXN0YW1wTWV0cmljO1xyXG59KShtZXRyaWNfMS5NZXRyaWMpO1xyXG5leHBvcnRzLlRpbWVzdGFtcE1ldHJpYyA9IFRpbWVzdGFtcE1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXN0YW1wTWV0cmljLmpzLm1hcCIsInZhciBzeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL3N5c3RlbVwiKTtcclxudmFyIHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vYnJpZGdlL3RyYW5zcG9ydFwiKTtcclxudmFyIFJlcG9zaXRvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVwb3NpdG9yeShjb25maWcpIHtcclxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydF8xLk1ldHJpY3NCcmlkZ2UodGhpcywgY29uZmlnLmNvbm5lY3Rpb24pO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBjb25maWcuaWRlbnRpdHkuc3lzdGVtICsgJy8nICsgY29uZmlnLmlkZW50aXR5LnNlcnZpY2UgKyAnLycgKyBjb25maWcuaWRlbnRpdHkuaW5zdGFuY2U7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eSA9IGNvbmZpZy5pZGVudGl0eTtcclxuICAgICAgICB0aGlzLl9zdGFydEhlYXJ0YmVhdGluZygpO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IG5ldyBzeXN0ZW1fMS5TeXN0ZW0oJycsIHRoaXMsIHRoaXMuX3RyYW5zcG9ydCk7XHJcbiAgICAgICAgdGhpcy5faW5pdFN5c3RlbU1ldHJpY3ModGhpcy5yb290LCBjb25maWcuY2xpY2tTdHJlYW0gfHwgY29uZmlnLmNsaWNrU3RyZWFtID09PSB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgUmVwb3NpdG9yeS5wcm90b3R5cGUuX3N0YXJ0SGVhcnRiZWF0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmhlYXJ0YmVhdCh0aGlzLCB0aGlzLl9jb25maWcuc2V0dGluZ3MuaGVhcnRiZWF0SW50ZXJ2YWwpO1xyXG4gICAgICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3RyYW5zcG9ydC5oZWFydGJlYXQoX3RoaXMsIF90aGlzLl9jb25maWcuc2V0dGluZ3MuaGVhcnRiZWF0SW50ZXJ2YWwpO1xyXG4gICAgICAgIH0sIHRoaXMuX2NvbmZpZy5zZXR0aW5ncy5oZWFydGJlYXRJbnRlcnZhbCk7XHJcbiAgICB9O1xyXG4gICAgUmVwb3NpdG9yeS5wcm90b3R5cGUuX2luaXRTeXN0ZW1NZXRyaWNzID0gZnVuY3Rpb24gKHJvb3RTeXN0ZW0sIHVzZUNsaWNrU3RyZWFtKSB7XHJcbiAgICAgICAgaWYgKG5hdmlnYXRvcikge1xyXG4gICAgICAgICAgICByb290U3lzdGVtLnN0cmluZ01ldHJpYygnVXNlckFnZW50JywgbmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1c2VDbGlja1N0cmVhbSAmJiBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICB2YXIgY2xpY2tTdHJlYW0gPSByb290U3lzdGVtLnN1YlN5c3RlbShcIkNsaWNrU3RyZWFtXCIpO1xyXG4gICAgICAgICAgICB2YXIgZG9jdW1lbnRDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlLnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNsaWNrU3RyZWFtLm9iamVjdE1ldHJpYyhcIkxhc3RCcm93c2VyRXZlbnRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2xpY2tcIixcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZS50YXJnZXQgPyBlLnRhcmdldC5jbGFzc05hbWUgOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGUudGFyZ2V0LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnPCcgKyBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGUudGFyZ2V0LmhyZWYgfHwgXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjbGlja1N0cmVhbS5vYmplY3RNZXRyaWMoXCJQYWdlXCIsIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBkb2N1bWVudC50aXRsZSxcclxuICAgICAgICAgICAgICAgIHBhZ2U6IHdpbmRvdy5sb2NhdGlvbi5ocmVmXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBkb2N1bWVudENsaWNrSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgnb25jbGljaycsIGRvY3VtZW50Q2xpY2tIYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVwb3NpdG9yeTtcclxufSkoKTtcclxuZXhwb3J0cy5SZXBvc2l0b3J5ID0gUmVwb3NpdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwb3NpdG9yeS5qcy5tYXAiLCJ2YXIgbnVtYmVyTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL251bWJlck1ldHJpY1wiKTtcclxudmFyIHRpbWVzcGFuTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL3RpbWVzcGFuTWV0cmljXCIpO1xyXG52YXIgc3RyaW5nTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL3N0cmluZ01ldHJpY1wiKTtcclxudmFyIGFkZHJlc3NNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MvYWRkcmVzc01ldHJpY1wiKTtcclxudmFyIG9iamVjdE1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljcy9vYmplY3RNZXRyaWNcIik7XHJcbnZhciB0aW1lc3RhbXBNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MvdGltZXN0YW1wTWV0cmljXCIpO1xyXG52YXIgY291bnRNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MvY291bnRNZXRyaWNcIik7XHJcbnZhciBzdGF0aXN0aWNzTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL3N0YXRpc3RpY3NNZXRyaWNcIik7XHJcbnZhciByYXRlTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL3JhdGVNZXRyaWNcIik7XHJcbnZhciBTeXN0ZW0gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3lzdGVtKG5hbWUsIHJlcG8sIHRyYW5zcG9ydCwgcGFyZW50LCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIHRoaXMubWV0cmljcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3ViU3lzdGVtcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uIHx8ICcnO1xyXG4gICAgICAgIHRoaXMucmVwbyA9IHJlcG87XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMuX2J1aWxkUGF0aCh0aGlzLnBhcmVudCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICh0aGlzLnBhdGgubGVuZ3RoID4gMCA/IHRoaXMucGF0aC5qb2luKCcvJykgKyAnLycgOiAnJykgKyB0aGlzLm5hbWU7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eSA9IHJlcG8uaWRlbnRpdHk7XHJcbiAgICAgICAgdGhpcy5yb290ID0gcmVwby5yb290O1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5jcmVhdGVTeXN0ZW0odGhpcyk7XHJcbiAgICB9XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnN1YlN5c3RlbSA9IGZ1bmN0aW9uIChuYW1lLCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIGlmICghbmFtZSB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nU3lzdGVtcyA9IHRoaXMuc3ViU3lzdGVtcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMubmFtZSA9PT0gbmFtZTsgfSk7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nU3lzdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1N5c3RlbXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzeXN0ZW0gPSBuZXcgU3lzdGVtKG5hbWUsIHRoaXMucmVwbywgdGhpcy5fdHJhbnNwb3J0LCB0aGlzLCBkZXNjcmlwdGlvbik7XHJcbiAgICAgICAgdGhpcy5zdWJTeXN0ZW1zLnB1c2goc3lzdGVtKTtcclxuICAgICAgICByZXR1cm4gc3lzdGVtO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnVwZGF0ZVN5c3RlbSh0aGlzLCB7IHN0YXRlOiBzdGF0ZSwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuc3RyaW5nTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgc3RyaW5nTWV0cmljXzEuU3RyaW5nTWV0cmljLnR5cGUsIHZhbHVlLCBmdW5jdGlvbiAobWV0cmljRGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RyaW5nTWV0cmljXzEuU3RyaW5nTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLm51bWJlck1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIG51bWJlck1ldHJpY18xLk51bWJlck1ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG51bWJlck1ldHJpY18xLk51bWJlck1ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5jb3VudE1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIGNvdW50TWV0cmljXzEuQ291bnRNZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3VudE1ldHJpY18xLkNvdW50TWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLmFkZHJlc3NNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCBhZGRyZXNzTWV0cmljXzEuQWRkcmVzc01ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFkZHJlc3NNZXRyaWNfMS5BZGRyZXNzTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLm9iamVjdE1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIG9iamVjdE1ldHJpY18xLk9iamVjdE1ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG9iamVjdE1ldHJpY18xLk9iamVjdE1ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS50aW1lc3Bhbk1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIHRpbWVzcGFuTWV0cmljXzEuVGltZXNwYW5NZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aW1lc3Bhbk1ldHJpY18xLlRpbWVzcGFuTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnRpbWVzdGFtcE1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIHRpbWVzdGFtcE1ldHJpY18xLlRpbWVzdGFtcE1ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRpbWVzdGFtcE1ldHJpY18xLlRpbWVzdGFtcE1ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5yYXRlTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgcmF0ZU1ldHJpY18xLlJhdGVNZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByYXRlTWV0cmljXzEuUmF0ZU1ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5zdGF0aXRpY3NNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCBzdGF0aXN0aWNzTWV0cmljXzEuU3RhdGlzdGljc01ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRpc3RpY3NNZXRyaWNfMS5TdGF0aXN0aWNzTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLl91bmlvblRvTWV0cmljRGVmID0gZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcclxuICAgICAgICB2YXIgbWV0cmljRGVmO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbWV0cmljRGVmID0geyBuYW1lOiBkZWZpbml0aW9uIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXRyaWNEZWYgPSBkZWZpbml0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWV0cmljRGVmLm5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldHJpYyBuYW1lIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWV0cmljRGVmO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuX2dldE9yQ3JlYXRlTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIGV4cGVjdGVkVHlwZSwgdmFsdWUsIGNyZWF0ZUZ1bmMpIHtcclxuICAgICAgICB2YXIgbWV0cmljRGVmID0gdGhpcy5fdW5pb25Ub01ldHJpY0RlZihkZWZpbml0aW9uKTtcclxuICAgICAgICB2YXIgbWF0Y2hpbmdNZXRyaWNzID0gdGhpcy5tZXRyaWNzLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lID09PSBtZXRyaWNEZWYubmFtZTsgfSk7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nTWV0cmljcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBleGlzdGluZ01ldHJpYyA9IG1hdGNoaW5nTWV0cmljc1swXTtcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nTWV0cmljLnR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIG1ldHJpYyBuYW1lZCAnICsgbWV0cmljRGVmLm5hbWUgKyAnIGlzIGFscmVhZHkgZGVmaW5lZCB3aXRoIGRpZmZlcmVudCB0eXBlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nTWV0cmljLnVwZGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nTWV0cmljO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV3TWV0cmljID0gY3JlYXRlRnVuYyhtZXRyaWNEZWYpO1xyXG4gICAgICAgIHRoaXMubWV0cmljcy5wdXNoKG5ld01ldHJpYyk7XHJcbiAgICAgICAgcmV0dXJuIG5ld01ldHJpYztcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLl9idWlsZFBhdGggPSBmdW5jdGlvbiAoc3lzdGVtKSB7XHJcbiAgICAgICAgaWYgKCFzeXN0ZW0gfHwgIXN5c3RlbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuX2J1aWxkUGF0aChzeXN0ZW0ucGFyZW50KTtcclxuICAgICAgICBwYXRoLnB1c2goc3lzdGVtLm5hbWUpO1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTeXN0ZW07XHJcbn0pKCk7XHJcbmV4cG9ydHMuU3lzdGVtID0gU3lzdGVtO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zeXN0ZW0uanMubWFwIiwidmFyIHJlcG9zaXRvcnlfMSA9IHJlcXVpcmUoXCIuL2NvcmUvcmVwb3NpdG9yeVwiKTtcclxudmFyIHRpY2s0Ml9nYXRld2F5X2Nvbm5lY3Rpb25fMSA9IHJlcXVpcmUoJ3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24nKTtcclxudmFyIHdpbmRvd0FzQW55ID0gd2luZG93O1xyXG53aW5kb3dBc0FueS50aWNrNDIgPSB3aW5kb3dBc0FueS50aWNrNDIgfHwge307XHJcbndpbmRvd0FzQW55LnRpY2s0Mi5tZXRyaWNzID0gd2luZG93QXNBbnkudGljazQyLm1ldHJpY3MgfHwgZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgaWYgKCFjb25maWcuaWRlbnRpdHkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5IG1pc3NpbmcgZnJvbSBtZXRyaWNzIGNvbmZpZ3VyYXRpb24nKTtcclxuICAgIH1cclxuICAgIGlmICghY29uZmlnLmlkZW50aXR5LnNlcnZpY2UgfHwgdHlwZW9mIGNvbmZpZy5pZGVudGl0eS5zZXJ2aWNlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmljZSBtaXNzaW5nIG9yIGludmFsaWQgaW4gbWV0cmljcyBpZGVudGl0eSBjb25maWd1cmF0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNvbmZpZy5pZGVudGl0eS5zeXN0ZW0gfHwgdHlwZW9mIGNvbmZpZy5pZGVudGl0eS5zeXN0ZW0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTeXN0ZW0gbWlzc2luZyBvciBpbnZhbGlkIGluIG1ldHJpY3MgaWRlbnRpdHkgY29uZmlndXJhdGlvbicpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjb25maWcuaWRlbnRpdHkuaW5zdGFuY2UgfHwgdHlwZW9mIGNvbmZpZy5pZGVudGl0eS5pbnN0YW5jZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RhbmNlbWlzc2luZyBvciBpbnZhbGlkIGluIG1ldHJpY3MgaWRlbnRpdHkgY29uZmlndXJhdGlvbicpO1xyXG4gICAgfVxyXG4gICAgY29uZmlnLnNldHRpbmdzID0gY29uZmlnLnNldHRpbmdzIHx8IHt9O1xyXG4gICAgY29uZmlnLnNldHRpbmdzLmhlYXJ0YmVhdEludGVydmFsID0gY29uZmlnLnNldHRpbmdzLmhlYXJ0YmVhdEludGVydmFsIHx8IDE1MDAwO1xyXG4gICAgaWYgKHR5cGVvZiBjb25maWcuY29ubmVjdGlvbiAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGNvbmZpZy5jb25uZWN0aW9uID0ge307XHJcbiAgICB9XHJcbiAgICBpZiAoISh0eXBlb2YgY29uZmlnLmNvbm5lY3Rpb24gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbmZpZy5jb25uZWN0aW9uLnNlbmQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY29uZmlnLmNvbm5lY3Rpb24ub24gPT09IFwiZnVuY3Rpb25cIikpIHtcclxuICAgICAgICBjb25maWcuY29ubmVjdGlvbiA9IHRpY2s0Ml9nYXRld2F5X2Nvbm5lY3Rpb25fMS5jb25uZWN0aW9uKGNvbmZpZy5jb25uZWN0aW9uKTtcclxuICAgIH1cclxuICAgIHZhciByZXBvID0gbmV3IHJlcG9zaXRvcnlfMS5SZXBvc2l0b3J5KGNvbmZpZyk7XHJcbiAgICByZXBvWyd2ZXJzaW9uJ10gPSByZXBvLnJvb3RbJ3ZlcnNpb24nXSA9ICcyLjAuMTAnO1xyXG4gICAgcmV0dXJuIHJlcG8ucm9vdDtcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dBc0FueS50aWNrNDIubWV0cmljcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0cmljc01vZHVsZS5qcy5tYXAiLCJ2YXIgd2luZG93cyA9IGZ1bmN0aW9uKGFnbSl7XHJcblx0XHJcblx0aWYoYWdtLnN1YnNjcmliZSl7XHJcblx0XHRhZ20uc3Vic2NyaWJlKFwiVDQyLlduZC5XaW5kb3dTdGF0ZUNoYW5nZWRcIiwge3RhcmdldDpcImFsbFwifSkudGhlbihmdW5jdGlvbihzdHJlYW0pe1xyXG5cdFx0XHRzdHJlYW0ub25EYXRhKGZ1bmN0aW9uIChzdHJlYW1EYXRhKSB7XHJcblx0XHRcdFx0dXBkYXRlX3dpbmRvdyhzdHJlYW1EYXRhLmRhdGEsIGNvbnRhaW5lcl9mcm9tX2ZpbHRlcihzdHJlYW1EYXRhLnNlcnZlcikpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIGF0dGFjaCBjYWxsYmFja3NcclxuXHRcdFx0Ly9zdHJlYW0ub24oXCJlbmRcIiwgaGFuZGxlU3RyZWFtQ2xvc2VkKTtcclxuXHRcdFx0Ly9zdHJlYW0ub24oXCJjbG9zZVwiLCBoYW5kbGVTdHJlYW1DbG9zZWQpO1xyXG5cclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblx0Ly9TdG9yZSB3aW5kb3dzIHRoYXQgYXJlIHRyYWNrZWQgYnkgSUQgYW5kIHJlY2VpdmUgdXBkYXRlc1x0XHJcblx0dmFyIHdpbmRvd3MgPSB7fTtcdFxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVfd2luZG93ICh3aW5kb3dfaW5mbywgY29udGFpbmVyX25hbWUpe1xyXG5cdFx0XHJcblx0XHR2YXIgd2luZG93X2lkID0gY29udGFpbmVyX25hbWUrXCIuXCIrd2luZG93X2luZm8ud2luZG93TmFtZTtcclxuXHJcblx0XHR2YXIgdGhlX3dpbmRvdyA9IHdpbmRvd3Nbd2luZG93X2lkXTtcclxuXHRcdCBcclxuXHRcdGlmICh0aGVfd2luZG93ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Ly9JZiB0aGUgdXNlciBpcyBzdWJzY3JpYmVkIGZvciB0aGUgZ2xvYmFsIGV2ZW50cywgY3JlYXRlIHRoZSB3aW5kb3cgb2JqZWN0LlxyXG5cdFx0XHRpZiggZ2V0X2NhbGxiYWNrcyh3aW5kb3dfYWRkZWRfY2FsbGJhY2tzLCBjb250YWluZXJfbmFtZSkubGVuZ3RoID4gMCB8fCBnZXRfY2FsbGJhY2tzKHdpbmRvd19yZW1vdmVkX2NhbGxiYWNrcywgY29udGFpbmVyX25hbWUpLmxlbmd0aCA+IDAgKSB7XHJcblx0XHRcdFx0dGhlX3dpbmRvdyA9IGFfd2luZG93X2Zyb20od2luZG93X2luZm8ud2luZG93TmFtZSwgY29udGFpbmVyX25hbWUsIHdpbmRvd19pbmZvLnVybCwgd2luZG93X2luZm8ud2luZG93SWQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRpZih0aGVfd2luZG93LmlkID09PSB1bmRlZmluZWQpe1xyXG5cdFx0XHR0aGVfd2luZG93LmlkID0gd2luZG93X2luZm8ud2luZG93SWQ7XHJcblx0XHRcdGV4ZWNfY2FsbGJhY2tzKHRoZV93aW5kb3cuY2FsbGJhY2tzLm9uX2F2YWlsYWJsZSwgdGhlX3dpbmRvdyk7XHJcblx0XHR9IFxyXG5cdFx0XHJcblx0XHRpZiAodGhlX3dpbmRvdy51cmwgIT09IHdpbmRvd19pbmZvLnVybCl7XHJcblx0XHRcdHRoZV93aW5kb3cudXJsID0gd2luZG93X2luZm8udXJsO1xyXG5cdFx0XHRleGVjX2NhbGxiYWNrcyh0aGVfd2luZG93LmNhbGxiYWNrcy5vbl91cmxfY2hhbmdlZCwgd2luZG93X2luZm8udXJsKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYod2luZG93X2luZm8uc3RhdGUgPT09XCJDcmVhdGVkXCIpe1xyXG5cdFx0XHQvL0V4ZWN1dGUgZ2xvYmFsIFwid2luZG93X2FkZGVkXCIgY2FsbGJhY2tzXHJcblx0XHRcdGV4ZWNfY2FsbGJhY2tzKGdldF9jYWxsYmFja3Mod2luZG93X2FkZGVkX2NhbGxiYWNrcywgY29udGFpbmVyX25hbWUpLCB0aGVfd2luZG93KTtcclxuXHRcdH0gXHJcblx0XHRcdFxyXG5cdFx0Ly9DbGVhciB0aGUgd2luZG93IG9uIGNsb3NlIGV2ZW50XHJcblx0XHRpZih3aW5kb3dfaW5mby5zdGF0ZSA9PT1cIkNsb3NlZFwiKXtcclxuXHRcdFx0Ly9FeGVjdXRlIGdsb2JhbCBcIndpbmRvd19yZW1vdmVkXCIgY2FsbGJhY2tzXHJcblx0XHRcdGV4ZWNfY2FsbGJhY2tzKGdldF9jYWxsYmFja3Mod2luZG93X3JlbW92ZWRfY2FsbGJhY2tzLCBjb250YWluZXJfbmFtZSksIHRoZV93aW5kb3cpO1xyXG5cdFx0XHQvL0V4ZWN1dGUgd2luZG93LXNwZWNpZmljIFwid2luZG93X3JlbW92ZWRcIiBjYWxsYmFja3NcclxuXHRcdFx0ZXhlY19jYWxsYmFja3ModGhlX3dpbmRvdy5jYWxsYmFja3Mub25fY2xvc2UpO1xyXG5cdFx0XHQvL1JlZnJlc2ggdGhlIHdpbmRvdyBvYmplY3Qgc3RhdGVcclxuXHRcdFx0dGhlX3dpbmRvdy5pZCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0dGhlX3dpbmRvdy5jYWxsYmFja3MgPSB7fTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHQvL0NyZWF0ZSBhIGRpY3Rpb25hcnkgdG8gc3RvcmUgdGhlIGNhbGxiYWNrcyBmb3IgdGhlIG1ldGhvZCBcIndpbmRvd19hZGRlZFwiLlxyXG5cdHZhciB3aW5kb3dfYWRkZWRfY2FsbGJhY2tzID0ge1xyXG5cdFx0Y29udGFpbmVyc19jYWxsYmFja3M6IHt9LCBcclxuXHRcdGFsbF9jb250YWluZXJzX2NhbGxiYWNrczogW11cclxuXHR9O1x0XHJcblx0XHJcblx0Ly9DcmVhdGUgYSBkaWN0aW9uYXJ5IHRvIHN0b3JlIHRoZSBjYWxsYmFja3MgZm9yIHRoZSBtZXRob2QgXCJ3aW5kb3dfcmVtb3ZlZFwiLlxyXG5cdHZhciB3aW5kb3dfcmVtb3ZlZF9jYWxsYmFja3MgPSB7XHJcblx0XHRjb250YWluZXJzX2NhbGxiYWNrczoge30sXHJcblx0XHRhbGxfY29udGFpbmVyc19jYWxsYmFja3M6IFtdXHJcblx0fTtcclxuXHRcclxuXHQvL0NyZWF0ZXMgYSBuZXcgd2luZG93IG9iamVjdCBvciByZXR1cm5zIGFuIGV4aXN0aW5nIG9uZVxyXG5cdC8vQWNjZXB0cyB3aW5kb3cgbmFtZSwgY29udGFpbmVyIGFuZCBVUkxcclxuXHQvL1JldHVybnMgYSB3aW5kb3cgb2JqZWN0LlxyXG5cdFxyXG5cdC8vSXQgaXMgbm90IGd1YXJhbnRlZWQgdG8gcmV0dXJuIHRoZSB3aW5kb3cgd2l0aCB0aGUgc2FtZSBVUkwgYW5kIElEXHJcblx0ZnVuY3Rpb24gYV93aW5kb3dfZnJvbShuYW1lLCBjb250YWluZXIsIHVybCwgaWQpe1xyXG5cdFx0XHJcblx0XHQvL0J5IGRlZmF1bHQgd2UgYXJlIHVzaW5nIG91ciBvd24gY29udGFpbmVyXHJcblx0XHRjb250YWluZXIgPSBjb250YWluZXJ8fCh3aW5kb3cuaHRtbENvbnRhaW5lciAhPT0gdW5kZWZpbmVkP2h0bWxDb250YWluZXIuY29udGFpbmVyTmFtZTp1bmRlZmluZWQpO1xyXG5cdFx0XHJcblx0XHQvL1Rocm93IGlmIHdlIGRvbid0IGtub3cgdGhlIGNvbnRhaW5lciwgdGhyb3dcclxuXHRcdGlmKGNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKXt0aHJvdyBcIlBsZWFzZSBzcGVjaWZ5IGEgY29udGFpbmVyLlwiO31cclxuXHJcblx0XHR2YXIgd2luZG93X2lkID0gY29udGFpbmVyK1wiLlwiK25hbWU7XHJcblx0XHRcclxuXHRcdHZhciBleGlzdGluZ193aW5kb3cgPSB3aW5kb3dzW3dpbmRvd19pZF0gO1xyXG5cclxuXHRcdGlmKGV4aXN0aW5nX3dpbmRvdyE9PXVuZGVmaW5lZCl7XHJcblx0XHRcdFxyXG5cdFx0XHQvL0lmIHRoZSB3aW5kb3cgaXMgY2xvc2VkLCB1cGRhdGUgdGhlIFVSTCBpbiB0aGUgcmVmZXJlbmNlXHJcblx0XHRcdGlmKCFleGlzdGluZ193aW5kb3cub3BlbmVkKCkpe1xyXG5cdFx0XHRcdGV4aXN0aW5nX3dpbmRvdy51cmwgPSB1cmw7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGV4aXN0aW5nX3dpbmRvdztcclxuXHRcdH1lbHNle1xyXG5cclxuXHRcdFx0Ly9Jbml0IG9iamVjdFxyXG5cdFx0XHR2YXIgd2luZG93X29iaiA9IE9iamVjdC5jcmVhdGUod2luZG93X3Byb3RvKTtcclxuXHRcdFx0d2luZG93X29iai5uYW1lID0gbmFtZTtcclxuXHRcdFx0d2luZG93X29iai5jb250YWluZXIgPSBjb250YWluZXI7XHJcblx0XHRcdHdpbmRvd19vYmoudXJsID0gdXJsO1xyXG4gICAgICAgICAgICB3aW5kb3dfb2JqLmlkID0gaWQ7XHJcblx0XHRcdHdpbmRvd19vYmouY2FsbGJhY2tzID0ge307XHRcdFx0XHJcblxyXG5cdFx0XHQvL0luc2VydCBBR00gc2VydmVyIHByb3BlcnRpZXNcclxuXHRcdFx0d2luZG93X29iai5hcHBsaWNhdGlvbiA9IHdpbmRvd19pZDtcclxuXHRcdFx0XHJcblx0XHRcdHdpbmRvd3Nbd2luZG93X2lkXSA9IHdpbmRvd19vYmo7XHJcblxyXG5cdFx0XHRyZXR1cm4gd2luZG93X29iajtcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0Ly9CaW5kcyBhIGdpdmVuIHdpbmRvdyBvYmplY3QgdG8gYW4gYWN0dWFsIHdpbmRvd1xyXG5cdGZ1bmN0aW9uIGJpbmRfd2luZG93KHRoZV93aW5kb3csIHN1Y2Nlc3MsIGVycm9yKXtcclxuXHRcdFxyXG5cdFx0Ly9UeXBpY2FsbHkgdGhlIGJpbmRpbmcgb2NjdXJzIHdoZW4gd2UgcmVjZWl2ZSBhbiBldmVudCwgc28gd2Ugd2lsbCByZXRyaWV2ZSBzb21lIGluZm8gYWJvdXQgdGhlIHdpbmRvd1xyXG5cdFx0Ly9hbmQgaWYgaXQgZXhpc3RzIHdlIHdpbGwgdHJpZ2dlciBhbiBhcnRpZmljaWFsIGV2ZW50IHdpdGggaXQuIFxyXG5cclxuXHRcdC8vQ2hlY2sgaWYgdGhlIHdpbmRvdyBpc24ndCBhbHJlYWR5IGJvdW5kXHJcblx0XHRpZih0aGVfd2luZG93LmlkPT09dW5kZWZpbmVkKXtcclxuXHRcdFx0XHJcblx0XHRcdC8vUmV0cmlldmUgd2luZG93IHBhcmFtZXRlcnMgXHRcclxuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5XbmQuRmluZEJ5TmFtZVwiLCB7d2luZG93TmFtZTp0aGVfd2luZG93Lm5hbWV9LCBjb250YWluZXJfZmlsdGVyKHRoZV93aW5kb3cuY29udGFpbmVyKSwge30sIGJpbmRfZnJvbV9pbmZvLCBlcnJvcik7XHJcblx0XHRcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRpbnZva2VfYWdtX3N1Y2Nlc3NfY2FsbGJhY2soc3VjY2VzcywgdGhlX3dpbmRvdyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhlX3dpbmRvdztcclxuXHJcblx0XHRmdW5jdGlvbiBiaW5kX2Zyb21faW5mbyhlKXtcclxuXHRcdFx0Ly9SZXRyaWV2ZSB3aW5kb3cgaW5mbyAoYSBiaXQgaGFja3kgYmVjYXVzZSB0aGUgcmVzcG9uc2UgZm9ybWF0IGlzIHdlaXJkKVxyXG5cdFx0XHR2YXIgd2luZG93X2luZm8gPSB2YWxzKGUucmV0dXJuZWQpWzBdO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYod2luZG93X2luZm89PT11bmRlZmluZWQpe1xyXG5cdFx0XHRcdGlmKHR5cGVvZiBlcnJvciA9PT0gXCJmdW5jdGlvblwiKXtlcnJvcihcIndlIGNvdW5kIG5vdCBvcGVuL2ZpbmQgdGhpcyB3aW5kb3dcIik7fVxyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHQvL1RyaWdnZXIgYW4gZXZlbnRcclxuXHRcdFx0XHR3aW5kb3dfaW5mby5zdGF0ZSA9IFwiQXR0YWNoZWRcIjtcclxuXHRcdFx0XHR1cGRhdGVfd2luZG93KHdpbmRvd19pbmZvLCB0aGVfd2luZG93LmNvbnRhaW5lcik7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly9FeGVjIHVzZXIgY2FsbGJhY2tcclxuXHRcdFx0XHRpbnZva2VfYWdtX3N1Y2Nlc3NfY2FsbGJhY2soc3VjY2VzcywgdGhlX3dpbmRvdyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vRnVuY3Rpb25zIGZvciBvcGVuaW5nLCBjbG9zaW5nLCByZXNpemluZyB3aW5kb3dzXHJcblx0dmFyIHdpbmRvd19wcm90byA9IHtcclxuXHRcdFxyXG5cdFx0b3BlbjpmdW5jdGlvbihkaW1lbnNpb25zLCBzdHlsZSwgc3VjY2VzcywgZXJyb3Ipe1xyXG5cdFx0XHRcclxuXHJcblx0XHRcdC8vQSB3cmFwcGVyIGZvciB0aGUgc3RhbmRhcmQgQUdNIFwib3BlblwiIGZ1bmN0aW9uIFxyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHRoZV93aW5kb3cgPSB0aGlzO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly9Jbml0IHN0eWxlIG9iamVjdHMgaWYgdGhleSBhcmUgbnVsbFxyXG5cdFx0XHRkaW1lbnNpb25zPWRpbWVuc2lvbnN8fHt9O1xyXG4gICAgICAgICAgICBcdFx0c3R5bGU9c3R5bGV8fHt9O1xyXG5cdFx0XHRcclxuXHRcdFx0Ly9UYWtlIG91dCB0aGUgc3RpY2t5LXdpbmRvd3MgcmVsYXRlZCBwcm9wZXJ0aWVzIGZyb20gdGhlIHN0eWxlIG9iamVjdFxyXG5cdFx0XHRcclxuXHRcdFx0dmFyIGlzU3RpY2t5ID0gc3R5bGUuaXNTdGlja3k7XHJcblx0XHRcdGRlbGV0ZSBzdHlsZS5pc1N0aWNreTtcclxuXHJcblx0XHRcdHZhciBzdGlja3lHcm91cCA9IHN0eWxlLnN0aWNreUdyb3VwO1xyXG5cdFx0XHRkZWxldGUgc3R5bGUuc3RpY2t5R3JvdXA7XHJcblxyXG5cclxuXHJcblx0XHRcdFxyXG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkh0bWwuQ3JlYXRlV2luZG93XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHtcclxuXHRcdFx0Ly9XaW5kb3cgbmFtZSBhbmQgdXJsXHJcblx0XHQgICAgICAgXHR3aW5kb3dOYW1lOnRoZV93aW5kb3cubmFtZSwgdXJsOnRoZV93aW5kb3cudXJsLCBcclxuXHRcdFx0Ly9kaW1lbnNpb25zXHJcblx0XHQgICAgICAgXHR0b3A6ZGltZW5zaW9ucy50b3AsIGxlZnQ6ZGltZW5zaW9ucy5sZWZ0LCB3aWR0aDpkaW1lbnNpb25zLndpZHRoLCBoZWlnaHQ6ZGltZW5zaW9ucy5oZWlnaHQsIFxyXG5cdFx0XHQvL1N0aWNreXdpbmRvd3MgLSByZWxhdGVkIHByb3BzXHJcblx0XHRcdGlzU3RpY2t5OiBpc1N0aWNreSwgc3RpY2t5R3JvdXA6c3RpY2t5R3JvdXAsIFxyXG5cdFx0XHQvL1N0eWxlIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgICAgIFx0d2luZG93U3R5bGVBdHRyaWJ1dGVzOkpTT04uc3RyaW5naWZ5KHN0eWxlKVxyXG5cdFx0XHRcclxuXHRcdFx0fSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyX2ZpbHRlcih0aGVfd2luZG93LmNvbnRhaW5lciksIFxyXG4gICAgICAgICAgICAgICAgICAgICAgIHt9LCBcclxuICAgICAgICAgICAgICAgICAgICAgICBvcGVuZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgY2Fubm90X29wZW4pO1xyXG5cdFx0XHRcclxuXHRcdFx0ZnVuY3Rpb24gb3BlbmVkKG1lc3NhZ2Upe1xyXG5cdFx0XHRcdC8vQWRkIGlkIHRvIHRoZSBjdXJyZW50IHdpbmRvd3MgYmVjYXVzZSB0aGUgY3VycmVudCBIVE1MIENvbnRhaW5lclxyXG5cdFx0XHRcdC8vZG9lc24ndCBzdXBwb3J0IHRyYWNraW5nIHRoZSB1cGRhdGVzIG9mIHRoZSB3aW5kb3dcdFx0XHRcdFxyXG5cdFx0XHRcdGlmKG1lc3NhZ2UucmV0dXJuZWQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0dGhlX3dpbmRvdy5pZCA9IG1lc3NhZ2UucmV0dXJuZWQuaWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGludm9rZV9hZ21fc3VjY2Vzc19jYWxsYmFjayhzdWNjZXNzLCB0aGVfd2luZG93KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gY2Fubm90X29wZW4oZSl7XHJcblx0XHRcdFx0Ly9DYWxsIHRoZSBlcnJvciBjYWxsYmFja1xyXG5cdFx0XHRcdGlmKHR5cGVvZiBlcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7ZXJyb3IoZSk7fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vVHJ5IHRvIGJpbmQgdGhlIHJldHVybmVkIG9iamVjdCBpbiBjYXNlLi4uXHJcblx0XHRcdFx0YmluZF93aW5kb3codGhlX3dpbmRvdyk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiB0aGVfd2luZG93O1xyXG5cdFx0fSxcclxuICAgICAgICBzZXRfc3R5bGU6ZnVuY3Rpb24oc3R5bGUsIHN1Y2Nlc3MsIGVycm9yKXsgcmV0dXJuIGFnbV9hY3Rpb24oXCJUNDIuV25kLlNldFdpbmRvd1N0eWxlXCIpLmNhbGwodGhpcywgc3VjY2VzcywgZXJyb3Ise3dpbmRvd1N0eWxlQXR0cmlidXRlczpKU09OLnN0cmluZ2lmeShzdHlsZSl9KTt9LFxyXG4gICAgICAgXHJcblx0ICAgIG9wZW5lZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlkIT09dW5kZWZpbmVkO30sXHJcblxyXG5cdFx0b25fYXZhaWxhYmxlOmFkZF9jYWxsYmFjayhcIm9uX2F2YWlsYWJsZVwiLCBmdW5jdGlvbih0aGVfd2luZG93LCBjYWxsYmFjayl7aWYodGhlX3dpbmRvdy5vcGVuZWQoKSl7Y2FsbGJhY2sodGhlX3dpbmRvdyk7fX0pLFxyXG5cclxuXHRcdGNsb3NlOmFnbV9hY3Rpb24oXCJUNDIuV25kLkNsb3NlXCIpLFxyXG5cclxuXHRcdG9uX2Nsb3NlOmFkZF9jYWxsYmFjayhcIm9uX2Nsb3NlXCIpLFxyXG5cclxuXHRcdG5hdmlnYXRlOmZ1bmN0aW9uKHVybCwgc3VjY2VzcywgZXJyb3IpeyByZXR1cm4gYWdtX2FjdGlvbihcIlQ0Mi5IdG1sLk9wZW5VcmxcIikuY2FsbCh0aGlzLCBzdWNjZXNzLCBlcnJvcix7dXJsOnVybH0pO30sXHJcblxyXG5cdFx0b25fdXJsX2NoYW5nZWQ6YWRkX2NhbGxiYWNrKFwib25fdXJsX2NoYW5nZWRcIiksXHJcblxyXG5cdFx0Zm9jdXM6YWdtX2FjdGlvbihcIlQ0Mi5XbmQuQWN0aXZhdGVcIiksXHJcblx0XHRcclxuXHRcdHNldF90aXRsZTpmdW5jdGlvbih0aXRsZSwgc3VjY2VzcywgZXJyb3Ipe1xyXG5cdFx0XHQvL0ludm9rZSB0aGUgQUdNIG1ldGhvZFxyXG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLlduZC5TZXRXaW5kb3dUaXRsZVwiLCB7d2luZG93SWQ6IHRoaXMuaWQsIHRpdGxlOnRpdGxlfSwgY29udGFpbmVyX2ZpbHRlcih0aGlzLmNvbnRhaW5lciksIHt9LCB0aXRsZV9pc19zZXQsIHRpdGxlX2Nhbm5vdF9iZV9zZXQpO1xyXG5cdFx0XHRcclxuXHRcdFx0ZnVuY3Rpb24gdGl0bGVfaXNfc2V0KCkge1xyXG5cdFx0XHRcdGludm9rZV9hZ21fc3VjY2Vzc19jYWxsYmFjayhzdWNjZXNzLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0ZnVuY3Rpb24gdGl0bGVfY2Fubm90X2JlX3NldChlKSB7XHJcblx0XHRcdFx0aW52b2tlX2FnbV9lcnJvcl9jYWxsYmFjayhlcnJvciwgZSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdGdldF9kZXRhaWxzOmZ1bmN0aW9uKHN1Y2Nlc3MsIGVycm9yKSB7XHJcblx0XHRcdHZhciB3aW5kb3dfaWQgPSB0aGlzLmlkO1xyXG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLlduZC5GaW5kQnlJZFwiLCB7d2luZG93SWQ6IHRoaXMuaWR9LCBjb250YWluZXJfZmlsdGVyKHRoaXMuY29udGFpbmVyKSwge30sIHJldHVybmVkX2RpbWVuc2lvbnMsIGNhbm5vdF9yZXR1cm5fZGltZW5zaW9ucyk7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiByZXR1cm5lZF9kaW1lbnNpb25zKHZhbHVlKSB7XHJcblx0XHRcdFx0aW52b2tlX2FnbV9zdWNjZXNzX2NhbGxiYWNrKHN1Y2Nlc3MsIHZhbHVlLnJldHVybmVkW3dpbmRvd19pZF0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRmdW5jdGlvbiBjYW5ub3RfcmV0dXJuX2RpbWVuc2lvbnMoZSkge1xyXG5cdFx0XHRcdGludm9rZV9hZ21fZXJyb3JfY2FsbGJhY2soZXJyb3IsIGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHRtb3ZlX3Jlc2l6ZTpmdW5jdGlvbihkaW1lbnNpb25zLCBzdWNjZXNzLCBlcnJvcil7IHJldHVybiBhZ21fYWN0aW9uKFwiVDQyLlduZC5yZXNpemVBbmRNb3ZlXCIpLmNhbGwodGhpcywgc3VjY2VzcywgZXJyb3IsIGRpbWVuc2lvbnMpO30sXHJcblx0XHRcclxuXHRcdG1heGltaXplOmFnbV9hY3Rpb24oXCJUNDIuV25kLk1heGltaXplXCIpLFxyXG5cdFx0XHJcblx0XHRyZXN0b3JlOmFnbV9hY3Rpb24oXCJUNDIuV25kLlJlc3RvcmVcIiksXHJcblxyXG5cdFx0bWluaW1pemU6YWdtX2FjdGlvbihcIlQ0Mi5XbmQuTWluaW1pemVcIiksXHJcblx0XHRcclxuXHRcdG1heGltaXplX3Jlc3RvcmU6YWdtX2FjdGlvbihcIlQ0Mi5XbmQuTWF4aW1pemVPclJlc3RvcmVEb3duXCIpXHRcclxuXHR9O1xyXG5cdFxyXG5cdC8vQWRkcyBhbiBhbGlhcyBvZiBhbiBBR00gbWV0aG9kIGluIHRoZSBXaW5kb3cgcHJvdG90eXBlXHJcblx0ZnVuY3Rpb24gYWdtX2FjdGlvbihhY3Rpb24pe1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHN1Y2Nlc3MsIGVycm9yLCBhcmdzKXtcclxuXHJcblx0XHRcdC8vU3RvcCBpZiB0aGUgd2luZG93IGlzIGNsb3NlZFxyXG5cdFx0XHRpZih0aGlzLnVybCA9PT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0XHRpZih0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIil7ZXJyb3IoXCJDYW5ub3QgZXhlY3V0ZSBhIGNvbW1hbmQgb24gYSBjbG9zZWQgd2luZG93LlwiKTt9XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm47fVxyXG5cclxuXHRcdFx0Ly9BZGQgdGhlIHdpbmRvdyBJRCB0byB0aGUgYXJndW1lbnRzXHJcblx0XHRcdGFyZ3MgPSBhcmdzfHx7fTtcclxuXHRcdFx0YXJncy53aW5kb3dJZCA9IHRoaXMuaWQ7XHJcblxyXG5cdFx0XHQvL0ludm9rZSB0aGUgQUdNIG1ldGhvZFxyXG5cdFx0XHRhZ20uaW52b2tlKGFjdGlvbiwgYXJncywgY29udGFpbmVyX2ZpbHRlcih0aGlzLmNvbnRhaW5lciksIHt9LCBmdWxmaWxsZWQsIGVycm9yKTtcclxuXHJcblx0XHRcdHZhciB0aGVfd2luZG93ID0gdGhpcztcclxuXHRcdFx0ZnVuY3Rpb24gZnVsZmlsbGVkKCl7XHJcblx0XHRcdFx0aW52b2tlX2FnbV9zdWNjZXNzX2NhbGxiYWNrKHN1Y2Nlc3MsIHRoZV93aW5kb3cpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fTtcclxuXHR9XHJcblx0XHRcclxuXHQvL1RoZSBBUEkgaXRzZWxmXHJcblx0dmFyIGFwaSA9IHtcclxuXHJcblx0XHRteTpmdW5jdGlvbigpe1xyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0dmFyIGggPSB3aW5kb3cuaHRtbENvbnRhaW5lcjtcdFx0XHRcclxuXHRcdFx0Ly9SZXRyaWV2ZSB0aGUgY3VycmVudCB3aW5kb3cgKHRoZSBvbncgaW4gd2hpY2ggeW91ciBhcHBsaWNhdGlvbiBjdXJyZW50bHkgcmVzaWRlcykuXHJcblx0XHRcdHJldHVybiBoID09PSB1bmRlZmluZWQ/IHVuZGVmaW5lZDogYV93aW5kb3dfZnJvbShoLmJyb3dzZXJXaW5kb3dOYW1lLCBoLmNvbnRhaW5lck5hbWUsIHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBoLndpbmRvd0lkKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdG9wZW46ZnVuY3Rpb24obmFtZSwgdXJsLCBjb250YWluZXIsIGRpbWVuc2lvbnMsIHN0eWxlLCBzdWNjZXNzLCBlcnJvcil7XHJcblx0XHRcdHJldHVybiBhX3dpbmRvd19mcm9tKG5hbWUsIGNvbnRhaW5lciwgdXJsKS5vcGVuKGRpbWVuc2lvbnMsIHN0eWxlLCBzdWNjZXNzLCBlcnJvcik7XHJcblx0XHR9LFxyXG5cclxuXHRcdGZpbmQ6ZnVuY3Rpb24obmFtZSwgY29udGFpbmVyLCBzdWNjZXNzLCBlcnJvcil7XHJcblx0XHRcdHJldHVybiBiaW5kX3dpbmRvdyhhX3dpbmRvd19mcm9tKG5hbWUsIGNvbnRhaW5lciksIHN1Y2Nlc3MsIGVycm9yKTtcclxuXHRcdH0sXHJcblx0XHRfZnJvbV9ldmVudDphX3dpbmRvd19mcm9tLFxyXG5cclxuXHRcdGxpc3Q6ZnVuY3Rpb24oY29udGFpbmVyLCBzdWNjZXNzLCBlcnJvcil7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ2Z1bmN0aW9uJyl7cmV0dXJuO31cclxuICAgICAgICAgICAgXHJcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuV25kLkxpc3RXaW5kb3dzXCIsIHt9LCBjb250YWluZXJfZmlsdGVyKGNvbnRhaW5lciksIHt3YWl0X2Zvcl9tZXRob2RfdGltZW91dDogMTUwMDB9LCBsaXN0ZWQsIGNhbm5vdF9saXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgZnVuY3Rpb24gbGlzdGVkKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIFx0aWYodmFsdWUucmV0dXJuZWQgPT09IHVuZGVmaW5lZCl7c3VjY2VzcyhbXSkgO3JldHVybjt9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFscyh2YWx1ZS5yZXR1cm5lZCkubWFwKGZ1bmN0aW9uKG9wZW5lZF93aW5kb3cpeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYV93aW5kb3dfZnJvbShvcGVuZWRfd2luZG93LndpbmRvd05hbWUsIGNvbnRhaW5lciwgb3BlbmVkX3dpbmRvdy51cmwsIG9wZW5lZF93aW5kb3cud2luZG93SWQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIFxyXG5cdFx0XHRmdW5jdGlvbiBjYW5ub3RfbGlzdChlKSB7XHJcblx0XHRcdFx0aW52b2tlX2FnbV9lcnJvcl9jYWxsYmFjayhlcnJvciwgZSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vQWRkIGNhbGxiYWNrIGZvciB3aW5kb3cgYWRkZWQgZm9yIHRoZSBsaXN0IG9mIGNvbnRhaW5lcnMuXHJcblx0XHR3aW5kb3dfYWRkZWQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250YWluZXIpIHtcclxuXHRcdFx0Ly9BZGQgdGhlIGN1cnJlbnQgY2FsbGJhY2sgdG8gdGhlIGNhbGxiYWNrIGRpY3Rpb25hcnkuXHJcblx0XHRcdHB1dF9jYWxsYmFja3Mod2luZG93X2FkZGVkX2NhbGxiYWNrcywgY2FsbGJhY2ssIGNvbnRhaW5lcik7XHJcblxyXG5cdFx0XHQvL0V4ZWN1dGUgYWxsIHRoZSBjYWxsYmFja3MgZm9yIGFscmVhZHkgZXhpc3Rpbmcgd2luZG93cy5cclxuXHRcdFx0XHJcblx0XHRcdC8vR2V0IGFsbCBleGlzdGluZyBodG1sIGNvbnRhaW5lcnMuXHJcblx0XHRcdGFwaS5jb250YWluZXJfYWRkZWQoZnVuY3Rpb24oc2VydmVyKSB7XHJcblx0XHRcdFx0Ly9JZiB0aGUgdXNlciBpcyBzdWJzY3JpYmVkIHRvIHRoZSBjb250YWluZXJcclxuXHRcdFx0XHRpZihjb250YWluZXIgPT09IHVuZGVmaW5lZCB8fCBjb250YWluZXIgPT09IHNlcnZlcikge1xyXG5cdFx0XHRcdFx0Ly9saXN0IGFsbCB0aGUgd2luZG93cyBpbiB0aGUgY29udGFpbmVyLlxyXG5cdFx0XHRcdFx0YXBpLmxpc3Qoc2VydmVyLCBcclxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24obGlzdF9vZl93aW5kb3dzKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly9leGVjdXRlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCB3aW5kb3cuXHJcblx0XHRcdFx0XHRcdFx0bGlzdF9vZl93aW5kb3dzLmZvckVhY2goZnVuY3Rpb24oZXhpc3Rpbmdfd2luZG93KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjayhleGlzdGluZ193aW5kb3cpO1xyXG5cdFx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHQvL0Vycm9yIGNhbGxiYWNrIGlmIHRoZSB3aW5kb3dzIGNhbm5vdCBiZSBsaXN0ZWQuXHJcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKGUpIHtjb25zb2xlLmxvZygnVW5hYmxlIHRvIGxvYWQgZXhpc3Rpbmcgd2luZG93cy4gJyArIGUubWVzc2FnZSk7fVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0d2luZG93X3JlbW92ZWQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250YWluZXIpIHtcclxuXHRcdFx0Ly9BZGQgdGhlIGN1cnJlbnQgY2FsbGJhY2sgdG8gdGhlIGNhbGxiYWNrIGRpY3Rpb25hcnkuXHJcblx0XHRcdHB1dF9jYWxsYmFja3Mod2luZG93X3JlbW92ZWRfY2FsbGJhY2tzLCBjYWxsYmFjaywgY29udGFpbmVyKTtcclxuXHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRjb250YWluZXJfYWRkZWQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGFnbS5zZXJ2ZXJfYWRkZWQoZnVuY3Rpb24oc2VydmVyKXtcclxuICAgICAgICAgICAgICAgIGlmKHNlcnZlci5hcHBsaWNhdGlvbi5pbmRleE9mKCdIdG1sQ29udGFpbmVyLicpIT09LTEpIHtcclxuICAgICAgICAgICAgICAgIFx0aW52b2tlX2FnbV9zdWNjZXNzX2NhbGxiYWNrKGNhbGxiYWNrLCBjb250YWluZXJfZnJvbV9maWx0ZXIoc2VydmVyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG5cdFx0Y29udGFpbmVyX3JlbW92ZWQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGFnbS5zZXJ2ZXJfcmVtb3ZlZChmdW5jdGlvbihzZXJ2ZXIpe1xyXG4gICAgICAgICAgICAgICAgaWYoc2VydmVyLmFwcGxpY2F0aW9uLmluZGV4T2YoJ0h0bWxDb250YWluZXIuJykhPT0tMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZV9hZ21fc3VjY2Vzc19jYWxsYmFjayhjYWxsYmFjaywgY29udGFpbmVyX2Zyb21fZmlsdGVyKHNlcnZlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblx0fTtcclxuXHRcclxuXHRhcGkudmVyc2lvbiA9IFwiMi4wLjFcIjtcclxuXHRcclxuXHRyZXR1cm4gYXBpO1xyXG59O1xyXG5cclxuaWYod2luZG93LnRpY2s0MiA9PT0gdW5kZWZpbmVkKXt3aW5kb3cudGljazQyID0ge307fVxyXG53aW5kb3cudGljazQyLndpbmRvd3MgPSB3aW5kb3dzO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvd3M7XHJcbiAgXHJcbmZ1bmN0aW9uIGFkZF9jYWxsYmFjayhrZXksIG9uX2FkZCl7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuXHRcdHZhciBvYmogPSB0aGlzLmNhbGxiYWNrcztcclxuXHRcdGlmKG9ialtrZXldPT09dW5kZWZpbmVkKXtvYmpba2V5XSA9IFtjYWxsYmFja107fVxyXG5cdFx0ZWxzZSB7b2JqW2tleV0ucHVzaChjYWxsYmFjayk7fVxyXG5cdFx0aWYodHlwZW9mIG9uX2FkZCA9PT0gXCJmdW5jdGlvblwiKXtvbl9hZGQodGhpcywgY2FsbGJhY2spO31cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBleGVjX2NhbGxiYWNrcyhhcnIsIHZhbCl7XHJcblx0aWYoYXJyIT09dW5kZWZpbmVkKXtcclxuXHRcdGFyci5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKXtjYWxsYmFjayh2YWwpO30pO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZXEoa2V5LHZhbCl7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKG9iail7XHJcblx0XHRyZXR1cm4ga2V5PT09dW5kZWZpbmVkfHx2YWw9PT11bmRlZmluZWR8fG9ialtrZXldPT09dmFsO1xyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbHMob2JqKXtcclxuXHRyZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24oYXJyLCBrZXkpe2Fyci5wdXNoKG9ialtrZXldKTtyZXR1cm4gYXJyO30sIFtdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFwX29iaihvYmosIGYpe1xyXG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbihuZXdfb2JqLCBrZXkpe25ld19vYmpba2V5XSA9IGYob2JqW2tleV0pIDtyZXR1cm4gbmV3X29iajt9LCB7fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnRhaW5lcl9maWx0ZXIobmFtZSl7XHJcbiAgdmFyIGNvbnRhaW5lckZ1bGxOYW1lID0gXCJIdG1sQ29udGFpbmVyLlwiO1xyXG5cclxuICBpZiAoaHRtbENvbnRhaW5lci5lbnYuZW52ICE9PSB1bmRlZmluZWQgfHwgaHRtbENvbnRhaW5lci5lbnYucmVnaW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGlmKG5hbWUuaW5kZXhPZihodG1sQ29udGFpbmVyLmVudi5lbnYpID09PSAtMSAmJiBuYW1lLmluZGV4T2YoaHRtbENvbnRhaW5lci5lbnYucmVnaW9uKSA9PT0gLTEpIHtcclxuICAgICAgY29udGFpbmVyRnVsbE5hbWUgKz0gaHRtbENvbnRhaW5lci5lbnYuZW52ICsgJy0nICsgaHRtbENvbnRhaW5lci5lbnYucmVnaW9uICsgJy4nO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29udGFpbmVyRnVsbE5hbWUgKz0gbmFtZTtcclxuXHJcbiAgcmV0dXJuIHthcHBsaWNhdGlvbjogY29udGFpbmVyRnVsbE5hbWV9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb250YWluZXJfZnJvbV9maWx0ZXIoZmlsdGVyKXtcclxuXHRyZXR1cm4gZmlsdGVyLmFwcGxpY2F0aW9uLm1hdGNoKC9IdG1sQ29udGFpbmVyXFwuKC4qPykkLylbMV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludm9rZV9hZ21fc3VjY2Vzc19jYWxsYmFjayhjYWxsYmFjaywgY2FsbGJhY2tfYXJndW1lbnQpIHtcclxuXHRpZih0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge2NhbGxiYWNrKGNhbGxiYWNrX2FyZ3VtZW50KTt9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludm9rZV9hZ21fZXJyb3JfY2FsbGJhY2soY2FsbGJhY2ssIGVycm9yKSB7XHJcblx0aWYodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtjYWxsYmFjayhlcnJvci5tZXNzYWdlKTt9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldF9jYWxsYmFja3MoY2FsbGJhY2tzLCBjb250YWluZXJfbmFtZSkge1xyXG5cdGlmKGNhbGxiYWNrcy5jb250YWluZXJzX2NhbGxiYWNrc1tjb250YWluZXJfbmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGNhbGxiYWNrcy5hbGxfY29udGFpbmVyc19jYWxsYmFja3MuY29uY2F0KGNhbGxiYWNrcy5jb250YWluZXJzX2NhbGxiYWNrc1tjb250YWluZXJfbmFtZV0pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gY2FsbGJhY2tzLmFsbF9jb250YWluZXJzX2NhbGxiYWNrcztcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHB1dF9jYWxsYmFja3MoZ2xvYmFsX2NhbGxiYWNrcywgY2FsbGJhY2ssIGNvbnRhaW5lcikge1xyXG5cdGlmKGNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRnbG9iYWxfY2FsbGJhY2tzLmFsbF9jb250YWluZXJzX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0aWYoZ2xvYmFsX2NhbGxiYWNrcy5jb250YWluZXJzX2NhbGxiYWNrc1tjb250YWluZXJdID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Z2xvYmFsX2NhbGxiYWNrcy5jb250YWluZXJzX2NhbGxiYWNrc1tjb250YWluZXJdID0gW2NhbGxiYWNrXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGdsb2JhbF9jYWxsYmFja3MuY29udGFpbmVyc19jYWxsYmFja3NbY29udGFpbmVyXS5wdXNoKGNhbGxiYWNrKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIl19
