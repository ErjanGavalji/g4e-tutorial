(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function() {
    'use strict';
    // Do not do anything if there is no support of ECMAScript 5
    if (typeof [].forEach !== 'function') {
        require('es5-shim');
        require('es5-shim/es5-sham');
    }

    var metrics = require('tick42-metrics');
    var agm = require('tick42-agm');
    var gatewayConnection = require('tick42-gateway-connection');
    var logger = require('tick42-logger');
    var appconfig = require('tick42-appconfig');
    var windows = require('tick42-windows');
    var appManager = require('tick42-app-manager');
    var activity = require('tick42-activity');
	var contexts = require('tick42-contexts');
    var pjson = require('../package.json');
    var cuid = require('cuid');

    // Do not do anything if the user turned off the auto initialization
    //
    if (typeof window !== 'undefined' && window.glue_auto_initialize === false) {
        return;
    }

    // Init the GLUE namespace
    var glue = {};
    glue.version = pjson.version;
    // Base configurations. Later they are updated depending on the runtime.
    var loggerConfiguration = { identity: { system: 'Tick42' } };
    var metricsConfiguration = { identity: { system: 'Tick42' } };
    var agmConfiguration = { instance: {}, server: { presence_interval: 3000 } };

    // Here we will store a reference to the connection with the Service Provider
    glue.connection = undefined;
    var appName;

    // If we are running in an HTML Container, use the HTML Container environment variables
    if (typeof window !== 'undefined' && window.htmlContainer !== undefined) {
        // Generate AGM app name
        appName = window.agm_application || window.htmlContainer.containerName + '.' + window.htmlContainer.browserWindowName;

        // Fill logger configurations with custom properties
        agmConfiguration.instance.application = appName;
        loggerConfiguration.identity.system = 'HtmlContainer.' + window.htmlContainer.containerName;
        loggerConfiguration.identity.service = 'JS.' + window.htmlContainer.browserWindowName;
        loggerConfiguration.identity.instance = '~' + window.htmlContainer.machineName;

        if (window.htmlContainer.appConfigFacade !== undefined && window.htmlContainer.appConfigFacade.config !== undefined) {
            // Initialize AppConfig
            glue.appconfig = appconfig();
            glue.appconfig.init(function () {
                function supplant(template) {
                    return template.replace(/\{([^{}]*)\}/g, function (match, key) {
                        var value = this;
                        key.split('.').forEach(function (part) {
                            if (value) {
                                value = value[part];
                            }
                        });
                        return typeof value === 'string' || typeof value === 'number' ? value : match;
                    });
                }

                var settings = window.htmlContainer.appConfigFacade.config;
                var identity = {};
                Object.keys(settings.identity).forEach(function (key) {
                    var value = supplant(settings.identity[key]);
                    identity[key] = value;
                });
                settings.identity = identity;
                return settings;
            }());
        }

        // Init the Connection
        glue.connection = gatewayConnection();

        // If we are running in normal browser, connect via Websocket
    } else {
        var connectionConfig = {};
        var uidPrefix;
        if (require('detect-node') || ('WebSocket' in window && window.WebSocket.CLOSING === 2)) {
            uidPrefix = 'WS';
            // Websocket URL (this is the default that is used in the demo WS server) Defaults to insecure.
            var defaultWsUrl = 'ws://localhost:22037';
            if (window && window.location && window.location.protocol === 'https') {
                defaultWsUrl = 'wss://localhost:22037'
            }
            connectionConfig.websocket_url = (window && window.glue_ws_url) || defaultWsUrl;
        } else {
            // if no support for WebSocket use HTTP
            uidPrefix = 'HTTP';
            // don't make insecure requests from secure env
            var defaultHttpUrl = window.location.protocol === 'http:' ? 'http://localhost:22037' : 'https://localhost:22037';
            connectionConfig.http_url = window.glue_http_url || defaultHttpUrl;
        }

        // Generate application UID to allow for the same application to be called multiple times.
        var uid = uidPrefix + cuid();

        // Generate AGM app name
        if (typeof document !== 'undefined' && document.title) {
            appName =  document.title + uid
        } else if (window && window.agm_application) {
            appName = window.agm_application;
        } else {
            appName = uid;
        }

        // Fill configurations with custom properties
        agmConfiguration.instance.application = appName;
        loggerConfiguration.identity.system = 'Browser';
        loggerConfiguration.identity.service = typeof document !== 'undefined' ? document.title || 'unknown' : 'unknown';
        loggerConfiguration.identity.instance = '~' + uid;

        // Init the Connection and specify the URL of the Web Socket server that we are connecting to.
        glue.connection = gatewayConnection(connectionConfig);
    }

    // Place the Connection, as part of the components' configuration
    loggerConfiguration.connection = glue.connection;
    metricsConfiguration.connection = glue.connection;
    agmConfiguration.connection = glue.connection;

    // Override some props with environment variables, if provided
    loggerConfiguration.identity.system = (window && window.glue_metric_system) || loggerConfiguration.identity.system;
    loggerConfiguration.identity.service = (window && window.glue_metric_service) || loggerConfiguration.identity.service;
    loggerConfiguration.identity.instance = (window && window.glue_metric_instance) || loggerConfiguration.identity.instance;

    // Initialize Logger (uses the same configuration as Metrics)
    glue.logger = logger(loggerConfiguration);

    // Fill metrics configuration with the same properties as metrics configurations
    metricsConfiguration.identity = loggerConfiguration.identity;
    metricsConfiguration.logger = glue.logger.subLogger('metrics');

    // Initialize Metrics and save into the 'glue' global variable
    var rootMetrics = metrics(metricsConfiguration);
    glue.metrics = rootMetrics.subSystem('App');

    // Initialize the metrics system in the logger's "metrics_level" method
    glue.logger.metricsLevel('warn', glue.metrics.parent.subSystem('LogEvents'));

    agmConfiguration.instance.application = (window && window.glue_agm_application) || agmConfiguration.instance.application;

    // Include the metric repo in the AGM configuration (so that AGM can broadcast metrics)
    agmConfiguration.metrics = rootMetrics.subSystem('AGM');

    // Initialize AGM save into the 'glue' global variable
    glue.agm = agm(agmConfiguration);

    // Add activity in the container only
    var activitiesFacade = window && window.htmlContainer ? window.htmlContainer.activityFacade : undefined;
    if (typeof activitiesFacade !== 'undefined') {
        var activityLogger = glue.logger.subLogger('activity');
        activityLogger.publishLevel('debug');
        activityLogger.consoleLevel('info');
        activityLogger.metricsLevel('off');
        glue.activities = activity({ agm: glue.agm, logger: activityLogger });
    }

    glue.windows = windows(glue.agm);

    // camel case for App Manager
    glue.appManager = appManager(glue.agm, glue.windows);

	glue.contexts = contexts();

    glue.info = {
			glueVersion: pjson.version,
			activities: glue.activities ? glue.activities.version : 'unknown',
			metrics: glue.metrics.repo.version,
			agm: glue.agm.version,
			windows: glue.windows.version,
			logger: glue.logger.version,
			appManager: glue.appManager.version,
			connection: glue.connection.version,
			contexts: glue.contexts.version,
		};

    // no conflict function
    var originalGlue = window && window.glue;
    glue.noConflict = function() {
        window.glue = originalGlue;
        return glue;
    };

    // feedback option
    glue.feedback = function() {
        if (!glue.agm) {
            return;
        }

        glue.agm.invoke('T42.ACS.Feedback', {}, 'best');
    };

    // Export GLUE
    if (window) {
        window.glue = glue;
    }
    module.exports = glue;
}());

},{"../package.json":130,"cuid":5,"detect-node":6,"es5-shim":8,"es5-shim/es5-sham":7,"tick42-activity":24,"tick42-agm":42,"tick42-app-manager":54,"tick42-appconfig":60,"tick42-contexts":78,"tick42-gateway-connection":80,"tick42-logger":86,"tick42-metrics":112,"tick42-windows":125}],2:[function(require,module,exports){
/**
 * (c) 2013 Beau Sorensen
 * MIT Licensed
 * For all details and documentation:
 * https://github.com/sorensen/ascii-table
 */

;(function() {
'use strict';

/*!
 * Module dependencies
 */

var slice = Array.prototype.slice
  , toString = Object.prototype.toString

/**
 * AsciiTable constructor
 *
 * @param {String|Object} title or JSON table
 * @param {Object} table options
 *  - `prefix` - string prefix added to each line on render
 * @constructor
 * @api public
 */

function AsciiTable(name, options) {
  this.options = options || {}
  this.reset(name)
}

/*!
 * Current library version, should match `package.json`
 */

AsciiTable.VERSION = '0.0.8'

/*!
 * Alignment constants
 */

AsciiTable.LEFT = 0
AsciiTable.CENTER = 1
AsciiTable.RIGHT = 2

/*!
 * Static methods
 */

/**
 * Create a new table instance
 *
 * @param {String|Object} title or JSON table
 * @param {Object} table options
 * @api public
 */

AsciiTable.factory = function(name, options) {
  return new AsciiTable(name, options)
}

/**
 * Align the a string at the given length
 *
 * @param {Number} direction
 * @param {String} string input
 * @param {Number} string length
 * @param {Number} padding character
 * @api public
 */

AsciiTable.align = function(dir, str, len, pad) {
  if (dir === AsciiTable.LEFT) return AsciiTable.alignLeft(str, len, pad)
  if (dir === AsciiTable.RIGHT) return AsciiTable.alignRight(str, len, pad)
  if (dir === AsciiTable.CENTER) return AsciiTable.alignCenter(str, len, pad)
  return AsciiTable.alignAuto(str, len, pad)
}

/**
 * Left align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignLeft = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var alen = len + 1 - str.length
  if (alen <= 0) return str
  return str + Array(len + 1 - str.length).join(pad)
}

/**
 * Center align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignCenter = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var nLen = str.length
    , half = Math.floor(len / 2 - nLen / 2)
    , odds = Math.abs((nLen % 2) - (len % 2))
    , len = str.length

  return AsciiTable.alignRight('', half, pad) 
    + str
    + AsciiTable.alignLeft('', half + odds, pad)
}

/**
 * Right align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignRight = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var alen = len + 1 - str.length
  if (alen <= 0) return str
  return Array(len + 1 - str.length).join(pad) + str
}

/**
 * Auto align string value based on object type
 *
 * @param {Any} object to string
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignAuto = function(str, len, pad) {
  if (str === undefined || str === null) str = ''
  var type = toString.call(str)
  pad || (pad = ' ')
  len = +len
  if (type !== '[object String]') {
    str = str.toString()
  }
  if (str.length < len) {
    switch(type) {
      case '[object Number]': return AsciiTable.alignRight(str, len, pad)
      default: return AsciiTable.alignLeft(str, len, pad)
    }
  }
  return str
}

/**
 * Fill an array at a given size with the given value
 *
 * @param {Number} array size
 * @param {Any} fill value
 * @return {Array} filled array
 * @api public
 */

AsciiTable.arrayFill = function(len, fill) {
  var arr = new Array(len)
  for (var i = 0; i !== len; i++) {
    arr[i] = fill;
  }
  return arr
}

/*!
 * Instance methods
 */

/**
 * Reset the table state back to defaults
 *
 * @param {String|Object} title or JSON table
 * @api public
 */

AsciiTable.prototype.reset = 
AsciiTable.prototype.clear = function(name) {
  this.__name = ''
  this.__nameAlign = AsciiTable.CENTER
  this.__rows = []
  this.__maxCells = 0
  this.__aligns = []
  this.__colMaxes = []
  this.__spacing = 1
  this.__heading = null
  this.__headingAlign = AsciiTable.CENTER
  this.setBorder()

  if (toString.call(name) === '[object String]') {
    this.__name = name
  } else if (toString.call(name) === '[object Object]') {
    this.fromJSON(name)
  }
  return this
}

/**
 * Set the table border
 *
 * @param {String} horizontal edges (optional, default `|`)
 * @param {String} vertical edges (optional, default `-`)
 * @param {String} top corners (optional, default `.`)
 * @param {String} bottom corners (optional, default `'`)
 * @api public
 */

AsciiTable.prototype.setBorder = function(edge, fill, top, bottom) {
  this.__border = true
  if (arguments.length === 1) {
    fill = top = bottom = edge
  }
  this.__edge = edge || '|'
  this.__fill = fill || '-'
  this.__top = top || '.'
  this.__bottom = bottom || "'"
  return this
}

/**
 * Remove all table borders
 *
 * @api public
 */

AsciiTable.prototype.removeBorder = function() {
  this.__border = false
  this.__edge = ' '
  this.__fill = ' '
  return this
}

/**
 * Set the column alignment at a given index
 *
 * @param {Number} column index
 * @param {Number} alignment direction
 * @api public
 */

AsciiTable.prototype.setAlign = function(idx, dir) {
  this.__aligns[idx] = dir
  return this
}

/**
 * Set the title of the table
 *
 * @param {String} title
 * @api public
 */

AsciiTable.prototype.setTitle = function(name) {
  this.__name = name
  return this
}

/**
 * Get the title of the table
 *
 * @return {String} title
 * @api public
 */

AsciiTable.prototype.getTitle = function() {
  return this.__name
}

/**
 * Set table title alignment
 *
 * @param {Number} direction
 * @api public
 */

AsciiTable.prototype.setTitleAlign = function(dir) {
  this.__nameAlign = dir
  return this
}

/**
 * AsciiTable sorting shortcut to sort rows
 *
 * @param {Function} sorting method
 * @api public
 */

AsciiTable.prototype.sort = function(method) {
  this.__rows.sort(method)
  return this
}

/**
 * Sort rows based on sort method for given column
 *
 * @param {Number} column index
 * @param {Function} sorting method
 * @api public
 */

AsciiTable.prototype.sortColumn = function(idx, method) {
  this.__rows.sort(function(a, b) {
    return method(a[idx], b[idx])
  })
  return this
}

/**
 * Set table heading for columns
 *
 * @api public
 */

AsciiTable.prototype.setHeading = function(row) {
  if (arguments.length > 1 || toString.call(row) !== '[object Array]') {
    row = slice.call(arguments)
  }
  this.__heading = row
  return this
}

/**
 * Get table heading for columns
 *
 * @return {Array} copy of headings
 * @api public
 */

AsciiTable.prototype.getHeading = function() {
  return this.__heading.slice()
}

/**
 * Set heading alignment
 *
 * @param {Number} direction
 * @api public
 */

AsciiTable.prototype.setHeadingAlign = function(dir) {
  this.__headingAlign = dir
  return this
}

/**
 * Add a row of information to the table
 * 
 * @param {...|Array} argument values in order of columns
 * @api public
 */

AsciiTable.prototype.addRow = function(row) {
  if (arguments.length > 1 || toString.call(row) !== '[object Array]') {
    row = slice.call(arguments)
  }
  this.__maxCells = Math.max(this.__maxCells, row.length)
  this.__rows.push(row)
  return this
}

/**
 * Get a copy of all rows of the table
 *
 * @return {Array} copy of rows
 * @api public
 */

AsciiTable.prototype.getRows = function() {
  return this.__rows.slice().map(function(row) {
    return row.slice()
  })
}

/**
 * Add rows in the format of a row matrix
 *
 * @param {Array} row matrix
 * @api public
 */

AsciiTable.prototype.addRowMatrix = function(rows) {
  for (var i = 0; i < rows.length; i++) {
    this.addRow(rows[i])
  }
  return this
}

/**
 * Add rows from the given data array, processed by the callback function rowCallback.
 *
 * @param {Array} data
 * @param (Function) rowCallback
 * @param (Boolean) asMatrix - controls if the row created by rowCallback should be assigned as row matrix
 * @api public
 */

AsciiTable.prototype.addData = function(data, rowCallback, asMatrix) {
  if (toString.call(data) !== '[object Array]') {
    return this;
  }
  for (var index = 0, limit = data.length; index < limit; index++) {
    var row = rowCallback(data[index]);
    if(asMatrix) {
      this.addRowMatrix(row);
    } else {
      this.addRow(row);
    }
  }
  return this
}

  /**
 * Reset the current row state
 *
 * @api public
 */

AsciiTable.prototype.clearRows = function() {
  this.__rows = []
  this.__maxCells = 0
  this.__colMaxes = []
  return this
}

/**
 * Apply an even spaced column justification
 *
 * @param {Boolean} on / off
 * @api public
 */

AsciiTable.prototype.setJustify = function(val) {
  arguments.length === 0 && (val = true)
  this.__justify = !!val
  return this
}

/**
 * Convert the current instance to a JSON structure
 *
 * @return {Object} json representation
 * @api public
 */

AsciiTable.prototype.toJSON = function() {
  return {
    title: this.getTitle()
  , heading: this.getHeading()
  , rows: this.getRows()
  }
}

/**
 * Populate the table from a JSON object
 *
 * @param {Object} json representation
 * @api public
 */

AsciiTable.prototype.parse = 
AsciiTable.prototype.fromJSON = function(obj) {
  return this
    .clear()
    .setTitle(obj.title)
    .setHeading(obj.heading)
    .addRowMatrix(obj.rows)
}

/**
 * Render the table with the current information
 *
 * @return {String} formatted table
 * @api public
 */

AsciiTable.prototype.render =
AsciiTable.prototype.valueOf =
AsciiTable.prototype.toString = function() {
  var self = this
    , body = []
    , mLen = this.__maxCells
    , max = AsciiTable.arrayFill(mLen, 0)
    , total = mLen * 3
    , rows = this.__rows
    , justify
    , border = this.__border
    , all = this.__heading 
        ? [this.__heading].concat(rows)
        : rows

  // Calculate max table cell lengths across all rows
  for (var i = 0; i < all.length; i++) {
    var row = all[i]
    for (var k = 0; k < mLen; k++) {
      var cell = row[k]
      max[k] = Math.max(max[k], cell ? cell.toString().length : 0)
    }
  }
  this.__colMaxes = max
  justify = this.__justify ? Math.max.apply(null, max) : 0

  // Get 
  max.forEach(function(x) {
    total += justify ? justify : x + self.__spacing
  })
  justify && (total += max.length)
  total -= this.__spacing

  // Heading
  border && body.push(this._seperator(total - mLen + 1, this.__top))
  if (this.__name) {
    body.push(this._renderTitle(total - mLen + 1))
    border && body.push(this._seperator(total - mLen + 1))
  }
  if (this.__heading) {
    body.push(this._renderRow(this.__heading, ' ', this.__headingAlign))
    body.push(this._rowSeperator(mLen, this.__fill))
  }
  for (var i = 0; i < this.__rows.length; i++) {
    body.push(this._renderRow(this.__rows[i], ' '))
  }
  border && body.push(this._seperator(total - mLen + 1, this.__bottom))

  var prefix = this.options.prefix || ''
  return prefix + body.join('\n' + prefix)
}

/**
 * Create a line seperator
 *
 * @param {Number} string size
 * @param {String} side values (default '|')
 * @api private
 */

AsciiTable.prototype._seperator = function(len, sep) {
  sep || (sep = this.__edge)
  return sep + AsciiTable.alignRight(sep, len, this.__fill)
}

/**
 * Create a row seperator
 *
 * @return {String} seperator
 * @api private
 */

AsciiTable.prototype._rowSeperator = function() {
  var blanks = AsciiTable.arrayFill(this.__maxCells, this.__fill)
  return this._renderRow(blanks, this.__fill)
}

/**
 * Render the table title in a centered box
 *
 * @param {Number} string size
 * @return {String} formatted title
 * @api private
 */

AsciiTable.prototype._renderTitle = function(len) {
  var name = ' ' + this.__name + ' '
    , str = AsciiTable.align(this.__nameAlign, name, len - 1, ' ')
  return this.__edge + str + this.__edge
}

/**
 * Render an invdividual row
 *
 * @param {Array} row
 * @param {String} column seperator
 * @param {Number} total row alignment (optional, default `auto`)
 * @return {String} formatted row
 * @api private
 */

AsciiTable.prototype._renderRow = function(row, str, align) {
  var tmp = ['']
    , max = this.__colMaxes

  for (var k = 0; k < this.__maxCells; k++) {
    var cell = row[k]
      , just = this.__justify ? Math.max.apply(null, max) : max[k]
      // , pad = k === this.__maxCells - 1 ? just : just + this.__spacing
      , pad = just
      , cAlign = this.__aligns[k]
      , use = align
      , method = 'alignAuto'
  
    if (typeof align === 'undefined') use = cAlign

    if (use === AsciiTable.LEFT) method = 'alignLeft'
    if (use === AsciiTable.CENTER) method = 'alignCenter'
    if (use === AsciiTable.RIGHT) method = 'alignRight'

    tmp.push(AsciiTable[method](cell, pad, str))
  }
  var front = tmp.join(str + this.__edge + str)
  front = front.substr(1, front.length)
  return front + str + this.__edge
}

/*!
 * Aliases
 */

// Create method shortcuts to all alignment methods for each direction
;['Left', 'Right', 'Center'].forEach(function(dir) {
  var constant = AsciiTable[dir.toUpperCase()]

  ;['setAlign', 'setTitleAlign', 'setHeadingAlign'].forEach(function(method) {
    // Call the base method with the direction constant as the last argument
    AsciiTable.prototype[method + dir] = function() {
      var args = slice.call(arguments).concat(constant)
      return this[method].apply(this, args)
    }
  })
})

/*!
 * Module exports.
 */

if (typeof exports !== 'undefined') {
  module.exports = AsciiTable
} else {
  this.AsciiTable = AsciiTable
}

}).call(this);

},{}],3:[function(require,module,exports){
module.exports = require('./ascii-table')
},{"./ascii-table":2}],4:[function(require,module,exports){
module.exports = function () {
	"use strict";

	var callbacks = {};

	function add(key, callback) {
		var callbacksForKey = callbacks[key];

		if (!callbacksForKey) {
			callbacksForKey = [];
			callbacks[key] = callbacksForKey;
		}

		var newLen = callbacksForKey.push(callback);
		var itemIndex = newLen - 1;

		// callback id is formed as <item-index>_<key>, we use that id to remove the callback 
		return itemIndex + '_' + key;
	}

	function remove(callbackId) {
		var parts = callbackId.split('_');
		if (parts.length !== 2) {
			return false;
		}

		var index = parts[0];
		var key = parts[1];
		
		var callbackArray = callbacks[key];
		if (!callbackArray || callbackArray.length === 0) {
			return false;
		}

		delete callbackArray[index];
		return true;
	}

	function execute(key, argumentsArr) {
		var callbacksForKey = callbacks[key];
		if (!callbacksForKey || callbacksForKey.length === 0){
			return;
		}

		var args = [].splice.call(arguments, 1);

		callbacksForKey.forEach(function (callback) {
			callback.apply(undefined, args);
		});
	}

	return {
		add: add,
		remove: remove,
		execute: execute
	};
};

},{}],5:[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 *
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

/*global window, navigator, document, require, process, module */
(function (app) {
  'use strict';
  var namespace = 'cuid',
    c = 0,
    blockSize = 4,
    base = 36,
    discreteValues = Math.pow(base, blockSize),

    pad = function pad(num, size) {
      var s = "000000000" + num;
      return s.substr(s.length-size);
    },

    randomBlock = function randomBlock() {
      return pad((Math.random() *
            discreteValues << 0)
            .toString(base), blockSize);
    },

    safeCounter = function () {
      c = (c < discreteValues) ? c : 0;
      c++; // this is not subliminal
      return c - 1;
    },

    api = function cuid() {
      // Starting with a lowercase letter makes
      // it HTML element ID friendly.
      var letter = 'c', // hard-coded allows for sequential access

        // timestamp
        // warning: this exposes the exact date and time
        // that the uid was created.
        timestamp = (new Date().getTime()).toString(base),

        // Prevent same-machine collisions.
        counter,

        // A few chars to generate distinct ids for different
        // clients (so different computers are far less
        // likely to generate the same id)
        fingerprint = api.fingerprint(),

        // Grab some more chars from Math.random()
        random = randomBlock() + randomBlock();

        counter = pad(safeCounter().toString(base), blockSize);

      return  (letter + timestamp + counter + fingerprint + random);
    };

  api.slug = function slug() {
    var date = new Date().getTime().toString(36),
      counter,
      print = api.fingerprint().slice(0,1) +
        api.fingerprint().slice(-1),
      random = randomBlock().slice(-2);

      counter = safeCounter().toString(36).slice(-4);

    return date.slice(-2) +
      counter + print + random;
  };

  api.globalCount = function globalCount() {
    // We want to cache the results of this
    var cache = (function calc() {
        var i,
          count = 0;

        for (i in window) {
          count++;
        }

        return count;
      }());

    api.globalCount = function () { return cache; };
    return cache;
  };

  api.fingerprint = function browserPrint() {
    return pad((navigator.mimeTypes.length +
      navigator.userAgent.length).toString(36) +
      api.globalCount().toString(36), 4);
  };

  // don't change anything from here down.
  if (app.register) {
    app.register(namespace, api);
  } else if (typeof module !== 'undefined') {
    module.exports = api;
  } else {
    app[namespace] = api;
  }

}(this));

},{}],6:[function(require,module,exports){
(function (global){
module.exports = false;

// Only Node.JS has a process variable that is of [[Class]] process
try {
 module.exports = Object.prototype.toString.call(global.process) === '[object process]' 
} catch(e) {}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],7:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
    }
}(this, function () {

    var call = Function.call;
    var prototypeOfObject = Object.prototype;
    var owns = call.bind(prototypeOfObject.hasOwnProperty);
    var isEnumerable = call.bind(prototypeOfObject.propertyIsEnumerable);
    var toStr = call.bind(prototypeOfObject.toString);

    // If JS engine supports accessors creating shortcuts.
    var defineGetter;
    var defineSetter;
    var lookupGetter;
    var lookupSetter;
    var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
    if (supportsAccessors) {
        /* eslint-disable no-underscore-dangle */
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
        /* eslint-enable no-underscore-dangle */
    }

    var isPrimitive = function isPrimitive(o) {
        return o == null || (typeof o !== 'object' && typeof o !== 'function');
    };

    // ES5 15.2.3.2
    // http://es5.github.com/#x15.2.3.2
    if (!Object.getPrototypeOf) {
        // https://github.com/es-shims/es5-shim/issues#issue/2
        // http://ejohn.org/blog/objectgetprototypeof/
        // recommended by fschaefer on github
        //
        // sure, and webreflection says ^_^
        // ... this will nerever possibly return null
        // ... Opera Mini breaks here with infinite loops
        Object.getPrototypeOf = function getPrototypeOf(object) {
            /* eslint-disable no-proto */
            var proto = object.__proto__;
            /* eslint-enable no-proto */
            if (proto || proto === null) {
                return proto;
            } else if (toStr(object.constructor) === '[object Function]') {
                return object.constructor.prototype;
            } else if (object instanceof Object) {
                return prototypeOfObject;
            } else {
                // Correctly return null for Objects created with `Object.create(null)`
                // (shammed or native) or `{ __proto__: null}`.  Also returns null for
                // cross-realm objects on browsers that lack `__proto__` support (like
                // IE <11), but that's the best we can do.
                return null;
            }
        };
    }

    // ES5 15.2.3.3
    // http://es5.github.com/#x15.2.3.3

    var doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {
        try {
            object.sentinel = 0;
            return Object.getOwnPropertyDescriptor(object, 'sentinel').value === 0;
        } catch (exception) {
            return false;
        }
    };

    // check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
    if (Object.defineProperty) {
        var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
        var getOwnPropertyDescriptorWorksOnDom = typeof document === 'undefined' ||
        doesGetOwnPropertyDescriptorWork(document.createElement('div'));
        if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
            var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
        }
    }

    if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
        var ERR_NON_OBJECT = 'Object.getOwnPropertyDescriptor called on a non-object: ';

        /* eslint-disable no-proto */
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            if (isPrimitive(object)) {
                throw new TypeError(ERR_NON_OBJECT + object);
            }

            // make a valiant attempt to use the real getOwnPropertyDescriptor
            // for I8's DOM elements.
            if (getOwnPropertyDescriptorFallback) {
                try {
                    return getOwnPropertyDescriptorFallback.call(Object, object, property);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            var descriptor;

            // If object does not owns property return undefined immediately.
            if (!owns(object, property)) {
                return descriptor;
            }

            // If object has a property then it's for sure `configurable`, and
            // probably `enumerable`. Detect enumerability though.
            descriptor = {
                enumerable: isEnumerable(object, property),
                configurable: true
            };

            // If JS engine supports accessor properties then property may be a
            // getter or setter.
            if (supportsAccessors) {
                // Unfortunately `__lookupGetter__` will return a getter even
                // if object has own non getter property along with a same named
                // inherited getter. To avoid misbehavior we temporary remove
                // `__proto__` so that `__lookupGetter__` will return getter only
                // if it's owned by an object.
                var prototype = object.__proto__;
                var notPrototypeOfObject = object !== prototypeOfObject;
                // avoid recursion problem, breaking in Opera Mini when
                // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
                // or any other Object.prototype accessor
                if (notPrototypeOfObject) {
                    object.__proto__ = prototypeOfObject;
                }

                var getter = lookupGetter(object, property);
                var setter = lookupSetter(object, property);

                if (notPrototypeOfObject) {
                    // Once we have getter and setter we can put values back.
                    object.__proto__ = prototype;
                }

                if (getter || setter) {
                    if (getter) {
                        descriptor.get = getter;
                    }
                    if (setter) {
                        descriptor.set = setter;
                    }
                    // If it was accessor property we're done and return here
                    // in order to avoid adding `value` to the descriptor.
                    return descriptor;
                }
            }

            // If we got this far we know that object has an own property that is
            // not an accessor so we set it as a value and return descriptor.
            descriptor.value = object[property];
            descriptor.writable = true;
            return descriptor;
        };
        /* eslint-enable no-proto */
    }

    // ES5 15.2.3.4
    // http://es5.github.com/#x15.2.3.4
    if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
            return Object.keys(object);
        };
    }

    // ES5 15.2.3.5
    // http://es5.github.com/#x15.2.3.5
    if (!Object.create) {

        // Contributed by Brandon Benvie, October, 2012
        var createEmpty;
        var supportsProto = !({ __proto__: null } instanceof Object);
                            // the following produces false positives
                            // in Opera Mini => not a reliable check
                            // Object.prototype.__proto__ === null

        // Check for document.domain and active x support
        // No need to use active x approach when document.domain is not set
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        /* global ActiveXObject */
        var shouldUseActiveX = function shouldUseActiveX() {
            // return early if document.domain not set
            if (!document.domain) {
                return false;
            }

            try {
                return !!new ActiveXObject('htmlfile');
            } catch (exception) {
                return false;
            }
        };

        // This supports IE8 when document.domain is used
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        var getEmptyViaActiveX = function getEmptyViaActiveX() {
            var empty;
            var xDoc;

            xDoc = new ActiveXObject('htmlfile');

            var script = 'script';
            xDoc.write('<' + script + '></' + script + '>');
            xDoc.close();

            empty = xDoc.parentWindow.Object.prototype;
            xDoc = null;

            return empty;
        };

        // The original implementation using an iframe
        // before the activex approach was added
        // see https://github.com/es-shims/es5-shim/issues/150
        var getEmptyViaIFrame = function getEmptyViaIFrame() {
            var iframe = document.createElement('iframe');
            var parent = document.body || document.documentElement;
            var empty;

            iframe.style.display = 'none';
            parent.appendChild(iframe);
            /* eslint-disable no-script-url */
            iframe.src = 'javascript:';
            /* eslint-enable no-script-url */

            empty = iframe.contentWindow.Object.prototype;
            parent.removeChild(iframe);
            iframe = null;

            return empty;
        };

        /* global document */
        if (supportsProto || typeof document === 'undefined') {
            createEmpty = function () {
                return { __proto__: null };
            };
        } else {
            // In old IE __proto__ can't be used to manually set `null`, nor does
            // any other method exist to make an object that inherits from nothing,
            // aside from Object.prototype itself. Instead, create a new global
            // object and *steal* its Object.prototype and strip it bare. This is
            // used as the prototype to create nullary objects.
            createEmpty = function () {
                // Determine which approach to use
                // see https://github.com/es-shims/es5-shim/issues/150
                var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();

                delete empty.constructor;
                delete empty.hasOwnProperty;
                delete empty.propertyIsEnumerable;
                delete empty.isPrototypeOf;
                delete empty.toLocaleString;
                delete empty.toString;
                delete empty.valueOf;

                var Empty = function Empty() {};
                Empty.prototype = empty;
                // short-circuit future calls
                createEmpty = function () {
                    return new Empty();
                };
                return new Empty();
            };
        }

        Object.create = function create(prototype, properties) {

            var object;
            var Type = function Type() {}; // An empty constructor.

            if (prototype === null) {
                object = createEmpty();
            } else {
                if (prototype !== null && isPrimitive(prototype)) {
                    // In the native implementation `parent` can be `null`
                    // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)
                    // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`
                    // like they are in modern browsers. Using `Object.create` on DOM elements
                    // is...err...probably inappropriate, but the native version allows for it.
                    throw new TypeError('Object prototype may only be an Object or null'); // same msg as Chrome
                }
                Type.prototype = prototype;
                object = new Type();
                // IE has no built-in implementation of `Object.getPrototypeOf`
                // neither `__proto__`, but this manually setting `__proto__` will
                // guarantee that `Object.getPrototypeOf` will work as expected with
                // objects created using `Object.create`
                /* eslint-disable no-proto */
                object.__proto__ = prototype;
                /* eslint-enable no-proto */
            }

            if (properties !== void 0) {
                Object.defineProperties(object, properties);
            }

            return object;
        };
    }

    // ES5 15.2.3.6
    // http://es5.github.com/#x15.2.3.6

    // Patch for WebKit and IE8 standard mode
    // Designed by hax <hax.github.com>
    // related issue: https://github.com/es-shims/es5-shim/issues#issue/5
    // IE8 Reference:
    //     http://msdn.microsoft.com/en-us/library/dd282900.aspx
    //     http://msdn.microsoft.com/en-us/library/dd229916.aspx
    // WebKit Bugs:
    //     https://bugs.webkit.org/show_bug.cgi?id=36423

    var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
        try {
            Object.defineProperty(object, 'sentinel', {});
            return 'sentinel' in object;
        } catch (exception) {
            return false;
        }
    };

    // check whether defineProperty works if it's given. Otherwise,
    // shim partially.
    if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document === 'undefined' ||
            doesDefinePropertyWork(document.createElement('div'));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
            var definePropertyFallback = Object.defineProperty,
                definePropertiesFallback = Object.defineProperties;
        }
    }

    if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
        var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
        var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

        Object.defineProperty = function defineProperty(object, property, descriptor) {
            if (isPrimitive(object)) {
                throw new TypeError(ERR_NON_OBJECT_TARGET + object);
            }
            if (isPrimitive(descriptor)) {
                throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
            }
            // make a valiant attempt to use the real defineProperty
            // for I8's DOM elements.
            if (definePropertyFallback) {
                try {
                    return definePropertyFallback.call(Object, object, property, descriptor);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            // If it's a data property.
            if ('value' in descriptor) {
                // fail silently if 'writable', 'enumerable', or 'configurable'
                // are requested but not supported
                /*
                // alternate approach:
                if ( // can't implement these features; allow false but not true
                    ('writable' in descriptor && !descriptor.writable) ||
                    ('enumerable' in descriptor && !descriptor.enumerable) ||
                    ('configurable' in descriptor && !descriptor.configurable)
                ))
                    throw new RangeError(
                        'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
                    );
                */

                if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
                    // As accessors are supported only on engines implementing
                    // `__proto__` we can safely override `__proto__` while defining
                    // a property to make sure that we don't hit an inherited
                    // accessor.
                    /* eslint-disable no-proto */
                    var prototype = object.__proto__;
                    object.__proto__ = prototypeOfObject;
                    // Deleting a property anyway since getter / setter may be
                    // defined on object itself.
                    delete object[property];
                    object[property] = descriptor.value;
                    // Setting original `__proto__` back now.
                    object.__proto__ = prototype;
                    /* eslint-enable no-proto */
                } else {
                    object[property] = descriptor.value;
                }
            } else {
                var hasGetter = 'get' in descriptor;
                var hasSetter = 'set' in descriptor;
                if (!supportsAccessors && (hasGetter || hasSetter)) {
                     return;
                }
                // If we got that far then getters and setters can be defined !!
                if (hasGetter) {
                    defineGetter(object, property, descriptor.get);
                }
                if (hasSetter) {
                    defineSetter(object, property, descriptor.set);
                }
            }
            return object;
        };
    }

    // ES5 15.2.3.7
    // http://es5.github.com/#x15.2.3.7
    if (!Object.defineProperties || definePropertiesFallback) {
        Object.defineProperties = function defineProperties(object, properties) {
            // make a valiant attempt to use the real defineProperties
            if (definePropertiesFallback) {
                try {
                    return definePropertiesFallback.call(Object, object, properties);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            Object.keys(properties).forEach(function (property) {
                if (property !== '__proto__') {
                    Object.defineProperty(object, property, properties[property]);
                }
            });
            return object;
        };
    }

    // ES5 15.2.3.8
    // http://es5.github.com/#x15.2.3.8
    if (!Object.seal) {
        Object.seal = function seal(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.seal can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // ES5 15.2.3.9
    // http://es5.github.com/#x15.2.3.9
    if (!Object.freeze) {
        Object.freeze = function freeze(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.freeze can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // detect a Rhino bug and patch it
    try {
        Object.freeze(function () {});
    } catch (exception) {
        Object.freeze = (function (freezeObject) {
            return function freeze(object) {
                if (typeof object === 'function') {
                    return object;
                } else {
                    return freezeObject(object);
                }
            };
        }(Object.freeze));
    }

    // ES5 15.2.3.10
    // http://es5.github.com/#x15.2.3.10
    if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.preventExtensions can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // ES5 15.2.3.11
    // http://es5.github.com/#x15.2.3.11
    if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.isSealed can only be called on Objects.');
            }
            return false;
        };
    }

    // ES5 15.2.3.12
    // http://es5.github.com/#x15.2.3.12
    if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.isFrozen can only be called on Objects.');
            }
            return false;
        };
    }

    // ES5 15.2.3.13
    // http://es5.github.com/#x15.2.3.13
    if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
            // 1. If Type(O) is not Object throw a TypeError exception.
            if (Object(object) !== object) {
                throw new TypeError('Object.isExtensible can only be called on Objects.');
            }
            // 2. Return the Boolean value of the [[Extensible]] internal property of O.
            var name = '';
            while (owns(object, name)) {
                name += '?';
            }
            object[name] = true;
            var returnValue = owns(object, name);
            delete object[name];
            return returnValue;
        };
    }

}));

},{}],8:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
    }
}(this, function () {
    /**
     * Brings an environment as close to ECMAScript 5 compliance
     * as is possible with the facilities of erstwhile engines.
     *
     * Annotated ES5: http://es5.github.com/ (specific links below)
     * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
     * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
     */

    // Shortcut to an often accessed properties, in order to avoid multiple
    // dereference that costs universally. This also holds a reference to known-good
    // functions.
    var $Array = Array;
    var ArrayPrototype = $Array.prototype;
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    var $Function = Function;
    var FunctionPrototype = $Function.prototype;
    var $String = String;
    var StringPrototype = $String.prototype;
    var $Number = Number;
    var NumberPrototype = $Number.prototype;
    var array_slice = ArrayPrototype.slice;
    var array_splice = ArrayPrototype.splice;
    var array_push = ArrayPrototype.push;
    var array_unshift = ArrayPrototype.unshift;
    var array_concat = ArrayPrototype.concat;
    var array_join = ArrayPrototype.join;
    var call = FunctionPrototype.call;
    var apply = FunctionPrototype.apply;
    var max = Math.max;
    var min = Math.min;

    // Having a toString local variable name breaks in Opera so use to_string.
    var to_string = ObjectPrototype.toString;

    /* global Symbol */
    /* eslint-disable one-var-declaration-per-line, no-redeclare, max-statements-per-line */
    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn(value) { try { var fnStr = fnToStr.call(value); var singleStripped = fnStr.replace(/\/\/.*\n/g, ''); var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, ''); var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' '); return constructorRegex.test(spaceStripped); } catch (e) { return false; /* not a function */ } }, tryFunctionObject = function tryFunctionObject(value) { try { if (isES6ClassFn(value)) { return false; } fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', isCallable = function isCallable(value) { if (!value) { return false; } if (typeof value !== 'function' && typeof value !== 'object') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } if (isES6ClassFn(value)) { return false; } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };

    var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
    var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
    /* eslint-enable one-var-declaration-per-line, no-redeclare, max-statements-per-line */

    /* inlined from http://npmjs.com/define-properties */
    var supportsDescriptors = $Object.defineProperty && (function () {
        try {
            var obj = {};
            $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
            for (var _ in obj) { // jscs:ignore disallowUnusedVariables
                return false;
            }
            return obj.x === obj;
        } catch (e) { /* this is ES3 */
            return false;
        }
    }());
    var defineProperties = (function (has) {
        // Define configurable, writable, and non-enumerable props
        // if they don't exist.
        var defineProperty;
        if (supportsDescriptors) {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                $Object.defineProperty(object, name, {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: method
                });
            };
        } else {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                object[name] = method;
            };
        }
        return function defineProperties(object, map, forceAssign) {
            for (var name in map) {
                if (has.call(map, name)) {
                    defineProperty(object, name, map[name], forceAssign);
                }
            }
        };
    }(ObjectPrototype.hasOwnProperty));

    //
    // Util
    // ======
    //

    /* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
    var isPrimitive = function isPrimitive(input) {
        var type = typeof input;
        return input === null || (type !== 'object' && type !== 'function');
    };

    var isActualNaN = $Number.isNaN || function isActualNaN(x) {
        return x !== x;
    };

    var ES = {
        // ES5 9.4
        // http://es5.github.com/#x9.4
        // http://jsperf.com/to-integer
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
        ToInteger: function ToInteger(num) {
            var n = +num;
            if (isActualNaN(n)) {
                n = 0;
            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
            return n;
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
        ToPrimitive: function ToPrimitive(input) {
            var val, valueOf, toStr;
            if (isPrimitive(input)) {
                return input;
            }
            valueOf = input.valueOf;
            if (isCallable(valueOf)) {
                val = valueOf.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            toStr = input.toString;
            if (isCallable(toStr)) {
                val = toStr.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            throw new TypeError();
        },

        // ES5 9.9
        // http://es5.github.com/#x9.9
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
        ToObject: function (o) {
            if (o == null) { // this matches both null and undefined
                throw new TypeError("can't convert " + o + ' to object');
            }
            return $Object(o);
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
        ToUint32: function ToUint32(x) {
            return x >>> 0;
        }
    };

    //
    // Function
    // ========
    //

    // ES-5 15.3.4.5
    // http://es5.github.com/#x15.3.4.5

    var Empty = function Empty() {};

    defineProperties(FunctionPrototype, {
        bind: function bind(that) { // .length is 1
            // 1. Let Target be the this value.
            var target = this;
            // 2. If IsCallable(Target) is false, throw a TypeError exception.
            if (!isCallable(target)) {
                throw new TypeError('Function.prototype.bind called on incompatible ' + target);
            }
            // 3. Let A be a new (possibly empty) internal list of all of the
            //   argument values provided after thisArg (arg1, arg2 etc), in order.
            // XXX slicedArgs will stand in for "A" if used
            var args = array_slice.call(arguments, 1); // for normal call
            // 4. Let F be a new native ECMAScript object.
            // 11. Set the [[Prototype]] internal property of F to the standard
            //   built-in Function prototype object as specified in 15.3.3.1.
            // 12. Set the [[Call]] internal property of F as described in
            //   15.3.4.5.1.
            // 13. Set the [[Construct]] internal property of F as described in
            //   15.3.4.5.2.
            // 14. Set the [[HasInstance]] internal property of F as described in
            //   15.3.4.5.3.
            var bound;
            var binder = function () {

                if (this instanceof bound) {
                    // 15.3.4.5.2 [[Construct]]
                    // When the [[Construct]] internal method of a function object,
                    // F that was created using the bind function is called with a
                    // list of arguments ExtraArgs, the following steps are taken:
                    // 1. Let target be the value of F's [[TargetFunction]]
                    //   internal property.
                    // 2. If target has no [[Construct]] internal method, a
                    //   TypeError exception is thrown.
                    // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Construct]] internal
                    //   method of target providing args as the arguments.

                    var result = apply.call(
                        target,
                        this,
                        array_concat.call(args, array_slice.call(arguments))
                    );
                    if ($Object(result) === result) {
                        return result;
                    }
                    return this;

                } else {
                    // 15.3.4.5.1 [[Call]]
                    // When the [[Call]] internal method of a function object, F,
                    // which was created using the bind function is called with a
                    // this value and a list of arguments ExtraArgs, the following
                    // steps are taken:
                    // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 2. Let boundThis be the value of F's [[BoundThis]] internal
                    //   property.
                    // 3. Let target be the value of F's [[TargetFunction]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Call]] internal method
                    //   of target providing boundThis as the this value and
                    //   providing args as the arguments.

                    // equiv: target.call(this, ...boundArgs, ...args)
                    return apply.call(
                        target,
                        that,
                        array_concat.call(args, array_slice.call(arguments))
                    );

                }

            };

            // 15. If the [[Class]] internal property of Target is "Function", then
            //     a. Let L be the length property of Target minus the length of A.
            //     b. Set the length own property of F to either 0 or L, whichever is
            //       larger.
            // 16. Else set the length own property of F to 0.

            var boundLength = max(0, target.length - args.length);

            // 17. Set the attributes of the length own property of F to the values
            //   specified in 15.3.5.1.
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                array_push.call(boundArgs, '$' + i);
            }

            // XXX Build a dynamic function with desired amount of arguments is the only
            // way to set the length property of a function.
            // In environments where Content Security Policies enabled (Chrome extensions,
            // for ex.) all use of eval or Function costructor throws an exception.
            // However in all of these environments Function.prototype.bind exists
            // and so this code will never be executed.
            bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                // Clean up dangling references.
                Empty.prototype = null;
            }

            // TODO
            // 18. Set the [[Extensible]] internal property of F to true.

            // TODO
            // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
            // 20. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
            //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
            //   false.
            // 21. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
            //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
            //   and false.

            // TODO
            // NOTE Function objects created using Function.prototype.bind do not
            // have a prototype property or the [[Code]], [[FormalParameters]], and
            // [[Scope]] internal properties.
            // XXX can't delete prototype in pure-js.

            // 22. Return F.
            return bound;
        }
    });

    // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
    // use it in defining shortcuts.
    var owns = call.bind(ObjectPrototype.hasOwnProperty);
    var toStr = call.bind(ObjectPrototype.toString);
    var arraySlice = call.bind(array_slice);
    var arraySliceApply = apply.bind(array_slice);
    var strSlice = call.bind(StringPrototype.slice);
    var strSplit = call.bind(StringPrototype.split);
    var strIndexOf = call.bind(StringPrototype.indexOf);
    var pushCall = call.bind(array_push);
    var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
    var arraySort = call.bind(ArrayPrototype.sort);

    //
    // Array
    // =====
    //

    var isArray = $Array.isArray || function isArray(obj) {
        return toStr(obj) === '[object Array]';
    };

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.13
    // Return len+argCount.
    // [bugfix, ielt8]
    // IE < 8 bug: [].unshift(0) === undefined but should be "1"
    var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
    defineProperties(ArrayPrototype, {
        unshift: function () {
            array_unshift.apply(this, arguments);
            return this.length;
        }
    }, hasUnshiftReturnValueBug);

    // ES5 15.4.3.2
    // http://es5.github.com/#x15.4.3.2
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
    defineProperties($Array, { isArray: isArray });

    // The IsCallable() check in the Array functions
    // has been replaced with a strict check on the
    // internal class of the object to trap cases where
    // the provided function was actually a regular
    // expression literal, which in V8 and
    // JavaScriptCore is a typeof "function".  Only in
    // V8 are regular expression literals permitted as
    // reduce parameters, so it is desirable in the
    // general case for the shim to match the more
    // strict and common behavior of rejecting regular
    // expressions.

    // ES5 15.4.4.18
    // http://es5.github.com/#x15.4.4.18
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

    // Check failure of by-index access of string characters (IE < 9)
    // and failure of `0 in boxedString` (Rhino)
    var boxedString = $Object('a');
    var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

    var properlyBoxesContext = function properlyBoxed(method) {
        // Check node 0.6.21 bug where third parameter is not boxed
        var properlyBoxesNonStrict = true;
        var properlyBoxesStrict = true;
        var threwException = false;
        if (method) {
            try {
                method.call('foo', function (_, __, context) {
                    if (typeof context !== 'object') {
                        properlyBoxesNonStrict = false;
                    }
                });

                method.call([1], function () {
                    'use strict';

                    properlyBoxesStrict = typeof this === 'string';
                }, 'x');
            } catch (e) {
                threwException = true;
            }
        }
        return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
    };

    defineProperties(ArrayPrototype, {
        forEach: function forEach(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var i = -1;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.forEach callback must be a function');
            }

            while (++i < length) {
                if (i in self) {
                    // Invoke the callback function with call, passing arguments:
                    // context, property value, property key, thisArg object
                    if (typeof T === 'undefined') {
                        callbackfn(self[i], i, object);
                    } else {
                        callbackfn.call(T, self[i], i, object);
                    }
                }
            }
        }
    }, !properlyBoxesContext(ArrayPrototype.forEach));

    // ES5 15.4.4.19
    // http://es5.github.com/#x15.4.4.19
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
    defineProperties(ArrayPrototype, {
        map: function map(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = $Array(length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.map callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    if (typeof T === 'undefined') {
                        result[i] = callbackfn(self[i], i, object);
                    } else {
                        result[i] = callbackfn.call(T, self[i], i, object);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.map));

    // ES5 15.4.4.20
    // http://es5.github.com/#x15.4.4.20
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
    defineProperties(ArrayPrototype, {
        filter: function filter(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = [];
            var value;
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.filter callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    value = self[i];
                    if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
                        pushCall(result, value);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.filter));

    // ES5 15.4.4.16
    // http://es5.github.com/#x15.4.4.16
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
    defineProperties(ArrayPrototype, {
        every: function every(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.every callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return false;
                }
            }
            return true;
        }
    }, !properlyBoxesContext(ArrayPrototype.every));

    // ES5 15.4.4.17
    // http://es5.github.com/#x15.4.4.17
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
    defineProperties(ArrayPrototype, {
        some: function some(callbackfn/*, thisArg */) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.some callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return true;
                }
            }
            return false;
        }
    }, !properlyBoxesContext(ArrayPrototype.some));

    // ES5 15.4.4.21
    // http://es5.github.com/#x15.4.4.21
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
    var reduceCoercesToObject = false;
    if (ArrayPrototype.reduce) {
        reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduce: function reduce(callbackfn/*, initialValue*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduce callback must be a function');
            }

            // no value to return if no initial value and an empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduce of empty array with no initial value');
            }

            var i = 0;
            var result;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i++];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (++i >= length) {
                        throw new TypeError('reduce of empty array with no initial value');
                    }
                } while (true);
            }

            for (; i < length; i++) {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            }

            return result;
        }
    }, !reduceCoercesToObject);

    // ES5 15.4.4.22
    // http://es5.github.com/#x15.4.4.22
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
    var reduceRightCoercesToObject = false;
    if (ArrayPrototype.reduceRight) {
        reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduceRight: function reduceRight(callbackfn/*, initial*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduceRight callback must be a function');
            }

            // no value to return if no initial value, empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduceRight of empty array with no initial value');
            }

            var result;
            var i = length - 1;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i--];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (--i < 0) {
                        throw new TypeError('reduceRight of empty array with no initial value');
                    }
                } while (true);
            }

            if (i < 0) {
                return result;
            }

            do {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            } while (i--);

            return result;
        }
    }, !reduceRightCoercesToObject);

    // ES5 15.4.4.14
    // http://es5.github.com/#x15.4.4.14
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
    var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
    defineProperties(ArrayPrototype, {
        indexOf: function indexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }

            var i = 0;
            if (arguments.length > 1) {
                i = ES.ToInteger(arguments[1]);
            }

            // handle negative indices
            i = i >= 0 ? i : max(0, length + i);
            for (; i < length; i++) {
                if (i in self && self[i] === searchElement) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2IndexOfBug);

    // ES5 15.4.4.15
    // http://es5.github.com/#x15.4.4.15
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
    var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
    defineProperties(ArrayPrototype, {
        lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }
            var i = length - 1;
            if (arguments.length > 1) {
                i = min(i, ES.ToInteger(arguments[1]));
            }
            // handle negative indices
            i = i >= 0 ? i : length - Math.abs(i);
            for (; i >= 0; i--) {
                if (i in self && searchElement === self[i]) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2LastIndexOfBug);

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.12
    var spliceNoopReturnsEmptyArray = (function () {
        var a = [1, 2];
        var result = a.splice();
        return a.length === 2 && isArray(result) && result.length === 0;
    }());
    defineProperties(ArrayPrototype, {
        // Safari 5.0 bug where .splice() returns undefined
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            } else {
                return array_splice.apply(this, arguments);
            }
        }
    }, !spliceNoopReturnsEmptyArray);

    var spliceWorksWithEmptyObject = (function () {
        var obj = {};
        ArrayPrototype.splice.call(obj, 0, 0, 1);
        return obj.length === 1;
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            }
            var args = arguments;
            this.length = max(ES.ToInteger(this.length), 0);
            if (arguments.length > 0 && typeof deleteCount !== 'number') {
                args = arraySlice(arguments);
                if (args.length < 2) {
                    pushCall(args, this.length - start);
                } else {
                    args[1] = ES.ToInteger(deleteCount);
                }
            }
            return array_splice.apply(this, args);
        }
    }, !spliceWorksWithEmptyObject);
    var spliceWorksWithLargeSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
        var arr = new $Array(1e5);
        // note: the index MUST be 8 or larger or the test will false pass
        arr[8] = 'x';
        arr.splice(1, 1);
        // note: this test must be defined *after* the indexOf shim
        // per https://github.com/es-shims/es5-shim/issues/313
        return arr.indexOf('x') === 7;
    }());
    var spliceWorksWithSmallSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Opera 12.15 breaks on this, no idea why.
        var n = 256;
        var arr = [];
        arr[n] = 'a';
        arr.splice(n + 1, 0, 'b');
        return arr[n] === 'a';
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            var O = ES.ToObject(this);
            var A = [];
            var len = ES.ToUint32(O.length);
            var relativeStart = ES.ToInteger(start);
            var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
            var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

            var k = 0;
            var from;
            while (k < actualDeleteCount) {
                from = $String(actualStart + k);
                if (owns(O, from)) {
                    A[k] = O[from];
                }
                k += 1;
            }

            var items = arraySlice(arguments, 2);
            var itemCount = items.length;
            var to;
            if (itemCount < actualDeleteCount) {
                k = actualStart;
                var maxK = len - actualDeleteCount;
                while (k < maxK) {
                    from = $String(k + actualDeleteCount);
                    to = $String(k + itemCount);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k += 1;
                }
                k = len;
                var minK = len - actualDeleteCount + itemCount;
                while (k > minK) {
                    delete O[k - 1];
                    k -= 1;
                }
            } else if (itemCount > actualDeleteCount) {
                k = len - actualDeleteCount;
                while (k > actualStart) {
                    from = $String(k + actualDeleteCount - 1);
                    to = $String(k + itemCount - 1);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k -= 1;
                }
            }
            k = actualStart;
            for (var i = 0; i < items.length; ++i) {
                O[k] = items[i];
                k += 1;
            }
            O.length = len - actualDeleteCount + itemCount;

            return A;
        }
    }, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

    var originalJoin = ArrayPrototype.join;
    var hasStringJoinBug;
    try {
        hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
    } catch (e) {
        hasStringJoinBug = true;
    }
    if (hasStringJoinBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
            }
        }, hasStringJoinBug);
    }

    var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
    if (hasJoinUndefinedBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(this, sep);
            }
        }, hasJoinUndefinedBug);
    }

    var pushShim = function push(item) {
        var O = ES.ToObject(this);
        var n = ES.ToUint32(O.length);
        var i = 0;
        while (i < arguments.length) {
            O[n + i] = arguments[i];
            i += 1;
        }
        O.length = n + i;
        return n + i;
    };

    var pushIsNotGeneric = (function () {
        var obj = {};
        var result = Array.prototype.push.call(obj, undefined);
        return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
    }());
    defineProperties(ArrayPrototype, {
        push: function push(item) {
            if (isArray(this)) {
                return array_push.apply(this, arguments);
            }
            return pushShim.apply(this, arguments);
        }
    }, pushIsNotGeneric);

    // This fixes a very weird bug in Opera 10.6 when pushing `undefined
    var pushUndefinedIsWeird = (function () {
        var arr = [];
        var result = arr.push(undefined);
        return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
    }());
    defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);

    // ES5 15.2.3.14
    // http://es5.github.io/#x15.4.4.10
    // Fix boxed string bug
    defineProperties(ArrayPrototype, {
        slice: function (start, end) {
            var arr = isString(this) ? strSplit(this, '') : this;
            return arraySliceApply(arr, arguments);
        }
    }, splitString);

    var sortIgnoresNonFunctions = (function () {
        try {
            [1, 2].sort(null);
            [1, 2].sort({});
            return true;
        } catch (e) {}
        return false;
    }());
    var sortThrowsOnRegex = (function () {
        // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
        try {
            [1, 2].sort(/a/);
            return false;
        } catch (e) {}
        return true;
    }());
    var sortIgnoresUndefined = (function () {
        // applies in IE 8, for one.
        try {
            [1, 2].sort(undefined);
            return true;
        } catch (e) {}
        return false;
    }());
    defineProperties(ArrayPrototype, {
        sort: function sort(compareFn) {
            if (typeof compareFn === 'undefined') {
                return arraySort(this);
            }
            if (!isCallable(compareFn)) {
                throw new TypeError('Array.prototype.sort callback must be a function');
            }
            return arraySort(this, compareFn);
        }
    }, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);

    //
    // Object
    // ======
    //

    // ES5 15.2.3.14
    // http://es5.github.com/#x15.2.3.14

    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = !isEnum({ 'toString': null }, 'toString');
    var hasProtoEnumBug = isEnum(function () {}, 'prototype');
    var hasStringEnumBug = !owns('x', '0');
    var equalsConstructorPrototype = function (o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var blacklistedKeys = {
        $window: true,
        $console: true,
        $parent: true,
        $self: true,
        $frame: true,
        $frames: true,
        $frameElement: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $external: true
    };
    var hasAutomationEqualityBug = (function () {
        /* globals window */
        if (typeof window === 'undefined') {
            return false;
        }
        for (var k in window) {
            try {
                if (!blacklistedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
                    equalsConstructorPrototype(window[k]);
                }
            } catch (e) {
                return true;
            }
        }
        return false;
    }());
    var equalsConstructorPrototypeIfNotBuggy = function (object) {
        if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(object);
        }
        try {
            return equalsConstructorPrototype(object);
        } catch (e) {
            return false;
        }
    };
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var dontEnumsLength = dontEnums.length;

    // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
    // can be replaced with require('is-arguments') if we ever use a build process instead
    var isStandardArguments = function isArguments(value) {
        return toStr(value) === '[object Arguments]';
    };
    var isLegacyArguments = function isArguments(value) {
        return value !== null &&
            typeof value === 'object' &&
            typeof value.length === 'number' &&
            value.length >= 0 &&
            !isArray(value) &&
            isCallable(value.callee);
    };
    var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

    defineProperties($Object, {
        keys: function keys(object) {
            var isFn = isCallable(object);
            var isArgs = isArguments(object);
            var isObject = object !== null && typeof object === 'object';
            var isStr = isObject && isString(object);

            if (!isObject && !isFn && !isArgs) {
                throw new TypeError('Object.keys called on a non-object');
            }

            var theKeys = [];
            var skipProto = hasProtoEnumBug && isFn;
            if ((isStr && hasStringEnumBug) || isArgs) {
                for (var i = 0; i < object.length; ++i) {
                    pushCall(theKeys, $String(i));
                }
            }

            if (!isArgs) {
                for (var name in object) {
                    if (!(skipProto && name === 'prototype') && owns(object, name)) {
                        pushCall(theKeys, $String(name));
                    }
                }
            }

            if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                for (var j = 0; j < dontEnumsLength; j++) {
                    var dontEnum = dontEnums[j];
                    if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
                        pushCall(theKeys, dontEnum);
                    }
                }
            }
            return theKeys;
        }
    });

    var keysWorksWithArguments = $Object.keys && (function () {
        // Safari 5.0 bug
        return $Object.keys(arguments).length === 2;
    }(1, 2));
    var keysHasArgumentsLengthBug = $Object.keys && (function () {
        var argKeys = $Object.keys(arguments);
        return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
    }(1));
    var originalKeys = $Object.keys;
    defineProperties($Object, {
        keys: function keys(object) {
            if (isArguments(object)) {
                return originalKeys(arraySlice(object));
            } else {
                return originalKeys(object);
            }
        }
    }, !keysWorksWithArguments || keysHasArgumentsLengthBug);

    //
    // Date
    // ====
    //

    var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
    var aNegativeTestDate = new Date(-1509842289600292);
    var aPositiveTestDate = new Date(1449662400000);
    var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
    var hasToDateStringFormatBug;
    var hasToStringFormatBug;
    var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
    if (timeZoneOffset < -720) {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
        hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
    } else {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
        hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
    }

    var originalGetFullYear = call.bind(Date.prototype.getFullYear);
    var originalGetMonth = call.bind(Date.prototype.getMonth);
    var originalGetDate = call.bind(Date.prototype.getDate);
    var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
    var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
    var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
    var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
    var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
    var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
    var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
    var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
    var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var daysInMonth = function daysInMonth(month, year) {
        return originalGetDate(new Date(year, month, 0));
    };

    defineProperties(Date.prototype, {
        getFullYear: function getFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            if (year < 0 && originalGetMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getMonth: function getMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getDate: function getDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            var date = originalGetDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        },
        getUTCFullYear: function getUTCFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            if (year < 0 && originalGetUTCMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getUTCMonth: function getUTCMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getUTCDate: function getUTCDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            var date = originalGetUTCDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        }
    }, hasNegativeMonthYearBug);

    defineProperties(Date.prototype, {
        toUTCString: function toUTCString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = originalGetUTCDay(this);
            var date = originalGetUTCDate(this);
            var month = originalGetUTCMonth(this);
            var year = originalGetUTCFullYear(this);
            var hour = originalGetUTCHours(this);
            var minute = originalGetUTCMinutes(this);
            var second = originalGetUTCSeconds(this);
            return dayName[day] + ', ' +
                (date < 10 ? '0' + date : date) + ' ' +
                monthName[month] + ' ' +
                year + ' ' +
                (hour < 10 ? '0' + hour : hour) + ':' +
                (minute < 10 ? '0' + minute : minute) + ':' +
                (second < 10 ? '0' + second : second) + ' GMT';
        }
    }, hasNegativeMonthYearBug || hasToUTCStringFormatBug);

    // Opera 12 has `,`
    defineProperties(Date.prototype, {
        toDateString: function toDateString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            return dayName[day] + ' ' +
                monthName[month] + ' ' +
                (date < 10 ? '0' + date : date) + ' ' +
                year;
        }
    }, hasNegativeMonthYearBug || hasToDateStringFormatBug);

    // can't use defineProperties here because of toString enumeration issue in IE <= 8
    if (hasNegativeMonthYearBug || hasToStringFormatBug) {
        Date.prototype.toString = function toString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            var hour = this.getHours();
            var minute = this.getMinutes();
            var second = this.getSeconds();
            var timezoneOffset = this.getTimezoneOffset();
            var hoursOffset = Math.floor(Math.abs(timezoneOffset) / 60);
            var minutesOffset = Math.floor(Math.abs(timezoneOffset) % 60);
            return dayName[day] + ' ' +
                monthName[month] + ' ' +
                (date < 10 ? '0' + date : date) + ' ' +
                year + ' ' +
                (hour < 10 ? '0' + hour : hour) + ':' +
                (minute < 10 ? '0' + minute : minute) + ':' +
                (second < 10 ? '0' + second : second) + ' GMT' +
                (timezoneOffset > 0 ? '-' : '+') +
                (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset) +
                (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
        };
        if (supportsDescriptors) {
            $Object.defineProperty(Date.prototype, 'toString', {
                configurable: true,
                enumerable: false,
                writable: true
            });
        }
    }

    // ES5 15.9.5.43
    // http://es5.github.com/#x15.9.5.43
    // This function returns a String value represent the instance in time
    // represented by this Date object. The format of the String is the Date Time
    // string format defined in 15.9.1.15. All fields are present in the String.
    // The time zone is always UTC, denoted by the suffix Z. If the time value of
    // this object is not a finite Number a RangeError exception is thrown.
    var negativeDate = -62198755200000;
    var negativeYearString = '-000001';
    var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
    var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

    var getTime = call.bind(Date.prototype.getTime);

    defineProperties(Date.prototype, {
        toISOString: function toISOString() {
            if (!isFinite(this) || !isFinite(getTime(this))) {
                // Adope Photoshop requires the second check.
                throw new RangeError('Date.prototype.toISOString called on non-finite value.');
            }

            var year = originalGetUTCFullYear(this);

            var month = originalGetUTCMonth(this);
            // see https://github.com/es-shims/es5-shim/issues/111
            year += Math.floor(month / 12);
            month = (month % 12 + 12) % 12;

            // the date time string format is specified in 15.9.1.15.
            var result = [month + 1, originalGetUTCDate(this), originalGetUTCHours(this), originalGetUTCMinutes(this), originalGetUTCSeconds(this)];
            year = (
                (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
                strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
            );

            for (var i = 0; i < result.length; ++i) {
                // pad months, days, hours, minutes, and seconds to have two digits.
                result[i] = strSlice('00' + result[i], -2);
            }
            // pad milliseconds to have three digits.
            return (
                year + '-' + arraySlice(result, 0, 2).join('-') +
                'T' + arraySlice(result, 2).join(':') + '.' +
                strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
            );
        }
    }, hasNegativeDateBug || hasSafari51DateBug);

    // ES5 15.9.5.44
    // http://es5.github.com/#x15.9.5.44
    // This function provides a String representation of a Date object for use by
    // JSON.stringify (15.12.3).
    var dateToJSONIsSupported = (function () {
        try {
            return Date.prototype.toJSON &&
                new Date(NaN).toJSON() === null &&
                new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
                Date.prototype.toJSON.call({ // generic
                    toISOString: function () { return true; }
                });
        } catch (e) {
            return false;
        }
    }());
    if (!dateToJSONIsSupported) {
        Date.prototype.toJSON = function toJSON(key) {
            // When the toJSON method is called with argument key, the following
            // steps are taken:

            // 1.  Let O be the result of calling ToObject, giving it the this
            // value as its argument.
            // 2. Let tv be ES.ToPrimitive(O, hint Number).
            var O = $Object(this);
            var tv = ES.ToPrimitive(O);
            // 3. If tv is a Number and is not finite, return null.
            if (typeof tv === 'number' && !isFinite(tv)) {
                return null;
            }
            // 4. Let toISO be the result of calling the [[Get]] internal method of
            // O with argument "toISOString".
            var toISO = O.toISOString;
            // 5. If IsCallable(toISO) is false, throw a TypeError exception.
            if (!isCallable(toISO)) {
                throw new TypeError('toISOString property is not callable');
            }
            // 6. Return the result of calling the [[Call]] internal method of
            //  toISO with O as the this value and an empty argument list.
            return toISO.call(O);

            // NOTE 1 The argument is ignored.

            // NOTE 2 The toJSON function is intentionally generic; it does not
            // require that its this value be a Date object. Therefore, it can be
            // transferred to other kinds of objects for use as a method. However,
            // it does require that any such object have a toISOString method. An
            // object is free to use the argument key to filter its
            // stringification.
        };
    }

    // ES5 15.9.4.2
    // http://es5.github.com/#x15.9.4.2
    // based on work shared by Daniel Friesen (dantman)
    // http://gist.github.com/303249
    var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
    var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
    var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
    if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
        // XXX global assignment won't work in embeddings that use
        // an alternate object for the context.
        /* global Date: true */
        /* eslint-disable no-undef */
        var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
        var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
        /* eslint-disable no-implicit-globals */
        Date = (function (NativeDate) {
        /* eslint-enable no-implicit-globals */
        /* eslint-enable no-undef */
            // Date.length === 7
            var DateShim = function Date(Y, M, D, h, m, s, ms) {
                var length = arguments.length;
                var date;
                if (this instanceof NativeDate) {
                    var seconds = s;
                    var millis = ms;
                    if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
                        // work around a Safari 8/9 bug where it treats the seconds as signed
                        var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                        var sToShift = Math.floor(msToShift / 1e3);
                        seconds += sToShift;
                        millis -= sToShift * 1e3;
                    }
                    date = length === 1 && $String(Y) === Y ? // isString(Y)
                        // We explicitly pass it through parse:
                        new NativeDate(DateShim.parse(Y)) :
                        // We have to manually make calls depending on argument
                        // length here
                        length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) :
                        length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) :
                        length >= 5 ? new NativeDate(Y, M, D, h, m) :
                        length >= 4 ? new NativeDate(Y, M, D, h) :
                        length >= 3 ? new NativeDate(Y, M, D) :
                        length >= 2 ? new NativeDate(Y, M) :
                        length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y) :
                                      new NativeDate();
                } else {
                    date = NativeDate.apply(this, arguments);
                }
                if (!isPrimitive(date)) {
                    // Prevent mixups with unfixed Date object
                    defineProperties(date, { constructor: DateShim }, true);
                }
                return date;
            };

            // 15.9.1.15 Date Time String Format.
            var isoDateExpression = new RegExp('^' +
                '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
                                          // 6-digit extended year
                '(?:-(\\d{2})' + // optional month capture
                '(?:-(\\d{2})' + // optional day capture
                '(?:' + // capture hours:minutes:seconds.milliseconds
                    'T(\\d{2})' + // hours capture
                    ':(\\d{2})' + // minutes capture
                    '(?:' + // optional :seconds.milliseconds
                        ':(\\d{2})' + // seconds capture
                        '(?:(\\.\\d{1,}))?' + // milliseconds capture
                    ')?' +
                '(' + // capture UTC offset component
                    'Z|' + // UTC capture
                    '(?:' + // offset specifier +/-hours:minutes
                        '([-+])' + // sign capture
                        '(\\d{2})' + // hours offset capture
                        ':(\\d{2})' + // minutes offset capture
                    ')' +
                ')?)?)?)?' +
            '$');

            var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

            var dayFromMonth = function dayFromMonth(year, month) {
                var t = month > 1 ? 1 : 0;
                return (
                    months[month] +
                    Math.floor((year - 1969 + t) / 4) -
                    Math.floor((year - 1901 + t) / 100) +
                    Math.floor((year - 1601 + t) / 400) +
                    365 * (year - 1970)
                );
            };

            var toUTC = function toUTC(t) {
                var s = 0;
                var ms = t;
                if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
                    // work around a Safari 8/9 bug where it treats the seconds as signed
                    var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                    var sToShift = Math.floor(msToShift / 1e3);
                    s += sToShift;
                    ms -= sToShift * 1e3;
                }
                return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
            };

            // Copy any custom methods a 3rd party library may have added
            for (var key in NativeDate) {
                if (owns(NativeDate, key)) {
                    DateShim[key] = NativeDate[key];
                }
            }

            // Copy "native" methods explicitly; they may be non-enumerable
            defineProperties(DateShim, {
                now: NativeDate.now,
                UTC: NativeDate.UTC
            }, true);
            DateShim.prototype = NativeDate.prototype;
            defineProperties(DateShim.prototype, {
                constructor: DateShim
            }, true);

            // Upgrade Date.parse to handle simplified ISO 8601 strings
            var parseShim = function parse(string) {
                var match = isoDateExpression.exec(string);
                if (match) {
                    // parse months, days, hours, minutes, seconds, and milliseconds
                    // provide default values if necessary
                    // parse the UTC offset component
                    var year = $Number(match[1]),
                        month = $Number(match[2] || 1) - 1,
                        day = $Number(match[3] || 1) - 1,
                        hour = $Number(match[4] || 0),
                        minute = $Number(match[5] || 0),
                        second = $Number(match[6] || 0),
                        millisecond = Math.floor($Number(match[7] || 0) * 1000),
                        // When time zone is missed, local offset should be used
                        // (ES 5.1 bug)
                        // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                        isLocalTime = Boolean(match[4] && !match[8]),
                        signOffset = match[9] === '-' ? 1 : -1,
                        hourOffset = $Number(match[10] || 0),
                        minuteOffset = $Number(match[11] || 0),
                        result;
                    var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
                    if (
                        hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
                        minute < 60 && second < 60 && millisecond < 1000 &&
                        month > -1 && month < 12 && hourOffset < 24 &&
                        minuteOffset < 60 && // detect invalid offsets
                        day > -1 &&
                        day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
                    ) {
                        result = (
                            (dayFromMonth(year, month) + day) * 24 +
                            hour +
                            hourOffset * signOffset
                        ) * 60;
                        result = (
                            (result + minute + minuteOffset * signOffset) * 60 +
                            second
                        ) * 1000 + millisecond;
                        if (isLocalTime) {
                            result = toUTC(result);
                        }
                        if (-8.64e15 <= result && result <= 8.64e15) {
                            return result;
                        }
                    }
                    return NaN;
                }
                return NativeDate.parse.apply(this, arguments);
            };
            defineProperties(DateShim, { parse: parseShim });

            return DateShim;
        }(Date));
        /* global Date: false */
    }

    // ES5 15.9.4.4
    // http://es5.github.com/#x15.9.4.4
    if (!Date.now) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }

    //
    // Number
    // ======
    //

    // ES5.1 15.7.4.5
    // http://es5.github.com/#x15.7.4.5
    var hasToFixedBugs = NumberPrototype.toFixed && (
      (0.00008).toFixed(3) !== '0.000' ||
      (0.9).toFixed(0) !== '1' ||
      (1.255).toFixed(2) !== '1.25' ||
      (1000000000000000128).toFixed(0) !== '1000000000000000128'
    );

    var toFixedHelpers = {
        base: 1e7,
        size: 6,
        data: [0, 0, 0, 0, 0, 0],
        multiply: function multiply(n, c) {
            var i = -1;
            var c2 = c;
            while (++i < toFixedHelpers.size) {
                c2 += n * toFixedHelpers.data[i];
                toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
                c2 = Math.floor(c2 / toFixedHelpers.base);
            }
        },
        divide: function divide(n) {
            var i = toFixedHelpers.size;
            var c = 0;
            while (--i >= 0) {
                c += toFixedHelpers.data[i];
                toFixedHelpers.data[i] = Math.floor(c / n);
                c = (c % n) * toFixedHelpers.base;
            }
        },
        numToString: function numToString() {
            var i = toFixedHelpers.size;
            var s = '';
            while (--i >= 0) {
                if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
                    var t = $String(toFixedHelpers.data[i]);
                    if (s === '') {
                        s = t;
                    } else {
                        s += strSlice('0000000', 0, 7 - t.length) + t;
                    }
                }
            }
            return s;
        },
        pow: function pow(x, n, acc) {
            return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
        },
        log: function log(x) {
            var n = 0;
            var x2 = x;
            while (x2 >= 4096) {
                n += 12;
                x2 /= 4096;
            }
            while (x2 >= 2) {
                n += 1;
                x2 /= 2;
            }
            return n;
        }
    };

    var toFixedShim = function toFixed(fractionDigits) {
        var f, x, s, m, e, z, j, k;

        // Test for NaN and round fractionDigits down
        f = $Number(fractionDigits);
        f = isActualNaN(f) ? 0 : Math.floor(f);

        if (f < 0 || f > 20) {
            throw new RangeError('Number.toFixed called with invalid number of decimals');
        }

        x = $Number(this);

        if (isActualNaN(x)) {
            return 'NaN';
        }

        // If it is too big or small, return the string value of the number
        if (x <= -1e21 || x >= 1e21) {
            return $String(x);
        }

        s = '';

        if (x < 0) {
            s = '-';
            x = -x;
        }

        m = '0';

        if (x > 1e-21) {
            // 1e-21 < x < 1e21
            // -70 < log2(x) < 70
            e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
            z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
            z *= 0x10000000000000; // Math.pow(2, 52);
            e = 52 - e;

            // -18 < e < 122
            // x = z / 2 ^ e
            if (e > 0) {
                toFixedHelpers.multiply(0, z);
                j = f;

                while (j >= 7) {
                    toFixedHelpers.multiply(1e7, 0);
                    j -= 7;
                }

                toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
                j = e - 1;

                while (j >= 23) {
                    toFixedHelpers.divide(1 << 23);
                    j -= 23;
                }

                toFixedHelpers.divide(1 << j);
                toFixedHelpers.multiply(1, 1);
                toFixedHelpers.divide(2);
                m = toFixedHelpers.numToString();
            } else {
                toFixedHelpers.multiply(0, z);
                toFixedHelpers.multiply(1 << (-e), 0);
                m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
            }
        }

        if (f > 0) {
            k = m.length;

            if (k <= f) {
                m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
            } else {
                m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
            }
        } else {
            m = s + m;
        }

        return m;
    };
    defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

    var hasToPrecisionUndefinedBug = (function () {
        try {
            return 1.0.toPrecision(undefined) === '1';
        } catch (e) {
            return true;
        }
    }());
    var originalToPrecision = NumberPrototype.toPrecision;
    defineProperties(NumberPrototype, {
        toPrecision: function toPrecision(precision) {
            return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
        }
    }, hasToPrecisionUndefinedBug);

    //
    // String
    // ======
    //

    // ES5 15.5.4.14
    // http://es5.github.com/#x15.5.4.14

    // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
    // Many browsers do not split properly with regular expressions or they
    // do not perform the split correctly under obscure conditions.
    // See http://blog.stevenlevithan.com/archives/cross-browser-split
    // I've tested in many browsers and this seems to cover the deviant ones:
    //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
    //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
    //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
    //       [undefined, "t", undefined, "e", ...]
    //    ''.split(/.?/) should be [], not [""]
    //    '.'.split(/()()/) should be ["."], not ["", "", "."]

    if (
        'ab'.split(/(?:ab)*/).length !== 2 ||
        '.'.split(/(.?)(.?)/).length !== 4 ||
        'tesst'.split(/(s)*/)[1] === 't' ||
        'test'.split(/(?:)/, -1).length !== 4 ||
        ''.split(/.?/).length ||
        '.'.split(/()()/).length > 1
    ) {
        (function () {
            var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
            var maxSafe32BitInt = Math.pow(2, 32) - 1;

            StringPrototype.split = function (separator, limit) {
                var string = String(this);
                if (typeof separator === 'undefined' && limit === 0) {
                    return [];
                }

                // If `separator` is not a regex, use native split
                if (!isRegex(separator)) {
                    return strSplit(this, separator, limit);
                }

                var output = [];
                var flags = (separator.ignoreCase ? 'i' : '') +
                            (separator.multiline ? 'm' : '') +
                            (separator.unicode ? 'u' : '') + // in ES6
                            (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
                    lastLastIndex = 0,
                    // Make `global` and avoid `lastIndex` issues by working with a copy
                    separator2, match, lastIndex, lastLength;
                var separatorCopy = new RegExp(separator.source, flags + 'g');
                if (!compliantExecNpcg) {
                    // Doesn't need flags gy, but they don't hurt
                    separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
                }
                /* Values for `limit`, per the spec:
                 * If undefined: 4294967295 // maxSafe32BitInt
                 * If 0, Infinity, or NaN: 0
                 * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
                 * If negative number: 4294967296 - Math.floor(Math.abs(limit))
                 * If other: Type-convert, then use the above rules
                 */
                var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
                match = separatorCopy.exec(string);
                while (match) {
                    // `separatorCopy.lastIndex` is not reliable cross-browser
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        pushCall(output, strSlice(string, lastLastIndex, match.index));
                        // Fix browsers whose `exec` methods don't consistently return `undefined` for
                        // nonparticipating capturing groups
                        if (!compliantExecNpcg && match.length > 1) {
                            /* eslint-disable no-loop-func */
                            match[0].replace(separator2, function () {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (typeof arguments[i] === 'undefined') {
                                        match[i] = void 0;
                                    }
                                }
                            });
                            /* eslint-enable no-loop-func */
                        }
                        if (match.length > 1 && match.index < string.length) {
                            array_push.apply(output, arraySlice(match, 1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= splitLimit) {
                            break;
                        }
                    }
                    if (separatorCopy.lastIndex === match.index) {
                        separatorCopy.lastIndex++; // Avoid an infinite loop
                    }
                    match = separatorCopy.exec(string);
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separatorCopy.test('')) {
                        pushCall(output, '');
                    }
                } else {
                    pushCall(output, strSlice(string, lastLastIndex));
                }
                return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
            };
        }());

    // [bugfix, chrome]
    // If separator is undefined, then the result array contains just one String,
    // which is the this value (converted to a String). If limit is not undefined,
    // then the output array is truncated so that it contains no more than limit
    // elements.
    // "0".split(undefined, 0) -> []
    } else if ('0'.split(void 0, 0).length) {
        StringPrototype.split = function split(separator, limit) {
            if (typeof separator === 'undefined' && limit === 0) {
                return [];
            }
            return strSplit(this, separator, limit);
        };
    }

    var str_replace = StringPrototype.replace;
    var replaceReportsGroupsCorrectly = (function () {
        var groups = [];
        'x'.replace(/x(.)?/g, function (match, group) {
            pushCall(groups, group);
        });
        return groups.length === 1 && typeof groups[0] === 'undefined';
    }());

    if (!replaceReportsGroupsCorrectly) {
        StringPrototype.replace = function replace(searchValue, replaceValue) {
            var isFn = isCallable(replaceValue);
            var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
            if (!isFn || !hasCapturingGroups) {
                return str_replace.call(this, searchValue, replaceValue);
            } else {
                var wrappedReplaceValue = function (match) {
                    var length = arguments.length;
                    var originalLastIndex = searchValue.lastIndex;
                    searchValue.lastIndex = 0;
                    var args = searchValue.exec(match) || [];
                    searchValue.lastIndex = originalLastIndex;
                    pushCall(args, arguments[length - 2], arguments[length - 1]);
                    return replaceValue.apply(this, args);
                };
                return str_replace.call(this, searchValue, wrappedReplaceValue);
            }
        };
    }

    // ECMA-262, 3rd B.2.3
    // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
    // non-normative section suggesting uniform semantics and it should be
    // normalized across all browsers
    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
    var string_substr = StringPrototype.substr;
    var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
    defineProperties(StringPrototype, {
        substr: function substr(start, length) {
            var normalizedStart = start;
            if (start < 0) {
                normalizedStart = max(this.length + start, 0);
            }
            return string_substr.call(this, normalizedStart, length);
        }
    }, hasNegativeSubstrBug);

    // ES5 15.5.4.20
    // whitespace from: http://es5.github.io/#x15.5.4.20
    var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
        '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
        '\u2029\uFEFF';
    var zeroWidth = '\u200b';
    var wsRegexChars = '[' + ws + ']';
    var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
    var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
    var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
    defineProperties(StringPrototype, {
        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
        // http://perfectionkills.com/whitespace-deviations/
        trim: function trim() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
        }
    }, hasTrimWhitespaceBug);
    var trim = call.bind(String.prototype.trim);

    var hasLastIndexBug = StringPrototype.lastIndexOf && 'abcあい'.lastIndexOf('あい', 2) !== -1;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var S = $String(this);
            var searchStr = $String(searchString);
            var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
            var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
            var start = min(max(pos, 0), S.length);
            var searchLen = searchStr.length;
            var k = start + searchLen;
            while (k > 0) {
                k = max(0, k - searchLen);
                var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
                if (index !== -1) {
                    return k + index;
                }
            }
            return -1;
        }
    }, hasLastIndexBug);

    var originalLastIndexOf = StringPrototype.lastIndexOf;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            return originalLastIndexOf.apply(this, arguments);
        }
    }, StringPrototype.lastIndexOf.length !== 1);

    // ES-5 15.1.2.2
    /* eslint-disable radix */
    if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
    /* eslint-enable radix */
        /* global parseInt: true */
        parseInt = (function (origParseInt) {
            var hexRegex = /^[\-+]?0[xX]/;
            return function parseInt(str, radix) {
                var string = trim(String(str));
                var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
                return origParseInt(string, defaultedRadix);
            };
        }(parseInt));
    }

    // https://es5.github.io/#x15.1.2.3
    if (1 / parseFloat('-0') !== -Infinity) {
        /* global parseFloat: true */
        parseFloat = (function (origParseFloat) {
            return function parseFloat(string) {
                var inputString = trim(String(string));
                var result = origParseFloat(inputString);
                return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
            };
        }(parseFloat));
    }

    if (String(new RangeError('test')) !== 'RangeError: test') {
        var errorToStringShim = function toString() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var name = this.name;
            if (typeof name === 'undefined') {
                name = 'Error';
            } else if (typeof name !== 'string') {
                name = $String(name);
            }
            var msg = this.message;
            if (typeof msg === 'undefined') {
                msg = '';
            } else if (typeof msg !== 'string') {
                msg = $String(msg);
            }
            if (!name) {
                return msg;
            }
            if (!msg) {
                return name;
            }
            return name + ': ' + msg;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        Error.prototype.toString = errorToStringShim;
    }

    if (supportsDescriptors) {
        var ensureNonEnumerable = function (obj, prop) {
            if (isEnum(obj, prop)) {
                var desc = Object.getOwnPropertyDescriptor(obj, prop);
                if (desc.configurable) {
                    desc.enumerable = false;
                    Object.defineProperty(obj, prop, desc);
                }
            }
        };
        ensureNonEnumerable(Error.prototype, 'message');
        if (Error.prototype.message !== '') {
            Error.prototype.message = '';
        }
        ensureNonEnumerable(Error.prototype, 'name');
    }

    if (String(/a/mig) !== '/a/gim') {
        var regexToString = function toString() {
            var str = '/' + this.source + '/';
            if (this.global) {
                str += 'g';
            }
            if (this.ignoreCase) {
                str += 'i';
            }
            if (this.multiline) {
                str += 'm';
            }
            return str;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        RegExp.prototype.toString = regexToString;
    }
}));

},{}],9:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   3.3.1
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  return typeof x === 'function' || typeof x === 'object' && x !== null;
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (!Array.isArray) {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
} else {
  _isArray = Array.isArray;
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  return function () {
    vertxNext(flush);
  };
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  _resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        _resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      _reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      _reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    _reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return _resolve(promise, value);
    }, function (reason) {
      return _reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$) {
  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$ === GET_THEN_ERROR) {
      _reject(promise, GET_THEN_ERROR.error);
    } else if (then$$ === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$)) {
      handleForeignThenable(promise, maybeThenable, then$$);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function _resolve(promise, value) {
  if (promise === value) {
    _reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function _reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      _reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      _resolve(promise, value);
    } else if (failed) {
      _reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      _reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      _resolve(promise, value);
    }, function rejectPromise(reason) {
      _reject(promise, reason);
    });
  } catch (e) {
    _reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this._input = input;
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate();
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    _reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
};

Enumerator.prototype._enumerate = function () {
  var length = this.length;
  var _input = this._input;

  for (var i = 0; this._state === PENDING && i < length; i++) {
    this._eachEntry(_input[i], i);
  }
};

Enumerator.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$ = c.resolve;

  if (resolve$$ === resolve) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$) {
        return resolve$$(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$(entry), i);
  }
};

Enumerator.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      _reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  _reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  }
}

Promise.all = all;
Promise.race = race;
Promise.resolve = resolve;
Promise.reject = reject;
Promise._setScheduler = setScheduler;
Promise._setAsap = setAsap;
Promise._asap = asap;

Promise.prototype = {
  constructor: Promise,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    })['catch'](function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor()['catch'](function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

function polyfill() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise;
}

polyfill();
// Strange compat..
Promise.polyfill = polyfill;
Promise.Promise = Promise;

return Promise;

})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":10}],10:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],11:[function(require,module,exports){
'use strict';
module.exports = require('./lib/index');

},{"./lib/index":15}],12:[function(require,module,exports){
'use strict';

var randomFromSeed = require('./random/random-from-seed');

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

module.exports = {
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};

},{"./random/random-from-seed":18}],13:[function(require,module,exports){
'use strict';
var alphabet = require('./alphabet');

/**
 * Decode the id to get the version and worker
 * Mainly for debugging and testing.
 * @param id - the shortid-generated id.
 */
function decode(id) {
    var characters = alphabet.shuffled();
    return {
        version: characters.indexOf(id.substr(0, 1)) & 0x0f,
        worker: characters.indexOf(id.substr(1, 1)) & 0x0f
    };
}

module.exports = decode;

},{"./alphabet":12}],14:[function(require,module,exports){
'use strict';

var randomByte = require('./random/random-byte');

function encode(lookup, number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

module.exports = encode;

},{"./random/random-byte":17}],15:[function(require,module,exports){
'use strict';

var alphabet = require('./alphabet');
var encode = require('./encode');
var decode = require('./decode');
var isValid = require('./is-valid');

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1459707606518;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 6;

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
var clusterWorkerId = require('./util/cluster-worker-id') || 0;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function generate() {

    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + encode(alphabet.lookup, version);
    str = str + encode(alphabet.lookup, clusterWorkerId);
    if (counter > 0) {
        str = str + encode(alphabet.lookup, counter);
    }
    str = str + encode(alphabet.lookup, seconds);

    return str;
}


/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}


// Export all other functions as properties of the generate function
module.exports = generate;
module.exports.generate = generate;
module.exports.seed = seed;
module.exports.worker = worker;
module.exports.characters = characters;
module.exports.decode = decode;
module.exports.isValid = isValid;

},{"./alphabet":12,"./decode":13,"./encode":14,"./is-valid":16,"./util/cluster-worker-id":19}],16:[function(require,module,exports){
'use strict';
var alphabet = require('./alphabet');

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var characters = alphabet.characters();
    var len = id.length;
    for(var i = 0; i < len;i++) {
        if (characters.indexOf(id[i]) === -1) {
            return false;
        }
    }
    return true;
}

module.exports = isShortId;

},{"./alphabet":12}],17:[function(require,module,exports){
'use strict';

var crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

function randomByte() {
    if (!crypto || !crypto.getRandomValues) {
        return Math.floor(Math.random() * 256) & 0x30;
    }
    var dest = new Uint8Array(1);
    crypto.getRandomValues(dest);
    return dest[0] & 0x30;
}

module.exports = randomByte;

},{}],18:[function(require,module,exports){
'use strict';

// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed(_seed_) {
    seed = _seed_;
}

module.exports = {
    nextValue: getNextValue,
    seed: setSeed
};

},{}],19:[function(require,module,exports){
'use strict';

module.exports = 0;

},{}],20:[function(require,module,exports){
"use strict";
var promiseExtensions_1 = require("./../helpers/promiseExtensions");
var activityManagementAPI_1 = require("./activityManagementAPI");
var activityAGM_1 = require("../core/activityAGM");
var ActivityAPI = (function () {
    function ActivityAPI(manager, my) {
        this.version = "2.4.2";
        this.__mgr = manager;
        this._my = my;
        this.all = new activityManagementAPI_1.ActivityManagementAPI(manager, my);
    }
    ActivityAPI.prototype.ready = function (callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this.__mgr.ready()
                .then(function () {
                resolve(_this);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    Object.defineProperty(ActivityAPI.prototype, "my", {
        get: function () {
            return this._my;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "aware", {
        get: function () {
            return this._my.window !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "inActivity", {
        get: function () {
            return this.aware && this._my.activity !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "agm", {
        get: function () {
            if (!this.aware) {
                return undefined;
            }
            if (!this.inActivity) {
                return new activityAGM_1.ActivityAGM(null);
            }
            return this._my.activity.agm;
        },
        enumerable: true,
        configurable: true
    });
    return ActivityAPI;
}());
exports.ActivityAPI = ActivityAPI;

},{"../core/activityAGM":28,"./../helpers/promiseExtensions":39,"./activityManagementAPI":21}],21:[function(require,module,exports){
"use strict";
var util = require("./../helpers/util");
var ActivityManagementAPI = (function () {
    function ActivityManagementAPI(manager, my) {
        this._m = manager;
        this._my = my;
        this.activityTypes = {
            get: this._getActivityTypesWrapper.bind(this),
            register: this._m.registerActivityType.bind(this._m),
            unregister: this._m.unregisterActivityType.bind(this._m),
            subscribe: this._m.subscribeActivityTypeEvents.bind(this._m),
            unsubscribe: undefined,
            initiate: this._m.initiate.bind(this._m)
        };
        this.windowTypes = {
            get: this._getWindowTypesWrapper.bind(this),
            registerFactory: this._m.registerWindowFactory.bind(this._m),
            unregisterFactory: this._m.unregisterWindowFactory.bind(this._m),
            subscribe: this._m.subscribeWindowTypeEvents.bind(this._m),
            unsubscribe: undefined
        };
        this.windows = {
            get: this._m.getWindows.bind(this._m),
            subscribe: this._m.subscribeWindowEvents.bind(this._m),
            announce: this._m.announceWindow.bind(this._m),
            unsubscribe: undefined,
            create: this._m.createWindow.bind(this._m)
        };
        this.instances = {
            get: this._m.getActivities.bind(this._m),
            subscribe: this._m.subscribeActivityEvents.bind(this._m),
            unsubscribe: undefined
        };
    }
    ActivityManagementAPI.prototype._getActivityTypesWrapper = function (name) {
        if (util.isUndefined(name)) {
            return this._m.getActivityTypes();
        }
        return this._m.getActivityType(name);
    };
    ActivityManagementAPI.prototype._getWindowTypesWrapper = function (name) {
        if (util.isUndefined(name)) {
            return this._m.getWindowTypes();
        }
        return this._m.getWindowType(name);
    };
    return ActivityManagementAPI;
}());
exports.ActivityManagementAPI = ActivityManagementAPI;

},{"./../helpers/util":41}],22:[function(require,module,exports){
"use strict";
var logger_1 = require("./../helpers/logger");
var util = require("./../helpers/util");
var ActivityMy = (function () {
    function ActivityMy(manager) {
        var _this = this;
        this._myActivityJoinedCallbacks = [];
        this._myActivityRemovedCallbacks = [];
        this._myContextUpdateCallbacks = [];
        this._logger = logger_1.Logger.Get(this);
        this._m = manager;
        manager.ready()
            .then(function (am) {
            am.subscribeActivityContextChanged(_this._subscribeMyContextChanged.bind(_this));
            am.subscribeWindowEvents(_this._subscribeMyWindowEvent.bind(_this));
        });
    }
    Object.defineProperty(ActivityMy.prototype, "window", {
        get: function () {
            if (util.isUndefinedOrNull(this._w)) {
                var announcedWindows = this._m.announcedWindows;
                if (announcedWindows.length > 0) {
                    this._w = announcedWindows[0];
                }
            }
            return this._w;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityMy.prototype, "activity", {
        get: function () {
            var myWin = this.window;
            if (util.isUndefinedOrNull(myWin)) {
                return undefined;
            }
            return myWin.activity;
        },
        enumerable: true,
        configurable: true
    });
    ActivityMy.prototype.createWindow = function (windowType) {
        return this._m.createWindow(this.activity, windowType);
    };
    ActivityMy.prototype.createStackedWindows = function (windowTypes, timeout) {
        return this._m.createStackedWindows(this.activity, windowTypes, timeout);
    };
    Object.defineProperty(ActivityMy.prototype, "context", {
        get: function () {
            var activity = this.activity;
            if (util.isUndefined(activity)) {
                return {};
            }
            return activity.context;
        },
        enumerable: true,
        configurable: true
    });
    ActivityMy.prototype.onActivityJoined = function (callback) {
        this._myActivityJoinedCallbacks.push(callback);
        var myWin = this.window;
        if (!util.isUndefinedOrNull(myWin) && !util.isUndefinedOrNull(myWin.activity)) {
            callback(myWin.activity);
        }
    };
    ActivityMy.prototype.onActivityLeft = function (callback) {
        this._myActivityRemovedCallbacks.push(callback);
    };
    ActivityMy.prototype.onContextChanged = function (callback) {
        this._myContextUpdateCallbacks.push(callback);
        var myWin = this.window;
        if (util.isUndefinedOrNull(myWin)) {
            return;
        }
        var activity = myWin.activity;
        if (util.isUndefinedOrNull(activity)) {
            return;
        }
        callback(activity.context, activity.context, [], activity);
    };
    ActivityMy.prototype._subscribeMyContextChanged = function (activity, context, delta, removed) {
        var myWin = this.window;
        if (util.isUndefinedOrNull(myWin)) {
            return;
        }
        var myActivity = myWin.activity;
        if (util.isUndefinedOrNull(myActivity)) {
            return;
        }
        if (activity.id !== myActivity.id) {
            return;
        }
        this._notifyMyContextChanged(activity, context, delta, removed);
    };
    ActivityMy.prototype._subscribeMyWindowEvent = function (activity, window, event) {
        if (util.isUndefinedOrNull(this.window)) {
            return;
        }
        if (this.window.id !== window.id) {
            return;
        }
        if (event === "joined") {
            this._notifyOnJoined(activity);
        }
        else {
            this._notifyMyWindowEvent(activity, this._myActivityRemovedCallbacks);
        }
    };
    ActivityMy.prototype._notifyMyWindowEvent = function (activity, callbackStore) {
        for (var index = 0; index < callbackStore.length; index++) {
            var element = callbackStore[index];
            try {
                element(activity, event);
            }
            catch (e) {
                this._logger.warn('error in user callback ' + e);
            }
        }
    };
    ActivityMy.prototype._notifyMyContextChanged = function (activity, context, delta, removed) {
        delta = delta || {};
        removed = removed || [];
        for (var index = 0; index < this._myContextUpdateCallbacks.length; index++) {
            var element = this._myContextUpdateCallbacks[index];
            try {
                element(context, delta, removed, activity);
            }
            catch (e) {
                this._logger.warn('error in user callback ' + e);
            }
        }
    };
    ActivityMy.prototype._notifyOnJoined = function (activity) {
        this._notifyMyWindowEvent(activity, this._myActivityJoinedCallbacks);
        this._notifyMyContextChanged(activity, activity.context);
    };
    return ActivityMy;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityMy;

},{"./../helpers/logger":38,"./../helpers/util":41}],23:[function(require,module,exports){
"use strict";
var ActivityConfig = (function () {
    function ActivityConfig() {
    }
    return ActivityConfig;
}());
exports.ActivityConfig = ActivityConfig;

},{}],24:[function(require,module,exports){
"use strict";
require("es6-promise");
var hcBridge_1 = require("./bridges/hcBridge");
var activityManager_1 = require("./core/activityManager");
var activityMyAPI_1 = require("./API/activityMyAPI");
var logger_1 = require("./helpers/logger");
var util = require("./helpers/util");
var activityConfig_1 = require("./activityConfig");
var activityAPI_1 = require("./API/activityAPI");
var activityAGM_1 = require("./core/activityAGM");
var activity = function (config) {
    config = config || new activityConfig_1.ActivityConfig;
    if (!util.isUndefined(config.logLevel)) {
        logger_1.Logger.Level = config.logLevel;
    }
    if (!util.isUndefinedOrNull(config.logger)) {
        logger_1.Logger.GlueLogger = config.logger;
    }
    var bridge;
    if (!util.isUndefined(window.htmlContainer)) {
        bridge = new hcBridge_1['default']();
    }
    else {
        throw new Error("Activity not supported in in browser");
    }
    if (!bridge) {
        throw new Error("A bridge to native activity is needed to create activity lib.");
    }
    activityAGM_1.ActivityAGM.AGM = config.agm;
    var activityManager = new activityManager_1['default'](bridge, !config.disableAutoAnnounce);
    var my = new activityMyAPI_1['default'](activityManager);
    return new activityAPI_1.ActivityAPI(activityManager, my);
};
module.exports = activity;

},{"./API/activityAPI":20,"./API/activityMyAPI":22,"./activityConfig":23,"./bridges/hcBridge":25,"./core/activityAGM":28,"./core/activityManager":29,"./helpers/logger":38,"./helpers/util":41,"es6-promise":9}],25:[function(require,module,exports){
"use strict";
var entityEvent_1 = require("../contracts/entityEvent");
var activityStatus_1 = require("../contracts/activityStatus");
var activityType_1 = require("../entities/activityType");
var windowType_1 = require("../entities/windowType");
var activity_1 = require("../entities/activity");
var activityWindow_1 = require("../entities/activityWindow");
var proxyWindowFactory_1 = require("../core/proxyWindowFactory");
var logger_1 = require("../helpers/logger");
var entityEvent_2 = require("../contracts/entityEvent");
var readyMarker_1 = require("../helpers/readyMarker");
var util = require("../helpers/util");
var entityEvent_3 = require("../contracts/entityEvent");
var HCBridge = (function () {
    function HCBridge(agm) {
        this._activityTypeEntityName = "activityType";
        this._windowTypeEntityName = "windowType";
        this._activityEntityName = "activity";
        this._windowEntityName = "activityWindow";
        this._logger = logger_1.Logger.Get(this);
        this._lastSeq = 0;
        this._eventQueue = [];
        this._activityTypeCallbacks = [];
        this._windowTypeCallbacks = [];
        this._activityCallbacks = [];
        this._windowCallbacks = [];
        this._agm = agm;
    }
    HCBridge.prototype.init = function () {
        var _this = this;
        this._readyMarker = new readyMarker_1.ReadyMarker("HC Bridge", 1);
        this._htmlContainer = window.htmlContainer.activityFacade;
        this._htmlContainer.init(this._agm ? this._agm.instance : undefined, this._hcEventHandler.bind(this), function () {
            _this._readyMarker.signal("Init done from HC");
        }, function (error) {
            _this._readyMarker.error(error);
        });
    };
    HCBridge.prototype.ready = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._readyMarker.setCallback(function (err) {
                if (!err) {
                    resolve(_this);
                }
                else {
                    _this._logger.error("Error initializing HC bridge - " + err);
                    reject(_this._readyMarker.getError());
                }
            });
        });
    };
    HCBridge.prototype._hcEventHandler = function (eventJson) {
        this._logger.trace(eventJson);
        var event = JSON.parse(eventJson);
        this._processEventBySeq(event);
    };
    HCBridge.prototype._processEventBySeq = function (event) {
        var seq = event.sequence;
        if (seq === this._lastSeq + 1) {
            this._processEvent(event);
            this._lastSeq++;
            var nextEvent = this._eventQueue[seq + 1];
            if (!util.isUndefined(nextEvent)) {
                this._logger.debug("replaying message number " + seq);
                this._processEventBySeq(nextEvent);
                delete this._eventQueue[seq + 1];
            }
        }
        else {
            this._eventQueue[seq] = event;
            this._logger.debug("Got out of order event with number " + seq + ". Will wait for previous event(s) before replaying.");
        }
    };
    HCBridge.prototype._processEvent = function (event) {
        var entityType = event.entityType;
        var eventContext = this._convertContext(event.context);
        var entity;
        switch (entityType) {
            case this._activityTypeEntityName:
                entity = HCBridge._hcToJsActivityType(event.entity);
                this._publishActivityTypeStatusChange(entity, eventContext);
                break;
            case this._windowTypeEntityName:
                entity = this._hcToJsWindowType(event.entity);
                this._publishWindowTypeStatusChange(entity, eventContext);
                break;
            case this._activityEntityName:
                entity = this._hcToJsActivity(event.entity);
                this._publishActivityStatusChange(entity, eventContext);
                break;
            case this._windowEntityName:
                entity = HCBridge._hcToJsWindow(event.entity);
                this._publishActivityWindowEvent(entity, eventContext);
                break;
        }
    };
    HCBridge.prototype._convertContext = function (hcContext) {
        if (hcContext.type === entityEvent_1.EntityEventType.StatusChange) {
            var oldStatus = new activityStatus_1.ActivityStatus(hcContext.oldStatus.state, hcContext.oldStatus.statusMessage, hcContext.oldStatus.statusTime);
            var newStatus = new activityStatus_1.ActivityStatus(hcContext.newStatus.state, hcContext.newStatus.statusMessage, hcContext.newStatus.statusTime);
            return new entityEvent_1.EntityStatusChangeEventContext(newStatus, oldStatus);
        }
        else if (hcContext.type === entityEvent_1.EntityEventType.ActivityWindowEvent) {
            var act = this._hcToJsActivity(hcContext.activity);
            return new entityEvent_1.EntityActivityWindowEventContext(act, hcContext.event);
        }
        else if (hcContext.type === entityEvent_1.EntityEventType.ActivityContextChange) {
            return new entityEvent_3.ActivityContextChangedContext(hcContext.newContext, hcContext.updated, hcContext.removed);
        }
        return new entityEvent_1.EntityEventContext(hcContext.type);
    };
    HCBridge._hcToJsWindow = function (hcWindow) {
        return new activityWindow_1['default'](hcWindow.id, hcWindow.name, hcWindow.type, hcWindow.activityId, hcWindow.instance, hcWindow.isIndependent);
    };
    HCBridge.prototype._hcToJsActivity = function (hcAct) {
        var window = hcAct.owner ? HCBridge._hcToJsWindow(hcAct.owner) : null;
        var windowId = window ? window.id : null;
        var status = new activityStatus_1.ActivityStatus(hcAct.status.state, hcAct.status.statusMessage, hcAct.status.statusTime);
        var context = JSON.parse(hcAct.context);
        return new activity_1['default'](hcAct.id, hcAct.type.name, status, context, windowId);
    };
    HCBridge._hcToJsActivityType = function (hcActType) {
        return new activityType_1['default'](hcActType.name, hcActType.ownerWindowType, hcActType.helperWindowTypes, hcActType.description);
    };
    HCBridge.prototype._hcToJsWindowType = function (hcWinType) {
        if (util.isUndefined(hcWinType.factories)) {
            hcWinType.factories = [];
        }
        var factories = hcWinType.factories.map(function (f) {
            return HCBridge._hcToJsWindowTypeFactory(f);
        });
        return new windowType_1['default'](hcWinType.name, factories);
    };
    HCBridge._hcToJsWindowTypeFactory = function (hcWinTypeFactory) {
        return new proxyWindowFactory_1.ProxyWindowFactory(hcWinTypeFactory.description);
    };
    HCBridge._getURLParameter = function (name) {
        return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.search) || [, ""])[1].replace(/\+/g, '%20')) || null;
    };
    HCBridge.prototype.getActivityTypes = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getActivityTypes(function (infos) {
                var result = [];
                for (var index = 0; index < infos.length; index++) {
                    var info = infos[index];
                    var newActivityType = HCBridge._hcToJsActivityType(info);
                    result.push(newActivityType);
                }
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.registerActivityType = function (activityTypeName, ownerWindow, helperWindows, layoutConfig, description) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (helperWindows === undefined) {
                helperWindows = [];
            }
            var config = {
                name: activityTypeName,
                ownerWindowType: ownerWindow,
                helperWindowTypes: helperWindows,
                description: description,
                layoutConfig: JSON.stringify(layoutConfig)
            };
            _this._htmlContainer.registerActivityType(JSON.stringify(config), function (info) {
                var newActivityType = HCBridge._hcToJsActivityType(info);
                resolve(newActivityType);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.unregisterActivityType = function (activityTypeName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.unregisterActivityType(activityTypeName, function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.getWindowTypes = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindowTypes(function (infos) {
                var result = [];
                for (var index = 0; index < infos.length; index++) {
                    var info = infos[index];
                    var newWindowType = _this._hcToJsWindowType(info);
                    result.push(newWindowType);
                }
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.registerWindowFactory = function (windowTypeName, factory) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowTypeName)) {
                reject("windowTypeName should be provided");
                return;
            }
            _this._htmlContainer.registerWindowFactory(windowTypeName, factory.create.bind(factory), function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.initiateActivity = function (activityType, context, callback) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activityType)) {
                reject("windowTypeName should be provided");
                return;
            }
            if (util.isUndefinedOrNull(context)) {
                context = {};
            }
            _this._htmlContainer.initiate(activityType, JSON.stringify(context), function (activityId) {
                resolve(activityId);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.getAnnouncementInfo = function () {
        var hc = window.htmlContainer;
        var context = hc.getContext();
        var result = { activityWindowId: "", activityWindowType: "", activityWindowIndependent: false, activityWindowName: "" };
        result.activityWindowType = context.activityWindowType;
        if (util.isUndefined(result.activityWindowType)) {
            result.activityWindowType = HCBridge._getURLParameter("activityWindowType");
        }
        result.activityWindowId = context.activityWindowId;
        if (util.isUndefined(result.activityWindowId)) {
            result.activityWindowId = HCBridge._getURLParameter("activityWindowId");
        }
        result.activityWindowIndependent = context.activityWindowIndependent;
        if (util.isUndefined(result.activityWindowIndependent)) {
        }
        result.activityWindowName = context.activityWindowName;
        if (util.isUndefined(result.activityWindowName)) {
            result.activityWindowName = HCBridge._getURLParameter("activityWindowName");
        }
        return result;
    };
    HCBridge.prototype.announceWindow = function (windowType, activityWindowId) {
        var _this = this;
        if (util.isUndefined(windowType)) {
            throw new Error("can not determine window type");
        }
        if (util.isUndefined(windowType)) {
            throw new Error("can not determine window activityWindowId");
        }
        this._htmlContainer.announceWindow(windowType, activityWindowId, function (error) {
            _this._logger.error("Error announcing activity window with id '" + activityWindowId + "'. " + error);
        });
    };
    HCBridge.prototype.getActivities = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._logger.trace("Executing getActivities()");
            _this._htmlContainer.getActivities(function (activitiesStr) {
                _this._logger.trace("Got getActivities() :" + activitiesStr);
                var activities = JSON.parse(activitiesStr);
                var result = activities.map(function (act) { return _this._hcToJsActivity(act); });
                resolve(result);
            }, function (error) {
                _this._logger.trace("Error in getActivities() :" + error);
                reject(error);
            });
        });
    };
    HCBridge.prototype.updateActivityContext = function (activity, context, fullReplace, removedKeys) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefined(removedKeys)) {
                removedKeys = [];
            }
            var options = {
                fullReplace: fullReplace,
                removedKeys: removedKeys
            };
            _this._htmlContainer.setActivityContext(activity.id, JSON.stringify(context), JSON.stringify(options), function (newContextString) {
                var newContext = JSON.parse(newContextString);
                resolve(newContext);
            }, function (error) { return reject(error); });
        });
    };
    HCBridge.prototype.getActivityWindows = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindows(function (windows) {
                var result = windows.map(function (wind) { return HCBridge._hcToJsWindow(wind); });
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.stopActivity = function (activity) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.stopActivity(activity.id, function (result) {
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.unregisterWindowFactory = function (windowTypeName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.registerWindowFactory(windowTypeName, function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.createWindow = function (id, windowDefinition) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.createWindow(id, JSON.stringify(windowDefinition), function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.createStackedWindows = function (id, windowDefinitions, timeout) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.createStackedWindows(id, JSON.stringify(windowDefinitions), timeout, function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.onActivityTypeStatusChange = function (callback) {
        this._activityTypeCallbacks.push(callback);
    };
    HCBridge.prototype.onWindowTypeStatusChange = function (callback) {
        this._windowTypeCallbacks.push(callback);
    };
    HCBridge.prototype.onActivityStatusChange = function (callback) {
        this._activityCallbacks.push(callback);
    };
    HCBridge.prototype.onActivityWindowChange = function (callback) {
        this._windowCallbacks.push(callback);
    };
    HCBridge.prototype.getWindowBounds = function (id) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindowBounds(id, function (bounds) {
                resolve(bounds);
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.setWindowBounds = function (id, bounds) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.setWindowBounds(id, JSON.stringify(bounds), function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.registerWindow = function (type, name, independent) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.registerWindow(type, name, independent, function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.closeWindow = function (id) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.closeWindow(id, function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.activateWindow = function (id, focus) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.activateWindow(id, focus, function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.setWindowVisibility = function (id, visible) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.setWindowVisibility(id, visible, function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype._publishStatusChange = function (entity, context, callbacks) {
        var entityEvent = new entityEvent_2.EntityEvent(entity, context);
        callbacks.forEach(function (callback) {
            callback(entityEvent);
        });
    };
    HCBridge.prototype._publishActivityTypeStatusChange = function (at, context) {
        this._publishStatusChange(at, context, this._activityTypeCallbacks);
    };
    HCBridge.prototype._publishWindowTypeStatusChange = function (wt, context) {
        this._publishStatusChange(wt, context, this._windowTypeCallbacks);
    };
    HCBridge.prototype._publishActivityStatusChange = function (act, context) {
        this._publishStatusChange(act, context, this._activityCallbacks);
    };
    HCBridge.prototype._publishActivityWindowEvent = function (w, context) {
        this._publishStatusChange(w, context, this._windowCallbacks);
    };
    return HCBridge;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= HCBridge;

},{"../contracts/activityStatus":26,"../contracts/entityEvent":27,"../core/proxyWindowFactory":31,"../entities/activity":32,"../entities/activityType":34,"../entities/activityWindow":35,"../entities/windowType":36,"../helpers/logger":38,"../helpers/readyMarker":40,"../helpers/util":41}],26:[function(require,module,exports){
"use strict";
var ActivityStatus = (function () {
    function ActivityStatus(state, message, time) {
        this.state = state;
        this.message = message;
        this.time = time;
    }
    ActivityStatus.prototype.getState = function () {
        return this.state;
    };
    ActivityStatus.prototype.getMessage = function () {
        return this.message;
    };
    ActivityStatus.prototype.getTime = function () {
        return this.time;
    };
    return ActivityStatus;
}());
exports.ActivityStatus = ActivityStatus;

},{}],27:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var EntityEvent = (function () {
    function EntityEvent(entitiy, context) {
        this.entity = entitiy;
        this.context = context;
    }
    return EntityEvent;
}());
exports.EntityEvent = EntityEvent;
var EntityEventContext = (function () {
    function EntityEventContext(eventType) {
        this.type = eventType;
    }
    return EntityEventContext;
}());
exports.EntityEventContext = EntityEventContext;
var EntityStatusChangeEventContext = (function (_super) {
    __extends(EntityStatusChangeEventContext, _super);
    function EntityStatusChangeEventContext(newStatus, oldStatus) {
        _super.call(this, EntityEventType.StatusChange);
        this.newStatus = newStatus;
        this.oldStatus = oldStatus;
    }
    return EntityStatusChangeEventContext;
}(EntityEventContext));
exports.EntityStatusChangeEventContext = EntityStatusChangeEventContext;
var EntityActivityWindowEventContext = (function (_super) {
    __extends(EntityActivityWindowEventContext, _super);
    function EntityActivityWindowEventContext(activity, event) {
        _super.call(this, EntityEventType.ActivityWindowEvent);
        this.activity = activity;
        this.event = event;
    }
    return EntityActivityWindowEventContext;
}(EntityEventContext));
exports.EntityActivityWindowEventContext = EntityActivityWindowEventContext;
var ActivityContextChangedContext = (function (_super) {
    __extends(ActivityContextChangedContext, _super);
    function ActivityContextChangedContext(context, updated, removed) {
        _super.call(this, EntityEventType.ActivityContextChange);
        this.updated = updated;
        this.removed = removed;
        this.context = JSON.parse(context);
    }
    return ActivityContextChangedContext;
}(EntityEventContext));
exports.ActivityContextChangedContext = ActivityContextChangedContext;
var EntityEventType = (function () {
    function EntityEventType() {
    }
    EntityEventType.Added = "added";
    EntityEventType.Removed = "removed";
    EntityEventType.Updated = "updated";
    EntityEventType.FactoryRegistered = "factoryRegistered";
    EntityEventType.FactoryUnregistered = "factoryUnregistered";
    EntityEventType.StatusChange = "statusChange";
    EntityEventType.ActivityContextChange = "activityContextUpdate";
    EntityEventType.ActivityWindowEvent = "activityWindowEvent";
    return EntityEventType;
}());
exports.EntityEventType = EntityEventType;

},{}],28:[function(require,module,exports){
"use strict";
var util = require("../helpers/util");
var ActivityAGM = (function () {
    function ActivityAGM(activity) {
        this._activity = activity;
    }
    ActivityAGM.prototype.register = function (definition, handler) {
        this._ensureHasAgm();
        ActivityAGM.AGM.register(definition, handler);
    };
    ActivityAGM.prototype.servers = function () {
        this._ensureHasAgm();
        if (util.isUndefinedOrNull(this._activity)) {
            return [];
        }
        return this._activity.windows.map(function (w) {
            return w.instance;
        });
    };
    ActivityAGM.prototype.methods = function () {
        this._ensureHasAgm();
        if (util.isUndefinedOrNull(this._activity)) {
            return [];
        }
        var windows = this._activity.windows;
        var methodNames = [];
        var methods = [];
        for (var index = 0; index < windows.length; index++) {
            var window_1 = windows[index];
            var windowMethods = this.methodsForWindow(window_1);
            for (var methodIndex = 0; methodIndex < windowMethods.length; methodIndex++) {
                var currentWindowMethod = windowMethods[methodIndex];
                if (methodNames.indexOf(currentWindowMethod.name) === -1) {
                    methodNames.push(currentWindowMethod.name);
                    methods.push(currentWindowMethod);
                }
            }
        }
        return methods;
    };
    ActivityAGM.prototype.methodsForWindow = function (window) {
        this._ensureHasAgm();
        if (!window.instance) {
            return [];
        }
        return ActivityAGM.AGM.methodsForInstance(window.instance);
    };
    ActivityAGM.prototype.invoke = function (methodName, arg, target, options, success, error) {
        this._ensureHasAgm();
        var activityServers = this.servers();
        var serversToInvokeAgainst = [];
        if (util.isUndefinedOrNull(target)) {
            target = "activity.all";
        }
        if (util.isString(target)) {
            if (target === "activity.all") {
                serversToInvokeAgainst = activityServers;
            }
            else if (target === "activity.best") {
                var potentialTargets = activityServers.filter(function (server) {
                    var methods = ActivityAGM.AGM.methodsForInstance(server);
                    return methods.filter(function (m) {
                        return m.name === methodName;
                    }).length > 0;
                });
                if (potentialTargets.length > 0) {
                    serversToInvokeAgainst = [potentialTargets[0]];
                }
            }
            else if (target === "all" || target === "best") {
                return ActivityAGM.AGM.invoke(methodName, arg, target, options, success, error);
            }
            else {
                throw new Error("Invalid invoke target " + target);
            }
        }
        else if (util.isArray(target)) {
            if (target.length >= 0) {
                var firstElem = target[0];
                if (this._isAgmInstance(firstElem)) {
                    serversToInvokeAgainst = target.map(function (instance) { return instance; });
                }
                else if (this._isActivityWindow(firstElem)) {
                    serversToInvokeAgainst = target.map(function (win) { return win.instance; });
                }
                else {
                    throw new Error("Unknown target object");
                }
            }
        }
        else {
            if (this._isAgmInstance(target)) {
                serversToInvokeAgainst = [target];
            }
            else if (this._isActivityWindow(target)) {
                serversToInvokeAgainst = [target.instance];
            }
            else {
                throw new Error("Unknown target object");
            }
        }
        return ActivityAGM.AGM.invoke(methodName, arg, serversToInvokeAgainst, options, success, error);
    };
    ActivityAGM.prototype.unregister = function (definition) {
        this._ensureHasAgm();
        return ActivityAGM.AGM.unregister(definition);
    };
    ActivityAGM.prototype.createStream = function (methodDefinition, subscriberAddedHandler, subscriberRemovedFunction) {
        this._ensureHasAgm();
        ActivityAGM.AGM.createStream(methodDefinition, subscriberAddedHandler, subscriberRemovedFunction);
    };
    ActivityAGM.prototype.subscribe = function (methodDefinition, parameters, target) {
        this._ensureHasAgm();
        var servers = this.servers();
        return ActivityAGM.AGM.subscribe(methodDefinition, parameters, servers);
    };
    ActivityAGM.prototype._ensureHasAgm = function () {
        if (util.isUndefinedOrNull(ActivityAGM.AGM)) {
            throw new Error("Agm should be configured to be used in activity");
        }
    };
    ActivityAGM.prototype._isAgmInstance = function (obj) {
        return obj.application != undefined;
    };
    ActivityAGM.prototype._isActivityWindow = function (obj) {
        return obj.instance !== undefined;
    };
    return ActivityAGM;
}());
exports.ActivityAGM = ActivityAGM;

},{"../helpers/util":41}],29:[function(require,module,exports){
"use strict";
var entityEvent_1 = require("../contracts/entityEvent");
var activityType_1 = require("../entities/activityType");
var promiseExtensions_1 = require("../helpers/promiseExtensions");
var readyMarker_1 = require("../helpers/readyMarker");
var entityObservableCollection_1 = require("../helpers/entityObservableCollection");
var logger_1 = require("../helpers/logger");
var util = require("../helpers/util");
var localWindowFactory_1 = require("./localWindowFactory");
var ActivityManager = (function () {
    function ActivityManager(bridge, autoAnnounce) {
        var _this = this;
        this._logger = logger_1.Logger.Get(this);
        this._announcedWindows = [];
        this._bridge = bridge;
        this._activityTypes = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._windowTypes = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._activities = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._windows = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._dataReadyMarker = new readyMarker_1.ReadyMarker("Activity Manager Data", ["GetActivityTypes", "GetWindowTypes", "GetActivities", "GetWindows"].length);
        if (autoAnnounce) {
            var announceMaker = new readyMarker_1.ReadyMarker("Activity Manager Announce", ["Announcement"].length);
            this._readyMarker = announceMaker;
            this._dataReadyMarker.setCallback(function (err) {
                if (err) {
                    _this._readyMarker.error(err);
                }
                _this._logger.debug("Auto announcing window");
                _this.announceWindow()
                    .then(function (w) {
                    _this._announcedWindows.push(w);
                    _this._readyMarker.signal("Successfully announced window with id '" + w.id + "'");
                })['catch'](function (err) {
                    _this._logger.debug("Will not announce window - " + err);
                    _this._readyMarker.signal();
                });
            });
        }
        else {
            this._readyMarker = this._dataReadyMarker;
        }
        this._bridge.init();
        this._bridge
            .ready()
            .then(function (aw) {
            _this._subscribeForData();
        })['catch'](function (error) {
            console.log(error);
        });
    }
    Object.defineProperty(ActivityManager.prototype, "announcedWindows", {
        get: function () {
            return this._announcedWindows;
        },
        set: function (v) {
            throw new Error("not allowed");
        },
        enumerable: true,
        configurable: true
    });
    ActivityManager.prototype.ready = function (callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this._readyMarker.setCallback(function (err) {
                if (!err) {
                    resolve(_this);
                }
                else {
                    reject(_this._readyMarker.getError());
                }
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getActivityTypes = function () {
        return this._activityTypes.get();
    };
    ActivityManager.prototype.getActivityType = function (name) {
        return this._activityTypes.getByName(name);
    };
    ActivityManager.prototype.registerActivityType = function (activityTypeName, ownerWindowType, helperWindowTypes, layoutConfig, description, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activityTypeName)) {
                reject("activityTypeName argument can not be undefined");
            }
            if (!util.isString(activityTypeName)) {
                reject("activityTypeName should be string");
            }
            var actType = _this.getActivityType(activityTypeName);
            if (!util.isUndefinedOrNull(actType)) {
                reject("Activity type '" + activityTypeName + "' already exists");
            }
            var ownerDefinition;
            if (util.isUndefined(ownerWindowType)) {
                reject("Owner window type can not be undefined");
            }
            if (util.isString(ownerWindowType)) {
                ownerDefinition = { type: ownerWindowType, name: "", isIndependent: false, arguments: {} };
            }
            else {
                ownerDefinition = ownerWindowType;
            }
            var helperDefinitions = [];
            if (!util.isUndefined(helperWindowTypes) && util.isArray(helperWindowTypes)) {
                for (var index in helperWindowTypes) {
                    var item = helperWindowTypes[index];
                    if (util.isString(item)) {
                        var definition = {
                            type: item,
                            name: "",
                            isIndependent: false,
                            arguments: {},
                            relativeTo: "",
                            relativeDirection: "",
                            windowStyleAttributes: {}
                        };
                        helperDefinitions.push(definition);
                    }
                    else {
                        helperDefinitions.push(item);
                    }
                }
            }
            _this._bridge
                .registerActivityType(activityTypeName, ownerDefinition, helperDefinitions, layoutConfig, description)
                .then(function (activityType) {
                _this._grabEntity(activityType);
                resolve(activityType);
            })['catch'](function (error) {
                reject(error);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.unregisterActivityType = function (type, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var actType = _this.getActivityType(type);
            if (util.isUndefined(actType)) {
                reject("Activity type '" + type + "' does not exists");
            }
            return _this._bridge.unregisterActivityType(type);
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.initiate = function (activityType, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var actType = _this.getActivityType(activityType);
            if (util.isUndefined(actType)) {
                reject("Activity type '" + activityType + "' does not exists");
            }
            _this._bridge
                .initiateActivity(activityType, context)
                .then(function (actId) {
                _this._activities
                    .getOrWait(actId)
                    .then(function (act) {
                    resolve(act);
                })['catch'](function (err) { return reject(err); });
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.subscribeActivityTypeEvents = function (handler) {
        this._activityTypes.subscribe(function (at, context) {
            handler(at, context.type);
        });
    };
    ActivityManager.prototype.getWindowTypes = function () {
        return this._windowTypes.get();
    };
    ActivityManager.prototype.getWindowType = function (name) {
        return this._windowTypes.getByName(name);
    };
    ActivityManager.prototype.registerWindowFactory = function (windowType, factoryMethod, description, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowType)) {
                reject("no windowType specified");
                return;
            }
            if (util.isObject(windowType)) {
                windowType = windowType.getName();
            }
            else if (!util.isString(windowType)) {
                reject("windowType should be string or object that has getName method");
                return;
            }
            var factory = new localWindowFactory_1.LocalWindowFactory(factoryMethod, description);
            _this._bridge
                .registerWindowFactory(windowType, factory)
                .then(function (v) {
                resolve(v);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.unregisterWindowFactory = function (windowType, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowType)) {
                reject("no windowType specified");
                return;
            }
            if (!util.isString(windowType)) {
                reject("windowType should be a string");
                return;
            }
            _this._bridge
                .unregisterWindowFactory(windowType)
                .then(function (v) {
                resolve(v);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getActivities = function (activityType) {
        var act = this._activities.get();
        if (!activityType) {
            return act;
        }
        var types = activityType;
        if (util.isString(activityType)) {
            types = [activityType];
        }
        else if (activityType instanceof activityType_1['default']) {
            types = [activityType.name];
        }
        else if (activityType instanceof Array) {
        }
        else {
            throw new Error("Invalid input argument 'activityType' = " + activityType);
        }
        return act.filter(function (act) {
            var type = act.type;
            return util.some(types, function (t) {
                return type.id == t.id;
            });
        });
    };
    ActivityManager.prototype.getActivityById = function (id) {
        return this._activities.getByName(id);
    };
    ActivityManager.prototype.announceWindow = function (activityWindowId, windowType) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var announcementInfo = _this._bridge.getAnnouncementInfo();
            if (util.isUndefined(activityWindowId)) {
                activityWindowId = announcementInfo.activityWindowId;
            }
            if (util.isUndefined(windowType)) {
                windowType = announcementInfo.activityWindowType;
            }
            if (util.isUndefinedOrNull(windowType)) {
                throw new Error("Can not announce - unknown windowType");
            }
            if (util.isUndefinedOrNull(activityWindowId)) {
                _this._logger.debug("Registering window with type:'" + windowType + "', name:'" + announcementInfo.activityWindowName + "', ind.:'" + announcementInfo.activityWindowIndependent + "'");
                _this._bridge.registerWindow(windowType, announcementInfo.activityWindowName, announcementInfo.activityWindowIndependent)
                    .then(_this._windows.getOrWait.bind(_this._windows))
                    .then(function (w) {
                    resolve(w);
                })['catch'](function (err) {
                    _this._logger.error(err);
                });
            }
            else {
                _this._logger.debug("Announcing window with id '" + activityWindowId + "' and type '" + windowType + "'");
                var currentWindow = _this._windows.getByName(activityWindowId);
                if (!util.isUndefinedOrNull(currentWindow)) {
                    _this._logger.debug("Window with id '" + activityWindowId + "' already announced - reusing the window");
                    resolve(currentWindow);
                    return;
                }
                var windowEventHandler = function (a, w, e) {
                    if (activityWindowId === w.id) {
                        if (e === "joined") {
                            var activity = w.activity;
                            if (util.isUndefined(activity)) {
                                reject("UNDEFINED ACTIVITY");
                            }
                            _this._logger.trace("Got joined event for id '" + activityWindowId + "'");
                            resolve(w);
                            _this.unsubscribeWindowEvents(windowEventHandler);
                        }
                    }
                };
                _this.subscribeWindowEvents(windowEventHandler);
                _this._logger.trace("Waiting for joined event for id '" + activityWindowId + "'");
                _this._bridge.announceWindow(windowType, activityWindowId);
            }
        });
        return promise;
    };
    ActivityManager.prototype.subscribeWindowTypeEvents = function (handler) {
        this._windowTypes.subscribe(function (wt, context) {
            handler(wt, context.type);
        });
    };
    ActivityManager.prototype.subscribeActivityEvents = function (handler) {
        this._activities.subscribe(function (act, context) {
            if (context.type === entityEvent_1.EntityEventType.StatusChange) {
                var p = context;
                handler(act, p.newStatus, p.oldStatus);
            }
        });
    };
    ActivityManager.prototype.subscribeWindowEvents = function (handler) {
        this._windows.subscribe(function (window, context) {
            if (context.type === entityEvent_1.EntityEventType.ActivityWindowEvent) {
                var p = context;
                handler(window.activity, window, p.event);
            }
            else if (context.type === 'removed') {
                handler(window.activity, window, context.type);
            }
        });
    };
    ActivityManager.prototype.unsubscribeWindowEvents = function (handler) {
    };
    ActivityManager.prototype.createWindow = function (activity, windowType, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity is undefined");
            }
            if (util.isUndefinedOrNull(windowType)) {
                reject("windowType is undefined");
            }
            var windowDefinition;
            if (util.isString(windowType)) {
                windowDefinition = { type: windowType, name: "", isIndependent: false, arguments: {} };
            }
            else {
                windowDefinition = windowType;
            }
            var relativeToWindow;
            if (!util.isUndefinedOrNull(windowDefinition.relativeTo)) {
                relativeToWindow = windowDefinition.relativeTo;
                if (util.isString(relativeToWindow)) {
                    var windows = _this.getWindows({ type: relativeToWindow });
                    if (!util.isUndefinedOrNull(windows) && windows.length > 0) {
                        windowDefinition.relativeTo = windows[0].id;
                    }
                }
                else if (!util.isUndefinedOrNull(relativeToWindow.type)) {
                    var windows = _this.getWindows({ type: relativeToWindow.type });
                    if (!util.isUndefinedOrNull(windows) && windows.length > 0) {
                        windowDefinition.relativeTo = windows[0].id;
                    }
                }
                else if (!util.isUndefinedOrNull(relativeToWindow.windowId)) {
                    windowDefinition.relativeTo = relativeToWindow.windowId;
                }
            }
            _this._bridge.createWindow(activity.id, windowDefinition)
                .then(function (wid) {
                _this._logger.debug("Window created, waiting for window entity with id " + wid);
                var handler = function (window, context) {
                    if (window.id === wid && window.activity) {
                        this._logger.debug("Got entity window with id " + wid);
                        resolve(window);
                        this._windows.unsubscribe(handler);
                    }
                }.bind(_this);
                _this._windows.subscribe(handler);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.createStackedWindows = function (activity, relativeWindowTypes, timeout, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity is undefined");
            }
            if (util.isUndefinedOrNull(relativeWindowTypes)) {
                reject("relativeWindowTypes is undefined");
            }
            if (!Array.isArray(relativeWindowTypes)) {
                reject("relativeWindowTypes has to be array");
            }
            if (util.isUndefinedOrNull(timeout)) {
                timeout = 20000;
            }
            var relativeWindows = [];
            relativeWindowTypes.forEach(function (element) {
                var windowDefinition;
                if (util.isString(element)) {
                    windowDefinition = { type: element, name: "", isIndependent: false, arguments: {} };
                }
                else {
                    windowDefinition = element;
                }
                var relativeToWindow;
                if (!util.isUndefinedOrNull(windowDefinition.relativeTo)) {
                    relativeToWindow = windowDefinition.relativeTo;
                    if (!util.isUndefinedOrNull(relativeToWindow.type)) {
                        windowDefinition.relativeTo = relativeToWindow.type;
                    }
                    else if (!util.isUndefinedOrNull(relativeToWindow.windowId)) {
                        var windows = _this.getWindows({ id: relativeToWindow.windowId });
                        if (!util.isUndefinedOrNull(windows) && windows.length > 0) {
                            windowDefinition.relativeTo = windows[0].type.name;
                            windowDefinition.useExisting = true;
                        }
                    }
                }
                relativeWindows.push(windowDefinition);
            });
            _this._bridge.createStackedWindows(activity.id, relativeWindows, timeout)
                .then(function (wid) {
                var activityWindows = [];
                var alreadyCreated = [];
                var handler = function (window, context) {
                    if (wid.indexOf(window.id) >= 0 && alreadyCreated.indexOf(window.id) < 0 && window.activity) {
                        this._logger.debug("Got entity window with id " + wid);
                        activityWindows.push(window);
                        alreadyCreated.push(window.id);
                        if (activityWindows.length == wid.length) {
                            resolve(activityWindows);
                            this._windows.unsubscribe(handler);
                        }
                    }
                }.bind(_this);
                _this._windows.subscribe(handler);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.joinWindowToActivity = function (activity, window, callback) {
        return undefined;
    };
    ActivityManager.prototype.leaveWindowFromActivity = function (activity, window, callback) {
        return undefined;
    };
    ActivityManager.prototype.setActivityContext = function (activity, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity can not be null");
            }
            _this._bridge
                .updateActivityContext(activity, context, true)
                .then(function (obj) {
                resolve(obj);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.updateActivityContext = function (activity, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity can not be null");
            }
            var removedKeys = [];
            for (var key in context) {
                if (context.hasOwnProperty(key) && context[key] === null) {
                    removedKeys.push(key);
                }
            }
            _this._bridge
                .updateActivityContext(activity, context, false, removedKeys)
                .then(function (obj) {
                resolve(obj);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.subscribeActivityContextChanged = function (handler) {
        this._activities.subscribe(function (act, context) {
            if (context.type === entityEvent_1.EntityEventType.ActivityContextChange) {
                var updateContext = context;
                handler(act, updateContext.context, updateContext.updated, updateContext.removed);
            }
        });
    };
    ActivityManager.prototype.stopActivity = function (activity, callback) {
        var promise = this._bridge.stopActivity(activity);
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getWindows = function (filter) {
        if (util.isUndefined(filter)) {
            return this._windows.get();
        }
        if (!util.isUndefined(filter.id)) {
            return [this._windows.getByName(filter.id)];
        }
        var allWindows = this._windows.get();
        return allWindows.filter(function (w) {
            if (!util.isUndefined(filter.type) && w.type.id !== filter.type) {
                return false;
            }
            if (!util.isUndefined(filter.name) && w.name !== filter.name) {
                return false;
            }
            if (!util.isUndefined(filter.activityId)) {
                if (util.isUndefinedOrNull(w.activity)) {
                    return false;
                }
                if (w.activity.id !== filter.activityId) {
                    return false;
                }
            }
            return true;
        });
    };
    ActivityManager.prototype._grabEntity = function (entity) {
        entity.manager = this;
    };
    ActivityManager.prototype._subscribeForData = function () {
        var _this = this;
        this._logger.debug("Start getting initial data...");
        this._bridge.onActivityTypeStatusChange(function (event) {
            _this._activityTypes.process(event);
        });
        this._bridge.getActivityTypes()
            .then(function (at) {
            _this._activityTypes.add(at);
            _this._dataReadyMarker.signal("Got act types");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity types -" + error);
        });
        this._bridge.onWindowTypeStatusChange(function (event) {
            _this._windowTypes.process(event);
        });
        this._bridge.getWindowTypes()
            .then(function (wt) {
            _this._windowTypes.add(wt);
            _this._dataReadyMarker.signal("Got window types");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting window types  " + error);
        });
        this._bridge.onActivityStatusChange(function (event) {
            _this._activities.process(event);
        });
        this._bridge.getActivities()
            .then(function (ac) {
            _this._activities.add(ac);
            _this._dataReadyMarker.signal("Got activities");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity instances -" + error);
        });
        this._bridge.onActivityWindowChange(function (event) {
            _this._windows.process(event);
        });
        this._bridge.getActivityWindows()
            .then(function (aw) {
            _this._windows.add(aw);
            _this._dataReadyMarker.signal("Got windows");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity windows -" + error);
        });
    };
    ActivityManager.prototype.getWindowBounds = function (id) {
        return this._bridge.getWindowBounds(id);
    };
    ActivityManager.prototype.setWindowBounds = function (id, bounds, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this._bridge.setWindowBounds(id, bounds)
                .then(function () { return resolve(); })['catch'](function (err) { return reject(err); });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.closeWindow = function (id) {
        return this._bridge.closeWindow(id);
    };
    ActivityManager.prototype.activateWindow = function (id, focus) {
        return this._bridge.activateWindow(id, focus);
    };
    ActivityManager.prototype.setWindowVisibility = function (id, visible) {
        return this._bridge.setWindowVisibility(id, visible);
    };
    return ActivityManager;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityManager;

},{"../contracts/entityEvent":27,"../entities/activityType":34,"../helpers/entityObservableCollection":37,"../helpers/logger":38,"../helpers/promiseExtensions":39,"../helpers/readyMarker":40,"../helpers/util":41,"./localWindowFactory":30}],30:[function(require,module,exports){
"use strict";
var LocalWindowFactory = (function () {
    function LocalWindowFactory(createFunction, description) {
        this._createFunction = createFunction;
        this._description = description;
    }
    LocalWindowFactory.prototype.create = function (activityWindowId, context, layout) {
        return this._createFunction(activityWindowId, context, layout);
    };
    LocalWindowFactory.prototype.description = function () {
        return this._description;
    };
    return LocalWindowFactory;
}());
exports.LocalWindowFactory = LocalWindowFactory;

},{}],31:[function(require,module,exports){
"use strict";
var ProxyWindowFactory = (function () {
    function ProxyWindowFactory(description) {
        this._description = description;
    }
    ProxyWindowFactory.prototype.create = function (activityWindowId, context) {
        return undefined;
    };
    ProxyWindowFactory.prototype.description = function () {
        return this._description;
    };
    return ProxyWindowFactory;
}());
exports.ProxyWindowFactory = ProxyWindowFactory;

},{}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var activityAGM_1 = require("../core/activityAGM");
var Activity = (function (_super) {
    __extends(Activity, _super);
    function Activity(id, actType, status, context, ownerId) {
        _super.call(this, id);
        this._id = id;
        this._actType = actType;
        this._status = status;
        this._context = context;
        this._ownerId = ownerId;
        this._agm = new activityAGM_1.ActivityAGM(this);
    }
    Object.defineProperty(Activity.prototype, "type", {
        get: function () {
            if (this.manager) {
                return this.manager.getActivityType(this._actType);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "context", {
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "status", {
        get: function () {
            return this._status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "owner", {
        get: function () {
            if (!this._ownerId) {
                return null;
            }
            return this.manager.getWindows({ id: this._ownerId })[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "windows", {
        get: function () {
            return this.manager.getWindows({ activityId: this._id });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "agm", {
        get: function () {
            return this._agm;
        },
        enumerable: true,
        configurable: true
    });
    Activity.prototype.join = function (window, callback) {
        return this.manager.joinWindowToActivity(this, window, callback);
    };
    Activity.prototype.createWindow = function (windowType, callback) {
        return this.manager.createWindow(this, windowType, callback);
    };
    Activity.prototype.createStackedWindows = function (windowTypes, timeout, callback) {
        return this.manager.createStackedWindows(this, windowTypes, timeout, callback);
    };
    Activity.prototype.leave = function (window, callback) {
        return this.manager.leaveWindowFromActivity(this, window, callback);
    };
    Activity.prototype.getWindowsByType = function (windowType) {
        var filter = { activityId: this._id, type: windowType };
        return this.manager.getWindows(filter);
    };
    Activity.prototype.setContext = function (context, callback) {
        return this.manager.setActivityContext(this, context, callback);
    };
    Activity.prototype.updateContext = function (context, callback) {
        return this.manager.updateActivityContext(this, context, callback);
    };
    Activity.prototype.onStatusChange = function (handler) {
        var _this = this;
        this.manager.subscribeActivityEvents(function (a, ns, os) {
            if (a.id === _this.id) {
                handler(a, ns, os);
            }
        });
    };
    Activity.prototype.onWindowEvent = function (handler) {
        var _this = this;
        this.manager.subscribeWindowEvents(function (a, w, e) {
            if (a.id === _this.id) {
                handler(a, w, e);
            }
        });
    };
    Activity.prototype.onContextChanged = function (handler) {
        var _this = this;
        this.manager.subscribeActivityContextChanged(function (act, context, delta, removed) {
            if (act.id === _this.id) {
                handler(context, delta, removed, act);
            }
        });
        try {
            handler(this.context, this.context, [], this);
        }
        catch (e) { }
    };
    Activity.prototype.stop = function () {
        this.manager.stopActivity(this);
    };
    Activity.prototype.updateCore = function (activity) {
        _super.prototype.updateCore.call(this, activity);
        this._actType = activity._actType;
        this._context = activity._context;
        this._status = activity._status;
        this._ownerId = activity._ownerId;
    };
    return Activity;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= Activity;

},{"../core/activityAGM":28,"./activityEntity":33}],33:[function(require,module,exports){
"use strict";
var ActivityEntity = (function () {
    function ActivityEntity(id) {
        this.listeners = [];
        this._id = id;
    }
    Object.defineProperty(ActivityEntity.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    ActivityEntity.prototype.onUpdated = function (handler) {
        this.listeners.push(handler);
    };
    ActivityEntity.prototype.update = function (other) {
        if (other._id != this._id) {
            throw Error("Can not update from entity with different id.");
        }
        this.updateCore(other);
        this.notify();
    };
    ActivityEntity.prototype.updateCore = function (other) {
    };
    ActivityEntity.prototype.notify = function () {
        for (var index = 0; index < this.listeners.length; index++) {
            var listener = this.listeners[index];
            listener(this);
        }
    };
    return ActivityEntity;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityEntity;

},{}],34:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var ActivityType = (function (_super) {
    __extends(ActivityType, _super);
    function ActivityType(name, ownerWindow, helperWindows, description) {
        _super.call(this, name);
        this._name = name;
        this._description = description;
        this._ownerWindow = ownerWindow;
        this._helperWindows = helperWindows || [];
    }
    Object.defineProperty(ActivityType.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "description", {
        get: function () {
            return this._description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "helperWindows", {
        get: function () {
            return this._helperWindows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "ownerWindow", {
        get: function () {
            return this._ownerWindow;
        },
        enumerable: true,
        configurable: true
    });
    ActivityType.prototype.subscribeActivityStatusChange = function (handler) {
        return undefined;
    };
    ActivityType.prototype.initiate = function (context, callback) {
        return this.manager.initiate(this._name, context, callback);
    };
    ActivityType.prototype.updateCore = function (type) {
        _super.prototype.updateCore.call(this, type);
        this._description = type._description;
        this._ownerWindow = type._ownerWindow;
        this._helperWindows = type._helperWindows;
    };
    return ActivityType;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityType;

},{"./activityEntity":33}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var logger_1 = require("../helpers/logger");
var util = require("../helpers/util");
var ActivityWindow = (function (_super) {
    __extends(ActivityWindow, _super);
    function ActivityWindow(id, name, type, activityId, instance, isIndependent) {
        _super.call(this, id);
        this._logger = logger_1.Logger.Get(this);
        this._type = type;
        this._activityId = activityId;
        this._name = name;
        this._instance = instance;
        this._isIndependent = isIndependent;
    }
    ActivityWindow.prototype.getBounds = function () {
        return this.manager.getWindowBounds(this.id);
    };
    Object.defineProperty(ActivityWindow.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "isIndependent", {
        get: function () {
            return this._isIndependent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "type", {
        get: function () {
            if (this.manager) {
                return this.manager.getWindowType(this._type);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "activity", {
        get: function () {
            if (util.isUndefined(this._activityId)) {
                return undefined;
            }
            return this.manager.getActivityById(this._activityId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "isOwner", {
        get: function () {
            var act = this.activity;
            if (util.isUndefined(act)) {
                return false;
            }
            return act.owner.id === this.id;
        },
        enumerable: true,
        configurable: true
    });
    ActivityWindow.prototype.setVisible = function (isVisible, callback) {
        return this.manager.setWindowVisibility(this.id, isVisible);
    };
    ActivityWindow.prototype.activate = function (focus) {
        return this.manager.activateWindow(this.id, focus);
    };
    ActivityWindow.prototype.setTitle = function (title, callback) {
        return undefined;
    };
    ActivityWindow.prototype.setBounds = function (bounds, callback) {
        return this.manager.setWindowBounds(this.id, bounds, callback);
    };
    ActivityWindow.prototype.setState = function (state, callback) {
        return undefined;
    };
    ActivityWindow.prototype.close = function () {
        return this.manager.closeWindow(this.id);
    };
    Object.defineProperty(ActivityWindow.prototype, "instance", {
        get: function () {
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    ActivityWindow.prototype.onActivityJoined = function (callback) {
        this._subscribeForActivityWindowEvent("joined", callback);
    };
    ActivityWindow.prototype.onActivityRemoved = function (callback) {
        this._subscribeForActivityWindowEvent("removed", callback);
    };
    ActivityWindow.prototype.updateCore = function (other) {
        this._activityId = other._activityId;
        this._isIndependent = other._isIndependent;
        if (!util.isUndefinedOrNull(other._instance)) {
            this._instance = other._instance;
        }
    };
    ActivityWindow.prototype._subscribeForActivityWindowEvent = function (eventName, callback) {
        var _this = this;
        this.manager.subscribeWindowEvents(function (activity, window, event) {
            if (window.id !== _this.id) {
                return;
            }
            if (event === eventName) {
                callback(activity);
            }
        });
    };
    return ActivityWindow;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityWindow;

},{"../helpers/logger":38,"../helpers/util":41,"./activityEntity":33}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var WindowType = (function (_super) {
    __extends(WindowType, _super);
    function WindowType(name, factories) {
        _super.call(this, name);
        this._name = name;
        this._factories = factories;
    }
    Object.defineProperty(WindowType.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowType.prototype, "factories", {
        get: function () {
            return this._factories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowType.prototype, "windows", {
        get: function () {
            return this.manager.getWindows({ type: this._name });
        },
        enumerable: true,
        configurable: true
    });
    WindowType.prototype.registerFactory = function (factory, factoryMethod, description, callback) {
        return this.manager.registerWindowFactory(this, factoryMethod, description);
    };
    return WindowType;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= WindowType;

},{"./activityEntity":33}],37:[function(require,module,exports){
"use strict";
var entityEvent_1 = require("../contracts/entityEvent");
var EntityObservableCollection = (function () {
    function EntityObservableCollection(processNew) {
        this._items = {};
        this._listeners = [];
        this._processNew = processNew;
    }
    EntityObservableCollection.prototype.addOne = function (item) {
        this.add([item]);
    };
    EntityObservableCollection.prototype.add = function (items) {
        for (var index = 0; index < items.length; index++) {
            var element = items[index];
            this.process(new entityEvent_1.EntityEvent(element, new entityEvent_1.EntityEventContext(entityEvent_1.EntityEventType.Added)));
        }
    };
    EntityObservableCollection.prototype.process = function (event) {
        var context = event.context;
        var type = context.type;
        var entity = event.entity;
        var internalEntity = this._updateInternalCollections(entity, type);
        this._notifyListeners(internalEntity, context);
    };
    EntityObservableCollection.prototype.get = function () {
        var result = [];
        for (var key in this._items) {
            if (this._items.hasOwnProperty(key)) {
                var element = this._items[key];
                result.push(element);
            }
        }
        return result;
    };
    EntityObservableCollection.prototype.getByName = function (name) {
        for (var key in this._items) {
            if (key === name) {
                return this._items[key];
            }
        }
        return undefined;
    };
    EntityObservableCollection.prototype.getOrWait = function (name) {
        var _this = this;
        return new Promise(function (resolve) {
            var entityAddedHandler = function (entity) {
                if (entity.id !== name) {
                    return;
                }
                resolve(entity);
                _this.unsubscribe(entityAddedHandler);
            };
            _this.subscribe(entityAddedHandler);
            var window = _this.getByName(name);
            if (window) {
                resolve(window);
                return;
            }
        });
    };
    EntityObservableCollection.prototype.subscribe = function (handler) {
        this._listeners.push(handler);
        for (var key in this._items) {
            var element = this._items[key];
            handler(element, new entityEvent_1.EntityEventContext(entityEvent_1.EntityEventType.Added.toString()));
        }
    };
    EntityObservableCollection.prototype.unsubscribe = function (handler) {
        var index = this._listeners.indexOf(handler);
        if (index != -1) {
            this._listeners.splice(index, 1);
        }
    };
    EntityObservableCollection.prototype._notifyListeners = function (entity, context) {
        for (var index = 0; index < this._listeners.length; index++) {
            var listener = this._listeners[index];
            try {
                listener(entity, context);
            }
            catch (e) { }
        }
    };
    EntityObservableCollection.prototype._updateInternalCollections = function (entity, type) {
        if (type === entityEvent_1.EntityEventType.Removed) {
            delete this._items[entity.id];
            this._processNew(entity);
            return entity;
        }
        else {
            var key = entity.id;
            if (!this._items.hasOwnProperty(key)) {
                this._processNew(entity);
                this._items[entity.id] = entity;
            }
            else {
                this._items[entity.id].update(entity);
            }
        }
        return this._items[entity.id];
    };
    return EntityObservableCollection;
}());
exports.EntityObservableCollection = EntityObservableCollection;

},{"../contracts/entityEvent":27}],38:[function(require,module,exports){
"use strict";
var util = require("./util");
var LogLevel = (function () {
    function LogLevel() {
    }
    LogLevel.Trace = "trace";
    LogLevel.Debug = "debug";
    LogLevel.Info = "info";
    LogLevel.Warn = "warn";
    LogLevel.Error = "error";
    return LogLevel;
}());
exports.LogLevel = LogLevel;
var Logger = (function () {
    function Logger(name) {
        this._name = name;
        if (!util.isUndefinedOrNull(Logger.GlueLogger)) {
            this._glueLogger = Logger.GlueLogger.subLogger(name);
        }
    }
    Logger.GetNamed = function (name) {
        return new Logger(name);
    };
    Logger.Get = function (owner) {
        return new Logger(Logger.GetTypeName(owner));
    };
    Logger.prototype.trace = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.trace(message);
        }
        else {
            if (Logger.Level === LogLevel.Trace) {
                console.info(this._getMessage(message, LogLevel.Trace));
            }
        }
    };
    Logger.prototype.debug = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.debug(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace) {
                console.info(this._getMessage(message, LogLevel.Debug));
            }
        }
    };
    Logger.prototype.info = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.info(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace ||
                Logger.Level === LogLevel.Info) {
                console.info(this._getMessage(message, LogLevel.Info));
            }
        }
    };
    Logger.prototype.warn = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.warn(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace ||
                Logger.Level === LogLevel.Info ||
                Logger.Level === LogLevel.Warn) {
                console.info(this._getMessage(message, LogLevel.Info));
            }
        }
    };
    Logger.prototype.error = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.error(message);
        }
        else {
            console.error(this._getMessage(message, LogLevel.Error));
            console.trace();
        }
    };
    Logger.prototype._getMessage = function (message, level) {
        return "[" + level + "] " + this._name + " - " + message;
    };
    Logger.GetTypeName = function (object) {
        var funcNameRegex = /function (.{1,})\(/;
        var results = (funcNameRegex).exec(object.constructor.toString());
        return (results && results.length > 1) ? results[1] : "";
    };
    Logger.Level = LogLevel.Info;
    return Logger;
}());
exports.Logger = Logger;

},{"./util":41}],39:[function(require,module,exports){
"use strict";
var util = require("../helpers/util");
var nextTick = function (cb) { setTimeout(cb, 0); };
function nodeify(promise, callback) {
    if (!util.isFunction(callback)) {
        return promise;
    }
    promise.then(function (resp) {
        nextTick(function () {
            callback(null, resp);
        });
    }, function (err) {
        nextTick(function () {
            callback(err, null);
        });
    });
}
exports.nodeify = nodeify;
;

},{"../helpers/util":41}],40:[function(require,module,exports){
"use strict";
var logger_1 = require("./logger");
var util = require("../helpers/util");
var ReadyMarker = (function () {
    function ReadyMarker(name, signalsToWait) {
        this._logger = logger_1.Logger.GetNamed("ReadyMarker [" + name + "]");
        this._logger.debug("Initializing ready marker for '" + name + "' with " + signalsToWait + " signals to wait");
        if (signalsToWait <= 0) {
            throw new Error("Invalid signal number. Should be > 0");
        }
        this._signals = signalsToWait;
        this._callbacks = [];
        this._name = name;
    }
    ReadyMarker.prototype.setCallback = function (callback) {
        if (this.isSet()) {
            callback(undefined);
            return;
        }
        else if (this.isError()) {
            callback(this._error);
            return;
        }
        this._callbacks.push(callback);
    };
    ReadyMarker.prototype.signal = function (message) {
        this._logger.debug("Signaled - " + message + " - signals left " + (this._signals - 1));
        this._signals--;
        if (this._signals < 0) {
            throw new Error("Error in ready marker '" + this._name + " - signals are " + this._signals);
        }
        if (this.isSet()) {
            this._callbacks.forEach(function (callback) {
                callback(undefined);
            });
        }
    };
    ReadyMarker.prototype.error = function (error) {
        this._error = error;
        this._callbacks.forEach(function (errorCallback) {
            errorCallback(error);
        });
    };
    ReadyMarker.prototype.isSet = function () {
        if (this.isError()) {
            return false;
        }
        return this._signals === 0;
    };
    ReadyMarker.prototype.isError = function () {
        return !util.isUndefined(this._error);
    };
    ReadyMarker.prototype.getError = function () {
        return this._error;
    };
    return ReadyMarker;
}());
exports.ReadyMarker = ReadyMarker;

},{"../helpers/util":41,"./logger":38}],41:[function(require,module,exports){
"use strict";
function isNumber(arg) {
    return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === 'string';
}
exports.isString = isString;
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isArray(arg) {
    if (Array.isArray) {
        return Array.isArray(arg);
    }
    return toString.call(arg) === '[object Array]';
}
exports.isArray = isArray;
function isUndefined(arg) {
    return typeof arg === 'undefined';
}
exports.isUndefined = isUndefined;
function isUndefinedOrNull(arg) {
    return !arg || typeof arg === 'undefined';
}
exports.isUndefinedOrNull = isUndefinedOrNull;
function isEmpty(arg) {
    for (var prop in arg) {
        if (arg.hasOwnProperty(prop))
            return false;
    }
    return true;
}
exports.isEmpty = isEmpty;
function isFunction(arg) {
    return !!(arg && arg.constructor && arg.call && arg.apply);
}
exports.isFunction = isFunction;
;
function some(array, predicate) {
    for (var index = 0; index < array.length; index++) {
        if (predicate(array[index], index)) {
            return true;
        }
    }
    return false;
}
exports.some = some;
function first(array, predicate) {
    for (var index = 0; index < array.length; index++) {
        if (predicate(array[index], index)) {
            return array[index];
        }
    }
    return undefined;
}
exports.first = first;

},{}],42:[function(require,module,exports){
(function (global){
var connection = require('tick42-gateway-connection');
var client = require('./agm_client');
var server = require('./agm_server');
var instance = require('./agm_instance');
var nativeAgm = require('./agm_native');
var deprecate = require('util-deprecate');
var pjson = require('../package.json');
// var add_sugar= require("./agm_sugar");
// Init namespace if not already there

// Add a global function that makes an AGM instance
agm = function (configuration) {
    'use strict';

    // We will store the library here
    var agm = {};

    agm.version = pjson.version;

    // Init debug
    if (typeof configuration !== 'object') {
        configuration = {};
    }

    // Init child configuration if it is not already passed by user
    var childConfigurations = ['connection', 'client', 'server'];
    childConfigurations.forEach(function (conf) {
        if (typeof configuration[conf] !== 'object') {
            configuration[conf] = {};
        }
        // Set debug if global debug is not set:
        if (configuration.debug) {
            configuration[conf].debug = true;
        }
    });

    // Init connection
    var c = configuration.connection;
    // Determine if we are given a connection object. If not, create it ourselves:
    agm.connection = (typeof c === 'object' && typeof c.send === 'function' && typeof c.on === 'function') ? c : connection(configuration.connection);

    // Create a connection proxy which sets the product name automatically
    var productName = 'agm';
    var agmEnabledConnection = {
        send: function (type, message) {
            agm.connection.send(productName, type, message);
        },

        on: function (type, handler) {
            agm.connection.on(productName, type, handler);
        }

    };

    // Save a reference to the root system object that we are given
    var metricsRoot = configuration.metrics;

    // Create subsystems for our modules and save them in their configuration.
    if (metricsRoot !== undefined) {
        configuration.client.metrics = metricsRoot.subSystem('Client');
        configuration.server.metrics = metricsRoot.subSystem('Server');
    }

    // Initialize our modules
    agm.instance = instance(configuration.instance, agmEnabledConnection);
    agm.client = client(agmEnabledConnection, agm.instance, configuration.client);
    agm.server = server(agmEnabledConnection, agm.instance, configuration.server);

    // Add method aliases
    agm.invoke = agm.client.invoke;
    agm.register = agm.server.register;
    agm.registerAsync = agm.server.registerAsync;
    agm.unregister = agm.server.unregister;
    agm.createStream = agm.server.createStream;
    agm.subscribe = agm.client.subscribe;
    agm.servers = agm.client.servers;
    agm.methods = agm.client.methods;
    agm.methods_for_instance = deprecate(agm.client.methods_for_instance, 'glue.agm.client.methods_for_instance() is deprecated and might be removed from future versions of glue. Use glue.agm.client.methodsForInstance() instead');
    agm.methodsForInstance = agm.client.methods_for_instance;
    agm.method = agm.client.method;
    agm.method_added = deprecate(agm.client.method_added, 'glue.agm.method_added() is deprecated and might be removed from future versions of glue. Use glue.agm.methodAdded() instead');
    agm.methodAdded = agm.client.method_added;
    agm.method_removed = deprecate(agm.client.method_removed, 'glue.agm.method_removed() is deprecated and might be removed from future versions of glue. Use glue.agm.methodRemoved() instead');
    agm.methodRemoved = agm.client.method_removed;

    agm.server_method_added = deprecate(agm.client.server_method_added, 'glue.agm.server_method_added() is deprecated and might be removed from future versions of glue. Use glue.agm.serverMethodAdded() instead');
    agm.serverMethodAdded = agm.client.server_method_added;
    agm.server_method_removed = deprecate(agm.client.server_method_removed, 'glue.agm.server_method_removed() is deprecated and might be removed from future versions of glue. Use glue.agm.serverMethodRemoved() instead');
    agm.serverMethodRemoved = agm.client.server_method_removed;

    agm.server_added = deprecate(agm.client.server_added, 'glue.agm.server_added() is deprecated and might be removed from future versions of glue. Use glue.agm.serverAdded() instead');
    agm.serverAdded = agm.client.server_added;
    agm.server_removed = deprecate(agm.client.server_removed, 'glue.agm.server_removed() is deprecated and might be removed from future versions of glue. Use glue.agm.serverRemoved() instead');
    agm.serverRemoved = agm.client.server_removed;

    agm.start = agm.server.start;
    agm.stop = agm.server.stop;

    if (global.console !== undefined && agm.debug === true) {
        console.log('AGM started.');
    }

    return agm;
    // return add_sugar(agm);

};

agm = global.htmlContainer !== undefined ? nativeAgm : agm;

// Export for browsers
if (global.tick42 === undefined) {
    global.tick42 = {};
}

global.tick42.agm = agm;

module.exports = agm;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":53,"./agm_client":43,"./agm_instance":49,"./agm_native":50,"./agm_server":51,"tick42-gateway-connection":80,"util-deprecate":128}],43:[function(require,module,exports){
(function (global){
/*
 The AGM Client analyses server presences, collects information about their methods and allows users to invoke these methods.
 */
var clientServerstate = require('./agm_client_serverstate');
var clientInvocationsstate = require('./agm_client_invocationsstate');
var clientSubscriptionstate = require('./agm_client_subscriptionstate');
var helpers = require('./agm_helpers');
var Promise = require('es6-promise').Promise;

module.exports = function (connection, instance, configuration) {
    'use strict';
    // Validate configuration
    if (typeof configuration !== 'object') {
        configuration = {};
        if (global.console !== undefined && configuration.debug === true) {
            console.log('Creating an AGM client with default configuration.');
        }
    }

    if (typeof configuration.remove_server_on_n_missing_heartbeats !== 'number') {
        configuration.remove_server_on_n_missing_heartbeats = 3;
    }

    if (typeof configuration.method_response_timeout !== 'number') {
        configuration.method_response_timeout = 3000;
    }

    if (typeof configuration.wait_for_method_timeout !== 'number') {
        configuration.wait_for_method_timeout = 3000;
    }
    // Instantiate the module which keeps track of all available servers and methods
    var servers = clientServerstate(configuration, instance);
    // ..and when you receive a heartbeat/presence from a server, delegate its processing to the module:
    connection.on('ServerPresenceMessage', function (msg) {
        servers.process_presence(msg, true);
    });

    connection.on('ServerHeartbeatMessage', function (msg) {
        servers.process_presence(msg, false);
    });
    // Instantiate the module that handles method execution and responses
    var response = clientInvocationsstate(
      configuration,
      instance,
      function (m) {
          connection.send('MethodInvocationRequestMessage', m);
      });
    // ..and instantiate the module that handles subscription to Streaming methods
    var subState = clientSubscriptionstate(
      configuration,
      instance,
      function (m) {
          connection.send('MethodInvocationRequestMessage', m);
      });
    // ..and delegate responses to them.
    connection.on('MethodInvocationResultMessage', function (msg) {
        if (msg && msg.EventStreamAction && msg.EventStreamAction !== 0) {
            subState.processPublisherMsg(msg);
        } else {
            response.process_method_response(msg);
        }
    });

    //   //Adds client callbacks which are executed when a new method is added or stops being available
    //   function method_added(callback) {
    //     if (typeof callback === 'function') {
    //       //Add the callback
    //       configuration.on_method_added = callback;
    //       //Call the callback for all the method which were added before the callback was registered.
    //       servers.get_methods().forEach(function (method) {
    //         callback(method);
    //       });
    //     } else {
    //       throw '\'method_added\' must be called with a function as an argument';
    //     }
    //   }
    //   function method_removed(callback) {
    //     if (typeof callback === 'function') {
    //       //Add the callback
    //       configuration.on_method_removed = callback;
    //     } else {
    //       throw '\'method_removed\' must be called with a function as an argument';
    //     }
    //   }

    //   //Adds client callbacks which are executed when a new method is added or stops being available
    //   function server_added(callback) {
    //     if (typeof callback === 'function') {
    //       //Add the callback
    //       configuration.on_server_added = callback;
    //       //Call the callback for all the method which were added before the callback was registered.
    //       servers.get_servers().forEach(function (server) {
    //         callback(server);
    //       });
    //     } else {
    //       throw '\'server_added\' must be called with a function as an argument';
    //     }
    //   }
    //   function server_removed(callback) {
    //     if (typeof callback === 'function') {
    //       //Add the callback
    //       configuration.on_server_removed = callback;
    //     } else {
    //       throw '\'server_removed\' must be called with a function as an argument';
    //     }
    //   }

    function subscribe(name, options, successCallback, errorCallback) {
        // options can have arguments:{}, target: 'best'/'all'/{server_instance}, waitTimeoutMs:3000

        function callSubstateSubscribe(targetServers, name, options, successProxy, errorProxy) {
            if (global.console !== undefined && configuration.debug === true) {
                console.log('>>> Subscribing to "' + name + '" on ' + targetServers.length + ' servers');
            }

            subState.subscribe(
              { name: name },
              options.arguments,
              targetServers,
              { method_response_timeout: options.waitTimeoutMs },
              successProxy,
              errorProxy
            );
        }

        var promise = new Promise(function (resolve, reject) {

            var successProxy = function (args) {
                resolve(args);
            };

            var errorProxy = function (args) {
                reject(args);
            };

            if (options === undefined) {
                options = {};
            }

            var target = options.target;
            if (target === undefined) {
                target = 'best';
            }

            if (typeof target === 'string' && target !== 'all' && target !== 'best') {
                reject({ message: '"' + target + '" is not a valid target. Valid targets are "all", "best", or an instance.' });
            }

            if (typeof options.waitTimeoutMs !== 'number' || options.waitTimeoutMs !== options.waitTimeoutMs /* NaN */) {
                options.waitTimeoutMs = configuration.wait_for_method_timeout;
            }

            var currentServers = serversForMethodAndTarget(name, target);

            // ...including the MethodRequestSubject for the streaming method
            // don't check if the method is streaming or not, subscribing to non-streaming method has to invoke it

            if (currentServers.length === 0) {
                setTimeout(function () {
                    var lateServers = serversForMethodAndTarget(name, target);
                    // TODO: change to use the methodAdded handler
                    // TODO: set agm.methodAdded and if(waitTimeout>=0){setTimeout}
                    callSubstateSubscribe(lateServers, name, options, successProxy, errorProxy);

                }, options.waitTimeoutMs);

            } else {
                callSubstateSubscribe(currentServers, name, options, successProxy, errorProxy);
            }
        });

        return helpers.promisify(promise, successCallback, errorCallback);
    }

    // Abstract get_method and get_servers functions
    // They rely on  get_method and get_servers from the "servers" module
    // In those ones you don't need to specify all of the method's props to find it.
    function getMethod(methodFilter) {
        if (typeof methodFilter === 'string') {
            methodFilter = { name: methodFilter };
        }
        // Do not execute for empty filter
        if (methodFilter === undefined) {
            return;
        }

        var exactMatch = servers.get_method(methodFilter);
        // Try calling the original "get_method" function (it will work if all method properties are specified):
        if (exactMatch !== undefined) {
            // Take all available methods and iterate them until we find a match
            return exactMatch;
        } else {
            return takeWhile(servers.get_methods(), function (method) {
                return methodMatch(methodFilter, method);
            });
        }
    }

    function getMethods(methodFilter) {
        if (methodFilter === undefined) {
            return servers.get_methods();
        }

        if (typeof methodFilter === 'string') {
            methodFilter = { name: methodFilter };
        }

        return servers.get_methods().filter(function (method) {
            return methodMatch(methodFilter, method);
        });
    }

    // Retrieves all servers that support any of several methods, listed as an array
    function getMethodsForInstance(instanceFilter) {
        var exactMatch = servers.get_methods(instanceFilter);
        // Try calling the original "get_methods" function (it will work if all instance properties are specified):
        if (exactMatch.length !== 0) {
            return exactMatch;
        } else {
            var methodIds = getServers().filter(function (server) {
                return instanceМatch(instanceFilter, server);
            })
                .reduce(function (methods, server) {
                    servers.get_methodIds(server).forEach(function (methodId) {
                        methods[methodId] = true;
                    });

                    return methods;
                }, {});

            return Object.keys(methodIds).map(function (methodId) {
                return servers.get_method(methodId);
            });
        }
    }

    // Retrieves all servers that support a given method
    function getServers(methodFilter) {
        // No method - get all servers
        if (methodFilter === undefined) {
            return servers.get_servers();
        }
        // Non-existing method - return an empty array
        var method = getMethod(methodFilter);
        if (method === undefined) {
            return [];
        }
        // Else, return servers for method
        return servers.get_servers(method);
    }

    // Retrieves all servers that support any of several methods, listed as an array
    function serversForMethods(methods) {
        return methods.reduce(function (soFar, method) {
            return soFar.concat(servers.get_servers(method, true));// (the second argument is there because we also need the request subject)
        }, []).sort(servers.compare_servers);
    }

    function serversForMethodAndTarget(methodFilter, target) {
        // Get the methods which match the filter
        var methods = getMethods(methodFilter);
        // Determine where to execute the method(s) (the "target" argument)
        // Get all servers that support the method(s) and get the ones that match the target criteria
        return filterByTarget(target, serversForMethods(methods));
    }

    // Invokes an AGM method (mostly it does input checking), the actual job is done by "request.invoke"
    function invoke(methodFilter, argumentObj, target, additionalOptions, success, error) {
        var promise = new Promise(function (resolve, reject) {
            var successProxy;
            var errorProxy;

            successProxy = function (args) {
                // var parsed = JSON.parse(args);
                resolve(args);
            };

            errorProxy = function (args) {
                // var parsed = JSON.parse(args);
                reject(args);
            };
            // Add default params
            if (argumentObj === undefined) {
                argumentObj = {};
            }

            if (target === undefined) {
                target = 'best';
            }

            if (typeof target === 'string' && target !== 'all' && target !== 'best') {
                reject({ message: '"' + target + '" is not a valid target. Valid targets are "all" and "best".' });
            }

            if (additionalOptions === undefined) {
                additionalOptions = {};
            }

            if (additionalOptions.method_response_timeout === undefined) {
                additionalOptions.method_response_timeout = configuration.method_response_timeout;
            }

            if (additionalOptions.wait_for_method_timeout === undefined) {
                additionalOptions.wait_for_method_timeout = configuration.wait_for_method_timeout;
            }

            // Check if the arguments are an object
            if (typeof argumentObj !== 'object') {
                reject({ message: 'The method arguments must be an object.' });
            }

            if (typeof methodFilter === 'string') {
                methodFilter = { name: methodFilter };
            }

            var servers = serversForMethodAndTarget(methodFilter, target);

            if (servers.length === 0) {

                invokeUnexisting(methodFilter, argumentObj, target, additionalOptions, successProxy, errorProxy);

            } else if (servers.length === 1) {
                if (global.console !== undefined && configuration.debug === true) {
                    console.log('>>> Invoking "' + methodFilter.name + '" on 1 server');
                }

                response.invoke(methodFilter, argumentObj, servers[0], additionalOptions, successProxy, errorProxy);

            } else {
                if (global.console !== undefined && configuration.debug === true) {
                    console.log('>>> Invoking "' + methodFilter.name + '" on ' + servers.length + ' servers');
                }

                invokeOnAll(methodFilter, argumentObj, servers, additionalOptions, successProxy, errorProxy);
            }
        });

        return helpers.promisify(promise, success, error);
    }

    // Called when the user tries to invoke a method which does not exist
    function invokeUnexisting(methodFilter, argumentObj, target, additionalOptions, success, error) {
        var serverFound = false;

        if (additionalOptions.wait_for_method_timeout === 0) {
            callError();
        } else {
            setTimeout(function () {
                configuration.server_method_added = configuration.server_method_added.filter(function (callback) {
                    return callback !== newServer;
                });

                if (!serverFound) {
                    callError();
                }
            }, additionalOptions.wait_for_method_timeout);

            registerCallback('server_method_added', identity, newServer);
        }

        function newServer() {
            if (serverFound) {
                return;
            }

            var server = serversForMethodAndTarget(methodFilter, target)[0];
            if (server !== undefined) {
                serverFound = true;
                response.invoke(methodFilter, argumentObj, server, additionalOptions, success, error);
            }
        }

        function callError() {
            // Check if the method exists and if it doesnt', return an error
            if (getMethods(methodFilter).length === 0) {
                error({
                    method: methodFilter,
                    called_with: argumentObj,
                    message: 'I could not find a method with those properties: ' + JSON.stringify(methodFilter)
                });
            } else {
                error({
                    method: methodFilter,
                    called_with: argumentObj,
                    message: 'I could not find servers with these properties: ' + JSON.stringify(target)
                });
                return;
            }
        }
    }

    // Called when the invokes a method with multiple targets
    // Calls a method for all servers and unifies the results they return into one:
    function invokeOnAll(method, argumentObj, servers, additionalOptions, success, error) {
        // Here we will store the results that the servers return
        var successes = [];
        var errors = [];
        // These are the callbacks
        var successCallback = function (result) {
            successes.push(result);
            sendResponse(successes, errors);
        };

        var errorCallback = function (result) {
            errors.push(result);
            sendResponse(successes, errors);
        };
        // Call the method for all targets
        servers.forEach(function (server) {
            response.invoke(method, argumentObj, server, additionalOptions, successCallback, errorCallback);
        });

        // Calls the main success and error callbacks with the aggregated results
        function sendResponse() {
            // wait till everybody is finished
            if (successes.length + errors.length < servers.length) {
                return;
            }
            // Execute the "success" callback
            if (successes.length !== 0) {
                var result = successes.reduce(function (obj, success) {
                    obj.method = success.method;
                    obj.called_with = success.called_with;
                    obj.returned = success.returned;
                    obj.all_return_values.push({
                        executed_by: success.executed_by,
                        returned: success.returned
                    });
                    obj.executed_by = success.executed_by;
                    return obj;
                }, { all_return_values: [] });

                // If we get errors from one of the servers add them to the success object that will be resolved.
                if (errors.length !== 0) {
                    result.all_errors = [];
                    errors.forEach(function (obj) {
                        result.all_errors.push({
                            // executed_by : obj.executed_by, // we don't get executed_by object from the error response
                            name: obj.method.name,
                            message: obj.message
                        });
                    });
                }

                success(result);

            } else if (errors.length !== 0) { // Execute the "error" callback
                error(errors.reduce(function (obj, error) {
                    obj.method = error.method;
                    obj.called_with = error.called_with;
                    obj.message = error.message;
                    obj.all_errors.push({
                        executed_by: error.executed_by,
                        message: error.message
                    });
                    // obj.executed_by = success.executed_by;
                    return obj;
                }, { all_errors: [] }));
            }
        }
    }

    var registerCallback = helpers.saveCallbackIn.bind(this, configuration);
    var applyOnServers = applyOn.bind(null, servers.get_servers);
    var applyOnMethods = applyOn.bind(null, servers.get_methods);
    var identity = function (a) {
        return a;
    };

    return {
        subscribe: subscribe,
        invoke: invoke,
        method: getMethod,
        servers: getServers,
        methods: getMethods,
        methods_for_instance: getMethodsForInstance,
        method_added: registerCallback.bind(null, 'method_added', applyOnMethods),
        method_removed: registerCallback.bind(null, 'method_removed', identity),
        server_added: registerCallback.bind(null, 'server_added', applyOnServers),
        server_removed: registerCallback.bind(null, 'server_removed', identity),
        server_method_added: registerCallback.bind(null, 'server_method_added', identity),
        server_method_removed: registerCallback.bind(null, 'server_method_removed', identity),
        parse_signature: helpers.signature_parse_friendly
    };
};

// in server_method_added we try to curry the following:
//	configuration, "server_method_added", functionwhichreturnsfirstarg

// Filters an array of servers and returns the ones which match the target criteria
function filterByTarget(target, servers) {
    'use strict';
    // If the user specified target as string:
    if (typeof target === 'string') {
        if (target === 'all') {
            target = servers;
        } else if (target === 'best') {
            target = servers[0] !== undefined ? [servers[0]] : [];  // If the user specified the target as server filter
        }
    } else {
        if (!Array.isArray(target)) {
            target = [target];
        }

        // var unexistingServers = [];
        // Retrieve all servers that match the filters
        target = target.reduce(function (matches, filter) {
            // Add matches for each filter
            var myMatches = servers.filter(function (server) {
                return instanceМatch(filter, server);
            });

            return matches.concat(myMatches);
        }, []);
    }

    return target;
}

// Matches a server definition against a server filter
function instanceМatch(instanceFilter, instanceDefinition) {
    'use strict';
    return containsProps(instanceFilter, instanceDefinition);
}

// Matches a method definition against a method filter
function methodMatch(methodFilter, methodDefinition) {
    'use strict';
    return containsProps(methodFilter, methodDefinition);
}

// Helpers

function containsProps(filter, object) {
    'use strict';
    return Object.keys(filter).reduce(function (match, prop) {
        if (filter[prop].constructor === RegExp) {
            if (!filter[prop].test(object[prop])) {
                return false;
            } else {
                return match;
            }
        } else {
            if (String(filter[prop]).toLowerCase() !== String(object[prop]).toLowerCase()) {
                return false;
            } else {
                return match;
            }
        }
    }, true);
}

function takeWhile(array, pred) {
    'use strict';
    var sz = array.length;
    for (var index = 0; index < sz; index++) {
        if (pred(array[index]) === true) {
            return array[index];
        }
    }

    return undefined;
}

function applyOn(objects, func) {
    'use strict';
    return objects().map(func);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_client_invocationsstate":44,"./agm_client_serverstate":46,"./agm_client_subscriptionstate":47,"./agm_helpers":48,"es6-promise":9}],44:[function(require,module,exports){
(function (global){
/*
 The Invcationsstate module handles AGM method invocations. via the 'invoke' method
 It sends and receives all invocation-related messages, via the "process_response" method
 that it exposes and via the "sendRequest" callback

 */

var helpers = require('./agm_helpers');

module.exports = function (configuration, instance, sendRequest) {
    'use strict';

    // Here we store all pending callbacks
    var pendingCallbacks = {};

    // Invokes an AGM method to a single AGM server, given valid input.
    function invoke(method, argumenObj, target, stuff, success, error) {
        // Generate a unique invocation ID, for this invocation
        var invocationId = Math.floor(Math.random() * 10000000000);

        // Register the user's callbacks
        registerInvocation(invocationId, {
            method: method,
            called_with: argumenObj
        }, success, error, stuff.method_response_timeout);

        // Get a response subject for this invocation
        instance.response_subject(method, function (responseSubject) {

            // Construct a message
            var message = {
                MethodRequestSubject: target.request_subject,
                MethodResponseSubject: responseSubject,
                Client: instance.info(),
                Context: {
                    ArgumentsJson: argumenObj,
                    InvocationId: invocationId,
                    ObjectType: stuff.object_type,
                    DisplayContext: stuff.display_context,
                    MethodName: method.name,
                    ExecutionServer: target,
                    Timeout: stuff.method_response_timeout
                }
            };
            // Send it

            sendRequest(message);
            if (global.console !== undefined && configuration.debug === true) {
                console.debug('%c>>> sending MethodInvocationRequestMessage', 'background-color:hsla(198, 51%, 79%, 0.5)');
                console.debug('%c' + JSON.stringify(message), 'background-color:hsla(198, 51%, 79%, 0.5)');
            }

        });
    }

    // Adds callbacks for a given invocation ID
    function registerInvocation(invocationId, response, success, error, timeout) {
        // Adds the callbacks
        pendingCallbacks[invocationId] = { response: response, success: success, error: error };
        // Schedules to throw a timeout if nobody answers
        setTimeout(function () {
            if (pendingCallbacks[invocationId] === undefined) {
                return;
            }

            error({
                method: response.method, called_with: response.argumenObj,
                message: 'Timeout reached'
            });
            delete pendingCallbacks[invocationId];
        }, timeout);
    }

    function processMethodResponse(message) {
        // Finds the appropriate callback
        var callback = pendingCallbacks[message.InvocationId];
        if (callback !== undefined) {
            if (global.console !== undefined && configuration.debug === true) {
                console.debug('%c<<< receiving MethodInvocationResultMessage', 'background-color:hsla(118, 51%, 79%, 0.5)');
                console.debug('%c' + JSON.stringify(message), 'background-color:hsla(118, 51%, 79%, 0.5)');
            }
            // If the server returned success, execute the success callback
            if (message.Status === 0 && typeof callback.success === 'function') {
                // parse the result
                var result = message.ResultContextJson;
                // If the result is an empty object, there is no result
                if (result && Object.keys(result).length === 0) {
                    result = undefined;
                }

                // Log that we received a result
                if (global.console !== undefined && configuration.debug === true) {
                    console.log('<<<  "' + callback.response.method.name + '" was executed by ' + JSON.stringify(helpers.preprocessServer(message.Server)));
                }
                // Execute the success callback
                callback.success({
                    method: callback.response.method,
                    called_with: callback.response.called_with,
                    executed_by: helpers.preprocessServer(message.Server),
                    returned: result,
                    message: message.ResultMessage,
                    log_details: message.ResultLogDetails
                });
                // Else, return an error
            } else if (typeof callback.error === 'function') {
                if (global.console !== undefined && configuration.debug === true) {
                    console.log('<<<  "' + callback.response.method.name + '" was executed with error by ' + JSON.stringify(helpers.preprocessServer(message.Server)));
                }

                callback.error({
                    method: callback.response.method,
                    called_with: callback.response.called_with,
                    message: message.ResultMessage,
                    log_details: message.ResultLogDetails,
                    status: message.status
                });
            }
            // Finally, remove the callbacks
            delete pendingCallbacks[message.InvocationId];
        }
    }

    return { process_method_response: processMethodResponse, invoke: invoke };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":48}],45:[function(require,module,exports){
(function (global){
/*
 The Methodstate module, keeps the state of available AGM methods in the network.
 */

var helpers = require('./agm_helpers');

module.exports = function (configuration) {
    'use strict';
    // A list of all available AGM methods
    var methods = {};

    // Save the reference to the metric function if it exists
    var objectMetric = (configuration.metrics !== undefined) ? configuration.metrics.numberMetric.bind(configuration.metrics) : function () {
    };

    // Adds a new server to a method. Creates the method if it is not created previously.
    function addServerToMethod(methodInfo, serverId, serverInfo) {
        // Get the method ID
        var methodId = getMethodId(methodInfo);

        // One method can have several request subjects per server.
        // So the request subject is actually not a property of the method
        var requestSubject = methodInfo.request_subject;
        delete  methodInfo.request_subject;

        // Copy the method and server objects to a format suitable for sending to users
        var methodInfoFriendly = helpers.cloneObject(methodInfo);
        var serverInfoFriendly = helpers.cloneObject(serverInfo);

        var method = methods[methodId];

        // If the method does not exist, create it
        if (method === undefined) {
            // Save the info
            method = methods[methodId] = { info: methodInfo, servers: {} };
            // Add request_subject
            method = addRequestSubject(method, serverId, requestSubject);

            // Execute user callbacks
            helpers.executeAllWith(configuration.method_added, methodInfoFriendly);
            // Log and publish metrics
            if (global.console !== undefined && console.table !== undefined && configuration.debug === true) {
                console.log('>>>>>> New method detected: ' + JSON.stringify(methodInfoFriendly));
                console.table(getMethods());
            }

            objectMetric('Methods total count', Object.keys(methods).length);
        } else {
            // Else, just add the request subject
            method = addRequestSubject(method, serverId, requestSubject);
        }
        // Execute user callbacks
        helpers.executeAllWith(configuration.server_method_added, {
            method: methodInfoFriendly,
            server: serverInfoFriendly
        });
    }

    // Adds request subject for server and method
    function addRequestSubject(method, serverId, requestSubject) {
        method.servers[serverId] = requestSubject;
        return method;
    }

    // Removes a server from a method. Deletes the method if there are no more servers left.
    function removeServerFromMethod(methodId, serverId, serverInfo) {
        // Obtain info about the method before removing it.
        var methodInfoFriendly = getMethod(methodId);
        var serverIinfoFriendly = helpers.cloneObject(serverInfo);

        // Remove the server from the list
        var servers = methods[methodId].servers;
        delete servers[serverId];
        // Remove the method if there aren't any servers left
        if (Object.keys(servers).length === 0) {

            // 'callback' is defined but never used.
            // var callback = configuration.on_method_removed;
            helpers.executeAllWith(configuration.method_removed, methodInfoFriendly);
            // remove method
            delete methods[methodId];
            // Log and metrics
            if (global.console !== undefined && console.table !== undefined && configuration.debug === true) {
                console.log('<<<<<< Method stopped being available: ' + JSON.stringify(methodInfoFriendly));
                console.table(getMethods());
            }

            objectMetric('Methods total count', Object.keys(methods).length);
        }
        // Execute user callbacks
        helpers.executeAllWith(configuration.server_method_removed, {
            method: methodInfoFriendly,
            server: serverIinfoFriendly
        });
    }

    // Generates a unique if for a method
    function getMethodId(m) {
        // Setting properies to defaults:
        var accepts = m.accepts !== undefined ? m.accepts : '';
        var returns = m.returns !== undefined ? m.returns : '';
        var version = m.version !== undefined ? m.version : 0;
        return (m.name + accepts + returns + version).toLowerCase();
    }

    // Retrieve all methods
    function getMethods() {
        return Object.keys(methods).map(function (method) {
            return helpers.cloneObject(methods[method].info);
        });
    }

    // Retrieve an array of the ID's of the servers for a method
    function getServersForMethod(methodInfo) {
        var method = methods[getMethodId(methodInfo)];
        if (method !== undefined) {
            return method.servers;
        } else {
            return {};
        }
    }

    // Retrieves a copy of the method, by its ID
    function getMethod(methodId) {
        if (typeof methodId === 'object') {
            methodId = getMethodId(methodId);
        }

        if (methods[methodId] !== undefined) {
            // We clone the method definition so it can be mutated without affecting the original
            return helpers.cloneObject(methods[methodId].info);
        }
    }

    return {
        get_methods: getMethods,
        get_method: getMethod,
        getMethodId: getMethodId,
        add_server_to_method: addServerToMethod,
        remove_server_from_method: removeServerFromMethod,
        get_servers_for_method: getServersForMethod
    };

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":48}],46:[function(require,module,exports){
(function (global){
/*
 The Serverstate module processes server presences and keeps the state of available AGM servers in the network.
 */
var helpers = require('./agm_helpers');
var getServerId = helpers.getServerId;
var clientMethodstate = require('./agm_client_methodstate');

module.exports = function (configuration, instance) {
    'use strict';

    // A list of all the servers in the network
    var servers = {};

    // Instantiates the "methodstate" module
    var methods = clientMethodstate(configuration);

    // Processes a presence message from a server
    function processPresence(presence, isPresence) {
        // console.log(presence.Instance)
        // Get server info.
        var serverinfo = helpers.preprocessServer(presence.Instance);

        if (isPresence) {
            // Ignore messages for dead servers
            // If it is a new server, register it.
            if (!exists(serverinfo)) {
                addServer(serverinfo);
            }

            if (presence.PublishingInterval) {
                setPresenceTimeout(serverinfo, presence.PublishingInterval);
            }
        }

        // Finally, update the methods
        if (presence.MethodDefinitions !== undefined) {
            updateMethods(serverinfo, presence.MethodDefinitions);
        }
    }

    // This function sets a timeout which removes the server unless
    // the function is called again before the timeout is over
    function setPresenceTimeout(serverinfo, duration) {
        if (duration === -1) {
            return;
        }

        // Retrieve the server
        var serverId = getServerId(serverinfo);
        var server = servers[serverId];
        // Stop the previous timeout
        if (server.bomb !== undefined) {
            clearTimeout(server.bomb);
        }
        // Set a new one
        server.bomb = setTimeout(function () {
            removeServer(serverinfo);
        }, (duration * configuration.remove_server_on_n_missing_heartbeats) + 1);

    }

    // Checks if a servers exists
    function exists(serverinfo) {
        var serverId = getServerId(serverinfo);
        return servers[serverId] !== undefined;
    }

    // Register a server
    function addServer(serverinfo) {
        // Obtain a server ID and store the new server
        var serverId = getServerId(serverinfo);
        servers[serverId] = { info: serverinfo, methods: [], bomb: undefined };

        // Log in console
        if (global.console !== undefined && console.table !== undefined && configuration.debug === true) {
            console.log('>>>>>> New server detected: ' + JSON.stringify(serverinfo));
            console.table(getServers());
        }

        // Execute user callbacks
        helpers.executeAllWith(configuration.server_added, serverinfo);

        return serverId;
    }

    // Unregisters a server
    function removeServer(serverinfo) {
        // Obtain a server ID
        var serverId = getServerId(serverinfo);
        // Remove the server's methods
        servers[serverId].methods.forEach(function (methodId) {
            methods.remove_server_from_method(methodId, serverId, serverinfo);
        });
        // Remove the server itself
        delete servers[serverId];
        // Log in console
        if (global.console !== undefined && console.table !== undefined && configuration.debug === true) {
            console.log('<<<<<< Server stopped being available:' + JSON.stringify(serverinfo));
            console.table(getServers());
        }

        // Execute user callbacks
        helpers.executeAllWith(configuration.server_removed, serverinfo);
    }

    // Updates the methods of a server
    function updateMethods(serverinfo, newMethods) {
        var serverId = getServerId(serverinfo);
        // Get an array of the methods the server had before we started this
        var oldMethodsIds = servers[serverId].methods;
        // Get an array of the methods that the server has now
        newMethods = newMethods.map(helpers.preprocess_method).reduce(function (obj, method) {
            obj[methods.getMethodId(method)] = method;
            return obj;
        }, {});
        // For each of the old methods
        oldMethodsIds.forEach(function (methodId) {
            // Check if it is still there
            if (newMethods[methodId] === undefined) {
                // If it isn't, remove it
                methods.remove_server_from_method(methodId, serverId, serverinfo);
            } else {
                // If it is there in both the old array and the new one, we don't need to add it again
                newMethods[methodId] = undefined;
            }
        });
        // Now add the new methods
        var newMethodsIds = Object.keys(newMethods);
        newMethodsIds.forEach(function (id) {
            if (newMethods[id] !== undefined) {
                methods.add_server_to_method(newMethods[id], serverId, serverinfo);
            }
        });
        // Now all we have to do is replace the list of methods the server has
        servers[serverId].methods = newMethodsIds;

    }

    // Get all servers for a given method
    function getServers(method, includeRequestSubject) {
        var serverIds;
        var idsToRequestSubjects;
        // If there isn't a method get the ID's of all servers
        if (method === undefined) {
            serverIds = Object.keys(servers);
            // Else, get a list of the servers that have the method
        } else {
            idsToRequestSubjects = methods.get_servers_for_method(method);
            serverIds = Object.keys(idsToRequestSubjects);
        }
        // Format the list
        return serverIds.map(function (serverId) {
            var server = helpers.cloneObject(servers[serverId].info);
            // Include the request subject for each server for each method:
            if (includeRequestSubject) {
                server.request_subject = idsToRequestSubjects[serverId];
            }

            return server;
        }).sort(compareServers);
    }

    // A comparer function. Sorts the servers based on availability
    function compareServers(server1, server2) {
        var s1 = 0;
        var s2 = 0;
        // +2 if the server is on the same machine
        if (server1.machine === instance.machine) {
            s1 = s1 + 2;
        }

        if (server2.machine === instance.machine) {
            s2 = s2 + 2;
        }
        // +1 if it runs under the same user
        if (server1.user === instance.user) {
            s1 = s1 + 1;
        }

        if (server2.user === instance.user) {
            s2 = s2 + 1;
        }

        return s2 - s1;
    }

    function getMethodIds(server) {
        return servers[getServerId(server)].methods;
    }

    // Get all methods for a given server
    function getMethods(server) {
        // If there is no server specified, return all
        if (server === undefined) {
            return methods.get_methods();
            // Else, get the methods from the server object
        } else if (exists(server)) {
            return getMethodIds(server).map(function (methodId) {
                return methods.get_method(methodId);
            });
            // If the server is specified, but it does not exist, return an empty array
        } else {
            return [];
        }
    }

    return {
        process_presence: processPresence,
        get_methods: getMethods,
        get_method_ids: getMethodIds,
        get_servers: getServers,
        get_method: methods.get_method,
        exists: exists,
        compare_servers: compareServers
    };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_client_methodstate":45,"./agm_helpers":48}],47:[function(require,module,exports){
(function (global){
/*
 The Subscription-state module handles AGM stream subscriptions via the 'subscribe' method
 It sends and receives all invocation-related messages, via the "process_response" method
 that it exposes and via the "sendRequest" callback

 */

var helpers = require('./agm_helpers');

module.exports = function (configuration, instance, sendRequest) {
    'use strict';

    var STATUS_AWAITING_ACCEPT = 'awaitingAccept'; // not even one server has accepted yet
    var STATUS_SUBSCRIBED = 'subscribed'; // at least one server has responded as 'Accepting'
    var ERR_MSG_SUB_FAILED = 'Subscription failed.';
    var ERR_MSG_SUB_REJECTED = 'Subscription rejected.';
    var ON_CLOSE_MSG_SERVER_INIT = 'ServerInitiated';
    var ON_CLOSE_MSG_CLIENT_INIT = 'ClientInitiated';

    var subscriptionsList = {};

    // Preps and sends a request to subscribe to a single AGM stream publisher.
    function subscribe(streamingMethod, argumentObj, targetServers, stuff, success, error) {

        if (targetServers.length === 0) {
            error(ERR_MSG_SUB_FAILED + ' No available servers matched the target params.');
            return;
        }

        // This same Id will be passed to all the servers (as 'InvocationId')
        // so they can respond back with it during the initial handshake
        var subscriptionId = 'subscriptionId_' + helpers.generateRandom();

        // Register the user's callbacks
        var pendingSub = registerSubscription(
         subscriptionId,
            {
                method: streamingMethod,
                called_with: argumentObj
            },
         success,
         error,
         stuff.method_response_timeout
        );

        if (typeof pendingSub !== 'object') {
            error(ERR_MSG_SUB_FAILED + ' Unable to register the user callbacks.');
            return;
        }

        // Send a subscription request to each server
        targetServers.forEach(function (target) {

            // Get a response subject for this invocation
            instance.response_subject(streamingMethod, function (responseSubject) {

                // Add server to the list of ones the client is expecting a response from
                pendingSub.trackedServers.push({
                    server: undefined,
                    streamId: undefined,
                    streamSubjects: {
                        global: undefined,
                        private: undefined
                    },
                    methodRequestSubject: target.request_subject,
                    methodResponseSubject: responseSubject
                });

                // Construct a message
                var message = {
                    EventStreamAction: 1, // "Subscribe" = client wishes to subscribe
                    MethodRequestSubject: target.request_subject,
                    MethodResponseSubject: responseSubject,
                    Client: instance.info(),
                    Context: {
                        ArgumentsJson: argumentObj,
                        InvocationId: subscriptionId,
                        ObjectType: stuff.object_type,
                        DisplayContext: stuff.display_context,
                        MethodName: streamingMethod.name,
                        ExecutionServer: target,
                        Timeout: stuff.method_response_timeout
                    }
                };

                // Send it
                sendRequest(message);

                if (global.console !== undefined && configuration.debug === true) {
                    console.debug('%c>>> sending MethodInvocationRequestMessage', 'background-color:hsla(198, 51%, 79%, 0.5)');
                    console.debug('%c' + JSON.stringify(message), 'background-color:hsla(198, 51%, 79%, 0.5)');
                }
            });

        });

    }

    function registerSubscription(subscriptionId, response, success, error, timeout) {

        subscriptionsList[subscriptionId] = {
            status: STATUS_AWAITING_ACCEPT,
            response: response,
            success: success,
            error: error,
            trackedServers: [],
            handlers: {
                onData: [],
                onClosed: []
                // onFailed: []
            },
            queued: {
                data: [],
                closers: []
            },
            timeoutId: undefined
        };

        subscriptionsList[subscriptionId].timeoutId = setTimeout(function () {
            if (subscriptionsList[subscriptionId] === undefined) {
                return; // no such subscription
            }

            var subscription = subscriptionsList[subscriptionId];

            if (subscription.status === STATUS_AWAITING_ACCEPT) {
                error({
                    method: response.method, called_with: response.called_with,
                    message: ERR_MSG_SUB_FAILED + ' Subscription attempt timed out after ' + timeout + 'ms.'
                });

                // None of the target servers has answered the subscription attempt
                delete subscriptionsList[subscriptionId];

            } else if (subscription.status === STATUS_SUBSCRIBED && subscription.trackedServers.length > 0) {
                // clean the trackedServers
                subscription.trackedServers = subscription.trackedServers.filter(function (server) {
                    return (typeof server.streamId === 'string' && server.streamId !== 'string');
                });

                subscription.timeoutId = undefined;

                if (subscription.trackedServers.length === 0) {
                    // There are no open streams, some servers accepted then closed very quickly
                    //  (that's why the status changed but there's no good server with a StreamId)

                    // call the onClosed handlers
                    var closersCount = subscription.queued.closers.length;
                    var closingServer = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;

                    subscription.handlers.onClosed.forEach(function (callback) {
                        if (typeof callback === 'function') {
                            callback({
                                message: ON_CLOSE_MSG_SERVER_INIT,
                                requestArguments: subscription.response.called_with,
                                server: closingServer,
                                stream: subscription.response.method
                            });
                        }
                    });

                    delete subscriptionsList[subscriptionId];
                }
            }
        }, timeout);

        return subscriptionsList[subscriptionId];
    }

    function processPublisherMsg(msg) {
        if (!(msg && msg.EventStreamAction && msg.EventStreamAction !== 0)) {
            return;
        }

        if (msg.EventStreamAction === 2) {

            serverIsKickingASubscriber(msg);

        } else if (msg.EventStreamAction === 3) {

            serverAcknowledgesGoodSubscription(msg);

        } else if (msg.EventStreamAction === 5) {

            serverHasPushedSomeDataIntoTheStream(msg);
        }

    }

    /** msg 'Response' Actions */
    // action 2
    function serverIsKickingASubscriber(msg) {

        // Note: this might be either the server rejecting a subscription request OR closing an existing subscription

        // Get ALL subscriptions
        var keys = Object.keys(subscriptionsList);

        // If it is a rejection there may be an InvocationId, it can narrow the search
        if (typeof msg.InvocationId === 'string' && msg.InvocationId !== '') {
            keys = keys.filter(function (k) {
                return k === msg.InvocationId;
            });
        }

        var deletionsList = [];

        // Find the kicking/rejecting server and remove it from the subscription.trackedServers[]
        keys.forEach(function (key) {
            if (typeof subscriptionsList[key] !== 'object') {
                return;
            }

            subscriptionsList[key].trackedServers = subscriptionsList[key].trackedServers.filter(function (server) {
                var isRejecting = server.methodRequestSubject === msg.MethodRequestSubject && server.methodResponseSubject === msg.MethodResponseSubject;
                var isKicking = (server.streamId === msg.StreamId && (server.streamSubjects.global === msg.EventStreamSubject || server.streamSubjects.private === msg.EventStreamSubject));
                var isRejectingOrKicking = isRejecting || isKicking;

                return !isRejectingOrKicking;
            });

            if (subscriptionsList[key].trackedServers.length === 0) {
                deletionsList.push(key);
            }
        });

        // Call onClosed OR error()
        // and remove the subscription
        deletionsList.forEach(function (key) {
            if (typeof subscriptionsList[key] !== 'object') {
                return;
            }

            if (subscriptionsList[key].status === STATUS_AWAITING_ACCEPT && typeof subscriptionsList[key].timeoutId === 'number') {

                var reason = (typeof msg.ResultMessage === 'string' && msg.ResultMessage !== '')
                 ? ' Publisher said "' + msg.ResultMessage + '".'
                 : ' No reason given.';

                var callArgs = typeof subscriptionsList[key].response.called_with === 'object'
                 ? JSON.stringify(subscriptionsList[key].response.called_with)
                 : '{}';

                subscriptionsList[key].error(ERR_MSG_SUB_REJECTED + reason + ' Called with:' + callArgs);
                clearTimeout(subscriptionsList[key].timeoutId);

            } else {

                // The timeout may or may not have expired yet,
                // but the status is 'subscribed' and trackedServers is now empty

                subscriptionsList[key].handlers.onClosed.forEach(function (callback) {
                    if (typeof callback === 'function') {
                        callback({
                            message: ON_CLOSE_MSG_SERVER_INIT,
                            requestArguments: subscriptionsList[key].response.called_with,
                            server: msg.Server,
                            stream: subscriptionsList[key].response.method
                        });
                    }
                });

            }

            delete subscriptionsList[key];

        });
    }

    // action 3
    function serverAcknowledgesGoodSubscription(msg) {

        var subscriptionId = msg.InvocationId;

        var subscription = subscriptionsList[subscriptionId];

        if (typeof subscription !== 'object') {
            return;
        }

        var acceptingServer = subscription.trackedServers.filter(function (server) {
            return (
             server.methodRequestSubject === msg.MethodRequestSubject &&
             server.methodResponseSubject === msg.MethodResponseSubject
            );
        })[0];

        if (typeof acceptingServer !== 'object') {
            return;
        }

        var isFirstResponse = (subscription.status === STATUS_AWAITING_ACCEPT);

        subscription.status = STATUS_SUBSCRIBED;

        var privateStreamSubject = generatePrivateStreamSubject(subscription.response.method.name);

        if (typeof acceptingServer.streamId === 'string' && acceptingServer.streamId !== '') {
            return; // already accepted previously
        }

        acceptingServer.server = msg.Server;
        acceptingServer.streamId = msg.StreamId;
        acceptingServer.streamSubjects.global = msg.EventStreamSubject;
        acceptingServer.streamSubjects.private = privateStreamSubject;
        // acceptingServer.methodResponseSubject stays the same

        var confirmatoryRequest = {
            EventStreamAction: 3, // "Subscribed" = client confirms intention to subscribe
            EventStreamSubject: privateStreamSubject,
            StreamId: msg.StreamId,
            MethodRequestSubject: msg.MethodRequestSubject,
            MethodResponseSubject: acceptingServer.methodResponseSubject,
            Client: instance.info(),
            Context: {
                ArgumentsJson: subscription.response.called_with,
                MethodName: subscription.response.method.name
            }
        };

        sendRequest(confirmatoryRequest);

        if (isFirstResponse) {
            // Pass in the subscription object
            subscription.success({
                onData: function (dataCallback) {
                    if (typeof dataCallback !== 'function') {
                        throw new TypeError('The data callback must be a function.');
                    }

                    this.handlers.onData.push(dataCallback);
                    if (this.handlers.onData.length === 1 && this.queued.data.length > 0) {
                        this.queued.data.forEach(function (dataItem) {
                            dataCallback(dataItem);
                        });
                    }
                }.bind(subscription),
                onClosed: function (closedCallback) {
                    if (typeof closedCallback !== 'function') {
                        throw new TypeError('The callback must be a function.');
                    }

                    this.handlers.onClosed.push(closedCallback);
                }.bind(subscription),
                onFailed: function () {},

                close: closeSubscription.bind(subscription, subscriptionId),
                requestArguments: subscription.response,
                serverInstance: helpers.convertInfoToInstance(msg.Server),
                stream: subscription.response.method
            });
        }
    }

    // action 5
    function serverHasPushedSomeDataIntoTheStream(msg) {

        // Find the subscription of interest by trawling the dictionary
        for (var key in subscriptionsList) {
            if (subscriptionsList.hasOwnProperty(key) && typeof subscriptionsList[key] === 'object') {

                var isPrivateData;

                var trackedServersFound = subscriptionsList[key].trackedServers.filter(function (ls) {
                    return (
                     ls.streamId === msg.StreamId &&
                     (ls.streamSubjects.global === msg.EventStreamSubject || ls.streamSubjects.private === msg.EventStreamSubject));
                });

                if (trackedServersFound.length === 0) {
                    isPrivateData = undefined;
                } else if (trackedServersFound[0].streamSubjects.global === msg.EventStreamSubject) {
                    isPrivateData = false;
                } else if (trackedServersFound[0].streamSubjects.private === msg.EventStreamSubject) {
                    isPrivateData = true;
                }

                if (isPrivateData !== undefined) {
                    // create the arrivedData object
                    var receivedStreamData = {
                        data: msg.ResultContextJson,
                        server: msg.Server,
                        requestArguments: subscriptionsList[key].response.called_with ||  {},
                        message: msg.ResultMessage,
                        private: isPrivateData
                    };

                    var onDataHandlers = subscriptionsList[key].handlers.onData;
                    var queuedData = subscriptionsList[key].queued.data;

                    if (Array.isArray(onDataHandlers)) {
                        if (onDataHandlers.length > 0) {
                            onDataHandlers.forEach(function (callback) {
                                if (typeof callback === 'function') {
                                    callback(receivedStreamData);
                                }
                            });
                        } else {
                            queuedData.push(receivedStreamData);
                        }
                    }
                }
            }
        }// end for-in
    }

    /** (subscription) Methods */
    function closeSubscription(subId) {
        instance.response_subject({}, function (responseSubject) {
            this.trackedServers.forEach(function (server) {
                sendRequest({
                    EventStreamAction: 2,
                    Client: instance.info(),
                    MethodRequestSubject: server.methodRequestSubject,
                    MethodResponseSubject: responseSubject,
                    StreamId: server.streamId,
                    EventStreamSubject: server.streamSubjects.private
                });
            });
        }.bind(this));

        var _this = this;

        // Call the onClosed handlers
        this.handlers.onClosed.forEach(function (callback) {
            if (typeof callback === 'function') {
                callback({
                    message: ON_CLOSE_MSG_CLIENT_INIT,
                    requestArguments: _this.response.called_with || {},
                    server: _this.trackedServers[_this.trackedServers.length - 1].server,
                    stream: _this.response.method
                });
            }
        });

        delete subscriptionsList[subId];
    }

    function generatePrivateStreamSubject(methodName) {

        var appInfo = instance.info();

        var privateStreamSubject = 'ESSpriv-jsb_' +
         appInfo.ApplicationName +
         '_on_' + methodName + '_' +
         helpers.generateRandom();

        return privateStreamSubject;
    }

    return { // an instance of the subState
        subscribe: subscribe,
        processPublisherMsg: processPublisherMsg
    };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":48}],48:[function(require,module,exports){
(function (global){
// Converts server properties from camel to snake case
function preprocessServer(m) {
    'use strict';
    return {
        machine: m.MachineName,
        pid: m.ProcessId,
        started: m.ProcessStartTime,
        user: m.UserName,
        application: m.ApplicationName,
        environment: m.Environment,
        region: m.Region,
        service_name: m.ServiceName,
        metrics_repository_id: m.MetricsRepositoryId,
        state: m.State
    };
}

function cloneObject(method) {
    'use strict';
    var newMethod = {};
    for (var i in method) {
        // Remove undefined values from object before passing it to the user
        if (method[i] !== undefined && method[i] !== '' && method[i] !== 0) {
            newMethod[i] = method[i];
        }
    }

    return newMethod;
}

// Helper: preprocesses the method definition
function preprocessMethod(methodInfo) {
    'use strict';
    var method = methodInfo.Method;
    return {
        name: method.Name,
        accepts: method.InputSignature,
        returns: method.ResultSignature,
        request_subject: methodInfo.MethodRequestSubject,
        description: method.Description,
        display_name: method.DisplayName,
        version: method.Version,
        object_types: method.ObjectTypeRestrictions,
        supportsStreaming: isStreamingFlagSet(method.Flags)
    };
}

function isStreamingFlagSet(flags) {
    'use strict';

    if (typeof flags !== 'number' || isNaN(flags)) {
        return false;
    }

    // checking the largest Bit using bitwise ops
    var mask = 32;
    var result = flags & mask;

    return result === mask;
}

function saveCallbackIn(callbackObj, event, onCallbackAdd, callback) {
    'use strict';
    if (typeof callback === 'function') {
        callbackObj[event] = callbackObj[event] || [];
        callbackObj[event].push(callback);
        onCallbackAdd(callback);
    } else {
        throw new Error('"' + event + '" must be called with a function as an argument');
    }
}

function executeAllWith(callbacks, input) {
    'use strict';
    if (typeof callbacks === 'object') {
        callbacks.forEach(function (callback) {
            callback(input);
        });
    }
}

// Generates a unique ID for a server
function getServerId(serverinfo) {
    'use strict';
    if (serverinfo === undefined) {
        return undefined;
    }
    // The matching is case-insensitive
    return (serverinfo.application + serverinfo.user + serverinfo.started + serverinfo.pid).toLowerCase();
}

function promisify(promise, successCallback, errorCallback) {
    'use strict';
    if (typeof successCallback !== 'function' && typeof errorCallback !== 'function') {
        return promise;
    }

    if (typeof successCallback !== 'function') {
        successCallback = function () {
            if (global.console !== undefined && agm.debug === true) {
                console.log('Success!');
            }
        };
    } else if (typeof errorCallback !== 'function') {
        errorCallback = function () {
            if (global.console !== undefined && agm.debug === true) {
                console.log('An error occurred.');
            }
        };
    }

    promise.then(successCallback, errorCallback);
}

function generateRandom() {
    'use strict';
    return Math.floor(Math.random() * 10000000000);
}

function convertInfoToInstance(info) {
    'use strict';

    if (typeof info !== 'object') {
        info = {};
    }

    return {
        application: info.ApplicationName,
        environment: info.Environment,
        machine: info.MachineName,
        pid: info.ProcessId,
        region: info.Region,
        service: info.ServiceName,
        user: info.UserName,
        started: info.ProcessStartTime
    }
}

module.exports = {
    getServerId: getServerId,
    executeAllWith: executeAllWith,
    saveCallbackIn: saveCallbackIn,
    preprocessServer: preprocessServer,
    preprocess_method: preprocessMethod,
    cloneObject: cloneObject,
    promisify: promisify,
    generateRandom: generateRandom,
    convertInfoToInstance: convertInfoToInstance
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
(function (global){
/*
 The AGM instance collects information about the machine we are in,
 and interacts with the .NET gateway in other ways,
 to deliver full AGM compatibility to AGM.JS.

 To do so, it relies on the default AGM client.
 */

var document = global.document || global.process;

module.exports = function (c, connection) {
    'use strict';
    var instance = {};
    // Generate default instance properties
    instance.ApplicationName = document.title + Math.floor(Math.random() * 1000000000);
    instance.ProcessId = Math.floor(Math.random() * 1000000000);
    instance.ProcessStartTime = new Date().getTime();

    // Apply user-submitted instance properties
    if (typeof c === 'object') {
        if (c.application !== undefined) {
            instance.ApplicationName = c.application;
        }

        instance.MachineName = c.machine;
        instance.UserName = c.user;
        instance.Environment = c.environment;
        instance.Region = c.region;
        instance.ServiceName = c.service_name;
        instance.MetricsRepositoryId = c.metrics_repository_id;
        instance.State = 1;
    }

    var identityUpdated = false;
    connection.on('Instance', function (i) {
        if (identityUpdated) {
            return;
        }

        if (instance.MachineName === undefined) {
            instance.MachineName = i.MachineName;
        }

        if (instance.UserName === undefined) {
            instance.UserName = i.UserName;
        }

        if (instance.Environment === undefined) {
            instance.Environment = i.Environment;
        }

        if (instance.Region === undefined) {
            instance.Region = i.Region;
        }

        if (instance.ServiceName === undefined) {
            instance.ServiceName = i.ServiceName;
        }

        if (instance.MetricsRepositoryId === undefined) {
            instance.MetricsRepositoryId = i.MetricsRepositoryId;
        }

        if (instance.State === undefined) {
            instance.State = i.State;
        }

        if (global.console !== undefined && global.console.table !== undefined && agm.debug === true) {
            console.log('Received instance with info from Gateway.');
        }

        identityUpdated = true;
    });
    // Create a method for accessing a property
    function createGetter(property) {
        return instance[property];
    }

    // Generates a request subject for a method
    // Delegates it to the .NET gateway if it is online,
    // to create subjects which are valid in the scope of the transport that is being used.
    var reqSubject = 0;

    function requestSubject(methodIdentifier, callback) {
        callback('req' + (reqSubject++) + instance.ProcessId);
    }

    // Generates a response subject subject for a method invocation
    // Delegates it to the .NET gateway if it is online,
    // to create subjects which are valid in the scope of the transport that is being used.
    var respSubject = 0;

    function responseSubject(methodIdentifier, callback) {
        callback('resp' + (respSubject++) + instance.ProcessId);
    }

    // Returns all instance properties
    function info() {
        return instance;
    }

    return {
        request_subject: requestSubject,
        response_subject: responseSubject,
        info: info,
        application: createGetter('ApplicationName'),
        pid: createGetter('ProcessId'),
        user: createGetter('UserName'),
        machine: createGetter('MachineName')

    };

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],50:[function(require,module,exports){
(function (global){
var Promise = require('es6-promise').Promise;
var h = require('./agm_helpers');
var PackageJson = require('../package.json');

module.exports = function (configuration) {
    'use strict';
    function stringToObject(param, stringPropName) {
        if (typeof param === 'string') {
            var obj = {};
            obj[stringPropName] = param;
            return obj;
        }

        return param;
    }

    // helper function for parsing dates properly
    function agmParse(str) {
        return JSON.parse(str, function (k, v) {
            if (typeof v !== 'string') {
                return v;
            }

            // pre-seed - this should be a bit faster than indexOf
            if (v[0] !== dateTimeIdentifier[0]) {
                return v;
            }

            if (v.indexOf(dateTimeIdentifier) !== 0) {
                return v;
            }

            var unixTimestampMs = v.substr(lenOfIdentitifier);
            return new Date(parseFloat(unixTimestampMs));
        });
    }

    /**
     * Converts a target argument to object ready to be passed to Agm facade
     * @param target
     */
    function targetArgToObject(target) {

        target = target || 'best';

        if (typeof target === 'string') {
            if (target !== 'all' && target !== 'best') {
                throw new Error('"' + target + '" is not a valid target. Valid targets are "all" and "best".');
            }

            return { target: target };
        } else {
            if (!Array.isArray(target)) {
                target = [target];
            }

            target = target.map(function (e) {
                return convertInstanceToRegex(e);
            });

            return { serverFilter: target };
        }
    }

    function convertInstanceToRegex(instance) {
        var instanceConverted = {};

        Object.keys(instance).forEach(function (key) {
            var propValue = instance[key];
            instanceConverted[key] = propValue;

            if (typeof propValue === 'undefined' || propValue === null) {
                return;
            }

            if (typeof propValue === 'string') {
                // do exact matching if user passed a string
                instanceConverted[key] = '^' + instance[key] + '$';
            } else if (instance[key].constructor === RegExp) {
                instanceConverted[key] = instance[key].source;
            } else {
                instanceConverted[key] = instance[key];
            }
        });

        return instanceConverted;
    }

    var result = {

        // Registers a JavaScript function as an AGM method, thus making it available other AGM instances on the same transport.
        register: function (methodInfo, callback) {

            var pv = this.agmFacade.protocolVersion;

            if (pv && pv >= 3) {
                // for newer HC use the version where we don't pass arguments as JSON (because of different issues)
                this.agmFacade.register(JSON.stringify(stringToObject(methodInfo, 'name')),
                 callback,
                 true); // return as objects
            } else {
                this.agmFacade.register(JSON.stringify(stringToObject(methodInfo, 'name')),
                 function (arg) {
                     var result = callback(JSON.parse(arg), arguments[1]);
                     return JSON.stringify(result);
                 });
            }
        },

        registerAsync: function (methodInfo, callback) {
            if (!this.agmFacade.registerAsync) {
                throw new Error('not supported in that version of HtmlContainer');
            }

            this.agmFacade.registerAsync(stringToObject(methodInfo, 'name'),
             function (args, instance, tracker) {
                // execute the user callback
                 callback(args,
                 instance,
                 function (successArgs) {
                     tracker.success(successArgs);
                 },

                 function (error) {
                     tracker.error(error);
                 });
             });
        },

        unregister: function (methodFilter) {
            this.agmFacade.unregister(JSON.stringify(stringToObject(methodFilter, 'name')));
        },

        // Invokes an AGM method asynchronously.
        invoke: function (methodFilter, args, target, options, successCallback, errorCallback) {

            var promise = new Promise(function (resolve, reject) {

                if (!args) {
                    args = {};
                }

                if (typeof args !== 'object') {
                    reject({ message: 'The method arguments must be an object.' });
                }

                if (!options) {
                    options = {};
                }

                target = targetArgToObject(target);

                if (this.agmFacade.invoke2) {
                    // invoke ver2 - do not stringify arguments and result values
                    this.agmFacade.invoke2(
                     JSON.stringify(stringToObject(methodFilter, 'name')),
                     args,
                     JSON.stringify(target),
                     JSON.stringify(options),
                     function (args) {
                         resolve(args);
                     },

                     function (err) {
                         reject(err);
                     }
                    );
                } else {
                    var successProxy;
                    var errorProxy;

                    successProxy = function (args) {
                        var parsed = JSON.parse(args);
                        resolve(parsed);
                    };

                    errorProxy = function (args) {
                        var parsed = JSON.parse(args);
                        reject(parsed);
                    };

                    this.agmFacade.invoke(
                     JSON.stringify(stringToObject(methodFilter, 'name')),
                     JSON.stringify(args),
                     JSON.stringify(target),
                     JSON.stringify(options),
                     successProxy,
                     errorProxy
                    );
                }

            }.bind(this));

            return h.promisify(promise, successCallback, errorCallback);
        },

        // Registers a handler which notifies you when a new AGM method is available.
        methodAdded: function (callback) {
            this.agmFacade.methodAdded(callback);
        },

        // Registers a handler which notifies you when an AGM method stops being available.
        methodRemoved: function (callback) {
            this.agmFacade.methodRemoved(callback);
        },

        serverAdded: function (callback) {
            this.agmFacade.serverAdded(callback);
        },

        serverRemoved: function (callback) {
            this.agmFacade.serverRemoved(callback);
        },

        serverMethodAdded: function (callback) {
            this.agmFacade.serverMethodAdded(callback);
        },

        serverMethodRemoved: function (callback) {
            this.agmFacade.serverMethodRemoved(callback);
        },

        // Retrieves a list of AGM servers (instances) optionally filtered by method.
        servers: function (methodFilter) {
            var jsonResult = this.agmFacade.servers(JSON.stringify(methodFilter));
            return agmParse(jsonResult);
        },

        // Retrieves a list of methods that matches a given filter. You can use this to check if a given method exists.
        methods: function (methodFilter) {
            var jsonResult = this.agmFacade.methods(JSON.stringify(methodFilter));
            return agmParse(jsonResult);
        },

        methodsForInstance: function (instanceFilter) {
            var jsonResult = this.agmFacade.methodsForInstance(JSON.stringify(instanceFilter));
            return agmParse(jsonResult);
        },

        // streaming support
        subscribe: function (name, options, successCallback, errorCallback) {
            var promise = new Promise(function (resolve, reject) {
                if (options === undefined) {
                    options = {};
                }

                options.args = JSON.stringify(options.arguments || {});
                options.target = targetArgToObject(options.target);

                this.agmFacade.subscribe2(name,
                 JSON.stringify(options),
                 function (stream) {
                     resolve(stream);
                 },

                 function (error) {
                     reject(error);
                 }
                );
            }.bind(this));

            return h.promisify(promise, successCallback, errorCallback);
        },

        createStream: function (streamDef, callbacks, successCallback, errorCallback) {
            var promise = new Promise(function (resolve, reject) {
                if (typeof streamDef === 'string') {
                    streamDef = { name: streamDef };
                }

                if (!callbacks) {
                    callbacks = {};
                }

                this.agmFacade.createStream2(
                 JSON.stringify(streamDef),
                 // TODO - wrap to transform params
                 callbacks.subscriptionRequestHandler,
                 // TODO - wrap to transform params
                 callbacks.subscriptionAddedHandler,
                 // TODO - wrap to transform params
                 callbacks.subscriptionRemovedHandler,
                 // success handler
                 function (stream) {
                     resolve(stream);
                 },
                 // error handler
                 function (error) {
                     reject(error);
                 }
                );
            }.bind(this));

            return h.promisify(promise, successCallback, errorCallback);
        }
    };

    result.version = PackageJson.version;

    // add metrics
    if (configuration !== undefined && configuration.metrics !== undefined) {
        configuration.metrics.metricsIdentity = configuration.metrics.identity;

        // quick and dirty - we need to stringify the configuration so we need to replace the metrics object (which has circular references)
        // with an object that holds only the properties needed
        var metricsConfig = {
            metricsIdentity: configuration.metrics.metricsIdentity,
            path: configuration.metrics.path
        };
        configuration.metrics = metricsConfig;
    }

    // create new AGM façade for this instance
    var facade = global.htmlContainer.jsAgmFacade;
    var configAsString = JSON.stringify(configuration, function (key, value) {
        if (key === 'logger') {
            return '';
        } else {
            return value;
        }
    });

    result.instance = facade.init(configAsString);
    result.agmFacade = facade;

    // date parsing
    var dateTimeIdentifier = result.agmFacade.jsonValueDatePrefix;
    var lenOfIdentitifier = dateTimeIdentifier.length;

    // deprecated API
    result.create_stream = result.createStream;
    result.methods_for_instance = result.methodsForInstance;
    result.method_added = result.methodAdded;
    result.method_removed = result.methodRemoved;
    result.server_added = result.serverAdded;
    result.server_removed = result.serverRemoved;
    result.server_method_added = result.serverMethodAdded;
    result.server_method_removed = result.serverMethodRemoved;

    return result;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":53,"./agm_helpers":48,"es6-promise":9}],51:[function(require,module,exports){
(function (global){
/*
 The AGM Server allows users register AGM methods.
 It exposes these methods to AGM clients (using presence messages) and listens for their invocation
 */

var helpers = require('./agm_helpers');
var Promise = require('es6-promise').Promise;
var streamPublisher = require('./agm_stream_publisher');

module.exports = function (connection, instance, configuration) {
    'use strict';
    // Validate configuration
    if (typeof configuration !== 'object') {
        configuration = {};

        if (global.console !== undefined && configuration.debug === true) {
            console.log('Creating an AGM server with default configuration.');
        }
    }
    // Add defaults
    if (typeof configuration.heartbeat_interval !== 'number') {
        configuration.heartbeat_interval = 5000;
    }

    if (typeof configuration.presence_interval !== 'number') {
        configuration.presence_interval = 10000;
    }

    // Save the reference to the metric function if it exists
    var metric = (configuration.metrics !== undefined) ? configuration.metrics.numberMetric.bind(configuration.metrics) : function () {
    };
    // An array of the server's methods
    var methods = [];

    var presenceTimer;

    var heartbeatTimer;

    if (heartbeatTimer === undefined) {
        heartbeatTimer = setInterval(sendHeartbeat, configuration.heartbeat_interval);
    }

    // Initialise the stream publisher module
    var publisher = streamPublisher(connection, instance, configuration, methods);

    function announceNewMethod(newMethod) {

        methods.push(newMethod);

        // Send presence so the clients know we have it
        sendPresence();
        // Start sending presence regularly (if we aren't already doing it)
        if (presenceTimer === undefined) {
            presenceTimer = setInterval(sendPresence, configuration.presence_interval);
        }

        metric('Registered methods', methods.length);
    }

    // registers a new agm method
    function register(methodDefinition, callback) {

        registerCore(methodDefinition, function (context, resultCallback) {
            // get the result as direct invocation of the callback and return it using resultCallback
            try {
                var result = callback(context.args, context.instance);
                resultCallback(null, result);
            } catch (e) {
                resultCallback(e, null);
            }
        });

    }

    // registers a new asyn agm method (the result can be returned in async way)
    function registerAsync(methodDefinition, callback) {

        registerCore(methodDefinition, function (context, resultCallback) {
            // invoke the callback passing success and error callbacks
            try {
                callback(context.args, context.instance,
                 // success callback
                 function (result) {
                     resultCallback(null, result);
                 },
                 // error callback
                 function (e) {
                     resultCallback(e, null);
                 });
            } catch (e) {
                resultCallback(e, null);
            }
        });
    }

    // core method for registering agm method
    function registerCore(methodDefinition, theFunction) {
        // transform the definition
        if (typeof methodDefinition === 'string') {
            methodDefinition = { name: methodDefinition };
        }

        // Get a request subject for this method
        instance.request_subject(methodDefinition, function (requestSubject) {

            var method = convertMethod(methodDefinition);
            method.MethodRequestSubject = requestSubject;

            // Add the method (store the unformatted definition in order to do checkups in the unregister method)
            announceNewMethod({
                method: method,
                definition: methodDefinition,
                the_function: theFunction
            });

        });
    }

    function createStream(streamDef, callbacks, successCallback, errorCallback) {
        // in callbacks we have subscriptionRequestHandler, subscriptionAddedHandler, subscriptionRemovedHandler

        var promise = new Promise(function (resolve, reject) {
            if (typeof streamDef === 'string') {

                if (streamDef === '') {
                    reject('Invalid stream name.');
                }

                streamDef = { name: streamDef };
            }

            if (!callbacks) {
                callbacks = {};
            }

            if (typeof callbacks.subscriptionRequestHandler !== 'function') {
                callbacks.subscriptionRequestHandler = function (request) {
                    request.accept();
                };
            }

            // Get a request subject, set the streaming bit then push into methods[]
            instance.request_subject(streamDef, function (requestSubject) {
                var streamConverted = convertMethod(streamDef);
                streamConverted.MethodRequestSubject = requestSubject;
                streamConverted.Method.Flags = 32; // 100000 bitmask with the largest flag (streaming: true)

                var newStreamingMethod = {
                    method: streamConverted,
                    definition: {
                        accepts: streamDef.accepts,
                        description: streamDef.description,
                        displayName: streamDef.displayName,
                        name: streamDef.name,
                        objectTypes: streamDef.objectTypes,
                        returns: streamDef.returns,
                        supportsStreaming: true
                    },
                    streamCallbacks: callbacks,
                    globalEventStreamSubject: streamDef.name + '.jsStream.' + helpers.generateRandom(),
                    subscriptions: [],
                    branchKeyToStreamIdMap: [] // [ {branchKey: '', streamId: 'strj_nds786y2378yb'}, {...}, ...]
                };

                announceNewMethod(newStreamingMethod);

                resolve({
                    branches: function () {
                        return publisher.getBranchList(newStreamingMethod);
                    },

                    close: function () {
                        publisher.closeAllSubscriptions(newStreamingMethod);
                        unregister(newStreamingMethod.definition);
                    },

                    definition: {
                        accepts: streamDef.accepts,
                        description: streamDef.description,
                        displayName: streamDef.displayName,
                        name: streamDef.name,
                        objectTypes: streamDef.objectTypes,
                        returns: streamDef.returns,
                        supportsStreaming: true
                    },
                    name: streamDef.name,
                    push: function (data, branches) {
                        if (typeof branches !== 'string' && !Array.isArray(branches) && branches !== undefined) {
                            throw new Error('invalid branches should be string or string array');
                        }
                        // TODO validate if is plain object
                        if (typeof data !== 'object') {
                            throw new Error('Invalid arguments. Data must be an object.');
                        }

                        publisher.pushData(newStreamingMethod, data, branches);
                    },

                    subscriptions: function () {
                        return publisher.getSubscriptionList(newStreamingMethod);
                    }
                });
            });

        });

        return helpers.promisify(promise, successCallback, errorCallback);
    }

    var invocations = 0;

    // Listens for method invocations
    connection.on('MethodInvocationRequestMessage', function (message) {
        // Find the method
        var method = methods.filter(function (m) {
            return m.method.MethodRequestSubject === message.MethodRequestSubject;
        })[0];

        // Stop if the message isn't for us
        if (method === undefined) {
            return;
        }

        // some logging if enabled
        if (global.console !== undefined && configuration.debug === true) {
            console.debug('%c<<< receiving MethodInvocationRequestMessage', 'background-color:hsla(198, 51%, 79%, 0.5)');
            console.debug('%c' + JSON.stringify(message), 'background-color:hsla(198, 51%, 79%, 0.5)');
        }

        metric('Invocations count', invocations++);

        // TODO see if have to move this earlier - i.e. if some messages from Client don't have MethodRequestSubject
        // Check if message is stream-related : defer publisher
        if (publisher.isStreamMsg(message, method)) {
            publisher.processSubscriberMsg(message, method);
            return;
        }

        // Execute it and save the result
        var invokingClient = helpers.convertInfoToInstance(message.Client);

        method.the_function({ args: message.Context.ArgumentsJson, instance: invokingClient }, function (err, result) {
            if (err) {
                // handle error case
                if (typeof err.message === 'string') {
                    err = err.message;
                } else if (typeof err !== 'string') {
                    err = '';
                }
            }

            // Don't send result if the client does not require it
            if (message.MethodResponseSubject === 'null') {
                return;
            }

            // The AGM library only transfers objects. If the result is not an object, put it in one
            if (result && (typeof result !== 'object' || result.constructor === Array)) {
                result = { _result: result };
            }

            var resultMessage = {
                MethodRequestSubject: message.MethodRequestSubject,
                MethodResponseSubject: message.MethodResponseSubject,
                MethodName: method.method.Method.Name,
                InvocationId: message.Context.InvocationId,
                ResultContextJson: result,
                Server: instance.info(),
                ResultMessage: err,
                Status: err ? 1 : 0
            };
            // Send result
            connection.send('MethodInvocationResultMessage', resultMessage);

            if (global.console !== undefined && configuration.debug === true) {
                console.debug('%c>>> sending MethodInvocationResultMessage', 'background-color:hsla(118, 51%, 79%, 0.5)');
                console.debug('%c' + JSON.stringify(resultMessage), 'background-color:hsla(118, 51%, 79%, 0.5)');
            }
        });
    });

    // Constructs a heartbeat message
    function constructHeartbeat() {
        return {
            PublishingInterval: configuration.heartbeat_interval,
            Instance: instance.info()
        };
    }

    // Constructs a presence message
    function constructPresence() {
        var p = {
            PublishingInterval: configuration.presence_interval,
            Instance: instance.info()
        };
        p.MethodDefinitions = methods.map(function (method) {
            return method.method;
        });

        return p;
    }

    // True if we should be broadcasting presences and heartbeats, false otherwise
    var broadcasting = true;

    function start() {
        broadcasting = true;
    }

    function stop() {
        broadcasting = false;
    }

    // Sends a presence
    function sendPresence() {
        if (broadcasting) {
            connection.send('ServerPresenceMessage', constructPresence());
        }
    }

    // Sends a heartbeat
    function sendHeartbeat() {
        if (broadcasting) {
            connection.send('ServerHeartbeatMessage', constructHeartbeat());
        }
    }

    // Converts the method definition from camel case to snake case
    function convertMethod(methodIdentifier) {
        // If we are given a string instead of an object, we presume that is the method's name:
        if (typeof methodIdentifier === 'string') {
            methodIdentifier = { name: methodIdentifier };
        }

        // Set default values
        if (typeof methodIdentifier.version !== 'number') {
            methodIdentifier.version = 0;
        }

        // Convert the method definition to the format that AGM requires
        return {
            Method: {
                Name: methodIdentifier.name,
                InputSignature: methodIdentifier.accepts,
                ResultSignature: methodIdentifier.returns,
                Description: methodIdentifier.description,
                DisplayName: methodIdentifier.display_name,
                Version: methodIdentifier.version,
                ObjectTypeRestrictions: methodIdentifier.object_types
            }
        };
    }

    function containsProps(filter, object) {
        var match = true;
        Object.keys(filter).forEach(function (prop) {
            if (filter[prop] !== object[prop]) {
                match = false;
            }
        });

        return match;
    }

    // Unregisters a previously registered AGM method
    function unregister(methodFilter) {
        if (typeof methodFilter === 'string') {
            methodFilter = { name: methodFilter };
        }

        methods = methods.filter(function (method) {
            return !containsProps(methodFilter, method.definition);
        });

        metric('Registered methods', methods.length);
    }

    return { register: register, registerAsync: registerAsync, unregister: unregister, start: start, stop: stop, createStream: createStream };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":48,"./agm_stream_publisher":52,"es6-promise":9}],52:[function(require,module,exports){
var helpers = require('./agm_helpers');

module.exports = function (connection, instance) {
    'use strict';
    function sendResult(message) {
        if (typeof message !== 'object') {
            throw new Error('Invalid message.');
        }

        if (typeof message.Status !== 'number') {
            message.Status = 0;
        }

        connection.send('MethodInvocationResultMessage', message);
    }

    function isStreamMsgForStreamingMethod(msg, method) {
        return (
         msg &&
         msg.EventStreamAction &&
         msg.EventStreamAction !== 0 &&
         typeof method === 'object' && method.definition.supportsStreaming === true
        );
    }

    function processSubscriberMsg(msg, streamingMethod) {
        if (!(msg && msg.EventStreamAction && msg.EventStreamAction !== 0)) {
            return;
        }

        if (msg.EventStreamAction === 1) {
            clientWishesToSubscribe(msg, streamingMethod);

        } else if (msg.EventStreamAction === 2) {
            clientWishesToUnsubscribe(msg, streamingMethod);

        } else if (msg.EventStreamAction === 3) {
            clientAcknowledgesItDidSubscribe(msg, streamingMethod);

        } else if (msg.EventStreamAction === 4) {
            clientPerSubHeartbeat(msg);
        }
    }

    /** msg 'Request' Actions */
    // action 1
    function clientWishesToSubscribe(msg, streamingMethod) {

        if (!(
         streamingMethod &&
         streamingMethod.streamCallbacks &&
         typeof streamingMethod.streamCallbacks.subscriptionRequestHandler === 'function')) {
            return;
        }

        // Pass-in the request object
        streamingMethod.streamCallbacks.subscriptionRequestHandler({
            accept: acceptRequestOnBranch.bind(null, msg, streamingMethod, ''),
            acceptOnBranch: acceptRequestOnBranch.bind(null, msg, streamingMethod),
            arguments: msg.Context.ArgumentsJson || {},
            instance: helpers.convertInfoToInstance(msg.Client),
            reject: rejectRequest.bind(null, msg, streamingMethod)
        });
    }

    // action 2
    function clientWishesToUnsubscribe(msg, streamingMethod) {

        if (!(
         streamingMethod &&
         Array.isArray(streamingMethod.subscriptions) &&
         streamingMethod.subscriptions.length > 0)) {
            return;
        }

        closeIndividualSubscription(streamingMethod, msg.StreamId, msg.EventStreamSubject, false);
    }

    // action 3
    function clientAcknowledgesItDidSubscribe(msg, streamingMethod) {
        // Client indicates it is listening to a specific StreamId

        if (typeof msg.StreamId !== 'string' || msg.StreamId === '') {
            return;
        }

        var branchKey = getBranchKey(streamingMethod, msg.StreamId);

        if (typeof branchKey !== 'string') {
            return;
        }

        if (!Array.isArray(streamingMethod.subscriptions)) {
            return;
        }

        var subscription = {
            branchKey: branchKey,
            instance: helpers.convertInfoToInstance(msg.Client),
            arguments: msg.Context.ArgumentsJson,
            streamId: msg.StreamId,
            privateEventStreamSubject: msg.EventStreamSubject,
            methodResponseSubject: msg.MethodResponseSubject
        };

        // Subscription back-obj is stored
        streamingMethod.subscriptions.push(subscription);

        var subFrontObj = conjureSubscriptionFrontObj(streamingMethod, subscription);
        var subAddedHandler = streamingMethod.streamCallbacks.subscriptionAddedHandler;
        if (typeof subAddedHandler === 'function') {
            // Pass-in the subscription object
            subAddedHandler(subFrontObj);
        }
    }

    // action 4
    function clientPerSubHeartbeat() {
        // A client may have multiple subscriptions, each one having its own heartbeat
        // Currently not implemented by the GW or the client
    }

    /** (request) Methods */
    function acceptRequestOnBranch(msg, streamingMethod, branch) {
        if (typeof branch !== 'string') {
            branch = '';
        }

        var streamId = getStreamId(streamingMethod, branch);

        sendResult({
            EventStreamAction: 3,
            EventStreamSubject: streamingMethod.globalEventStreamSubject,
            InvocationId: msg.Context.InvocationId,
            MethodName: streamingMethod.method.Method.Name,
            MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
            MethodResponseSubject: msg.MethodResponseSubject,
            MethodVersion: streamingMethod.method.Method.Version,
            ResultMessage: 'Accepted',
            Server: instance.info(),
            StreamId: streamId
        });
    }

    function getBranchKey(streamingMethod, streamId) {
        if (typeof streamId !== 'string' || typeof streamingMethod !== 'object') {
            return;
        }

        var needle = streamingMethod.branchKeyToStreamIdMap.filter(function (branch) {
            return branch.streamId === streamId;
        })[0];

        if (typeof needle !== 'object' || typeof needle.key !== 'string') {
            return;
        }

        return needle.key;
    }

    function getStreamId(streamingMethod, branchKey) {
        if (typeof branchKey !== 'string') {
            branchKey = '';
        }

        var needleBranch = streamingMethod.branchKeyToStreamIdMap.filter(function (branch) {
            return branch.key === branchKey;
        })[0];

        var streamId = (needleBranch ? needleBranch.streamId : undefined);

        if (typeof	streamId !== 'string' || streamId === '') {
            streamId = generateNewStreamId(streamingMethod.method.Method.Name);
            streamingMethod.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });
        }

        return streamId;
    }

    function generateNewStreamId(streamingMethodName) {
        var appInfo = instance.info();

        var newStreamId = 'streamId-jsb _of_' + streamingMethodName + '__by_' + appInfo.ApplicationName + '_' + helpers.generateRandom();

        return newStreamId;
    }

    function rejectRequest(msg, streamingMethod, reason) {
        if (typeof reason !== 'string') {
            reason = '';
        }

        sendResult({
            EventStreamAction: 2,
            EventStreamSubject: streamingMethod.globalEventStreamSubject,
            // InvocationId: msg.Context.InvocationId,
            MethodName: streamingMethod.method.Method.Name,
            MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
            MethodResponseSubject: msg.MethodResponseSubject,
            MethodVersion: streamingMethod.method.Method.Version,
            ResultMessage: reason,
            Server: instance.info(),
            StreamId: 'default_rejection_streamId'
        });
    }

    /** (subscription) Methods */
    function conjureSubscriptionFrontObj(streamingMethod, subscription) {
        // expose a subscription to the user
        return {
            arguments: subscription.arguments || {},
            branchKey: subscription.branchKey,
            close: closeIndividualSubscription.bind(
             null,
             streamingMethod,
             subscription.streamId,
             subscription.privateEventStreamSubject,
             true
            ),
            instance: subscription.instance,
            push: pushDataToSingle.bind(null, streamingMethod, subscription),
            stream: streamingMethod.definition
        };
    }

    function conjureBranchFrontObj(streamingMethod, branchKey) {
        // expose a branch to the user
        return {
            key: branchKey,
            subscriptions: getSubscriptionList.bind(null, streamingMethod, branchKey),
            close: closeMultipleSubscriptions.bind(null, streamingMethod, branchKey),
            push: function (data) {
                pushToBranch(streamingMethod, data, branchKey);
            }
        };
    }

    function closeIndividualSubscription(streamingMethod, streamId, privateEventStreamSubject, sendKickMessage) {

        var subscription = streamingMethod.subscriptions.filter(function (subItem) {
            return (
             subItem.privateEventStreamSubject === privateEventStreamSubject && subItem.streamId === streamId);
        })[0];

        if (typeof subscription !== 'object') {
            return; // unrecognised subscription
        }

        var initialLength = streamingMethod.subscriptions.length;

        streamingMethod.subscriptions = streamingMethod.subscriptions.filter(function (subItem) {
            return !(
             subItem.privateEventStreamSubject === subscription.privateEventStreamSubject && subItem.streamId === subscription.streamId);
        });

        var filteredLength = streamingMethod.subscriptions.length;

        if (filteredLength !== (initialLength - 1)) {
            return; // the subscription wasn't removed
        }

        if (sendKickMessage === true) {
            sendResult({
                EventStreamAction: 2,
                EventStreamSubject: privateEventStreamSubject,
                MethodName: streamingMethod.method.Method.Name,
                MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
                MethodResponseSubject: subscription.methodResponseSubject,
                MethodVersion: streamingMethod.method.Method.Version,
                ResponseContextJson: {},
                Server: instance.info(),
                StreamId: subscription.streamId,
                Status: 0
            });
        }

        var subRemovedHandler = streamingMethod.streamCallbacks.subscriptionRemovedHandler;
        if (typeof subRemovedHandler === 'function') {
            var subscriber = subscription.instance;
            subRemovedHandler(subscriber);
        }
    }

    function closeMultipleSubscriptions(streamingMethod, branchKey) {
        if (typeof streamingMethod !== 'object' || !Array.isArray(streamingMethod.branchKeyToStreamIdMap)) {
            return;
        }

        var streamList = streamingMethod.branchKeyToStreamIdMap;

        if (typeof branchKey === 'string') {
            streamList = streamingMethod.branchKeyToStreamIdMap.filter(function (br) {
                return (typeof br === 'object' && br.key === branchKey);
            });
        }

        // TODO: consider getting the unique branch keys from 'live subscribers'

        streamList.forEach(function (br) {
            var streamId = br.streamId;

            sendResult({
                EventStreamAction: 2,
                EventStreamSubject: streamingMethod.globalEventStreamSubject,
                MethodName: streamingMethod.method.Method.Name,
                MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
                Server: instance.info(),
                StreamId: streamId,
                Status: 0
            });
        });
    }

    function pushDataToSingle(streamingMethod, subscription, data) {

        // TODO validate data is a plain object
        if (typeof data !== 'object') {
            throw new Error('Invalid arguments. Data must be an object.');
        }

        sendResult({
            EventStreamAction: 5,
            EventStreamSubject: subscription.privateEventStreamSubject,
            MethodName: streamingMethod.method.Method.Name,
            MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
            ResultContextJson: data,
            Server: instance.info(),
            StreamId: subscription.streamId
        });
    }

    function pushToBranch(streamingMethod, data, branches) {
        if (typeof streamingMethod !== 'object' || !Array.isArray(streamingMethod.branchKeyToStreamIdMap)) {
            return;
        }

        // TODO validate data is a plain object
        if (typeof data !== 'object') {
            throw new Error('Invalid arguments. Data must be an object.');
        }

        if (typeof branches === 'string') {
            branches = [branches]; // user wants to push to single branch
        } else if (!Array.isArray(branches) || branches.length <= 0) {
            branches = null;
        }

        // get the StreamId's from the method's branch map
        var streamIdList = streamingMethod.branchKeyToStreamIdMap
            .filter(function (br) {
                return (
             branches === null || (Boolean(br) && typeof br.key === 'string' && branches.indexOf(br.key) >= 0));
            }).map(function (br) {
                return br.streamId;
            });

        streamIdList.forEach(function (streamId) {

            sendResult({
                EventStreamAction: 5,
                EventStreamSubject: streamingMethod.globalEventStreamSubject,
                MethodName: streamingMethod.method.Method.Name,
                MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
                ResultContextJson: data,
                Server: instance.info(),
                StreamId: streamId
            });

        });

    }

    function getSubscriptionList(streamingMethod, branchKey) {
        if (typeof streamingMethod !== 'object') {
            return [];
        }

        var subscriptions = [];

        if (typeof branchKey !== 'string') {
            subscriptions = streamingMethod.subscriptions;
        } else {
            subscriptions = streamingMethod.subscriptions.filter(function (sub) {
                return sub.branchKey === branchKey;
            });
        }

        return subscriptions.map(function (sub) {
            return conjureSubscriptionFrontObj(streamingMethod, sub);
        });
    }

    function getBranchList(streamingMethod) {
        if (typeof streamingMethod !== 'object') {
            return [];
        }

        var uniqueBranchNames = getUniqueBranchNames(streamingMethod);

        return uniqueBranchNames.map(function (branchKey) {

            return conjureBranchFrontObj(streamingMethod, branchKey);

        });
    }

    function getUniqueBranchNames(streamingMethod) {
        var keysWithDuplicates = streamingMethod.subscriptions.map(function (sub) {
            var result = null;
            if (typeof sub === 'object' && typeof sub.branchKey === 'string') {
                result = sub.branchKey;
            }

            return result;
        });

        var seen = [];

        var branchArray = keysWithDuplicates.filter(function (bKey) {
            if (bKey === null || seen.indexOf(bKey) >= 0) {
                return false;
            }

            seen.push(bKey);
            return true;
        });

        return branchArray;
    }

    return { // an instance fo the publisher
        isStreamMsg: isStreamMsgForStreamingMethod,
        processSubscriberMsg: processSubscriberMsg,
        pushData: pushToBranch,
        closeAllSubscriptions: closeMultipleSubscriptions,
        getSubscriptionList: getSubscriptionList,
        getBranchList: getBranchList,
        generateNewStreamId: generateNewStreamId
    };
};

},{"./agm_helpers":48}],53:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-agm@^2.3.5",
      "C:\\work\\stash\\GLUE-dev\\dev\\js-glue"
    ]
  ],
  "_from": "tick42-agm@>=2.3.5 <3.0.0",
  "_id": "tick42-agm@2.3.5",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-agm",
  "_nodeVersion": "6.0.0",
  "_npmUser": {},
  "_npmVersion": "3.10.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-agm",
    "raw": "tick42-agm@^2.3.5",
    "rawSpec": "^2.3.5",
    "scope": null,
    "spec": ">=2.3.5 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "http://192.168.0.234:4873/tick42-agm/-/tick42-agm-2.3.5.tgz",
  "_shasum": "9639fb00e98d94155b190d970373bb8e56993877",
  "_shrinkwrap": null,
  "_spec": "tick42-agm@^2.3.5",
  "_where": "C:\\work\\stash\\GLUE-dev\\dev\\js-glue",
  "author": {
    "name": "Tick42",
    "url": "http://www.tick42.com"
  },
  "bin": {
    "agm": "bin/agm",
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "bugs": {
    "url": "https://jira.tick42.com/browse/APPCTRL"
  },
  "dependencies": {
    "es6-promise": "^3.0.2",
    "tick42-gateway-connection": "^1.1.2",
    "util-deprecate": "^1.0.2"
  },
  "description": "JavaScript AGM",
  "devDependencies": {
    "blanket": "^1.1.6",
    "bluebird": "^2.9.30",
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "fs": "0.0.2",
    "http-server": "^0.9.0",
    "jsdom": "^8.1.0",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "shelljs": "^0.6.0"
  },
  "dist": {
    "shasum": "9639fb00e98d94155b190d970373bb8e56993877",
    "tarball": "http://192.168.0.234:4873/tick42-agm/-/tick42-agm-2.3.5.tgz"
  },
  "gitHead": "9c0887e464e10469f491c938ad6e247e12fc8552",
  "keywords": [
    "agm",
    "javascript",
    "library"
  ],
  "main": "library/agm.js",
  "name": "tick42-agm",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix",
    "prepublish": "npm update & npm run build",
    "serve": "http-server -p 8000 -a 127.0.0.1",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "watch": "onchange \"./library/**/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "title": "Tick42 AGM",
  "version": "2.3.5"
}

},{}],54:[function(require,module,exports){
(function (global){
var application = require("./application");
var instance = require("./instance");
var helpers = require("./helpers");
var PackageJson = require("../package.json");
var deprecate = require('util-deprecate');
var cuid = require('cuid');

module.exports = global.app_manager = function app_manager(agm, windows) {
	var token = cuid();

	var instanceIdFunction = function (e) {
		if (e.Context) {
			if (e.Context._t42 && e.Context._t42.id) {
				return e.Context._t42.id;
			}

			// backward compatibility
			if (e.Context.guid !== undefined) {
				return e.Context.guid;
			}
		}
		return e.Name + '_' + e.Id;
	};

    // Internal id is the id we use for tracking
    var getInternalInstanceId = function(instance){
        if (instance.context) {
            if (instance.context._t42 && instance.context._t42.id) {
                return instance.context._t42.id;
            }

            // backward compatibility
            if (instance.context.guid) {
                return instance.context.guid;
            }
        }

        return instance.application.name + '_' + instance.id;
    };

	var branch_changed_callback;

	var apps = application(agm, function () { return instances;}, token);
	var instances = instance(agm, apps, token, instanceIdFunction);
	var manager = {
		token: token,
		applications: apps.all,
		application: apps.get_by_id,
		onAppAdded: helpers.add_callback("added").bind(apps),
		onAppAvailable: helpers.add_callback("available").bind(apps),
		onAppRemoved: helpers.add_callback("removed").bind(apps),
		onAppUnavailable: helpers.add_callback("unavailable").bind(apps),

		instances: instances.all,
		onInstanceStarted: helpers.add_callback("started").bind(instances),
		onInstanceStopped: helpers.add_callback("stopped").bind(instances),
		onInstanceUpdated: helpers.add_callback("updated").bind(instances),

		getBranches: function (success, error) {
			agm.invoke("T42.ACS.GetBranches", {}, "best", {}, function (e) {
				if (success) {
					success(helpers.vals(e.returned.Branches));
				}
			}, error);
		},
		getCurrentBranch: function (success, error) {
			agm.invoke("T42.ACS.GetCurrentBranch", {}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Branch);
				}
			}, error);
		},
		setCurrentBranch: function (branch, success, error) {
			agm.invoke("T42.ACS.SetCurrentBranch", {Branch: branch}, "best", {}, success, error);
		},
		currentUser: function (success, error) {
			agm.invoke("T42.ACS.GetUser", {}, "best", {}, success, error);
		},
		getFunctionalEntitlement: function (fn, success, error) {
			agm.invoke("T42.ACS.GetFunctionalEntitlement", {Function: fn}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Entitlement);
				}
			}, error);
		},
		getFunctionalEntitlementBranch: function (fn, br, success, error) {
			agm.invoke("T42.ACS.GetFunctionalEntitlement", {Function: fn, Branch: br}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Entitlement);
				}
			}, error);
		},
		canI: function (fn, success, error) {
			agm.invoke("T42.ACS.CanI", {Function: fn}, "best", {}, success, error);
		},

		canIBranch: function(fn, branch, success, error) {
			agm.invoke("T42.ACS.CanI", {Function: fn, Branch: branch}, "best", {}, success, error);
		},

		exit: function () {
			agm.invoke("T42.ACS.Shutdown", {}, "all", {},
				function (a) {
					console.log(a);
				},
				function (e) {
					console.log(e);
				});
		},

		setRegion: function (region, success, error){
			agm.invoke("T42.ACS.SetConfigurationRegion", {Region: region}, "best", {}, success, error);
		},

		getRegion: function(success, error){
			agm.invoke("T42.ACS.GetConfigurationRegion", {}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Region);
				}
			}, error);
		},

		_trigger_app_event: apps._trigger,
		_trigger_instance_event: instances._trigger

	};



	//Tell the app when its instances are added/removed
	manager.onInstanceStarted(function (instance) {
		if (instance.application) {
			//Trigger "instance_started" event on application
			manager._trigger_app_event("instanceStarted", instance, instance.application.name);

			//Trigger "window_opened" event on instance
			var container;
			if (windows && glue) {
				container = instance.application.configuration.container;
				if(container !== null && container !== ""){
					glue.agm.invoke("T42.Wnd.FindById", {windowId: instance.id}, {application: container}, {}, window_opened, function(e){console.log(e)});
				}
			}
		}

		function window_opened(a) {
			//Wrap the window in a window object, using the glue windows lib
			var w = a.returned [Object.keys(a.returned)[0]];
			var win = glue.windows._from_event(w.windowName, container, w.url, w.windowId, w.windowStyleAttributes, w.windowTitle);

			//Trigger the window opened event
			manager._trigger_instance_event("windowAdded", win, id);
		}
	});

	manager.onInstanceStopped(function (instance) {
		if (instance.application) {
			manager._trigger_app_event("instanceStopped", instance, instance.application.name);

			var id = getInternalInstanceId(instance);
			manager._trigger_instance_event("windowRemoved", {}, id);

		}
	});

	manager.onInstanceUpdated(function (instance) {
		if (instance.application) {
		// manager._trigger_app_event("instance_stopped", instance, instance.application.name);

		// var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
		// manager._trigger_instance_event("title_changed", {}, id);
		}
	});
	//When an app is removed, remove also its instances

	manager.onAppRemoved(function (app) {
		app.instances.forEach(function (instance) {
			manager._trigger_instance_event("stopped", {}, getInternalInstanceId(instance));
		});
	});

	manager.onBranchesChanged = function (callback) {
		branch_changed_callback = callback;
	};

	function on_branch_changed(e) {
		if (typeof branch_changed_callback === "function") {
			branch_changed_callback(helpers.vals(e));
		}
	}

	function handle_app_ready(app) {
		if (app.IsReady) {
			manager._trigger_app_event("available", app);
		} else {

			manager._trigger_app_event("unavailable", app);
		}
	}

	function app_failed(e) {
		var id = instanceIdFunction(e);
		manager._trigger_instance_event("error", e, id);
	}

	// deprecates
	manager.can_i = deprecate(manager.canI, 'appManager.can_i is deprecated and might be removed from future versions of glue. Use appManager.canI() instead');
	manager.can_i_branch = deprecate(manager.canIbranch, 'appManager.can_i_branch is deprecated and might be removed from future versions of glue. Use appManager.canIbranch() instead');
	manager.current_user = deprecate(manager.currentUser, 'appManager.current_user is deprecated and might be removed from future versions of glue. Use appManager.currentUser() instead');
	manager.set_current_branch = deprecate(manager.setCurrentBranch, 'appManager.set_current_branch is deprecated and might be removed from future versions of glue. Use appManager.setCurrentBranch() instead');
	manager.get_current_branch = deprecate(manager.getCurrentBranch, 'appManager.get_current_branch is deprecated and might be removed from future versions of glue. Use appManager.getCurrentBranch() instead');
	manager.get_branches = deprecate(manager.getBranches, 'appManager.get_branches is deprecated and might be removed from future versions of glue. Use appManager.getBranches() instead');
	manager.get_functional_entitlement_branch = deprecate(manager.getFunctionalEntitlementBranch, 'appManager.get_functional_entitlement_branch is deprecated and might be removed from future versions of glue. Use appManager.getFunctionalEntitlementBranch() instead');
	manager.get_functional_entitlement = deprecate(manager.getFunctionalEntitlement, 'appManager.get_functional_entitlement is deprecated and might be removed from future versions of glue. Use appManager.getFunctionalEntitlement() instead');
	manager.get_region = deprecate(manager.getRegion, 'appManager.get_region is deprecated and might be removed from future versions of glue. Use appManager.getRegion() instead');
	manager.set_region = deprecate(manager.setRegion, 'appManager.set_region is deprecated and might be removed from future versions of glue. Use appManager.setRegion() instead');
	manager.on_app_unavailable = deprecate(manager.onAppUnavailable, 'appManager.on_app_unavailable is deprecated and might be removed from future versions of glue. Use appManager.onAppUnavailable() instead');
	manager.on_app_removed = deprecate(manager.onAppRemoved, 'appManager.on_app_removed is deprecated and might be removed from future versions of glue. Use appManager.onAppRemoved() instead');
	manager.on_app_added = deprecate(manager.onAppAdded, 'appManager.on_app_added is deprecated and might be removed from future versions of glue. Use appManager.onAppAdded() instead');
	manager.on_app_available = deprecate(manager.onAppAvailable, 'appManager.on_app_available is deprecated and might be removed from future versions of glue. Use appManager.onAppAvailable() instead');
	manager.on_branches_changed = deprecate(manager.onBranchesChanged, 'appManager.on_branches_changed  is deprecated and might be removed from future versions of glue. Use appManager.onBranchesChanged() instead');
	manager.on_instance_started = deprecate(manager.onInstanceStarted, 'appManager.on_instance_started is deprecated and might be removed from future versions of glue. Use appManager.onInstanceStarted() instead');
	manager.on_instance_stopped = deprecate(manager.onInstanceStopped, 'appManager.on_instance_stopped is deprecated and might be removed from future versions of glue. Use appManager.onInstanceStopped() instead');
	manager.on_instance_updated= deprecate(manager.onInstanceUpdated, 'appManager.on_instance_updated is deprecated and might be removed from future versions of glue. Use appManager.onInstanceUpdated() instead');

	if (agm && agm.subscribe) {

		manager.agm = agm;
		var handlers = [
			{event: "OnApplicationAdded", trigger: "added", on: apps},
			{event: "OnApplicationRemoved", trigger: "removed", on: apps},
			{event: "OnApplicationChanged", trigger: "changed", on: apps},
			{event: "OnApplicationStarted", trigger: "started", on: instances},
			{event: "OnApplicationStopped", trigger: "stopped", on: instances},
			{event: "OnApplicationUpdated", trigger: "updated", on: instances},
			{event: "OnApplicationAgmServerReady", trigger: "agmReady", on: instances},
			{event: "OnApplicationReady", func: handle_app_ready},
			{event: "OnBranchesModified", func: on_branch_changed},
			{event: "OnApplicationStartFailed", raw_func: app_failed}
		];

		agm.serverMethodAdded(function (resp) {
			if ((resp.server.application.indexOf('AppManager') !== -1 && resp.method.name.indexOf('T42.ACS.OnEvent') !== -1)) {
				agm.subscribe("T42.ACS.OnEvent", {target: "all"})
					.then(function (subscription) {
						subscription.onData(function (streamData) {
							var events = streamData.data;
							handlers.forEach(function (handler) {
								var objects = events[handler.event];
								if (objects) {

									if (handler.raw_func !== undefined) {
										handler.raw_func(objects);
										return;
									}

									helpers.vals(objects).forEach(function (object) {
										if (handler.on !== undefined) {
											handler.on._trigger(handler.trigger, object);
										} else {
											handler.func(object);
										}
									});
								}
							});
						})
					});
			}
		});
	}

	manager.version =  PackageJson.version;

	return manager;
};

global.tick42 = global.tick42 ||{};
global.tick42.app_manager = global.app_manager;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":59,"./application":55,"./helpers":57,"./instance":58,"cuid":5,"util-deprecate":128}],55:[function(require,module,exports){
var event_manager = require("./event_manager");
var helpers = require("./helpers");
var deprecate = require('util-deprecate');
var cuid = require('cuid');
var Promise = require('es6-promise').Promise;

module.exports = function(agm, instances, token) {
	var app_proto = helpers.add_callbacks({

		// options
		//  - useMyFrameColor - true/false - if set the started app will have the same frame color as the current
		//  - frameColor - Color - use to set a frame color for the new application. This will override useMyFrameColor
		//  - winStateSync = 'twoWay', 'oneWay', 'oneWayFromChild'
		start: function(context, options) {
			var name = this.name;
			return new Promise(function (resolve, reject) {

				context = context || {};
				context._t42 = {};
				// use id for tracking
				context._t42.id = context.guid || cuid();
				context._t42.token = token;

				options = options || {};
				var inContainer = typeof htmlContainer !== 'undefined';

				var layoutOptions = {};
				context._t42.layoutOptions = layoutOptions;

				if (options.useMyFrameColor && inContainer) {
					layoutOptions.frameColor = htmlContainer.getFrameColor();
				}

				if (options.frameColor) {
					layoutOptions.frameColor = options.frameColor;
				}

				if (options.stateTracking){
					layoutOptions.stateTracking =  {
						mode: options.stateTracking,
						ownerWindowId: inContainer ? 	htmlContainer.windowId: 'browser'
					};
				}

				if (agm) {
					agm.invoke("T42.ACS.StartApplication",
						{Name: name, Context: context},
						"best", {},
						function () {
							var instance = instances()._trigger("create", {Context: context});
							resolve(instance);
						},
						function (err) {
							reject(err);
						});
				}
			});
		}
	}, ["Added", "Removed", "Available", "Unavailable", "InstanceStarted", "InstanceStopped", "Changed"], "on");

	//deprecated
	app_proto.on_added = deprecate(app_proto.onAdded, 'application.on_added is deprecated and might be removed from future versions of glue. Use application.onAdded() instead');
	app_proto.on_removed = deprecate(app_proto.onRemoved, 'application.on_removed is deprecated and might be removed from future versions of glue. Use application.onRemoved() instead');
	app_proto.on_available = deprecate(app_proto.onAvailable, 'application.on_available is deprecated and might be removed from future versions of glue. Use application.onAvailable() instead');
	app_proto.on_unavailable = deprecate(app_proto.onUnavailable, 'application.on_unavailable is deprecated and might be removed from future versions of glue. Use application.onUnavailable() instead');
	app_proto.on_instance_started = deprecate(app_proto.onInstanceStarted, 'application.on_instance_started is deprecated and might be removed from future versions of glue. Use application.onInstanceStarted() instead');
	app_proto.on_instance_stopped = deprecate(app_proto.onInstanceStopped, 'application.on_instance_stopped is deprecated and might be removed from future versions of glue. Use application.onInstanceStopped() instead');
	app_proto.on_changed = deprecate(app_proto.onChanged, 'application.on_changed is deprecated and might be removed from future versions of glue. Use application.onChanged() instead');


	//constructor, init_event, id_field
	function update_app(props, obj) {
		obj.name = props.Name;
		obj.title = props.Title;
		obj.version = props.Version;
		obj.instances = [];
		obj.configuration = {};
		obj.configuration.auto_start = props.AutoStart;
		obj.configuration.caption = props.Caption;
		obj.configuration.hidden = props.IsHidden;
		obj.configuration.container = props.ApplicationName;
		obj.configuration.activityType = props.ActivityType;
		//obj.disabled = props.IsDisabled;
		obj.configuration.allow_multiple = props.AllowMultiple;
		obj.available = props.IsReady || false;
		obj.icon = props.Icon;
		obj.sortOrder = props.SortOrder;
		obj.userProperties = props.UserProperties;
		return obj;
	}

	var appToEventManager = {
		create: function create_app(props) {
			return update_app(props, Object.create(app_proto));
		},
		update: update_app,
		init_event: "added",
		exit_event: "removed",
		id_field: "Name",
		callbacks: {
			available: function () {
				this.available = true;
			},
			changed: function (props) {
				this.icon = props.Icon;
				this.title = props.Title;
				this.configuration.caption = props.Caption;
			},
			unavailable: function () {
				this.available = false;
			},
			instanceStarted: function (instance) {
				this.instances.push(instance);
			},
			instanceStopped: function (instance) {
				this.instances = this.instances.filter(function (my_instance) {
					return my_instance !== instance;
				});
			}
		}
	}
	//deprecated
	appToEventManager.callbacks.instance_started = deprecate(appToEventManager.callbacks.instanceStarted, 'application.instance_started is deprecated and might be removed from future versions of glue. Use application.instanceStarted() instead');
	appToEventManager.callbacks.instance_stopped = deprecate(appToEventManager.callbacks.instanceStopped, 'application.instance_stopped is deprecated and might be removed from future versions of glue. Use application.instanceStopped() instead');


	return event_manager(appToEventManager);
};

},{"./event_manager":56,"./helpers":57,"cuid":5,"es6-promise":9,"util-deprecate":128}],56:[function(require,module,exports){
var helpers = require("./helpers");

function exec_callbacks(obj, arr, val) {
	if (arr !== undefined) {
		arr.forEach(function (callback) {
			callback.call(obj, val);
		});
	}
}

module.exports = function create_environment(settings) {
	var objects = {};
	var global_callbacks = {};
	return {
		all: function () {
			return helpers.vals(objects);
		},
		get_by_id: function (id) {
			return objects[id];
		},
		_trigger: function (type, props, id) {
			id = id || ( typeof settings.id_field === "function" ? settings.id_field(props) : props[settings.id_field]);

			//Quit if we receive an event for an object before initiating it.
			if (objects[id] === undefined && ( type !== settings.init_event && type !== settings.create_event)) {
				//console.log ("Received '"+type+"' event before '"+settings.init_event+"'");
				return;
			}


			//Create or retrieve an object, representing the entity
			var obj = objects[id] = objects[id] || init_object(settings.create(props));

			if (type === settings.init_event) {
				//Quit if we receive a init event for an object that is already active
				if (obj.active) {
					//console.log ("Received second '"+settings.init_event+"' for app "+id);
					return;
					//Else, make it active
				} else {
					obj.active = true;
					settings.update(props, obj);
				}
				//When the entity is removed, set it to non-active
			} else if (type === settings.exit_event) {
				if (settings.removeOnExit){
					delete objects[id];
				} else {
					obj.active = false;
				}
				//When a create event is received, just return the object without doing anything else
			} else if (type === settings.create_event) {
				return obj;

			} else if (type === settings.update_event) {
				settings.update(props, obj);
			}

			//Execute system callbacks
			if (settings.callbacks[type] !== undefined) {
				settings.callbacks[type].call(obj, props);
			}

			// make sure that errors in user specified callbacks does not
			// break our library
			try {
				//Execute global callbacks
				exec_callbacks(undefined, global_callbacks[type], obj);

				//Execute user-defined callbacks that are attached to the object
				exec_callbacks(obj, obj.callbacks[type], props);
			}
			catch (e){
				console.error(e);
			}
			//When the entity is removed, remove all callbacks (after you execute them)
			if (type === settings.exit_event) {
				obj.callbacks = {};
			}
			return obj;

		},
		//Expose the global callbacks object so that user can register some
		callbacks: global_callbacks
	};
};

function init_object(object) {
	object.callbacks = {};
	object.active = false;
	return object;
}

},{"./helpers":57}],57:[function(require,module,exports){
function noop(){}

function exec_if(condition) {
	return function (app, callback) {
		if (condition(app)) {
			callback.call(app);
		}
	};
}

exports.add_callbacks = function add_callbacks(object, events, prefix) {
	events.forEach(function (event) {
		if (typeof event === "string") {
			event = {name: event, trigger_when: noop};
		}
		object[prefix + event.name] = exports.add_callback(event.name, exec_if(event.trigger_when));
	});
	return object;

};

exports.add_callback = function add_callback(key, on_add){
	return function(callback){
		var obj = this.callbacks;
		if(typeof key !== 'undefined'){
			key = key.charAt(0).toLowerCase() + key.slice(1);
		}

		if(obj[key]===undefined){
			obj[key] = [callback];
		}
		else {
			obj[key].push(callback);
		}
		if(typeof on_add === "function"){
			on_add(this, callback);
		}
		return this;
	};
};

exports.vals = function vals(obj) {
	return Object.keys(obj).reduce(function (arr, key) {
		arr.push(obj[key]);
		return arr;
	}, []);
};

},{}],58:[function(require,module,exports){
var event_manager = require("./event_manager");
var helpers = require("./helpers");
var deprecate = require('util-deprecate');

module.exports = function(agm, apps, token, instanceIdFunction) {
	var instance_proto = helpers.add_callbacks({
			stop: function (params, success, error) {
				agm.invoke("T42.ACS.StopApplication", {Name: this.application.name, Id: this.id}, "best", {}, function (e) {
					console.log(e);
				}, error);
			},
			activate: function (params, success, error) {
				agm.invoke("T42.ACS.ActivateApplication", {Name: this.application.name, Id: this.id}, "best", {}, function (e) {
					console.log(e);
				}, error);
			},
			// True if the instance is spawn from this AppManager (by comparing tokens)
			own: function () {
				if (this.context && this.context._t42 && this.context._t42.token) {
					return this.context._t42.token === token;
				}
				return false;
			}
		},
		[
			{
				name: "WindowAdded", trigger_when: function (app) {
				return app.active && app.main_window !== undefined;
			}
			},
			{
				name: "WindowRemoved", trigger_when: function (app) {
				return app.main_window === undefined;
			}
			},
			{
				name: "Started", trigger_when: function (app) {
				return app.id !== undefined && app.active;
			}
			},
			{
				name: "Stopped", trigger_when: function (app) {
				return app.id !== undefined && !app.active;
			}
			},
			{
				name: "AgmReady", trigger_when: function (app) {
				return app.active && app.agm !== undefined;
			}
			},
			{
				name: "Error", trigger_when: function (app) {
				return app.error !== undefined;
			}
			},
		], "on");

	//deprecated
	instance_proto.on_window_added = deprecate(instance_proto.onWindowAdded, 'instance.on_window_added is deprecated and might be removed from future versions of glue. Use instance.onWindowAdded() instead');
	instance_proto.on_window_removed = deprecate(instance_proto.onWindowRemoved, 'instance.on_window_removed is deprecated and might be removed from future versions of glue. Use instance.onWindowRemoved() instead');
	instance_proto.on_started = deprecate(instance_proto.onStarted, 'instance.on_started is deprecated and might be removed from future versions of glue. Use instance.onStarted() instead');
	instance_proto.on_stopped = deprecate(instance_proto.onStopped, 'instance.on_stopped is deprecated and might be removed from future versions of glue. Use instance.onStopped() instead');
	instance_proto.on_agm_ready = deprecate(instance_proto.onAgmReady, 'instance.on_agm_ready is deprecated and might be removed from future versions of glue. Use instance.onAgmReady() instead');
	instance_proto.on_error = deprecate(instance_proto.onError, 'instance.on_error is deprecated and might be removed from future versions of glue. Use instance.onError() instead');

	function update_instance(props, obj) {
		obj.id = props.Id;
		obj.application = apps.get_by_id(props.Name);
		obj.context = props.Context;
		obj.title = props.Title;
		obj.activityId = props.ActivityId;
		return obj;
	}

	var instanceToEventManager = {
		create: function (props) {
			return update_instance(props, Object.create(instance_proto));
		},
		update: update_instance,
		create_event: "create",
		init_event: "started",
		exit_event: "stopped",
		update_event: "updated",
		id_field: instanceIdFunction,
		callbacks: {
			agmReady: function (e) {
				//get the first AGM
				var server_name = Object.keys(e.AgmServers)[0];
				//Attach it to the object
				this.agm = convert_agm_instance(e.AgmServers[server_name]);
			},
			error: function (e) {
				this.error = e;
			},
			windowAdded: function (win) {
				this.main_window = win;
				this.windows = this.windows || [];
				this.windows.push(win);
			},
			windowRemoved: function () {
				this.main_window = undefined;
				this.windows = [];
			}
		},
		removeOnExit: true
	};

	//deprecated
	instanceToEventManager.callbacks.agm_ready = deprecate(instanceToEventManager.callbacks.agmReady, 'instance.agm_ready is deprecated and might be removed from future versions of glue. Use instance.agmReady() instead');
	instanceToEventManager.callbacks.window_added = deprecate(instanceToEventManager.callbacks.windowAdded, 'instance.window_added is deprecated and might be removed from future versions of glue. Use instance.windowAdded() instead');
	instanceToEventManager.callbacks.window_removed = deprecate(instanceToEventManager.callbacks.windowRemoved, 'instance.window_removed is deprecated and might be removed from future versions of glue. Use instance.windowRemoved() instead');

	return event_manager(instanceToEventManager);
};

function convert_agm_instance(agm) {
	return {
		machine: agm.machineName,
		user: agm.userName,
		environment: agm.environment,
		application: agm.applicationName
	};
}

},{"./event_manager":56,"./helpers":57,"util-deprecate":128}],59:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-app-manager@^2.0.0",
      "C:\\work\\stash\\GLUE-dev\\dev\\js-glue"
    ]
  ],
  "_from": "tick42-app-manager@>=2.0.0 <3.0.0",
  "_id": "tick42-app-manager@2.5.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-app-manager",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-app-manager",
    "raw": "tick42-app-manager@^2.0.0",
    "rawSpec": "^2.0.0",
    "scope": null,
    "spec": ">=2.0.0 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_shasum": "9ff991b7976c80df71e794785216fee1c5a8024f",
  "_shrinkwrap": null,
  "_spec": "tick42-app-manager@^2.0.0",
  "_where": "C:\\work\\stash\\GLUE-dev\\dev\\js-glue",
  "author": {
    "name": "Tick42",
    "url": "http://www.tick42.com"
  },
  "dependencies": {
    "cuid": "^1.3.8",
    "es6-promise": "^3.0.2"
  },
  "description": "App Manager API for JavaScript",
  "devDependencies": {
    "blanket": "^1.1.6",
    "bootstrap": "^3.3.4",
    "browserify-versionify": "^1.0.4",
    "grunt": "^0.4.5",
    "grunt-browserify": "^3.3.0",
    "grunt-cli": "^0.1.0",
    "grunt-contrib-clean": "^0.6.0",
    "grunt-contrib-connect": "^0.9.0",
    "grunt-contrib-jshint": "^0.11.0",
    "grunt-contrib-qunit": "^0.5.2",
    "grunt-contrib-uglify": "^0.6.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-exorcise": "^1.0.0",
    "http-server": "^0.8.0",
    "jquery": "^2.1.4",
    "lodash": "^3.9.3",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "tick42-agm": "^1.3.0",
    "uglifyify": "^3.0.1"
  },
  "directories": {
    "example": "examples"
  },
  "dist": {
    "shasum": "9ff991b7976c80df71e794785216fee1c5a8024f",
    "tarball": "http://192.168.0.234:4873/tick42-app-manager/-/tick42-app-manager-2.5.1.tgz"
  },
  "gitHead": "f7c18004a06925fbddb9e5411d41145b52cb7a23",
  "license": "ISC",
  "main": "library/app_manager.js",
  "name": "tick42-app-manager",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "https://stash.tick42.com/scm/ofgw/js-app-manager.git"
  },
  "scripts": {
    "prepublish": "grunt",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "2.5.1"
}

},{}],60:[function(require,module,exports){
/**
 * @module appconfig
 */
var _ = require('./util');
var Model = require('./model');
var helpers = require('./helpers');

var events = {
    connect: 'connect',
    disconnect: 'disconnect',
    update: 'update',
    status: 'status'
};

var EventBus = function () {
    'use strict';
    var subscriptionsByType;
    var on = function (type, once, callback, scope) {
        if (!_.isFunction(callback)) {
            return;
        }

        var subscription = {
            type: type,
            once: once,
            callback: callback,
            scope: scope
        };

        var subscriptions = subscriptionsByType[type];
        if (typeof subscriptions === 'undefined') {
            subscriptions = subscriptionsByType[type] = [];
        }

        subscription.id = subscriptions.push(subscription) - 1;
        return subscription;
    };

    var emit = function () {
        var args = [].slice.call(arguments);
        var type = args.splice(0, 1)[0];
        var subscriptions = subscriptionsByType[type];
        if (typeof subscriptions === 'undefined') {
            subscriptions = subscriptionsByType[type] = [];
        }

        subscriptions.forEach(function (subscription) {
            if (!subscription) {
                return;
            }

            try {
                subscription.callback.apply(subscription.scope, args);
            } catch (x) {
                _.warn('Exception during execution of callback', subscription, args, x);
            }

            if (subscription.once) {
                off(subscription);
            }
        });
    };

    var off = function (subscription) {
        var subscriptions = subscriptionsByType[subscription.type];
        if (typeof subscriptions !== 'undefined') {
            delete subscriptions[subscription.id];
        }
    };

    var resume = function (subscription) {
        if (typeof subscription.id === 'undefined') {
            return on(subscription.type, subscription.once, subscription.callback, subscription.scope);
        } else {
            var subscriptions = subscriptionsByType[subscription.type];
            if (typeof subscriptions === 'undefined') {
                subscriptions = subscriptionsByType[subscription.type] = [];
            }

            subscriptions[subscription.id] = subscription;
            return subscription;
        }
    };

    var reset = function () {
        if (typeof subscriptionsByType !== 'undefined') {
            Object.keys(subscriptionsByType).forEach(function (type) {
                var subscriptions = subscriptionsByType[type];
                if (typeof subscriptions !== 'undefined') {
                    subscriptions.forEach(function (subscription) {
                        delete subscription.id;
                    });
                }
            });
        }

        subscriptionsByType = {};
    };

    reset();
    return {
        on: on,
        emit: emit,
        off: off,
        resume: resume,
        reset: reset

    };
};

var AppConfig = function () {
    'use strict';
    var defaultListen  = true;
    var gateway;
    var initGateway;
    var bus = new EventBus();
    var model = new Model(bus);

    var root = require('./props')(model.root);
    var self = this;

    var gatewayConnection;
    var pollingIntervalId;
    var clearPollingInterval = function () {
        if (typeof pollingIntervalId !== 'undefined') {
            clearInterval(pollingIntervalId);
        }
    };

    // Public API
    self.init = function (settings) {
        settings = settings || {};
        var isIdentityValid = typeof settings.identity === 'object' &&
          Object.keys(settings.identity).length > 0;

        if (isIdentityValid) {
            self.identity = settings.identity;
        }

        defaultListen = settings.defaultListen || defaultListen;
        if (!self.identity) {
            throw new TypeError('identity must be non empty object.');
        }

        model.separator = settings.defaultSeparator || model.separator;

        self.schema = settings.schema || self.schema || 'ApplicationConfiguration';

        initGateway = _.isFunction(settings.gateway)
        ? settings.gateway
        : function () {
            if (typeof settings.gateway === 'undefined') {
                settings.gateway = {};
            }

            if (typeof settings.gateway.instance === 'undefined') {
                settings.gateway.instance = _.uuid();
            }

            return require('./gateway')(settings.gateway);
        };
    };

    self.connect = function (listen, callback, scope) {
        clearPollingInterval();
        var subscription;
        if (arguments.length > 0) {
            if (_.isFunction(listen)) {
                callback = listen;
                scope = callback;
                listen = defaultListen;
            }

            subscription = bus.on(events.connect, true, callback, scope);
        }

        var error;
        if (!self.identity) {
            error = 'identity is not specified. did you forget to call init()?';
        } else {
            if (!gateway) {
                gateway = initGateway();
            }

            if (!listen) {
                gatewayConnection =
                  gateway.connect(
                    self.schema,
                    self.identity,
                    false,
                    function (error, snapshot) {
                        if (typeof error === 'undefined') {
                            model.applySnapshot(snapshot);
                        }

                        bus.emit(events.connect, error);
                    },

                    function (error, status) {
                        bus.emit(events.status, error, status);
                    });
            } else {
                var connectEmitted = false;
                gatewayConnection = gateway.connect(
                  self.schema,
                  self.identity,
                  true,
                  function (error, snapshot, updates) {
                      if (typeof snapshot !== 'undefined') {
                          model.applySnapshot(snapshot);
                      }

                      if (typeof updates !== 'undefined') {
                          model.applyUpdates(updates);
                      }

                      if (!connectEmitted) {
                          connectEmitted = true;
                          bus.emit(events.connect, error);
                      }
                  },

                  function (error, status) {
                      var LISTEN_NOT_SUPPORTED = 8;
                      if (status.code === LISTEN_NOT_SUPPORTED) {
                          pollingIntervalId = setInterval(function () {
                              gateway.disconnect(gatewayConnection);
                              gatewayConnection = gateway.connect(self.schema, self.identity, false, function (error, snapshot) {
                                  model.applySnapshot(snapshot, false);
                              });
                          }, 2000);
                      }
                  });
            }
        }

        if (error) {
            setTimeout(bus.emit, 0, events.connect, error);
            throw new Error(error);
        }

        return subscription;

    };

    self.props = function (section, separator) {
        return root.props(section, separator);
    };

    self.modify = function (modifications, callback, scope) {
        if (typeof modifications === 'object') {
            modifications = [modifications];
        }

        var subscription = bus.on(events.update, true, callback, scope);

        return subscription;
    };

    self.onConnect = function (callback, scope) {
        return bus.on(events.connect, false, callback, scope);

    };

    self.onDisconnect = function (callback, scope) {
        return bus.on(events.disconnect, false, callback, scope);
    };

    self.off = function (subscription) {
        if (subscription) {
            bus.off(subscription);
        }
    };

    self.on = function (subscription) {
        if (subscription) {
            bus.resume(subscription);
        }
    };

    self.disconnect = function (callback, scope) {
        if (_.isFunction(callback)) {
            bus.on(events.disconnect, true, callback, scope);
        }

        clearPollingInterval();
        if (typeof gateway !== 'undefined') {
            gateway.disconnect(gatewayConnection, function (error) {
                bus.emit(events.disconnect, error);
            });

            gateway = undefined;
        } else {
            bus.emit(events.disconnect, 'not connected');
        }
    };
};

AppConfig.prototype.identityEqual = helpers.identityEqual;
AppConfig.prototype.identityToString = helpers.identityToString;

module.exports = function () {
    'use strict';
    return new AppConfig();
};

},{"./gateway":61,"./helpers":62,"./model":63,"./props":64,"./util":65}],61:[function(require,module,exports){
var gatewayConnection = require('tick42-gateway-connection');
var helpers = require('./helpers');
var identityToString = helpers.identityToString;
var PRODUCT = 'appconfig';

var GatewayTransport = function (options) {
    'use strict';
    var connection;
    var dataHandlers = {};
    var statusHandlers = {};
    options = options || {};

    function handleStatusMessage(msg) {
        var handler = statusHandlers[msg.instance];
        if (handler) {
            handler(msg.error, msg.status);
        }
    }

    function handleDataMessage(msg) {
        var schema = msg.schema;
        var schemaHandlers = dataHandlers[schema];
        if (typeof schemaHandlers === 'undefined') {
            return;
        }

        var identityKey = identityToString(msg.identity, true);
        var identityHandlers = schemaHandlers[identityKey];
        if (typeof identityHandlers === 'undefined') {
            return;
        }

        identityHandlers.forEach(function (handler) {
            if (handler) {
                handler(msg.error, msg.snapshot, msg.updates);
            }
        });
    }

    function ensureConnection() {
        if (typeof (connection) === 'undefined') {
            if (typeof options.connection !== 'undefined') {
                connection = options.connection;
            } else {
                connection = gatewayConnection(options.settings, options.custom_connection);
            }
        }
    }

    var dataSubscription;
    var statusSubscription;
    var connect = function (schema, identity, listen, handler, statusHandler) {
        ensureConnection();
        var schemaHandlers = dataHandlers[schema];
        if (typeof schemaHandlers === 'undefined') {
            schemaHandlers = dataHandlers[schema] = {};
        }

        var identityKey = identityToString(identity, true);
        var identityHandlers = schemaHandlers[identityKey];
        if (typeof identityHandlers === 'undefined') {
            identityHandlers = schemaHandlers[identityKey] = [];
        }

        var handlerToRegister;
        var index;
        if (listen) {
            handlerToRegister = handler;
        } else {
            handlerToRegister = function (error, snapshot, updates) {
                handler(error, snapshot, updates);
                delete identityHandlers[index];
            };
        }

        index = identityHandlers.push(handlerToRegister) - 1;

        if (typeof (dataSubscription) === 'undefined') {
            dataSubscription = connection.on(PRODUCT, GatewayTransport.MessageType.DATA, function (msg) {
                handleDataMessage(msg);
            });
        }

        var instance = options.instance;
        statusHandlers[instance] = statusHandler;
        if (typeof (statusSubscription) === 'undefined') {
            statusSubscription = connection.on(PRODUCT, GatewayTransport.MessageType.STATUS, function (msg) {
                handleStatusMessage(msg);
            });
        }

        var msg = {
            schema: schema,
            identity: identity,
            instance: instance,
            listen: listen
        };
        connection.send(PRODUCT, GatewayTransport.MessageType.CONNECT, msg);
        return {
            schema: schema,
            identity: identity,
            listen: listen,
            handler: handler,
            index: index
        };
    };

    var modify = function (schema, identity, modifications) {
        ensureConnection();
        connection.send(PRODUCT, GatewayTransport.MessageType.MODIFY, modifications);
    };

    var disconnect = function (descriptor) {
        var schemaHandlers = dataHandlers[descriptor.schema];
        if (typeof schemaHandlers !== 'undefined') {
            var identityKey = identityToString(descriptor.identity, true);
            var identityHandlers = schemaHandlers[identityKey];
            if (typeof identityHandlers !== 'undefined') {
                var handler = identityHandlers[descriptor.index];
                if (typeof handler !== 'undefined') {
                    var msg = {
                        schema: descriptor.schema,
                        identity: descriptor.identity,
                        instance: options.instance
                    };
                    connection.send(GatewayTransport.MessageType.DISCONNECT, msg);
                    delete identityHandlers[descriptor.index];
                }

                if (identityHandlers.length === 0) {
                    delete schemaHandlers[identityKey];
                }
            }

            if (Object.keys(schemaHandlers).length === 0) {
                delete dataHandlers[descriptor.schema];
            }
        }

        if (Object.keys(dataHandlers).length === 0) {
            if (typeof (dataSubscription) !== 'undefined') {
                connection.off(dataSubscription);
            }
        }

        delete statusHandlers[descriptor.instance];
        if (Object.keys(statusHandlers).length === 0) {
            if (typeof statusSubscription !== 'undefined') {
                connection.off(statusSubscription);
            }
        }
    };

    return {
        connect: connect,
        modify: modify,
        disconnect: disconnect
    };
};

GatewayTransport.MessageType = {
    // { schema: 'ApplicationConfiguration', identity: {}, listen: true, instance: '' }
    CONNECT: 'connect',
    // { schema: 'ApplicationConfiguration', identity: {}, instance: '' }
    DISCONNECT: 'disconnect',
    // { schema: 'ApplicationConfiguration', identity: {}, updates: [], instance: '' }
    MODIFY: 'modify',
    // { schema: 'ApplicationConfiguration', identity: {}, error: '', snapshot: {defaultKeyValue: '', keys: [], props: {}}, updates: [] }
    DATA: 'data',
    // { schema: 'ApplicationConfiguration', identity: {}, instance: '', status: '', error: '' }
    STATUS: 'status'
};

module.exports = GatewayTransport;

},{"./helpers":62,"tick42-gateway-connection":67}],62:[function(require,module,exports){
function escapeIdentityText(text) {
    'use strict';
    if (typeof text === 'string') {
        return text.replace(/[\\]/g, '\\\\').replace(/[:]/g, '\\:');
    } else {
        return text;
    }
}

function identityToString(identity, includeKeys, separator, order) {
    'use strict';
    if (typeof (identity) === 'undefined') {
        return null;
    }

    separator = separator || '/';
    var keys = Object.keys(identity);
    if (typeof (order) === 'function') {
        keys.sort(order);
    } else {
        keys.sort();
    }

    return keys.map(function (key) {
        return includeKeys ? (escapeIdentityText(key) + ':' + escapeIdentityText(identity[key])) : identity[key];
    }).join(separator);
}

function identityEqual(identity1, identity2) {
    'use strict';
    return identityToString(identity1, true) === identityToString(identity2, true);
}

function flatten(props, separator, name) {
    'use strict';
    separator = separator || '.';
    var prefix = name ? name + separator : '';
    var val = {};
    Object.keys(props).forEach(function (key) {
        if (key.indexOf(prefix) !== 0) {
            return;
        }

        var path = key.substring(prefix.length);
        var target = val;
        var parts = path.split(separator);
        var i;
        for (i = 0; i < parts.length - 1; i++) {
            if (!target[parts[i]]) {
                target[parts[i]] = {};
            }

            target = target[parts[i]];
        }

        target[parts[i]] = props[key].value;
    });

    return val;
}

function propEqual(lhs, rhs) {
    'use strict';
    if (lhs.value !== rhs.value) {
        return false;
    }

    for (var i = 0; i < lhs.underlying.length; i++) {
        var lhsUnderlying = lhs.underlying[i];
        var rhsUnderlying = rhs.underlying[i] || {};
        if (lhsUnderlying.value !== rhsUnderlying.value || !identityEqual(lhsUnderlying.parent, rhsUnderlying.parent)) {
            return false;
        }
    }

    return true;
}

module.exports = {
    flatten: flatten,
    propEqual: propEqual,
    identityToString: identityToString,
    identityEqual: identityEqual
};

},{}],63:[function(require,module,exports){
var propEqual = require('./helpers').propEqual;

var UpdateType = {
    Added: 'Added',
    Changed: 'Changed',
    Removed: 'Removed'
};

var Model = function (bus, separator) {
    'use strict';
    this.bus = bus;
    this.root = new ViewModel(this, '', separator || '.');
    this.views = {};
};

var ViewModel = function (model, path, separator) {
    'use strict';
    var self = this;
    self.model = model;
    self.props = {};
    self.separator = separator || model.separator;
    self.path = path;
};

ViewModel.prototype.getViewModel = function (name, separator) {
    'use strict';
    var path = this.path + name + (separator ? separator : '.');
    var model = this.model;
    if (path === '') {
        return model.root;
    }

    if (!model.views[path]) {
        var bestParent = '';
        // fill subview references and choose best parent props to copy from.
        Object.keys(model.views).forEach(function (key) {
            if (path.indexOf(key) === 0) {
                if (bestParent.length < key.length) {
                    bestParent = key;
                }
                // keep subviews sorted.
                var subviews = model.views[key].subviews;
                for (var i = 0; i < subviews.length; i++) {
                    if (subviews[i].indexOf(path)) {
                        subviews.splice(i, 0, path);
                        return;
                    }
                }

                subviews.push(path);
            }
        });

        var viewModel = new ViewModel(model, path, separator);

        var parentProps = bestParent === '' ? model.root.props : model.views[bestParent].model.props;
        Object.keys(parentProps).forEach(function (key) {
            var prop = parentProps[key];
            if (prop.name.indexOf(path) === 0) {
                var name = prop.name.substring(path.length);
                viewModel.props[name] = prop;
            }
        });

        model.views[path] = {
            subviews: [],
            model: viewModel
        };
    }

    return model.views[path].model;
};

ViewModel.prototype.on = function (callback, scope) {
    'use strict';
    return this.model.on(this.path, callback, scope);
};

Model.prototype.on = function (path, callback, scope) {
    'use strict';
    var type = updateTypeForPath(path);
    return this.bus.on(type, false, callback, scope);
};

Model.prototype.applySnapshot = function (snapshot, isSnapshot) {
    'use strict';
    isSnapshot = typeof isSnapshot === 'undefined' ? true : isSnapshot;

    var updates = toUpdates(isSnapshot ? {} : this.root.props, snapshot.props);
    applyUpdatesAndEmitEvents(this, updates, isSnapshot);
};

function updateTypeForPath(path) {
    'use strict';
    var type = 'update';
    if (path !== '') {
        type = type + '|' + path;
    }

    return type;
}

// shallow copy
function cloneUpdateForPath(update, path) {
    'use strict';
    var clone = {
        type: update.type,
        name: update.name.substring(path.length)
    };

    switch (update.type) {
        case UpdateType.Changed:
            clone.oldValue = update.oldValue;
            clone.value = update.value;
            break;
        case UpdateType.Added:
            clone.value = update.value;
            break;
        case UpdateType.Removed:
            break;
        default:
            break;
    }
    return clone;
}

function applyUpdatesAndEmitEvents(model, updates, isSnapshot) {
    'use strict';
    var views = Object.keys(model.views);
    var effectiveUpdates = { '': updates };
    if (views.length > 0) {
        // sort views for prefix search
        if (views.length > 1) {
            views.sort();
        }

        updates.forEach(function (update) {
            var view;
            for (var i = 0; i < views.length; views++) {
                if (update.name.indexOf(views[i]) === 0) {
                    view = views[i];
                    break;
                }
            }

            if (typeof view === 'undefined') {
                return;
            }

            effectiveUpdates[view].push(cloneUpdateForPath(update, view));
        });
    }

    var affectedPaths = Object.keys(effectiveUpdates);
    if (affectedPaths.length > 1) {
        affectedPaths.sort();
    }

    affectedPaths.forEach(function (path) {
        var viewModel = path === '' ? model.root : model.views[path].model;
        if (isSnapshot) {
            viewModel.props = {};
        }

        effectiveUpdates[path].forEach(function (update) {
            switch (update.type) {
                case UpdateType.Added:
               // break omitted
                case UpdateType.Changed:
                // changed works even for missing properties
                    viewModel.props[update.name] = update.value;
                    break;
                case UpdateType.Removed:
                    delete viewModel.props[update.name];
                    break;
                default:
                // do nothing
                    break;
            }
        });
    });

    affectedPaths.forEach(function (path) {
        var type = updateTypeForPath(path);
        model.bus.emit(type, isSnapshot, updates);
    });
}

Model.prototype.applyUpdates = function (updates) {
    'use strict';
    applyUpdatesAndEmitEvents(this, updates, false);
};

function toUpdates(image, snapshot) {
    'use strict';
    snapshot = snapshot || {};
    var updates = [];
    var toDelete = Object.keys(image);
    Object.keys(snapshot).forEach(function (key) {
        var update = {};
        if (typeof image[key] === 'undefined') {
            update.type = UpdateType.Added;
        } else {
            if (!propEqual(image[key], snapshot[key])) {
                update.type = UpdateType.Changed;
                update.oldValue = image[key];
            }

            var indexToDelete;
            for (indexToDelete = 0; indexToDelete < toDelete.length; toDelete++) {
                if (toDelete[indexToDelete] === key) {
                    break;
                }
            }

            if (typeof toDelete[indexToDelete] !== 'undefined') {
                toDelete.splice(indexToDelete, 1);
            }
        }

        if (update.type) {
            update.value = snapshot[key];
            update.name = key;
            updates.push(update);
        }
    });

    toDelete.forEach(function (key) {
        updates.push({
            type: UpdateType.Removed,
            name: key
        });
    });

    return updates;
}

module.exports = Model;

},{"./helpers":62}],64:[function(require,module,exports){
var flatten = require('./helpers').flatten;

var Props = function (model) {
    'use strict';
    var prop = function (name) {
        return model.props[name];
    };

    var val = function val(name) {
        if (typeof name === 'undefined' || typeof model.props[name] === 'undefined') {
            return flatten(model.props, model.separator, name);
        }

        return model.props[name].value;
    };

    var props = function (section, separator) {
        section = section || '';
        if (section === '') {
            // TODO: support separator change for '' (same) section.
            return self;
        }

        separator = separator || model.separator;
        return new Props(model.getViewModel(section, separator));
    };

    var forEach = function (callback, scope) {
        Object.keys(model.props).forEach(function (key) {
            callback.call(scope, model.props[key]);
        });
    };

    var onUpdate = function (callback, scope) {
        model.on(callback, scope);
    };

    var self = {
        prop: prop,
        val: val,
        props: props,
        forEach: forEach,
        onUpdate: onUpdate
    };
    return self;
};

module.exports = Props;

},{"./helpers":62}],65:[function(require,module,exports){
var uuid = function () {
    'use strict';
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : ((r & 0x3) | 0x8);
        return v.toString(16);
    });
};

var isFunction = function (value) {
    'use strict';
    if (value === undefined || value === null) {
        return false;
    }

    return typeof value === 'function';
};

var isString = function (value) {
    'use strict';
    return typeof value === 'string';
};

var levels = {
    debug: 'debug',
    info: 'info',
    warn: 'warn',
    error: 'error'
};
var log = function (level, args) {
    'use strict';
    if (console) {
        var logger = console[level];
        if (isFunction(logger)) {
            var now = new Date();
            [].splice.call(args, 0, 0, now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds());
            logger.apply(console, args);
        }
    }
};

var info = function () {
    'use strict';
    log(levels.info, arguments);
};

var warn = function () {
    'use strict';
    log(levels.warn, arguments);
};

var debug = function () {
    'use strict';
    log(levels.debug, arguments);
};

module.exports = {
    uuid: uuid,
    isFunction: isFunction,
    isString: isString,
    log: log,
    warn: warn,
    info: info,
    debug: debug
};

},{}],66:[function(require,module,exports){
var callbackRegistry = require('callback-registry');
var packageJson = require('../package.json');

/**
 * A template for gateway connections - this is extended from specific protocols and transports.
 */
module.exports = function (settings) {
    'use strict';
    // The message handlers that have to be executed for each received message
    var messageHandlers = {};
    var ids = 0;
    var registry = callbackRegistry();

    return {
        _connected : false,

        // assembles a new message to be sent to gateway,
        // this should be replaced from concrete gateway connection
        _createMessage: function(type, message, id) {
            throw new Error('Not implemented - you should extend the connection with protocol ' + type + message + id);
        },

        // processes a new message calling the distribute method,
        // this should be replaced from concrete if they have different message structure
        _processMessage: function(message) {
            throw new Error('Not implemented - you should extend the connection with protocol ' + message);
        },

        // Executes appropriate message handlers for the message type.
        _distributeMessage: function (message, type) {
            // Retrieve handlers for the message type
            var handlers = messageHandlers[type.toLowerCase()];
            if (handlers !== undefined) {
                // Execute them
                Object.keys(handlers).forEach(function (handlerId) {
                    var handler = handlers[handlerId];
                    if (handler !== undefined) {
                        handler(message);
                    }
                });
            }
        },

        // triggers connection change notifying all users
        _triggerConnectionChanged: function(connected) {
            this._connected = connected;

            if (connected) {
                registry.execute('connected');
            } else {
                registry.execute('disconnected');
            }
        },

        // Attaches a handler
        on: function (product, type, messageHandler) {
            type = type.toLowerCase();
            if (messageHandlers[type] === undefined) {
                messageHandlers[type] = {};
            }

            var id = ids++;
            messageHandlers[type][id] = messageHandler;

            return {
                type: type,
                id: id
            };
        },

        // Remove a handler
        off: function (info) {
            delete messageHandlers[info.type.toLowerCase()][info.id];
        },

        connected: function (callback) {
            if (this._connected) {
                callback(settings.ws || settings.http);
            }

            registry.add('connected', callback);
        },

        disconnected: function (callback) {
            registry.add('disconnected', callback);
        },

        login: function() {
            return true;
        },

        logout: function() {
            return true;
        },

        // Init function that will be called after successful login
        init: function() {
            return true;
        },

        protocolVersion : settings.protocolVersion || 1,

        version: packageJson.version
    }
};


},{"../package.json":75,"callback-registry":4}],67:[function(require,module,exports){
(function (global){
var baseConnection = require('./connection');

/**
 * Check readme.md for detailed description
 */
var connection = function (settings, customConnection) {
    'use strict';
    settings = settings || {};
    var connection = baseConnection(settings);

    // if running in HC we use gw1 protocol and hc transport
    if (global.htmlContainer !== undefined) {
        connection = require('./protocols/gw1')(connection, settings);
        return require('./transports/hc')(connection, settings);
    }

    // if running in the browser - let's check which protocol version user wants
    if (settings.protocolVersion === 3) {
        connection = require('./protocols/gw3')(connection, settings);
    } else if (settings.protocolVersion === 2) {
        connection = require('./protocols/gw2')(connection, settings);
    } else {
        connection = require('./protocols/gw1')(connection, settings);
    }

    if (settings.ws !== undefined) {
        return require('./transports/ws')(connection, settings);
    } else if (settings.http !== undefined) {
        return require('./transports/http')(connection, settings);
    } else if (customConnection !== undefined) {
        return require('./transports/mock')(connection, customConnection, settings);
    } else {
        throw new Error('No connection. Make sure you are running the application from Tick42 HtmlContainer or fill the \'connection.websocket_url\' property.');
    }
};

if (global.tick42 === undefined) {
    global.tick42 = {};
}

global.tick42.connection = connection;

module.exports = connection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./connection":66,"./protocols/gw1":68,"./protocols/gw2":69,"./protocols/gw3":70,"./transports/hc":71,"./transports/http":72,"./transports/mock":73,"./transports/ws":74}],68:[function(require,module,exports){
// Connection to gateway V1 - the one that runs on the desktop without authentication
var Promise = require('es6-promise').Promise;

module.exports = function(connection) {
    'use strict';

    connection._processMessage = function(message) {
        message = JSON.parse(message);
        connection._distributeMessage(message.message, message.type);
    };

    connection._createMessage = function(type, message, id) {
        return JSON.stringify({
            type: type,
            message: message,
            id: id
        });
    };

    connection.login = function() {
        return new Promise(function(resolve) {
            resolve();
        });
    };
    return connection;
};

},{"es6-promise":9}],69:[function(require,module,exports){
// Connection to gateway V2 - gw1 +  authentication
var Promise = require('es6-promise').Promise;

module.exports = function(connection) {
    'use strict';

    var sessionCookie;
    connection._processMessage = function(message) {
        message = JSON.parse(message);
        var dataType = message.type;

        if (dataType === 'SEND')  {
            message = message.data;
            connection._distributeMessage(message.message, message.type);
        } else {
            connection._distributeMessage(message, message.type);
        }
    };

    connection._createMessage = function(type, message, id) {
        if (type === 'LOGIN') {
            return JSON.stringify(message);
        }

        if (type === 'LOGOUT') {
            return JSON.stringify({ type: 'LOGOUT' });
        }

        return JSON.stringify({
            type: 'SEND',
            sessionCookie: sessionCookie,
            data: {
                type: type,
                message: message,
                id: id
            }
        });
    };

    connection.login = function(message) {
        return new Promise(function(resolve, reject) {
            var request;
            if (message.token) {
                request = {
                    token: message.token,
                    type: 'LOGIN_TOKEN'
                };
            } else if (message.username) {
                request = {
                    user: message.username,
                    password: message.password,
                    type: 'LOGIN'
                };
            } else {
                throw new Error('invalid auth message' + JSON.stringify(message));
            }

            var lrSubs = connection.on('', 'LOGIN_RESPONSE', function (response) {
                connection.off(lrSubs);

                if (response && !response.errorMessage) {
                    sessionCookie = response.sessionCookie;
                    resolve(response);
                } else {
                    reject(response);
                }
            });

            connection.send('', 'LOGIN', request);
        });
    };

    connection.logout = function() {
        connection.send('', 'LOGOUT');
    };

    return connection;
};


},{"es6-promise":9}],70:[function(require,module,exports){
var shortid = require('shortid');
var Promise = require('es6-promise').Promise;
var URLSearchParams = require('url-search-params');

module.exports = function(connection, settings) {
    'use strict';
    var datePrefix = '#T42_DATE_';
    var datePrefixLen = datePrefix.length;
    var dateMinLen = datePrefixLen + 1;// prefix + at least one char (1970/01/01 = 0)
    var datePrefixFirstChar = datePrefix[0];

    connection.instance = shortid.generate();

    connection._processMessage = function(message) {
        message = JSON.parse(message, function(key, value) {
            if (typeof key !== 'string') {
                return value;
            }
            if (key[0] !== datePrefixFirstChar) {
                return value;
            }
            if (value.length < dateMinLen) {
                return value;
            }
            var milliseconds = parseInt(value.substring(datePrefixLen, value.length), 10);
            if (isNaN(milliseconds)) {
                return value;
            }
            return new Date(milliseconds);
        });
        connection._distributeMessage(message, message.type);
    };

    connection._createMessage =  function(type, message) {
        return JSON.stringify(message, function (key, value) {
            // serialize dates as #T42_DATE(<MILLISECONDS_FROM_1970_01_01>)

            if (value === null || typeof value !== 'object') {
                return value;
            }
            // some duck typing
            if (!value.getTime) {
                return value;
            }

            if (!(value instanceof Date)) {
                return value;
            }

            return datePrefix + value.getTime();
        });
    };

    connection.login = function(message) {
        return new Promise(function(resolve, reject) {
            var authentication = {};
            var gwToken = getGatewayToken();
            if (gwToken) {
                authentication.method = 'gateway-token';
                authentication.token = gwToken;
            } else if (message.token) {
                authentication.method = 'access-token';
                authentication.token = message.token;
            } else if (message.username) {
                authentication.method = 'secret';
                authentication.user = message.username;
                authentication.secret = message.password;
            } else {
                throw new Error('invalid auth message' + JSON.stringify(message));
            }

            var requestId = shortid.generate();
            var helloMsg = {
                request_id: requestId,
                type: 'hello',
                identity: { application: settings.application, instance: connection.instance },
                authentication: authentication
            };

            var welcomeSub = connection.on('', 'welcome', function (msg) {
                if (msg.request_id !== requestId) {
                    return;
                }

                connection.off(welcomeSub);
                connection.off(errorSub);
                connection.peerId = msg.peer_id;
                connection.gwToken = gwToken;
                resolve(msg);
            });

            var errorSub = connection.on('', 'error', function (msg) {
                if (msg.request_id !== requestId) {
                    return;
                }

                connection.off(errorSub);
                connection.off(welcomeSub);
                reject(msg);
            });

            connection.send('', 'LOGIN', helloMsg);
        });
    };

    connection.logout = function() {
        connection.send('', 'LOGOUT');
    };

    function getGatewayToken() {
        if (settings.gwTokenProvider) {
            return settings.gwTokenProvider.get();
        }

        if (location && location.search) {
            var searchParams = new URLSearchParams(location.search.slice(1));
            return searchParams.get('t42gwtoken');
        }

        return null;
    }

    return connection;
};


},{"es6-promise":9,"shortid":11,"url-search-params":127}],71:[function(require,module,exports){
(function (global){
/**
 * Connection to HtmlContainer
 */
module.exports = function (connection) {
    'use strict';
    var connectionId = Math.floor(1e10 * Math.random()).toString();
    // Route messages to facade(s)
    connection.send = function (product, type, message) {
        if (product === 'metrics') {
            global.htmlContainer.metricsFacade.send(type, JSON.stringify(message));
        } else if (product === 'log') {
            global.htmlContainer.loggingFacade.send(type, JSON.stringify(message));
        } else if (product === 'appconfig') {
            global.htmlContainer.appConfigFacade.send(type, JSON.stringify(message), connectionId);
        }
    };

    if (global.htmlContainer.appConfigFacade !== undefined) {
        global.htmlContainer.appConfigFacade.initConnection(
            connectionId,
            function (messageAsJson) {
                return connection._handle_message(JSON.parse(messageAsJson));
            });
    }

    global.connections = global.connections || {};
    // Expose function for sending messages:
    global.connections['connection' + connectionId] = connection._handle_message;

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],72:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
    'use strict';
    var url = settings.http;
    // polling interval in ms, default is 1 second
    var interval = settings.http_interval_ms;
    if (!interval) {
        interval = 1000;
    }

    function logDebug(message) {
        if (global.console !== undefined && (settings.debug === true || settings.trace === true)) {
            console.log(message);
        }
    }

    function logTrace(message) {
        if (global.console !== undefined && settings.trace === true) {
            console.log(message);
        }
    }

    logDebug('Attemping to connect to Gateway via HTTP with url \'' + url + '\' and polling interval ' + interval + ' ms');

    connection.init = function() {
        poll(url, interval, 0, function (items) {
            for (var index = 0; index < items.length; index++) {
                connection._processMessage(items[index]);
            }
        });
    }

    connection.send = function (product, type, message, id) {
        var msg = connection._createMessage(type, message, id);
        httpPost(url, msg);
    };

    /**
     * Polls data from a given url on some interval
     * @param url       Base server url. A sequence url param may be added based on the seq param
     * @param interval  Interval (in ms) between polling requestts
     * @param seq       Next sequence number we should ask for (if 0 the server will return the last known message)
     * @param ondata    Data callback
     */
    function poll(url, interval, seq, ondata) {
        // construct the get Url - if seq != 0 add as url param to get
        // only messages after this sequence
        var getUrl = url;

        if (seq !== 0) {
            getUrl = url + '?sequence=' + seq + '&no-cache=' + new Date().getTime();
        }

        // create a request
        var xmlhttp = createCORSRequest('GET', getUrl, function () {
            if (seq === 0) {
                logDebug('Connected to Gateway on ' + url);
            }

            logTrace('Response from \'' + getUrl + '\' is ' + xmlhttp.responseText);
            var message = JSON.parse(xmlhttp.responseText);
            // the server returns the number of the next sequence that we must query for
            var nextSeq = message.nextSequence;
            // call user callbacke
            ondata(message.data);
            // re-schedule
            setTimeout(function () {
                poll(url, interval, nextSeq, ondata);
            }, interval);
        });

        xmlhttp.onerror = function (ev) {
            console.log('Error polling data from http server \'' + getUrl + '\' - ' + ev);
            // re-schedule
            setTimeout(function () {
                poll(url, interval, seq, ondata);
            }, interval);
        };

        logTrace('Sending GET to \'' + getUrl + '\'');
        xmlhttp.send();
    }

    /**
     * POSTs a message to a given url
     */
    function httpPost(url, message) {
        // create a request
        var xmlhttp = createCORSRequest('POST', url);
        logTrace('Sending POST to \'' + url + '\' : ' + message);
        xmlhttp.send(message);
    }

    /**
     * Creates CORS request (cross domain requests) for different browsers - XMLHttpRequest withCredentials
     * for Chrome and FF and XDomainRequest for IE
     */
    function createCORSRequest(method, url, resultCallback) {
        var xhr = new XMLHttpRequest();

        if ('withCredentials' in xhr) {
            // Check if the XMLHttpRequest object has a "withCredentials" property.
            // "withCredentials" only exists on XMLHTTPRequest2 objects.
            xhr.open(method, url, true);
            if (typeof resultCallback !== 'undefined') {
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        resultCallback();
                    }
                };
            }
        } else if (typeof XDomainRequest !== 'undefined') {
            // Otherwise, check if XDomainRequest.
            // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
            xhr = new XDomainRequest();
            xhr.open(method, url);
            if (typeof resultCallback !== 'undefined') {
                xhr.onload = resultCallback;
            }
        } else {
            // Otherwise, CORS is not supported by the browser.
            xhr = null;
        }

        return xhr;
    }

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],73:[function(require,module,exports){
/**
 * Used for tests
 */
module.exports = function(connection, customConnection) {
    'use strict';
    connection.send = function (product, type, message) {
        customConnection.publish({
            type: type,
            message: message
        });
    };

    customConnection.subscribe(connection._handle_message);
    return connection;
};

},{}],74:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
    'use strict';

    // Load the 'ws' library, but only if we are running under node js
    var WebSocket = require('detect-node') ? require('ws') : global.WebSocket;

    function initiateSocket() {
        var ws = new WebSocket(settings.ws);
        ws.onclose = function () {
            connection._triggerConnectionChanged(false);
        };
        // Log on connection
        ws.onopen = function () {
            connection._triggerConnectionChanged(true);
        };
        // Attach handler
        ws.onmessage = function (message) {
            connection._processMessage(message.data);
        };

        return ws;
    }

    // Holds callback execution until socket connection is established.
    function waitForSocketConnection (callback) {
        if (!callback) {
            return;
        }

        if (socket.readyState === 1) {
            return callback();
        } else if (socket.readyState > 1) {
            // > 1 means closing or closed
            socket = initiateSocket();
        }

        setTimeout(function () {
            waitForSocketConnection(callback);
        }, 50); // wait 5 milliseconds for the connection...
    }

    // Initiate a new socket (this gets re-executed on reconnect)
    var socket = initiateSocket();

    // Create a function for sending a message
    connection.send = function (product, type, message, id) {
        waitForSocketConnection(function() {
            var msg = connection._createMessage(type, message, id);
            if (!msg) {
                return;
            }
            socket.send(msg);
        });
    };

    connection.websocket_url = function (a) {
        settings.websocket_url = a;
        socket.close();
        socket = initiateSocket();
    };

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-node":6,"ws":129}],75:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-gateway-connection@>=1.3.2",
      "C:\\work\\stash\\GLUE-dev\\dev\\js-glue\\node_modules\\tick42-appconfig"
    ]
  ],
  "_from": "tick42-gateway-connection@>=1.3.2",
  "_id": "tick42-gateway-connection@2.1.4",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-appconfig/tick42-gateway-connection",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-gateway-connection",
    "raw": "tick42-gateway-connection@>=1.3.2",
    "rawSpec": ">=1.3.2",
    "scope": null,
    "spec": ">=1.3.2",
    "type": "range"
  },
  "_requiredBy": [
    "/tick42-appconfig"
  ],
  "_shasum": "cecf52da785b3d0b528dce1e10c19fad5168065f",
  "_shrinkwrap": null,
  "_spec": "tick42-gateway-connection@>=1.3.2",
  "_where": "C:\\work\\stash\\GLUE-dev\\dev\\js-glue\\node_modules\\tick42-appconfig",
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "dependencies": {
    "browserify-versionify": "^1.0.4",
    "callback-registry": "^1.0.1",
    "detect-node": "^2.0.3",
    "es6-promise": "^3.2.1",
    "shortid": "^2.2.6",
    "url-search-params": "^0.5.0",
    "ws": "^0.7.2"
  },
  "description": "Tick42 Gateway Connection.",
  "devDependencies": {
    "blanket": "^1.1.6",
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "fs": "0.0.2",
    "jsdom": "^8.1.0",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "shelljs": "^0.6.0"
  },
  "dist": {
    "shasum": "cecf52da785b3d0b528dce1e10c19fad5168065f",
    "tarball": "http://192.168.0.234:4873/tick42-gateway-connection/-/tick42-gateway-connection-2.1.4.tgz"
  },
  "gitHead": "4ddd1de82628d82b3f96467690925610fc1547af",
  "main": "library/main.js",
  "name": "tick42-gateway-connection",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "readmeFilename": "readme.md",
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix ",
    "prepublish": "npm update & npm run build",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "watch": "onchange \"./library/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "version": "2.1.4"
}

},{}],76:[function(require,module,exports){
function createBridge() {
    'use strict';

    return {};
}

module.exports = createBridge;

},{}],77:[function(require,module,exports){
function createBridge() {
    'use strict';
    var facade = htmlContainer.sharedContextFacade;

    function all() {
        var allObj = facade.all();
        if (!allObj || !allObj.keys) {
            return [];
        }
        return allObj.keys;
    }

    function update(name, data) {
        return facade.update(name, data);
    }

    function set(name, data) {
        facade.set(name, data);
    }

    function subscribe(name, callback) {
        return facade.subscribe(name, callback);
    }

    function unsubscribe(key) {
        facade.unsubscribe(key);
    }

    return {
        all: all,
        update: update,
        set: set,
        subscribe: subscribe,
        unsubscribe: unsubscribe
    };
}

module.exports = createBridge;



},{}],78:[function(require,module,exports){
var PackageJson = require('../package.json');
var hcBridge = require('./bridges/hc.js');
var gwBridge = require('./bridges/gw.js');

function contexts(config) {
    'use strict';
    var bridge = getBridge(config);

    function getBridge(config) {
        if (typeof htmlContainer !== 'undefined') {
            if (!htmlContainer.sharedContextFacade) {
                return 'Your version of HtmlContainer does not support contexts. Get version 1.46.0.0 or later to have that feature.';
            }
            return hcBridge(config);
        }
        return gwBridge(config);
    }

    function all() {
        return bridge.all();
    }

    function update(name, data) {
        return bridge.update(name, data);
    }

    function set(name, data) {
        return bridge.set(name, data);
    }

    function subscribe(name, callback) {
        return bridge.subscribe(name, callback);
    }

    function unsubscribe(key) {
        bridge.unsubscribe(key);
    }

    // bridge being a string means the initializtion failed and there is some error in that string
    if (typeof bridge === 'string') {
        return {
            error: bridge,
            version: PackageJson.version
        };
    }

    return {
        all: all,
        update: update,
        set: set,
        subscribe: subscribe,
        unsubscribe: unsubscribe,
        version: PackageJson.version
    };
}

module.exports = contexts;

},{"../package.json":79,"./bridges/gw.js":76,"./bridges/hc.js":77}],79:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-contexts@0.0.2",
      "C:\\work\\stash\\GLUE-dev\\js-glue"
    ]
  ],
  "_from": "tick42-contexts@0.0.2",
  "_id": "tick42-contexts@0.0.2",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-contexts",
  "_nodeVersion": "5.3.0",
  "_npmUser": {},
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-contexts",
    "raw": "tick42-contexts@0.0.2",
    "rawSpec": "0.0.2",
    "scope": null,
    "spec": "0.0.2",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "http://192.168.0.234:4873/tick42-contexts/-/tick42-contexts-0.0.2.tgz",
  "_shasum": "af038bb59ec4309129f392e763b4b55274ceee5e",
  "_shrinkwrap": null,
  "_spec": "tick42-contexts@0.0.2",
  "_where": "C:\\work\\stash\\GLUE-dev\\js-glue",
  "author": {
    "name": "Tick42"
  },
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "dependencies": {
    "tick42-gateway-connection": ">=1.1.9"
  },
  "description": "A library for shared contexts",
  "devDependencies": {
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2"
  },
  "dist": {
    "shasum": "af038bb59ec4309129f392e763b4b55274ceee5e",
    "tarball": "http://192.168.0.234:4873/tick42-contexts/-/tick42-contexts-0.0.2.tgz"
  },
  "gitHead": "ad0ff4156b209cdeb0b8553ff0b3daa33585f76d",
  "license": "ISC",
  "main": "library/main.js",
  "name": "tick42-contexts",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "https://kpopov@stash.tick42.com/scm/tg/js-contexts.git"
  },
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix",
    "prepublish": "npm update & npm run build",
    "watch": "onchange \"./library/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "version": "0.0.2"
}

},{}],80:[function(require,module,exports){
(function (global){
var PackageJson = require("../package.json");
var connection = function (settings, custom_connection){
  settings = settings || {};
  //The message handlers that have to be executed for each received message
  var message_handlers = {};

  var ids = 0;

  var connection = {
    //Executes appropriate message handlers for the message type.
    _handle_message: function (message) {
      //Retrieve handlers for the message type
      var handlers = message_handlers[message.type];
      if (handlers !== undefined) {
        //Execute them
        Object.keys(handlers).forEach(function (handler_id) {
          var handler = handlers[handler_id];
          if (handler !== undefined) {
            handler(message.message);
          }
        });
      }
    },
    //Attaches a handler
    on: function (product, type, message_handler) {
      if (message_handlers[type] === undefined) {
        message_handlers[type] = {};
      }
      var id = ids++;
      message_handlers[type][id]= message_handler;

      return {
        type:type,
        id:id
      };
    },
    //Remove a handler
    off: function (info) {
      delete message_handlers[info.type][info.id];
    },
    //Dummy functions for transports that are always connected
    connected: function (a) {a();},
    disconnected: function () {},
    version: PackageJson.version
  };

  function create_custom_connection (connection) {
    connection.send = function (product, type, message) {
      custom_connection.publish({
        type:type,
        message:message
      });
    };
    custom_connection.subscribe(connection._handle_message);
    return connection;
  }

  if (settings.websocket_url !== undefined) {
    return require("./ws")(connection, settings);
  } else if (settings.http_url !== undefined) {
    return require("./http")(connection, settings);
  } else if (global.fin !== undefined) {
    return require("./fin")(connection, settings);
  } else if (custom_connection !== undefined) {
    return create_custom_connection(connection, settings);
    //Connect via HTML Container facade
  } else if (global.htmlContainer !== undefined) {
    return require("./cont")(connection, settings);
  } else {
    throw "No connection. Make sure you are running the application from OpenFin, or Tick42 HTML Container or fill the 'connection.websocket_url' property.";
  }
};

if (global.tick42 === undefined) {
  global.tick42 = {};
}
global.tick42.connection = connection;

module.exports = connection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":85,"./cont":81,"./fin":82,"./http":83,"./ws":84}],81:[function(require,module,exports){
(function (global){
module.exports = function (connection) {
  var connection_id = Math.floor(1e10 * Math.random()).toString();
  //Route messages to facade(s)
  connection.send = function (product, type, message) {
    if (product === "metrics") {
      global.htmlContainer.metricsFacade.send(type, JSON.stringify(message));
    } else if (product === "log") {
      global.htmlContainer.loggingFacade.send(type, JSON.stringify(message));
    } else if (product === "appconfig") {
      global.htmlContainer.appConfigFacade.send(type, JSON.stringify(message), connection_id);
    }
  };
  if (global.htmlContainer.appConfigFacade !== undefined) {
    global.htmlContainer.appConfigFacade.initConnection(
      connection_id,
      function (messageAsJson) {
        return connection._handle_message(JSON.parse(messageAsJson));
      });
  }
  global.connections = global.connections || {};
  //Expose function for sending messages:
  global.connections['connection'+connection_id] = connection._handle_message;

  return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],82:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
  if (global.console !== undefined && settings.debug === true) {
    console.log("Attemping to connect to Gateway via OpenFin Inter Application Bus.");
  }

  //A function for sending a message
  connection.send = function (product, type, message) {
    fin.desktop.InterApplicationBus.publish("AGM", {type:type, message:message});
  };
  //A function that receives messages
  fin.desktop.InterApplicationBus.subscribe('*','AGM', connection._handle_message);
  if (global.console !== undefined && settings.debug === true){
    console.log("Connected to OpenFin transport.");
  }

  return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],83:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
  var url = settings.http_url;
  // polling interval in ms, default is 1 second
  var interval = settings.http_interval_ms;
  if (!interval) interval = 1000;

  function log_debug (message) {
    if (global.console !== undefined && (settings.debug === true || settings.trace === true)) {
      console.log(message);
    }
  }

  function log_trace (message) {
    if (global.console !== undefined && settings.trace === true) {
      console.log(message);
    }
  }

  log_debug("Attemping to connect to Gateway via HTTP with url '" + url + "' and polling interval " + interval + " ms");

  poll(url, interval, 0, function (items) {
    for (var index = 0; index < items.length; index++) {
      connection._handle_message(items[index]);
    }
  });

  connection.send = function (product, type, message, id) {
    var msg = JSON.stringify({ type: type, message: message, id: id });
    http_post(url, msg);
  };

  /**
   * Polls data from a given url on some interval
   * @param url       Base server url. A sequence url param may be added based on the seq param
   * @param interval  Interval (in ms) between polling requestts
   * @param seq       Next sequence number we should ask for (if 0 the server will return the last known message)
   * @param ondata    Data callback
   */
  function poll (url, interval, seq, ondata) {
    // construct the get Url - if seq != 0 add as url param to get
    // only messages after this sequence
    var getUrl = url;

    if (seq !== 0) {
      getUrl = url + "?sequence=" + seq + "&no-cache=" + new Date().getTime();
    }

    // create a request
    var xmlhttp = createCORSRequest("GET", getUrl, function () {
      if (seq === 0) {
        log_debug("Connected to Gateway on " + url);
      }
      log_trace("Response from '" + getUrl + "' is " + xmlhttp.responseText);
      var message = JSON.parse(xmlhttp.responseText);
      // the server returns the number of the next sequence that we must query for
      var nextSeq = message.nextSequence;
      // call user callbacke
      ondata(message.data);
      // re-schedule
      setTimeout(function () {
        poll(url, interval, nextSeq, ondata);
      }, interval);
    });

    xmlhttp.onerror = function (ev) {
      console.log("Error polling data from http server '" + getUrl + "' - " + ev);
      // re-schedule
      setTimeout(function () {
        poll(url, interval, seq, ondata);
      }, interval);
    };

    log_trace("Sending GET to '" + getUrl + "'");
    xmlhttp.send();
  }

  /**
   * POSTs a message to a given url
   */
  function http_post (url, message) {
    // create a request
    var xmlhttp = createCORSRequest("POST", url);
    log_trace("Sending POST to '" + url + "' : " + message);
    xmlhttp.send(message);
  }

  /**
   * Creates CORS request (cross domain requests) for different browsers - XMLHttpRequest withCredentials
   * for Chrome and FF and XDomainRequest for IE
   */
  function createCORSRequest (method, url, result_callback) {
    var xhr = new XMLHttpRequest();

    if ("withCredentials" in xhr) {
      // Check if the XMLHttpRequest object has a "withCredentials" property.
      // "withCredentials" only exists on XMLHTTPRequest2 objects.
      xhr.open(method, url, true);
      if (typeof result_callback !== "undefined"){
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4 && xhr.status == 200) {
            result_callback();
          }
        };
      }
    } else if (typeof XDomainRequest != "undefined") {
      // Otherwise, check if XDomainRequest.
      // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
      xhr = new XDomainRequest();
      xhr.open(method, url);
      if (typeof result_callback !== "undefined"){
        xhr.onload = result_callback;
      }
    } else {
      // Otherwise, CORS is not supported by the browser.
      xhr = null;
    }
    return xhr;
  }

  return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],84:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
  var connected = false;

  //Load the 'ws' library, but only if we are running under node js
  var WebSocket = require("detect-node") ? require("ws") : global.WebSocket;

  function initiate_socket () {
    if (global.console !== undefined && settings.debug === true) {
      console.log("Attemping to connect to Gateway via WebSocket.");
    }

    var ws = new WebSocket(settings.websocket_url);
    //Add user callbacks
    ws.onclose = function (event) {
      if (typeof settings.disconnected==="function") {
        settings.disconnected(settings.websocket_url, event);
      }
      connected = false;
    };
    //Log on connection
    ws.onopen = function () {
      if (typeof settings.connected==="function") {
        settings.connected(settings.websocket_url);
      }
      if (global.console !== undefined && settings.debug === true) {
        console.log("Connected to WS URL "+settings.websocket_url);
      }
      connected = true;
    };
    //Attach handler
    ws.onmessage = function (message) {
      connection._handle_message(JSON.parse(message.data));
    };
    return ws;
  }

  //Initiate a new socket (this gets re-executed on reconnect)
  var socket = initiate_socket();

  //Create a function for sending a message
  connection.send = function (product, type, message, id) {
    //If we are connected send the message
    if (socket.readyState === 1) {
      socket.send(JSON.stringify({type:type, message:message, id:id}));
      //If we are not connected and we are not attempting to connect right now, attempt to connect
    } else if (socket.readyState !== 0) {
      socket = initiate_socket();
    }
  };

  connection.websocket_url = function (a) {
    settings.websocket_url = a;
    socket.close();
    socket = initiate_socket();
  };

  connection.connected = function (a) {
    if (connected) {
      a(settings.websocket_url);
    }
    settings.connected = a;
  };
  connection.disconnected = function (a) {
    settings.disconnected = a;
  };

  return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-node":6,"ws":129}],85:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-gateway-connection@^1.1.6",
      "C:\\work\\stash\\GLUE-dev\\dev\\js-glue"
    ]
  ],
  "_from": "tick42-gateway-connection@>=1.1.6 <2.0.0",
  "_id": "tick42-gateway-connection@1.3.2",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-gateway-connection",
  "_nodeVersion": "5.3.0",
  "_npmUser": {},
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-gateway-connection",
    "raw": "tick42-gateway-connection@^1.1.6",
    "rawSpec": "^1.1.6",
    "scope": null,
    "spec": ">=1.1.6 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/",
    "/tick42-agm"
  ],
  "_resolved": "http://192.168.0.234:4873/tick42-gateway-connection/-/tick42-gateway-connection-1.3.2.tgz",
  "_shasum": "2a755cbeb72fd4524b0107aa4333d33edc74d10f",
  "_shrinkwrap": null,
  "_spec": "tick42-gateway-connection@^1.1.6",
  "_where": "C:\\work\\stash\\GLUE-dev\\dev\\js-glue",
  "dependencies": {
    "browserify-versionify": "^1.0.4",
    "detect-node": "^2.0.3",
    "ws": "^0.7.2"
  },
  "description": "Tick42 Gateway Connection.",
  "devDependencies": {
    "blanket": "^1.1.6",
    "grunt": "^0.4.5",
    "grunt-browserify": "^3.3.0",
    "grunt-cli": "^0.1.0",
    "grunt-contrib-clean": "^0.6.0",
    "grunt-contrib-connect": "^0.9.0",
    "grunt-contrib-jshint": "^0.11.0",
    "grunt-contrib-qunit": "^0.5.2",
    "grunt-contrib-uglify": "^0.6.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-exorcise": "^1.0.0",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "uglifyify": "^3.0.1"
  },
  "dist": {
    "shasum": "2a755cbeb72fd4524b0107aa4333d33edc74d10f",
    "tarball": "http://192.168.0.234:4873/tick42-gateway-connection/-/tick42-gateway-connection-1.3.2.tgz"
  },
  "gitHead": "1b0f4f73a8aa940afd1263a4050e8e0452a3a02a",
  "main": "library/connection.js",
  "name": "tick42-gateway-connection",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "scripts": {},
  "version": "1.3.2"
}

},{}],86:[function(require,module,exports){
var asciiTable = require('ascii-table');
var tick42Connection = require('tick42-gateway-connection');
var PackageJson = require('../package.json');

var levels = ['trace', 'debug', 'info', 'warn', 'error', 'off'];

function serializePath(path) {
    'use strict';
    return path.length === 0 ? '' : path.join('.');
}

var isConnection = function (c) {
    'use strict';
    return typeof c === 'object' && typeof c.send === 'function' && typeof c.on === 'function';
};

function getLevel(logger, level) {
    'use strict';
    // Retrieves the console or publish level of a logger
    // logger - the logger for which to retrieve the level
    // level - a string which can either be "publishLevel" for retrieving the publish level or "c_level" for retrieving the console level.
    if (logger[level] !== undefined) {
        return logger[level];
    } else if (logger.parent !== undefined) {
        return getLevel(logger.parent, level);
    }
}

function messageToTable(title, rows) {
    'use strict';
    // Display message as table in file
    var keys = getAllKeys(rows);
    // fill rows with message properties
    var tableRows = rows.map(function (obj) {
        return keys.map(function (key) {
            return obj[key];
        });
    });

    var tableMessage = asciiTable.factory({
        title: title,
        heading: keys,
        rows: tableRows
    });
    return tableMessage.toString();
}

function getAllKeys(data) {
    'use strict';
    // Accepts an array of objects and returns an array of all the keys from all objects
    var allKeys = [];

    data.forEach(function (obj) {
        Object.keys(obj).forEach(function (key) {
            if (allKeys.indexOf(key) === -1) {
                allKeys.push(key);
            }
        });
    });

    return allKeys;
}

function logger(configuration) {
    'use strict';
    if (typeof configuration.connection !== 'object') {
        configuration.connection = {};
    }

    // Set debug for the connection module if global debug is set
    configuration.connection.debug = configuration.debug;

    // Init connection
    // Determine if we are given a ready 'connection' object or a configuration.
    var connection = isConnection(configuration.connection) ? configuration.connection : tick42Connection(configuration.connection);

    var idKeys = ['system', 'service', 'instance'];

    // Convert instance to string, throw exceptions if it is not full
    var instanceStr = idKeys.map(function (key) {
        var prop = configuration.identity[key];
        if (typeof prop !== 'string') {
            throw new Error('Please specify "' + key + '" in your identity');
        }

        return prop;
    }).join('/');

    var loggerProto = {
        subLogger: function (name) {
            // Check if the sublogger is already created
            var existingSublogger = this.subloggers.filter(function (subLogger) {
                return subLogger.name === name;
            })[0];

            if (existingSublogger !== undefined) {
                return existingSublogger;
            }

            // Check if the name isn't the same as one of the parent properties
            Object.keys(this).forEach(function (key) {
                if (key === name) {
                    throw new Error('This sub logger name is not allowed.');
                }
            });
            // Check if the name isn't the same as one of the parent methods
            Object.keys(loggerProto).forEach(function (key) {
                if (key === name) {
                    throw new Error('This sub logger name is not allowed.');
                }
            });

            var path = this.path.slice(0);
            path.push(this.name);
            return createLogger(name, path, this);
        },

        publishLevel: function (level) {
            if (level !== null && level !== undefined) {
                this._publishLevel = level;
            }

            return getLevel(this, '_publishLevel');
        },

        consoleLevel: function (level) {
            if (level !== null && level !== undefined) {
                this._consoleLevel = level;
            }

            return getLevel(this, '_consoleLevel');
        },

        metricsLevel: function (level, metricsSystem) {
            if (level !== null && level !== undefined) {
                this._metricLevel = level;
            }

            if (metricsSystem !== undefined) {
                if (typeof metricsSystem === 'object' && typeof metricsSystem.objectMetric === 'function') {
                    this.metricSystem = metricsSystem;
                } else {
                    throw new Error('Please specify metric system ');
                }
            }
        },

        table: function (message) {
            // message must be in an array, to be displayed as table
            if (!Array.isArray(message)) {
                throw new Error('The message must be in an array');
            }

            // Retrieve logger name and levels
            var loggerName = getLoggerName(this);

            // Publish in console
            if (shouldPublish(getLevel(this, '_consoleLevel'), 'info')) {
                console.info(loggerName + ':');
                console.table(message);
            }
            // Publish in file
            if (shouldPublish(getLevel(this, '_publishLevel'), 'info')) {
                connection.send('log', 'LogMessage', {
                    instance: instanceStr,
                    level: levels.indexOf('info'),
                    logger: loggerName,
                    message: messageToTable(loggerName, message)
                });
            }
        },

        log: function (message, level) {
            publishMessage(this, level || 'info', message);
        }
    };

    function createLogger(name, path, parent) {
        var logger = Object.create(loggerProto);
        logger.name = name;
        logger.path = path;
        logger.subloggers = [];
        logger.parent = parent;
        if (parent !== undefined) {
            // add sublogger to subloggers array
            parent.subloggers.push(logger);
            // add easy access to sublogger
            parent[logger.name] = logger;
            // create metric system
            if (parent.metricSystem !== undefined) {
                logger.metricsLevel('warn', parent.metricSystem.subSystem(logger.name));
            }
        }

        levels.forEach(function (level) {
            logger[level] = function (message) {
                publishMessage(logger, level, message);
            };
        });

        logger.off = function () {};

        logger.version = PackageJson.version;

        return logger;
    }

    function publishMessage(logger, level, message) {
        // Retrieve logger name and levels
        var loggerName = getLoggerName(logger);

        // Add stack trace if the message is an error
        if (level === 'error') {
            var e = new Error();
            if (e.stack) {
                message = message + '\n' + (e.stack.split('\n')
                    .slice(3)
                    .join('\n'));
            }
        }

        // Publish in console
        if (shouldPublish(getLevel(logger, '_consoleLevel'), level)) {
            if (!console[level]) {
                return;
            }
            console[level](loggerName + ': ' + message);
        }
        // Publish in file
        if (shouldPublish(getLevel(logger, '_publishLevel'), level)) {
            connection.send('log', 'LogMessage', {
                instance: instanceStr,
                level: levels.indexOf(level),
                logger: loggerName,
                message: message
            });
        }

        // Publish in metrics
        if (shouldPublish(getLevel(logger, '_metricLevel'), level)) {
            if (logger.metricSystem !== undefined) {
                logger.metricSystem.objectMetric('LogMessage', {
                    Time: new Date(),
                    Logger: loggerName,
                    Level: level,
                    Message: message
                });

                if (level === 'error') {
                    logger.metricSystem.setState(100, message);
                }
            }
        }
    }

    var shouldPublish = function (publishLevel, messageLevel) {
        return (!publishLevel || levels.indexOf(publishLevel) <= levels.indexOf(messageLevel));
    };

    var getLoggerName = function (logger) {
        var loggerPathAndName = logger.path.slice();
        loggerPathAndName.push(logger.name);
        return '[' + serializePath(loggerPathAndName) + ']';
    };

    var mainLogger = createLogger('main', [], undefined);
    mainLogger.publishLevel('warn');
    mainLogger.consoleLevel('info');
    mainLogger.metricsLevel('warn');

    return mainLogger;
}

if (typeof window !== 'undefined') {
    window.tick42 = window.tick42 || {};
    window.tick42.log = logger;
}

module.exports = logger;

},{"../package.json":97,"ascii-table":3,"tick42-gateway-connection":88}],87:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"../package.json":96,"callback-registry":4,"dup":66}],88:[function(require,module,exports){
(function (global){
var baseConnection = require('./connection');

/**
 * Check readme.md for detailed description
 */
var connection = function (settings, customConnection) {
    'use strict';
    settings = settings || {};
    var connection = baseConnection(settings);

    // if running in HC we use gw1 protocol and hc transport
    if (global.htmlContainer !== undefined) {
        connection = require('./protocols/gw1')(connection, settings);
        return require('./transports/hc')(connection, settings);
    }

    // if running in the browser - let's check which protocol version user wants
    if (settings.protocolVersion === 3) {
        connection = require('./protocols/gw3')(connection, settings);
    } else if (settings.protocolVersion === 2) {
        connection = require('./protocols/gw2')(connection, settings);
    } else {
        connection = require('./protocols/gw1')(connection, settings);
    }

    if (settings.ws !== undefined) {
        return require('./transports/ws')(connection, settings);
    } else if (settings.http !== undefined) {
        return require('./transports/http')(connection, settings);
    } else if (customConnection !== undefined) {
        return require('./transports/mock')(connection, customConnection, settings);
    } else {
        throw new Error('No connection. Make sure you are running the application from Tick42 HtmlContainer or fill the \'connection.websocket_url\' property.');
    }
};

if (global.tick42 === undefined) {
    global.tick42 = {};
}

global.tick42.connection = connection;

module.exports = connection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./connection":87,"./protocols/gw1":89,"./protocols/gw2":90,"./protocols/gw3":91,"./transports/hc":92,"./transports/http":93,"./transports/mock":94,"./transports/ws":95}],89:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"dup":68,"es6-promise":9}],90:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"dup":69,"es6-promise":9}],91:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70,"es6-promise":9,"shortid":11,"url-search-params":127}],92:[function(require,module,exports){
(function (global){
/**
 * Connection to HtmlContainer
 */
module.exports = function (connection) {
    'use strict';
    var connectionId = Math.floor(1e10 * Math.random()).toString();
    // Route messages to facade(s)
    connection.send = function (product, type, message) {
        if (product === 'metrics') {
            global.htmlContainer.metricsFacade.send(type, JSON.stringify(message));
        } else if (product === 'log') {
            global.htmlContainer.loggingFacade.send(type, JSON.stringify(message));
        } else if (product === 'appconfig') {
            global.htmlContainer.appConfigFacade.send(type, JSON.stringify(message), connectionId);
        }
    };

    if (global.htmlContainer.appConfigFacade !== undefined) {
        global.htmlContainer.appConfigFacade.initConnection(
            connectionId,
            function (messageAsJson) {
                return connection._handle_message(JSON.parse(messageAsJson));
            });
    }

    global.connections = global.connections || {};
    // Expose function for sending messages:
    global.connections['connection' + connectionId] = connection._handle_message;

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],93:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
    'use strict';
    var url = settings.http;
    // polling interval in ms, default is 1 second
    var interval = settings.http_interval_ms;
    if (!interval) {
        interval = 1000;
    }

    function logDebug(message) {
        if (global.console !== undefined && (settings.debug === true || settings.trace === true)) {
            console.log(message);
        }
    }

    function logTrace(message) {
        if (global.console !== undefined && settings.trace === true) {
            console.log(message);
        }
    }

    logDebug('Attemping to connect to Gateway via HTTP with url \'' + url + '\' and polling interval ' + interval + ' ms');

    connection.init = function() {
        poll(url, interval, 0, function (items) {
            for (var index = 0; index < items.length; index++) {
                connection._processMessage(items[index]);
            }
        });
    }

    connection.send = function (product, type, message, id) {
        var msg = connection._createMessage(type, message, id);
        httpPost(url, msg);
    };

    /**
     * Polls data from a given url on some interval
     * @param url       Base server url. A sequence url param may be added based on the seq param
     * @param interval  Interval (in ms) between polling requestts
     * @param seq       Next sequence number we should ask for (if 0 the server will return the last known message)
     * @param ondata    Data callback
     */
    function poll(url, interval, seq, ondata) {
        // construct the get Url - if seq != 0 add as url param to get
        // only messages after this sequence
        var getUrl = url;

        if (seq !== 0) {
            getUrl = url + '?sequence=' + seq + '&no-cache=' + new Date().getTime();
        }

        // create a request
        var xmlhttp = createCORSRequest('GET', getUrl, function () {
            if (seq === 0) {
                logDebug('Connected to Gateway on ' + url);
            }

            logTrace('Response from \'' + getUrl + '\' is ' + xmlhttp.responseText);
            var message = JSON.parse(xmlhttp.responseText);
            // the server returns the number of the next sequence that we must query for
            var nextSeq = message.nextSequence;
            // call user callbacke
            ondata(message.data);
            // re-schedule
            setTimeout(function () {
                poll(url, interval, nextSeq, ondata);
            }, interval);
        });

        xmlhttp.onerror = function (ev) {
            console.log('Error polling data from http server \'' + getUrl + '\' - ' + ev);
            // re-schedule
            setTimeout(function () {
                poll(url, interval, seq, ondata);
            }, interval);
        };

        logTrace('Sending GET to \'' + getUrl + '\'');
        xmlhttp.send();
    }

    /**
     * POSTs a message to a given url
     */
    function httpPost(url, message) {
        // create a request
        var xmlhttp = createCORSRequest('POST', url);
        logTrace('Sending POST to \'' + url + '\' : ' + message);
        xmlhttp.send(message);
    }

    /**
     * Creates CORS request (cross domain requests) for different browsers - XMLHttpRequest withCredentials
     * for Chrome and FF and XDomainRequest for IE
     */
    function createCORSRequest(method, url, resultCallback) {
        var xhr = new XMLHttpRequest();

        if ('withCredentials' in xhr) {
            // Check if the XMLHttpRequest object has a "withCredentials" property.
            // "withCredentials" only exists on XMLHTTPRequest2 objects.
            xhr.open(method, url, true);
            if (typeof resultCallback !== 'undefined') {
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        resultCallback();
                    }
                };
            }
        } else if (typeof XDomainRequest !== 'undefined') {
            // Otherwise, check if XDomainRequest.
            // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
            xhr = new XDomainRequest();
            xhr.open(method, url);
            if (typeof resultCallback !== 'undefined') {
                xhr.onload = resultCallback;
            }
        } else {
            // Otherwise, CORS is not supported by the browser.
            xhr = null;
        }

        return xhr;
    }

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],94:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"dup":73}],95:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
    'use strict';

    // Load the 'ws' library, but only if we are running under node js
    var WebSocket = require('detect-node') ? require('ws') : global.WebSocket;

    function initiateSocket() {
        var ws = new WebSocket(settings.ws);
        ws.onclose = function () {
            connection._triggerConnectionChanged(false);
        };
        // Log on connection
        ws.onopen = function () {
            connection._triggerConnectionChanged(true);
        };
        // Attach handler
        ws.onmessage = function (message) {
            connection._processMessage(message.data);
        };

        return ws;
    }

    // Holds callback execution until socket connection is established.
    function waitForSocketConnection (callback) {
        if (!callback) {
            return;
        }

        if (socket.readyState === 1) {
            return callback();
        } else if (socket.readyState > 1) {
            // > 1 means closing or closed
            socket = initiateSocket();
        }

        setTimeout(function () {
            waitForSocketConnection(callback);
        }, 50); // wait 5 milliseconds for the connection...
    }

    // Initiate a new socket (this gets re-executed on reconnect)
    var socket = initiateSocket();

    // Create a function for sending a message
    connection.send = function (product, type, message, id) {
        waitForSocketConnection(function() {
            var msg = connection._createMessage(type, message, id);
            if (!msg) {
                return;
            }
            socket.send(msg);
        });
    };

    connection.websocket_url = function (a) {
        settings.websocket_url = a;
        socket.close();
        socket = initiateSocket();
    };

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-node":6,"ws":129}],96:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-gateway-connection@>=1.3.2",
      "C:\\work\\stash\\GLUE-dev\\dev\\js-glue\\node_modules\\tick42-appconfig"
    ],
    [
      "tick42-gateway-connection@>=1.1.9",
      "C:\\work\\stash\\GLUE-dev\\dev\\js-glue\\node_modules\\tick42-logger"
    ]
  ],
  "_from": "tick42-gateway-connection@>=1.1.9",
  "_id": "tick42-gateway-connection@2.1.4",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-logger/tick42-gateway-connection",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-gateway-connection",
    "raw": "tick42-gateway-connection@>=1.1.9",
    "rawSpec": ">=1.1.9",
    "scope": null,
    "spec": ">=1.1.9",
    "type": "range"
  },
  "_requiredBy": [
    "/tick42-logger"
  ],
  "_shrinkwrap": null,
  "_spec": "tick42-gateway-connection@>=1.1.9",
  "_where": "C:\\work\\stash\\GLUE-dev\\dev\\js-glue\\node_modules\\tick42-logger",
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "dependencies": {
    "browserify-versionify": "^1.0.4",
    "callback-registry": "^1.0.1",
    "detect-node": "^2.0.3",
    "es6-promise": "^3.2.1",
    "shortid": "^2.2.6",
    "url-search-params": "^0.5.0",
    "ws": "^0.7.2"
  },
  "description": "Tick42 Gateway Connection.",
  "devDependencies": {
    "blanket": "^1.1.6",
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "fs": "0.0.2",
    "jsdom": "^8.1.0",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "shelljs": "^0.6.0"
  },
  "dist": {
    "shasum": "cecf52da785b3d0b528dce1e10c19fad5168065f",
    "tarball": "http://192.168.0.234:4873/tick42-gateway-connection/-/tick42-gateway-connection-2.1.4.tgz"
  },
  "gitHead": "4ddd1de82628d82b3f96467690925610fc1547af",
  "main": "library/main.js",
  "name": "tick42-gateway-connection",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "readmeFilename": "readme.md",
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix ",
    "prepublish": "npm update & npm run build",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "watch": "onchange \"./library/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "version": "2.1.4"
}

},{}],97:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-logger@2.0.6",
      "C:\\work\\stash\\GLUE-dev\\js-glue"
    ]
  ],
  "_from": "tick42-logger@2.0.6",
  "_id": "tick42-logger@2.0.6",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-logger",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-logger",
    "raw": "tick42-logger@2.0.6",
    "rawSpec": "2.0.6",
    "scope": null,
    "spec": "2.0.6",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_shasum": "04124763b30d2bbe199e38aac715e308e425c023",
  "_shrinkwrap": null,
  "_spec": "tick42-logger@2.0.6",
  "_where": "C:\\work\\stash\\GLUE-dev\\js-glue",
  "author": {
    "name": "Tick42"
  },
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "dependencies": {
    "ascii-table": "0.0.8",
    "tick42-gateway-connection": ">=1.1.9"
  },
  "description": "A library for logging",
  "devDependencies": {
    "blanket": "^1.1.6",
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "fs": "0.0.2",
    "jsdom": "^8.1.0",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "shelljs": "^0.6.0"
  },
  "dist": {
    "shasum": "04124763b30d2bbe199e38aac715e308e425c023",
    "tarball": "http://192.168.0.234:4873/tick42-logger/-/tick42-logger-2.0.6.tgz"
  },
  "gitHead": "34be3019b237911937638a6f4abf1e820f6d1829",
  "license": "ISC",
  "main": "library/logger",
  "name": "tick42-logger",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "https://stash.tick42.com:8443/scm/ofgw/js-logger.git"
  },
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix",
    "prepublish": "npm update & npm run build",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "watch": "onchange \"./library/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "version": "2.0.6"
}

},{}],98:[function(require,module,exports){
"use strict";
var objectMetric_1 = require("../metrics/objectMetric");
var stringMetric_1 = require("../metrics/stringMetric");
var numberMetric_1 = require("../metrics/numberMetric");
var timestampMetric_1 = require("../metrics/timestampMetric");
var MetricSerializer = (function () {
    function MetricSerializer() {
    }
    MetricSerializer.metricToMessage = function (metric) {
        var def = MetricSerializer._getMetricDefinition(metric.name, metric.value, metric.path, metric.type, metric.description, metric.period, metric.resolution);
        return {
            id: metric.id,
            instance: metric.repo.instance,
            definition: def,
            value: MetricSerializer._serializeValue(metric.value, metric),
        };
    };
    MetricSerializer._getMetricDefinition = function (name, value, path, type, description, resolution, period) {
        var def = {
            name: name,
            description: description,
            type: type ? type : MetricSerializer._getTypeFromValue(value),
            path: path,
            resolution: resolution,
            period: period
        };
        if (def.type === objectMetric_1.ObjectMetric.type) {
            def.Composite = Object.keys(value).reduce(function (arr, key) {
                var val = value[key];
                arr.push(MetricSerializer._getMetricDefinition(key, val, path));
                return arr;
            }, []);
        }
        return def;
    };
    MetricSerializer._serializeValue = function (value, metric) {
        if (value && value.constructor === Date) {
            return {
                value: {
                    type: this._valueTypes.indexOf("date"),
                    value: value.valueOf(),
                    isArray: false
                }
            };
        }
        else if (typeof value === "object") {
            return {
                CompositeValue: Object.keys(value).reduce(function (arr, key) {
                    var val = MetricSerializer._serializeValue(value[key]);
                    val.InnerMetricName = key;
                    arr.push(val);
                    return arr;
                }, [])
            };
        }
        else {
            var valueType = metric ? metric.getValueType() : undefined;
            valueType = valueType | this._valueTypes.indexOf(typeof value);
            return { value: { type: valueType, value: value, isArray: false } };
        }
    };
    MetricSerializer._getTypeFromValue = function (value) {
        var typeAsString = value.constructor === Date ? 'timestamp' : typeof value;
        switch (typeAsString) {
            case 'string':
                return stringMetric_1.StringMetric.type;
            case 'number':
                return numberMetric_1.NumberMetric.type;
            case 'timestamp':
                return timestampMetric_1.TimestampMetric.type;
            case 'object':
                return objectMetric_1.ObjectMetric.type;
        }
        return 0;
    };
    MetricSerializer._valueTypes = [
        "boolean",
        "int",
        "number",
        "long",
        "string",
        "date",
        "object"];
    return MetricSerializer;
}());
exports.MetricSerializer = MetricSerializer;

},{"../metrics/numberMetric":103,"../metrics/objectMetric":104,"../metrics/stringMetric":107,"../metrics/timestampMetric":109}],99:[function(require,module,exports){
"use strict";
var metricSerializer_1 = require("./metricSerializer");
var MetricsBridge = (function () {
    function MetricsBridge(repo, connection) {
        var _this = this;
        this._repo = repo;
        this._connection = connection;
        connection.on('metrics', "MetricsSnapshotRequest", function (instanceInfo) {
            if (instanceInfo.Instance !== repo.instance) {
                return;
            }
            _this.sendFull(_this._repo);
        });
    }
    MetricsBridge.prototype.sendFull = function (repo) {
        var rootSystem = repo.root;
        if (!rootSystem) {
            return;
        }
        if (rootSystem.subSystems.length == 0) {
            return;
        }
        this.sendFullSystem(rootSystem);
    };
    MetricsBridge.prototype.sendFullSystem = function (s) {
        var _this = this;
        this.createSystem(s);
        s.subSystems.forEach(function (sub) {
            _this.sendFullSystem((sub));
        });
        s.metrics.forEach(function (m) {
            _this.createMetric(m);
        });
    };
    MetricsBridge.prototype.createMetric = function (metric) {
        this._send("CreateMetric", metricSerializer_1.MetricSerializer.metricToMessage(metric));
    };
    MetricsBridge.prototype.updateMetric = function (metric) {
        this._send("UpdateMetric", metricSerializer_1.MetricSerializer.metricToMessage(metric));
    };
    MetricsBridge.prototype.createSystem = function (system) {
        if (system.parent !== undefined) {
            this._send("CreateMetricSystem", {
                id: system.id,
                instance: system.repo.instance,
                definition: { name: system.name, description: system.description, path: system.path }
            });
        }
    };
    MetricsBridge.prototype.updateSystem = function (system, state) {
        this._send("UpdateMetricSystem", {
            id: system.id,
            instance: system.repo.instance,
            state: state
        });
    };
    MetricsBridge.prototype.heartbeat = function (repo, interval) {
        this._send("HeartbeatMetrics", { publishingInterval: interval, instance: repo.instance });
    };
    MetricsBridge.prototype._send = function (type, message) {
        this._connection.send("metrics", type, message);
    };
    return MetricsBridge;
}());
exports.MetricsBridge = MetricsBridge;

},{"./metricSerializer":98}],100:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var AddressMetric = (function (_super) {
    __extends(AddressMetric, _super);
    function AddressMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, AddressMetric.type, value || '');
    }
    AddressMetric.type = 8;
    return AddressMetric;
}(metric_1.Metric));
exports.AddressMetric = AddressMetric;

},{"./metric":102}],101:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var CountMetric = (function (_super) {
    __extends(CountMetric, _super);
    function CountMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, CountMetric.type, value || 0);
    }
    CountMetric.prototype.increment = function () {
        this.incrementBy(1);
    };
    CountMetric.prototype.decrement = function () {
        this.decrementBy(1);
    };
    CountMetric.prototype.incrementBy = function (n) {
        this.update((this.value || 0) + n);
    };
    CountMetric.prototype.decrementBy = function (n) {
        this.update((this.value || 0) - n);
    };
    CountMetric.prototype.getValueType = function () {
        return 3;
    };
    CountMetric.type = 3;
    return CountMetric;
}(metric_1.Metric));
exports.CountMetric = CountMetric;

},{"./metric":102}],102:[function(require,module,exports){
"use strict";
var Metric = (function () {
    function Metric(def, parent, transport, type, value) {
        this.name = def.name;
        this.description = def.description;
        this.period = def.period;
        this.resolution = def.resolution;
        this.system = parent;
        this.repo = parent.repo;
        this.id = parent.path + "/" + this.name;
        this.value = value;
        this.type = type;
        this.path = parent.path.slice(0);
        this.path.push(parent.name);
        this._transport = transport;
        this._transport.createMetric(this);
    }
    Metric.prototype.update = function (value) {
        this.value = value;
        this._transport.updateMetric(this);
    };
    Metric.prototype.getValueType = function () {
        return undefined;
    };
    Metric.type = 0;
    return Metric;
}());
exports.Metric = Metric;

},{}],103:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var NumberMetric = (function (_super) {
    __extends(NumberMetric, _super);
    function NumberMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, NumberMetric.type, value || 0);
    }
    NumberMetric.prototype.increment = function () {
        this.incrementBy(1);
    };
    NumberMetric.prototype.decrement = function () {
        this.decrementBy(1);
    };
    NumberMetric.prototype.incrementBy = function (n) {
        this.update((this.value || 0) + n);
    };
    NumberMetric.prototype.decrementBy = function (n) {
        this.update((this.value || 0) - n);
    };
    NumberMetric.type = 2;
    return NumberMetric;
}(metric_1.Metric));
exports.NumberMetric = NumberMetric;

},{"./metric":102}],104:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var ObjectMetric = (function (_super) {
    __extends(ObjectMetric, _super);
    function ObjectMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, ObjectMetric.type, value);
    }
    ObjectMetric.prototype.update = function (value) {
        _super.prototype.update.call(this, value);
    };
    ObjectMetric.type = 11;
    return ObjectMetric;
}(metric_1.Metric));
exports.ObjectMetric = ObjectMetric;

},{"./metric":102}],105:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var RateMetric = (function (_super) {
    __extends(RateMetric, _super);
    function RateMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, RateMetric.type, value || 0);
    }
    RateMetric.type = 4;
    return RateMetric;
}(metric_1.Metric));
exports.RateMetric = RateMetric;

},{"./metric":102}],106:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var StatisticsMetric = (function (_super) {
    __extends(StatisticsMetric, _super);
    function StatisticsMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, StatisticsMetric.type, value || 0);
    }
    StatisticsMetric.type = 6;
    return StatisticsMetric;
}(metric_1.Metric));
exports.StatisticsMetric = StatisticsMetric;

},{"./metric":102}],107:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var StringMetric = (function (_super) {
    __extends(StringMetric, _super);
    function StringMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, StringMetric.type, value || '');
    }
    StringMetric.type = 1;
    return StringMetric;
}(metric_1.Metric));
exports.StringMetric = StringMetric;

},{"./metric":102}],108:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var TimespanMetric = (function (_super) {
    __extends(TimespanMetric, _super);
    function TimespanMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, TimespanMetric.type, value || false);
    }
    TimespanMetric.prototype.start = function () {
        this.update(true);
    };
    TimespanMetric.prototype.stop = function () {
        this.update(false);
    };
    TimespanMetric.type = 10;
    return TimespanMetric;
}(metric_1.Metric));
exports.TimespanMetric = TimespanMetric;

},{"./metric":102}],109:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var TimestampMetric = (function (_super) {
    __extends(TimestampMetric, _super);
    function TimestampMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, TimestampMetric.type, value || new Date());
    }
    TimestampMetric.prototype.now = function () {
        this.update(new Date());
    };
    TimestampMetric.type = 7;
    return TimestampMetric;
}(metric_1.Metric));
exports.TimestampMetric = TimestampMetric;

},{"./metric":102}],110:[function(require,module,exports){
"use strict";
var system_1 = require("./system");
var transport_1 = require("./bridge/transport");
var Repository = (function () {
    function Repository(config) {
        this._config = config;
        this._transport = new transport_1.MetricsBridge(this, config.connection);
        this.instance = config.identity.system + '/' + config.identity.service + '/' + config.identity.instance;
        this.identity = config.identity;
        this._startHeartbeating();
        this.root = new system_1.System('', this, this._transport);
        this._initSystemMetrics(this.root, config.clickStream || config.clickStream === undefined);
    }
    Repository.prototype._startHeartbeating = function () {
        var _this = this;
        this._transport.heartbeat(this, this._config.settings.heartbeatInterval);
        setInterval(function () {
            _this._transport.heartbeat(_this, _this._config.settings.heartbeatInterval);
        }, this._config.settings.heartbeatInterval);
    };
    Repository.prototype._initSystemMetrics = function (rootSystem, useClickStream) {
        if (typeof navigator !== 'undefined') {
            rootSystem.stringMetric('UserAgent', navigator.userAgent);
        }
        if (useClickStream && typeof document !== 'undefined') {
            var clickStream_1 = rootSystem.subSystem("ClickStream");
            var documentClickHandler = function (e) {
                if (!e.target) {
                    return;
                }
                clickStream_1.objectMetric("LastBrowserEvent", {
                    type: "click",
                    timestamp: new Date(),
                    target: {
                        className: e.target ? e.target.className : '',
                        id: e.target.id,
                        type: '<' + e.target.tagName.toLowerCase() + '>',
                        href: e.target.href || ""
                    }
                });
            };
            clickStream_1.objectMetric("Page", {
                title: document.title,
                page: window.location.href
            });
            if (document.addEventListener) {
                document.addEventListener('click', documentClickHandler);
            }
            else {
                document.attachEvent('onclick', documentClickHandler);
            }
        }
    };
    return Repository;
}());
exports.Repository = Repository;

},{"./bridge/transport":99,"./system":111}],111:[function(require,module,exports){
"use strict";
var numberMetric_1 = require("./metrics/numberMetric");
var timespanMetric_1 = require("./metrics/timespanMetric");
var stringMetric_1 = require("./metrics/stringMetric");
var addressMetric_1 = require("./metrics/addressMetric");
var objectMetric_1 = require("./metrics/objectMetric");
var timestampMetric_1 = require("./metrics/timestampMetric");
var countMetric_1 = require("./metrics/countMetric");
var statisticsMetric_1 = require("./metrics/statisticsMetric");
var rateMetric_1 = require("./metrics/rateMetric");
var System = (function () {
    function System(name, repo, transport, parent, description) {
        this.metrics = [];
        this.subSystems = [];
        this.name = name;
        this.description = description || '';
        this.repo = repo;
        this.parent = parent;
        this._transport = transport;
        this.path = this._buildPath(this.parent);
        this.id = (this.path.length > 0 ? this.path.join('/') + '/' : '') + this.name;
        this.identity = repo.identity;
        this.root = repo.root;
        this._transport.createSystem(this);
    }
    System.prototype.subSystem = function (name, description) {
        if (!name || name.length === 0) {
            throw new Error('name is required');
        }
        var matchingSystems = this.subSystems.filter(function (s) { return s.name === name; });
        if (matchingSystems.length > 0) {
            return matchingSystems[0];
        }
        var system = new System(name, this.repo, this._transport, this, description);
        this.subSystems.push(system);
        return system;
    };
    System.prototype.setState = function (state, description) {
        this._transport.updateSystem(this, { state: state, description: description });
    };
    System.prototype.stringMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, stringMetric_1.StringMetric.type, value, function (metricDef) {
            return new stringMetric_1.StringMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.numberMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, numberMetric_1.NumberMetric.type, value, function (metricDef) {
            return new numberMetric_1.NumberMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.countMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, countMetric_1.CountMetric.type, value, function (metricDef) {
            return new countMetric_1.CountMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.addressMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, addressMetric_1.AddressMetric.type, value, function (metricDef) {
            return new addressMetric_1.AddressMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.objectMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, objectMetric_1.ObjectMetric.type, value, function (metricDef) {
            return new objectMetric_1.ObjectMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.timespanMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, timespanMetric_1.TimespanMetric.type, value, function (metricDef) {
            return new timespanMetric_1.TimespanMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.timestampMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, timestampMetric_1.TimestampMetric.type, value, function (metricDef) {
            return new timestampMetric_1.TimestampMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.rateMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, rateMetric_1.RateMetric.type, value, function (metricDef) {
            return new rateMetric_1.RateMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.statiticsMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, statisticsMetric_1.StatisticsMetric.type, value, function (metricDef) {
            return new statisticsMetric_1.StatisticsMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype._unionToMetricDef = function (definition) {
        var metricDef;
        if (typeof definition === 'string') {
            metricDef = { name: definition };
        }
        else {
            metricDef = definition;
        }
        if (metricDef.name === undefined) {
            throw new Error('Metric name is required.');
        }
        return metricDef;
    };
    System.prototype._getOrCreateMetric = function (definition, expectedType, value, createFunc) {
        var metricDef = this._unionToMetricDef(definition);
        var matchingMetrics = this.metrics.filter(function (m) { return m.name === metricDef.name; });
        if (matchingMetrics.length > 0) {
            var existingMetric = matchingMetrics[0];
            if (existingMetric.type !== expectedType) {
                throw new Error('A metric named ' + metricDef.name + ' is already defined with different type');
            }
            if (typeof value !== 'undefined') {
                existingMetric.update(value);
            }
            return existingMetric;
        }
        var newMetric = createFunc(metricDef);
        this.metrics.push(newMetric);
        return newMetric;
    };
    System.prototype._buildPath = function (system) {
        if (!system || !system.parent) {
            return [];
        }
        var path = this._buildPath(system.parent);
        path.push(system.name);
        return path;
    };
    return System;
}());
exports.System = System;

},{"./metrics/addressMetric":100,"./metrics/countMetric":101,"./metrics/numberMetric":103,"./metrics/objectMetric":104,"./metrics/rateMetric":105,"./metrics/statisticsMetric":106,"./metrics/stringMetric":107,"./metrics/timespanMetric":108,"./metrics/timestampMetric":109}],112:[function(require,module,exports){
"use strict";
var repository_1 = require("./core/repository");
var tick42_gateway_connection_1 = require('tick42-gateway-connection');
var windowAsAny = typeof window === 'undefined' ? (new Object()) : window;
windowAsAny.tick42 = windowAsAny.tick42 || {};
windowAsAny.tick42.metrics = windowAsAny.tick42.metrics || function (config) {
    if (!config.identity) {
        throw new Error('Identity missing from metrics configuration');
    }
    if (!config.identity.service || typeof config.identity.service !== 'string') {
        throw new Error('Service missing or invalid in metrics identity configuration');
    }
    if (!config.identity.system || typeof config.identity.system !== 'string') {
        throw new Error('System missing or invalid in metrics identity configuration');
    }
    if (!config.identity.instance || typeof config.identity.instance !== 'string') {
        throw new Error('Instancemissing or invalid in metrics identity configuration');
    }
    config.settings = config.settings || {};
    config.settings.heartbeatInterval = config.settings.heartbeatInterval || 15000;
    if (typeof config.connection !== "object") {
        config.connection = {};
    }
    if (!(typeof config.connection === "object" && typeof config.connection.send === "function" && typeof config.connection.on === "function")) {
        config.connection = tick42_gateway_connection_1.connection(config.connection);
    }
    var repo = new repository_1.Repository(config);
    repo['version'] = repo.root['version'] = '2.0.15';
    return repo.root;
};
module.exports = windowAsAny.tick42.metrics;

},{"./core/repository":110,"tick42-gateway-connection":114}],113:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"../package.json":122,"callback-registry":4,"dup":66}],114:[function(require,module,exports){
(function (global){
var baseConnection = require('./connection');

/**
 * Check readme.md for detailed description
 */
var connection = function (settings, customConnection) {
    'use strict';
    settings = settings || {};
    var connection = baseConnection(settings);

    // if running in HC we use gw1 protocol and hc transport
    if (global.htmlContainer !== undefined) {
        connection = require('./protocols/gw1')(connection, settings);
        return require('./transports/hc')(connection, settings);
    }

    // if running in the browser - let's check which protocol version user wants
    if (settings.protocolVersion === 3) {
        connection = require('./protocols/gw3')(connection, settings);
    } else if (settings.protocolVersion === 2) {
        connection = require('./protocols/gw2')(connection, settings);
    } else {
        connection = require('./protocols/gw1')(connection, settings);
    }

    if (settings.ws !== undefined) {
        return require('./transports/ws')(connection, settings);
    } else if (settings.http !== undefined) {
        return require('./transports/http')(connection, settings);
    } else if (customConnection !== undefined) {
        return require('./transports/mock')(connection, customConnection, settings);
    } else {
        throw new Error('No connection. Make sure you are running the application from Tick42 HtmlContainer or fill the \'connection.websocket_url\' property.');
    }
};

if (global.tick42 === undefined) {
    global.tick42 = {};
}

global.tick42.connection = connection;

module.exports = connection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./connection":113,"./protocols/gw1":115,"./protocols/gw2":116,"./protocols/gw3":117,"./transports/hc":118,"./transports/http":119,"./transports/mock":120,"./transports/ws":121}],115:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"dup":68,"es6-promise":9}],116:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"dup":69,"es6-promise":9}],117:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70,"es6-promise":9,"shortid":11,"url-search-params":127}],118:[function(require,module,exports){
(function (global){
/**
 * Connection to HtmlContainer
 */
module.exports = function (connection) {
    'use strict';
    var connectionId = Math.floor(1e10 * Math.random()).toString();
    // Route messages to facade(s)
    connection.send = function (product, type, message) {
        if (product === 'metrics') {
            global.htmlContainer.metricsFacade.send(type, JSON.stringify(message));
        } else if (product === 'log') {
            global.htmlContainer.loggingFacade.send(type, JSON.stringify(message));
        } else if (product === 'appconfig') {
            global.htmlContainer.appConfigFacade.send(type, JSON.stringify(message), connectionId);
        }
    };

    if (global.htmlContainer.appConfigFacade !== undefined) {
        global.htmlContainer.appConfigFacade.initConnection(
            connectionId,
            function (messageAsJson) {
                return connection._handle_message(JSON.parse(messageAsJson));
            });
    }

    global.connections = global.connections || {};
    // Expose function for sending messages:
    global.connections['connection' + connectionId] = connection._handle_message;

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],119:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
    'use strict';
    var url = settings.http;
    // polling interval in ms, default is 1 second
    var interval = settings.http_interval_ms;
    if (!interval) {
        interval = 1000;
    }

    function logDebug(message) {
        if (global.console !== undefined && (settings.debug === true || settings.trace === true)) {
            console.log(message);
        }
    }

    function logTrace(message) {
        if (global.console !== undefined && settings.trace === true) {
            console.log(message);
        }
    }

    logDebug('Attemping to connect to Gateway via HTTP with url \'' + url + '\' and polling interval ' + interval + ' ms');

    connection.init = function() {
        poll(url, interval, 0, function (items) {
            for (var index = 0; index < items.length; index++) {
                connection._processMessage(items[index]);
            }
        });
    }

    connection.send = function (product, type, message, id) {
        var msg = connection._createMessage(type, message, id);
        httpPost(url, msg);
    };

    /**
     * Polls data from a given url on some interval
     * @param url       Base server url. A sequence url param may be added based on the seq param
     * @param interval  Interval (in ms) between polling requestts
     * @param seq       Next sequence number we should ask for (if 0 the server will return the last known message)
     * @param ondata    Data callback
     */
    function poll(url, interval, seq, ondata) {
        // construct the get Url - if seq != 0 add as url param to get
        // only messages after this sequence
        var getUrl = url;

        if (seq !== 0) {
            getUrl = url + '?sequence=' + seq + '&no-cache=' + new Date().getTime();
        }

        // create a request
        var xmlhttp = createCORSRequest('GET', getUrl, function () {
            if (seq === 0) {
                logDebug('Connected to Gateway on ' + url);
            }

            logTrace('Response from \'' + getUrl + '\' is ' + xmlhttp.responseText);
            var message = JSON.parse(xmlhttp.responseText);
            // the server returns the number of the next sequence that we must query for
            var nextSeq = message.nextSequence;
            // call user callbacke
            ondata(message.data);
            // re-schedule
            setTimeout(function () {
                poll(url, interval, nextSeq, ondata);
            }, interval);
        });

        xmlhttp.onerror = function (ev) {
            console.log('Error polling data from http server \'' + getUrl + '\' - ' + ev);
            // re-schedule
            setTimeout(function () {
                poll(url, interval, seq, ondata);
            }, interval);
        };

        logTrace('Sending GET to \'' + getUrl + '\'');
        xmlhttp.send();
    }

    /**
     * POSTs a message to a given url
     */
    function httpPost(url, message) {
        // create a request
        var xmlhttp = createCORSRequest('POST', url);
        logTrace('Sending POST to \'' + url + '\' : ' + message);
        xmlhttp.send(message);
    }

    /**
     * Creates CORS request (cross domain requests) for different browsers - XMLHttpRequest withCredentials
     * for Chrome and FF and XDomainRequest for IE
     */
    function createCORSRequest(method, url, resultCallback) {
        var xhr = new XMLHttpRequest();

        if ('withCredentials' in xhr) {
            // Check if the XMLHttpRequest object has a "withCredentials" property.
            // "withCredentials" only exists on XMLHTTPRequest2 objects.
            xhr.open(method, url, true);
            if (typeof resultCallback !== 'undefined') {
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        resultCallback();
                    }
                };
            }
        } else if (typeof XDomainRequest !== 'undefined') {
            // Otherwise, check if XDomainRequest.
            // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
            xhr = new XDomainRequest();
            xhr.open(method, url);
            if (typeof resultCallback !== 'undefined') {
                xhr.onload = resultCallback;
            }
        } else {
            // Otherwise, CORS is not supported by the browser.
            xhr = null;
        }

        return xhr;
    }

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],120:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"dup":73}],121:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
    'use strict';

    // Load the 'ws' library, but only if we are running under node js
    var WebSocket = require('detect-node') ? require('ws') : global.WebSocket;

    function initiateSocket() {
        var ws = new WebSocket(settings.ws);
        ws.onclose = function () {
            connection._triggerConnectionChanged(false);
        };
        // Log on connection
        ws.onopen = function () {
            connection._triggerConnectionChanged(true);
        };
        // Attach handler
        ws.onmessage = function (message) {
            connection._processMessage(message.data);
        };

        return ws;
    }

    // Holds callback execution until socket connection is established.
    function waitForSocketConnection (callback) {
        if (!callback) {
            return;
        }

        if (socket.readyState === 1) {
            return callback();
        } else if (socket.readyState > 1) {
            // > 1 means closing or closed
            socket = initiateSocket();
        }

        setTimeout(function () {
            waitForSocketConnection(callback);
        }, 50); // wait 5 milliseconds for the connection...
    }

    // Initiate a new socket (this gets re-executed on reconnect)
    var socket = initiateSocket();

    // Create a function for sending a message
    connection.send = function (product, type, message, id) {
        waitForSocketConnection(function() {
            var msg = connection._createMessage(type, message, id);
            if (!msg) {
                return;
            }
            socket.send(msg);
        });
    };

    connection.websocket_url = function (a) {
        settings.websocket_url = a;
        socket.close();
        socket = initiateSocket();
    };

    return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-node":6,"ws":129}],122:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-gateway-connection@>=1.3.2",
      "C:\\work\\stash\\GLUE-dev\\dev\\js-glue\\node_modules\\tick42-appconfig"
    ],
    [
      "tick42-gateway-connection@>=1.1.2",
      "C:\\work\\stash\\GLUE-dev\\dev\\js-glue\\node_modules\\tick42-metrics"
    ]
  ],
  "_from": "tick42-gateway-connection@>=1.1.2",
  "_id": "tick42-gateway-connection@2.1.4",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-metrics/tick42-gateway-connection",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-gateway-connection",
    "raw": "tick42-gateway-connection@>=1.1.2",
    "rawSpec": ">=1.1.2",
    "scope": null,
    "spec": ">=1.1.2",
    "type": "range"
  },
  "_requiredBy": [
    "/tick42-metrics"
  ],
  "_shrinkwrap": null,
  "_spec": "tick42-gateway-connection@>=1.1.2",
  "_where": "C:\\work\\stash\\GLUE-dev\\dev\\js-glue\\node_modules\\tick42-metrics",
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "dependencies": {
    "browserify-versionify": "^1.0.4",
    "callback-registry": "^1.0.1",
    "detect-node": "^2.0.3",
    "es6-promise": "^3.2.1",
    "shortid": "^2.2.6",
    "url-search-params": "^0.5.0",
    "ws": "^0.7.2"
  },
  "description": "Tick42 Gateway Connection.",
  "devDependencies": {
    "blanket": "^1.1.6",
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "fs": "0.0.2",
    "jsdom": "^8.1.0",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "shelljs": "^0.6.0"
  },
  "dist": {
    "shasum": "cecf52da785b3d0b528dce1e10c19fad5168065f",
    "tarball": "http://192.168.0.234:4873/tick42-gateway-connection/-/tick42-gateway-connection-2.1.4.tgz"
  },
  "gitHead": "4ddd1de82628d82b3f96467690925610fc1547af",
  "main": "library/main.js",
  "name": "tick42-gateway-connection",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "readmeFilename": "readme.md",
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix ",
    "prepublish": "npm update & npm run build",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "watch": "onchange \"./library/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "version": "2.1.4"
}

},{}],123:[function(require,module,exports){
  var helpers = module.exports = {};

  helpers.invokeAgmSuccessCallback = function (callback, callbackAargument) {
      'use strict';
      if (typeof callback === 'function') {
          callback(callbackAargument);
      }
  }

  helpers.invokeAgmErrorCallback =  function (callback, error) {
      'use strict';
      if (typeof callback === 'function') {
          callback(error.message);
      }
  }

  helpers.execCallbacks =  function (arr, val) {
      'use strict';
      if (arr !== undefined) {
          arr.forEach(function(callback) {
              callback(val);
          });
      }
  }

  helpers.vals = function(obj) {
      'use strict';
      return Object.keys(obj).reduce(function(arr, key) {
          arr.push(obj[key]);
          return arr;
      }, []);
  };


  helpers.assign = function(target) {
      'use strict';
      // We must check against these specific cases.
      if (target === undefined || target === null) {
          throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);
      for (var index = 1; index < arguments.length; index++) {
          var source = arguments[index];
          if (source !== undefined && source !== null) {
              for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                      output[nextKey] = source[nextKey];
                  }
              }
          }
      }
      return output;
  }

},{}],124:[function(require,module,exports){
var deprecate = require('util-deprecate');
var helpers = require('./helpers');

module.exports.init = init;
module.exports.create = createWindow;

var agm;

function setWindowStyleAttributes(windowStyles) {
    'use strict';
    // Adding windowStyleAttributes
    if (windowStyles !== undefined && typeof windowStyles !== 'object') {
        return JSON.parse(windowStyles);
    } else if (windowStyles !== undefined && typeof windowStyles === 'object') {
        return windowStyles;
    } else {
        return {};
    }
}

function init(a) {
    'use strict';
    agm = a;
}


function createWindow(id, internalId, name, containerObj, url, title, windowStyles) {
    'use strict';

    if (!containerObj) {
        throw new Error('containerObj can not be undefined');
    }

    var resultWindow;

    function addCallback(key, callback) {
        var obj = resultWindow._callbacks;
        if (obj[key] === undefined) {
            obj[key] = [callback];
        } else {
            obj[key].push(callback);
        }
    }

    // Functions for opening, closing, resizing windows
    function open(dimensions, options, success, error) {

        // A wrapper for the standard AGM "open" function
        var theWindow = this;

        // Init style objects if they are null
        dimensions = dimensions || {};
        options = options || {};

        var target = containerObj.getAgmTarget();

        var args = {
            // Window name and url
            windowName: theWindow.name,
            url: theWindow.url,

            // dimensions
            top: dimensions.top,
            left: dimensions.left,
            width: dimensions.width,
            height: dimensions.height,

            // Style attributes
            windowStyleAttributes: JSON.stringify(options)
        };

        args = helpers.assign(args, options);

        agm.invoke('T42.Html.CreateWindow',
            args,
            target,
            {},
            opened,
            cannotOpen);

        function opened(message) {
            // Add id to the current windows because the current HTML Container
            // doesn't support tracking the updates of the window
            if (message.returned !== undefined) {
                theWindow.id = message.returned.id;
            }
            helpers.invokeAgmSuccessCallback(success, theWindow);
        }

        function cannotOpen(e) {
            // Call the error callback
            if (typeof error === 'function') {
                error(e);
            }
            // Try to bind the returned object in case...
            // bindWindow(theWindow);
        }

        return theWindow;
    }

    function setStyle(style, success, error) {
        return agmAction('T42.Wnd.SetWindowStyle', success, error, { windowStyleAttributes: JSON.stringify(style) });
    }

    function opened() {
        return resultWindow.id !== undefined;
    }

    function handleWindowClose() {
        if (resultWindow.id !== undefined) {
            helpers.execCallbacks(resultWindow._callbacks.onClose);
            resultWindow.id = undefined;
            resultWindow._callbacks = {};
        }
    }

    function close() {
        return agmAction('T42.Wnd.Close', function(win) {
            console.log('"' + win.name +  '" window was closed.');
        }, function (err) {
            console.log('"' + resultWindow.name +  '" window was NOT closed due following error: ', err)
        });
    }

    function navigate(url, success, error) {
        return agmAction('T42.Html.OpenUrl', success, error, { url: url });
    }

    function setTitle(title, success, error) {
        return agmAction('T42.Wnd.SetWindowTitle', success, error, { title: title });
    }

    function getDetails(success, error) {
        var windowId = resultWindow.id;
        agm.invoke('T42.Wnd.FindById', { windowId: resultWindow.id }, containerObj.getAgmTarget(), {}, returnedDimensions, cannotReturnDimensions);

        function returnedDimensions(value) {
            helpers.invokeAgmSuccessCallback(success, value.returned[windowId]);
        }

        function cannotReturnDimensions(e) {
            helpers.invokeAgmErrorCallback(error, e);
        }
    }

    function moveResize(dimensions, success, error) {
        return agmAction('T42.Wnd.ResizeAndMove', success, error, dimensions)
    }

    function addTabButton(buttonInfo, success, error) {
        addFrameButton(buttonInfo, success, error);
    }

    function addFrameButton(buttonInfo, success, error) {
        if (typeof buttonInfo === 'undefined') {
            if (typeof error !== 'function') {
                return;
            } else {
                error('No button info');
            }
        }

        if (buttonInfo.buttonId === undefined) {
            if (typeof error !== 'function') {
                return;
            } else {
                error('No buttonId');
            }
        }

        if (buttonInfo.imageBase64 === undefined) {
            if (typeof error !== 'function') {
                return;
            } else {
                error('No imageBase64');
            }
        }

        // Invoke the AGM method
        agm.invoke('T42.Wnd.AddButton', {
            windowId: resultWindow.id,
            buttonInfo: buttonInfo
        }, containerObj.getAgmTarget(), {}, buttonIsAdded.bind(this), buttonCannotBeAdded.bind(this));

        function buttonIsAdded() {
            var _buttonId = buttonInfo.buttonId;
            resultWindow.buttons[_buttonId] = {
                id: _buttonId,
                info: buttonInfo
            };
            helpers.invokeAgmSuccessCallback(success, this);
        }

        function buttonCannotBeAdded(e) {
            helpers.invokeAgmErrorCallback(error, e);
        }
    }

    function onTitleChanged(callback) {
        callback(resultWindow.title);
        addCallback('onTitleChanged', callback);
    }

    function onAvailable(callback) {
        if (resultWindow.opened()) {
            callback(this);
        }
        return addCallback('onAvailable', callback);
    }

    function onClose(callback) {
        addCallback('onClose', callback);
    }

    function onUrlChanged(callback) {
        addCallback('onUrlChanged', callback);
    }

    function onTabButton(callback) {
        onFrameButton(callback);
    }

    function onFrameButton(callback) {
        addCallback('onFrameButton', callback);
    }

    function activate(success, error) {
        return agmAction('T42.Wnd.Activate', success, error);
    }

    function maximizeRestore(success, error) {
        return agmAction('T42.Wnd.MaximizeOrRestoreDown', success, error);
    }

    function maximize(success, error) {
        return agmAction('T42.Wnd.Maximize', success, error);
    }

    function restore(success, error) {
        return agmAction('T42.Wnd.Restore', success, error);
    }

    function minimize(success, error) {
        return agmAction('T42.Wnd.Minimize', success, error);
    }

    function collapse(success, error) {
        return agmAction('T42.Wnd.Collapse', success, error);
    }

    function titleChanged(title) {
        resultWindow.title = title;
        helpers.execCallbacks(resultWindow._callbacks.onTitleChanged, title);
    }

    function urlChanged(url) {
        resultWindow.url = url;
        helpers.execCallbacks(resultWindow._callbacks.onUrlChanged, url);
    }

    // Adds an alias of an AGM method in the Window prototype
    function agmAction(action, success, error, args) {
        // Stop if the window is closed
        if (resultWindow.url === undefined) {
            if (typeof error === 'function') {
                error('Cannot execute a command on a closed window.');
            }
            return;
        }

        // Add the window ID to the arguments
        args = args || {};
        args.windowId = resultWindow.id;

        // Invoke the AGM method
        agm.invoke(action, args, containerObj.getAgmTarget(), {}, fulfilled, error);

        function fulfilled() {
            helpers.invokeAgmSuccessCallback(success, resultWindow);
        }
    }

    resultWindow = {
        _internalId: internalId,
        _callbacks: {},

        name: name,
        container: containerObj.name,
        url: url,
        id: id,
        application: containerObj.name + '.' + name,
        title: title,
        buttons: {},
        windowStyleAttributes: setWindowStyleAttributes(windowStyles),

        onAvailable: onAvailable,
        onClose: onClose,
        onUrlChanged: onUrlChanged,
        onTitleChanged: onTitleChanged,
        onTabButton: onTabButton,
        onFrameButton: onFrameButton,

        maximize: maximize,
        restore: restore,
        minimize: minimize,
        maximizeRestore: maximizeRestore,
        collapse: collapse,
        focus: activate,
        open: open,
        opened: opened,
        getDetails: getDetails,
        moveResize: moveResize,
        setTitle: setTitle,
        setStyle: setStyle,
        navigate: navigate,
        addTabButton: addTabButton,
        addFrameButton : addFrameButton,
        close: close,
        handleWindowClose: handleWindowClose,
        titleChanged: titleChanged,
        urlChanged: urlChanged,

        // deprecates
        set_style: deprecate(setStyle, 'window.set_style() is deprecated and might be removed from future versions of glue. Use window.setStyle() instead'),
        on_available: deprecate(onAvailable, 'window.on_available() is deprecated and might be removed from future versions of glue. Use window.onAvailable() instead'),
        on_close: deprecate(onClose, 'window.on_close() is deprecated and might be removed from future versions of glue. Use window.onClose() instead'),
        on_url_changed: deprecate(onUrlChanged, 'window.on_url_changed() is deprecated and might be removed from future versions of glue. Use window.onUrlChanged() instead'),
        set_title: deprecate(setTitle, 'window.set_title() is deprecated and might be removed from future versions of glue. Use window.setTitle() instead'),
        get_details: deprecate(getDetails, 'window.get_details() is deprecated and might be removed from future versions of glue. Use window.getDetails() instead'),
        move_resize: deprecate(moveResize, 'window.move_resize() is deprecated and might be removed from future versions of glue. Use window.moveResize() instead'),
        maximize_restore: deprecate(maximizeRestore, 'window.maximize_restore() is deprecated and might be removed from future versions of glue. Use window.maximizeRestore() instead')

    };
    return resultWindow;
}

},{"./helpers":123,"util-deprecate":128}],125:[function(require,module,exports){
(function (global){
var PackageJson = require('../package.json');
var deprecate = require('util-deprecate');
var windowFactory = require('./window');
var helpers = require('./helpers');

var windows = function (agm) {
    'use strict'

    windowFactory.init(agm);

    if (global.htmlContainer && agm.subscribe) {
        // Only container.
        agm.serverMethodAdded(function (resp) {
            if ((resp.server.application.indexOf('HtmlContainer.') !== -1 && resp.server.application.indexOf('.Internal') !== -1) && resp.method.name.indexOf('T42.Wnd.WindowStateChanged') !== -1) {
                agm.subscribe('T42.Wnd.WindowStateChanged', { target: 'all' }).then(function (stream) {
                    stream.onData(function (streamData) {
                        updateWindow(streamData.data, matchContainer(streamData.server.application));
                    });
                    // attach callbacks
                    // stream.on("end", handleStreamClosed);
                    // stream.on("close", handleStreamClosed);
                });
            }
        });

        agm.serverAdded(function (server) {
            if (server.application.indexOf('HtmlContainer.') !== -1) {
                var container = constructContainerObject(server.application);
                addContainer(containers, container);
                getAllWindowsOnAddedContainer(container);
            }
        });
    }

    // Store windows that are tracked by ID and receive updates
    var windows = {};
    var containers = [];

    if (global.htmlContainer) {
        var myContainer = constructContainerObject(htmlContainer.containerName);
        addContainer(containers, myContainer);
        createWindow(htmlContainer.browserWindowName, myContainer, window.location.href, htmlContainer.windowId, htmlContainer.windowStyleAttributes);
    }

    function ensureContainerAvailiable(container, successCallback, errorCallback) {
        var containerFound = matchContainer(container)
        if (containerFound) {
            successCallback(containerFound);
            return;
        }

        setTimeout(function () {
            var containerFound = matchContainer(container)
            if (containerFound) {
                successCallback(containerFound);
            } else {
                errorCallback();
            }
        }, 2000);
    }

    function matchContainer(containerIdentifier) {
        if (!containerIdentifier) {
            return containers[0];
        }
        return containers.filter(function (container) {
            return container.shortName === containerIdentifier ||
                container.name === containerIdentifier ||
                container.agmApplication === containerIdentifier;
        })[0];
    }

    function constructContainerObject(containerIdentity) {
        var parts = containerIdentity.split('.');
        if (parts.length === 2) {
            parts.splice(0, 0, 'HtmlContainer');
        }

        var agmApplication = parts[0] + '.' + parts[1] + '.' + parts[2];

        return {
            shortName: parts[2],
            name: parts[1] + '.' + parts[2],
            agmApplication: agmApplication,
            getAgmTarget: function () {
                return { application: agmApplication }
            }
        };
    }

    function addContainer(containers, container) {
        if (containers.filter(function(cont) {
            return cont.shortName === container.shortName &&
            cont.name === container.name &&
            cont.agmApplication === container.agmApplication
        }).length  === 0) {
            containers.push(container);
        }
    }

    function getCallbacks(callbacks, containerName) {
        if (callbacks.containersCallbacks[containerName] !== undefined) {
            return callbacks.allContainersCallbacks.concat(callbacks.containersCallbacks[containerName]);
        } else {
            return callbacks.allContainersCallbacks;
        }
    }

    function putCallbacks(globalCallbacks, callback, container) {
        if (container === undefined) {
            globalCallbacks.allContainersCallbacks.push(callback);
        } else {
            if (globalCallbacks.containersCallbacks[container] === undefined) {
                globalCallbacks.containersCallbacks[container] = [callback];
            } else {
                globalCallbacks.containersCallbacks[container].push(callback);
            }
        }
    }

    function updateWindow(windowInfo, containerName) {
        var theWindow = getWindow(windowInfo.windowName, containerName, windowInfo.url, windowInfo.windowId, windowInfo.windowStyleAttributes, windowInfo.windowTitle);

        if (theWindow.id === undefined) {
            theWindow.id = windowInfo.windowId;
            helpers.execCallbacks(theWindow._callbacks.onAvailable, theWindow);
        }

        if (windowInfo.state === 'TitleChanged') {
            theWindow.titleChanged(windowInfo.windowTitle);
        }

        if (windowInfo.state === 'UrlChanged') {
            theWindow.urlChanged(windowInfo.url);
        }

        if (windowInfo.state === 'Created') {
            // Execute global "window_added" callbacks
            helpers.execCallbacks(getCallbacks(windowAddedCallbacks, containerName), theWindow);
        }

        // Clear the window on close event
        if (windowInfo.state === 'Closed') {
            // Execute global "window_removed" callbacks
            helpers.execCallbacks(getCallbacks(windowRemovedCallbacks, containerName), theWindow);

            delete windows[theWindow._internalId];

            theWindow.handleWindowClose();
        }

        // ButtonClicked
        if (windowInfo.state === 'ButtonClicked') {
            // Execute global "window_added" callbacks
            if (theWindow.buttons !== undefined && Object.keys(theWindow.buttons).length !== 0) {
                if (theWindow._callbacks.onFrameButton === undefined) {
                    return;
                }
                helpers.execCallbacks(theWindow._callbacks.onFrameButton, windowInfo.buttonId, theWindow.buttons[windowInfo.buttonId].info);

                theWindow._callbacks.onFrameButton.forEach(function (callback) {
                    callback(windowInfo.buttonId, theWindow.buttons[windowInfo.buttonId].info);
                });
            }
        }
    }

    // Create a dictionary to store the callbacks for the method "window_added".
    var windowAddedCallbacks = {
        containersCallbacks: {},
        allContainersCallbacks: []
    };

    // Create a dictionary to store the callbacks for the method "window_removed".
    var windowRemovedCallbacks = {
        containersCallbacks: {},
        allContainersCallbacks: []
    };

    function createWindowId(name, container) {
        return container.agmApplication + '.' + name;
    }

    function createWindow(name, container, url, id, windowStyles, title) {
        var windowId = createWindowId(name, container);

        var windowObj = windowFactory.create(id, windowId, name, container, url, title, windowStyles);

        windows[windowId] = windowObj;

        return windowObj;
    }

    // It is not guaranteed to return the window with the same URL and ID
    function getWindow(name, container, url, id, windowStyles, title) {

        var windowId = createWindowId(name, container);

        var existingWindow = windows[windowId];

        if (existingWindow !== undefined) {
            return existingWindow;
        } else {
            // Init object
            return createWindow(name, container, url, id, windowStyles, title);
        }
    }

    function my() {
        var h;
        if (typeof window !== 'undefined') {
            h = window.htmlContainer;
        }
        // Retrieve the current window (the onw in which your application currently resides).
        if (h === undefined) {
            return undefined;
        } else {
            return getWindow(h.browserWindowName, matchContainer(h.containerName), window.location.href, h.windowId, h.windowStyleAttributes, document.title);
        }
    }

    function open(name, url, container, dimensions, style, success, error) {
        container = container || 'Internal';
        ensureContainerAvailiable(container, function (container) {
            return getWindow(name, container, url, undefined, style)
                    .open(dimensions, style, success, error);
        }, function () {
            error('can not find container')
        });
    }

    function find (name, container, success) {

        container = matchContainer(container);

        var windowsForListing = Object.keys(windows).reduce(function (memo, winId) {
            var window = windows[winId];
            if (window.container === container.name && window.name === name) {
                memo.push(window);
            }
            return memo;
        }, []);

        if (typeof success !== 'function') {
            return windowsForListing[0];
        }

        success(windowsForListing[0]);
    }

    function list (container, success) {

        container = matchContainer(container);

        var windowsForListing = Object.keys(windows).reduce(function (memo, winId) {
            var window = windows[winId];
            if (window.container === container.name) {
                memo.push(window);
            }
            return memo;
        }, []);

        if (typeof success !== 'function') {

            return windowsForListing;
        }

        success(windowsForListing);
    }

    function windowAdded(callback, container) {
        // Add the current callback to the callback dictionary.
        putCallbacks(windowAddedCallbacks, callback, container);
    }

    function windowRemoved(callback, container) {
        // Add the current callback to the callback dictionary.
        putCallbacks(windowRemovedCallbacks, callback, container);
    }

    function containerAdded(callback) {
        agm.serverAdded(function (server) {
            if (server.application.indexOf('HtmlContainer.') !== -1) {
                helpers.invokeAgmSuccessCallback(callback, server.application);
            }
        });
    }

    function containerRemoved(callback) {
        agm.serverRemoved(function (server) {
            if (server.application.indexOf('HtmlContainer.') !== -1) {
                helpers.invokeAgmSuccessCallback(callback, server.application);
            }
        });
    }

    function getAllWindowsOnAddedContainer(container) {
        agm.invoke('T42.Wnd.ListWindows', {}, 'best', {},
                        function (listOfWindows) {
                            Object.keys(listOfWindows.returned).forEach(function (existingWindow) {
                                var windowInfo = listOfWindows.returned[existingWindow];
                                // Storing all window
                                var theWindow = getWindow(windowInfo.windowName, container, windowInfo.url, windowInfo.windowId, windowInfo.windowStyleAttributes, windowInfo.windowTitle)
                                helpers.execCallbacks(getCallbacks(windowAddedCallbacks, container.name), theWindow);
                            });
                        },
                        // Error callback if the windows cannot be listed.
                        function (e) {
                            console.log('Unable to load existing windows. ' + e);
                        }
                    );
    }

    // The API itself
    var api = {
        my: my,
        open: open,
        find: find,
        list: list,
        windowAdded: windowAdded,
        windowRemoved: windowRemoved,
        containerAdded: containerAdded,
        containerRemoved: containerRemoved,

        _from_event: function(name, container, url, id, windowStyles, title) {
            container = matchContainer(container);
            return getWindow(name, container, url, id, windowStyles, title);
        }
    };

    // deprecates
    api.window_added = deprecate(api.windowAdded, 'window.window_added() is deprecated and might be removed from future versions of glue. Use window.windowAdded() instead');
    api.window_removed = deprecate(api.windowRemoved, 'window.window_removed() is deprecated and might be removed from future versions of glue. Use window.windowRemoved() instead');
    api.container_added = deprecate(api.containerAdded, 'window.container_added() is deprecated and might be removed from future versions of glue. Use window.containerAdded() instead');
    api.container_removed = deprecate(api.containerRemoved, 'window.container_removed() is deprecated and might be removed from future versions of glue. Use window.containerRemoved() instead');

    api.version = PackageJson.version;

    return api;
};

if (typeof window !== 'undefined') {
    window.tick42 = window.tick42 || {};
    window.tick42.windows = windows;
}

module.exports = windows;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":126,"./helpers":123,"./window":124,"util-deprecate":128}],126:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-windows@2.2.8",
      "C:\\work\\stash\\GLUE-dev\\dev\\js-glue"
    ]
  ],
  "_from": "tick42-windows@2.2.8",
  "_id": "tick42-windows@2.2.8",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-windows",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-windows",
    "raw": "tick42-windows@2.2.8",
    "rawSpec": "2.2.8",
    "scope": null,
    "spec": "2.2.8",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_shasum": "b54f0c03eae212d88bedbc32c78f12028fbe9a83",
  "_shrinkwrap": null,
  "_spec": "tick42-windows@2.2.8",
  "_where": "C:\\work\\stash\\GLUE-dev\\dev\\js-glue",
  "author": {
    "name": "Tick42"
  },
  "bin": {
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "./bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "dependencies": {
    "es6-promise": "^3.0.2",
    "util-deprecate": "^1.0.2"
  },
  "description": "A windowing API for the Tick42 HTML Container",
  "devDependencies": {
    "blanket": "^1.1.6",
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-config-tick42": "^1.0.0",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "fs": "0.0.2",
    "jscs": "^3.0.7",
    "jsdom": "^8.1.0",
    "jshint": "^2.9.1",
    "minifyify": "^7.3.2",
    "onchange": "^2.1.2",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "shelljs": "^0.6.0"
  },
  "directories": {
    "test": "tests"
  },
  "dist": {
    "shasum": "b54f0c03eae212d88bedbc32c78f12028fbe9a83",
    "tarball": "http://192.168.0.234:4873/tick42-windows/-/tick42-windows-2.2.8.tgz"
  },
  "gitHead": "495e99177ce2e8606762714276345caf39b721fd",
  "license": "ISC",
  "main": "library/windows.js",
  "name": "tick42-windows",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "https://stash.tick42.com:8443/scm/ofgw/js-windows.git"
  },
  "scripts": {
    "build": "npm run eslint && node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix",
    "prepublish": "npm update & npm run build",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "watch": "onchange \"./library/*.js\" -iv -e \"./bin\" -- npm run build"
  },
  "version": "2.2.8"
}

},{}],127:[function(require,module,exports){
(function (global){
/*!
Copyright (C) 2015 by WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
'use strict';

function encode(str) {
  return encodeURIComponent(str).replace(find, replacer);
}

function decode(str) {
  return decodeURIComponent(str.replace(plus, ' '));
}

function URLSearchParams(query) {
  this[secret] = Object.create(null);
  if (!query) return;
  for (var
    index, value,
    pairs = (query || '').split('&'),
    i = 0,
    length = pairs.length; i < length; i++
  ) {
    value = pairs[i];
    index = value.indexOf('=');
    if (-1 < index) {
      this.append(
        decode(value.slice(0, index)),
        decode(value.slice(index + 1))
      );
    }
  }
}

var
  URLSearchParamsProto = URLSearchParams.prototype,
  find = /[!'\(\)~]|%20|%00/g,
  plus = /\+/g,
  replace = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  },
  replacer = function (match) {
    return replace[match];
  },
  iterable = isIterable(),
  secret = '__URLSearchParams__:' + Math.random()
;

function isIterable() {
  try {
    return !!Symbol.iterator;
  } catch(error) {
    return false;
  }
}

URLSearchParamsProto.append = function append(name, value) {
  var dict = this[secret];
  if (name in dict) {
    dict[name].push('' + value);
  } else {
    dict[name] = ['' + value];
  }
};

URLSearchParamsProto.delete = function del(name) {
  delete this[secret][name];
};

URLSearchParamsProto.get = function get(name) {
  var dict = this[secret];
  return name in dict ? dict[name][0] : null;
};

URLSearchParamsProto.getAll = function getAll(name) {
  var dict = this[secret];
  return name in dict ? dict[name].slice(0) : [];
};

URLSearchParamsProto.has = function has(name) {
  return name in this[secret];
};

URLSearchParamsProto.set = function set(name, value) {
  this[secret][name] = ['' + value];
};

URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
  var dict = this[secret];
  Object.getOwnPropertyNames(dict).forEach(function(name) {
    dict[name].forEach(function(value) {
      callback.call(thisArg, value, name, this);
    }, this);
  }, this);
};

URLSearchParamsProto.keys = function keys() {
  var items = [];
  this.forEach(function(value, name) { items.push(name); });
  var iterator = {
    next: function() {
      var value = items.shift();
      return {done: value === undefined, value: value};
    }
  };

  if (iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }

  return iterator;
};

URLSearchParamsProto.values = function values() {
  var items = [];
  this.forEach(function(value) { items.push(value); });
  var iterator = {
    next: function() {
      var value = items.shift();
      return {done: value === undefined, value: value};
    }
  };

  if (iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }

  return iterator;
};

URLSearchParamsProto.entries = function entries() {
  var items = [];
  this.forEach(function(value, name) { items.push([name, value]); });
  var iterator = {
    next: function() {
      var value = items.shift();
      return {done: value === undefined, value: value};
    }
  };

  if (iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }

  return iterator;
};

if (iterable) {
  URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
}

/*
URLSearchParamsProto.toBody = function() {
  return new Blob(
    [this.toString()],
    {type: 'application/x-www-form-urlencoded'}
  );
};
*/

URLSearchParamsProto.toJSON = function toJSON() {
  return {};
};

URLSearchParamsProto.toString = function toString() {
  var dict = this[secret], query = [], i, key, name, value;
  for (key in dict) {
    name = encode(key);
    for (
      i = 0,
      value = dict[key];
      i < value.length; i++
    ) {
      query.push(name + '=' + encode(value[i]));
    }
  }
  return query.join('&');
};

module.exports = global.URLSearchParams || URLSearchParams;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],128:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],129:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],130:[function(require,module,exports){
module.exports={
  "name": "tick42-glue",
  "version": "2.13.0",
  "description": "A JavaScript library which provides support for Tick42 GLUE.",
  "main": "library/glue.js",
  "bin": {
    "init-dev-mode": "bin/init-dev-mode.js",
    "remove-installed-dependencies": "bin/remove-installed-dependencies.js",
    "remove-development-dependencies": "bin/remove-development-dependencies.js",
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "scripts": {
    "eslint": "eslint library",
    "eslint:fix": "eslint library --fix",
    "test": "npm run eslint && mocha --require ./test/test_helper \"test/**/*.js\"",
    "build": "node bin/clean.js && node bin/build.js && node bin/minify && node bin/file-versionify",
    "build:dev": "npm run eslint && node bin/clean & node bin/build",
    "prepublish": "npm update && npm run build",
    "init:develop": "node bin/init-dev-mode",
    "clear:develop": "node bin/remove-development-dependencies",
    "watch": "onchange \"./library/*.js\" \"./node_modules/tick42-*/library/*.js\"  \"./node_modules/tick42-*/library_js/*.js\" \"../node_modules/tick42-*/library/*.js\"  \"../node_modules/tick42-*/library_js/*.js\" -iv -e \"./bin\" -- npm run build:dev",
    "watch:develop": "node bin/remove-installed-dependencies && npm run watch",
    "watch:prod": "npm install && npm run watch"
  },
  "repository": {
    "type": "git",
    "url": "https://stash.tick42.com:8443/scm/ofgw/js-glue.git"
  },
  "author": {
    "name": "Tick42",
    "url": "http://www.tick42.com"
  },
  "license": "ISC",
  "dependencies": {
    "cuid": "^1.3.8",
    "eslint": "^3.1.1",
    "eslint-config-standard": "^5.3.5",
    "eslint-plugin-promise": "^2.0.0",
    "eslint-plugin-standard": "^2.0.0",
    "eslint-config-tick42": "^1.0.0",
    "detect-node": "^2.0.3",
    "es5-shim": "^4.1.14",
    "tick42-activity": "^2.0.0",
    "tick42-agm": "^2.3.5",
    "tick42-app-manager": "^2.0.0",
    "tick42-appconfig": "^0.1.0",
    "tick42-gateway-connection": "^1.1.6",
    "tick42-logger": "^2.0.3",
    "tick42-metrics": "^2.0.13",
    "tick42-windows": "^2.0.2",
    "tick42-contexts": "*"
  },
  "devDependencies": {
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "chai": "^3.5.0",
    "fs": "0.0.2",
    "jsdom": "^8.1.0",
    "jshint": "^2.9.1",
    "minifyify": "^7.3.2",
    "mocha": "^2.4.5",
    "onchange": "^2.1.2",
    "shelljs": "^0.6.0"
  }
}

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWJyYXJ5L2dsdWUuanMiLCJub2RlX21vZHVsZXMvYXNjaWktdGFibGUvYXNjaWktdGFibGUuanMiLCJub2RlX21vZHVsZXMvYXNjaWktdGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FsbGJhY2stcmVnaXN0cnkvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N1aWQvZGlzdC9icm93c2VyLWN1aWQuanMiLCJub2RlX21vZHVsZXMvZGV0ZWN0LW5vZGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LXNoaW0vZXM1LXNoYW0uanMiLCJub2RlX21vZHVsZXMvZXM1LXNoaW0vZXM1LXNoaW0uanMiLCJub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2hvcnRpZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaG9ydGlkL2xpYi9hbHBoYWJldC5qcyIsIm5vZGVfbW9kdWxlcy9zaG9ydGlkL2xpYi9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvc2hvcnRpZC9saWIvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0aWQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0aWQvbGliL2lzLXZhbGlkLmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0aWQvbGliL3JhbmRvbS9yYW5kb20tYnl0ZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0aWQvbGliL3JhbmRvbS9yYW5kb20tZnJvbS1zZWVkLmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0aWQvbGliL3V0aWwvY2x1c3Rlci13b3JrZXItaWQtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9BUEkvYWN0aXZpdHlBUEkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvQVBJL2FjdGl2aXR5TWFuYWdlbWVudEFQSS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9BUEkvYWN0aXZpdHlNeUFQSS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9hY3Rpdml0eUNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9hY3Rpdml0eU1vZHVsZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9icmlkZ2VzL2hjQnJpZGdlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2NvbnRyYWN0cy9hY3Rpdml0eVN0YXR1cy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9jb250cmFjdHMvZW50aXR5RXZlbnQuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvY29yZS9hY3Rpdml0eUFHTS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9jb3JlL2FjdGl2aXR5TWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9jb3JlL2xvY2FsV2luZG93RmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9jb3JlL3Byb3h5V2luZG93RmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9lbnRpdGllcy9hY3Rpdml0eS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9lbnRpdGllcy9hY3Rpdml0eUVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9lbnRpdGllcy9hY3Rpdml0eVR5cGUuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvZW50aXRpZXMvYWN0aXZpdHlXaW5kb3cuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvZW50aXRpZXMvd2luZG93VHlwZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9oZWxwZXJzL2VudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2hlbHBlcnMvbG9nZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2hlbHBlcnMvcHJvbWlzZUV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvaGVscGVycy9yZWFkeU1hcmtlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9oZWxwZXJzL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L2FnbS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX2NsaWVudF9pbnZvY2F0aW9uc3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fY2xpZW50X21ldGhvZHN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fY2xpZW50X3NlcnZlcnN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fY2xpZW50X3N1YnNjcmlwdGlvbnN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21faGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX2luc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fbmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fc2VydmVyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fc3RyZWFtX3B1Ymxpc2hlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9hcHBfbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9hcHBsaWNhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9ldmVudF9tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHAtbWFuYWdlci9saWJyYXJ5L2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcC1tYW5hZ2VyL2xpYnJhcnkvaW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcC1tYW5hZ2VyL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL2xpYnJhcnkvYXBwY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHBjb25maWcvbGlicmFyeS9nYXRld2F5LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHBjb25maWcvbGlicmFyeS9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHBjb25maWcvbGlicmFyeS9tb2RlbC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL2xpYnJhcnkvcHJvcHMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9saWJyYXJ5L3V0aWwuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9ub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L2Nvbm5lY3Rpb24uanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9ub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9ub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L3Byb3RvY29scy9ndzEuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9ub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L3Byb3RvY29scy9ndzIuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9ub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L3Byb3RvY29scy9ndzMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9ub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L3RyYW5zcG9ydHMvaGMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9ub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L3RyYW5zcG9ydHMvaHR0cC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL25vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvdHJhbnNwb3J0cy9tb2NrLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHBjb25maWcvbm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS90cmFuc3BvcnRzL3dzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHBjb25maWcvbm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1jb250ZXh0cy9saWJyYXJ5L2JyaWRnZXMvZ3cuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWNvbnRleHRzL2xpYnJhcnkvYnJpZGdlcy9oYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItY29udGV4dHMvbGlicmFyeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1jb250ZXh0cy9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L2Nvbm5lY3Rpb24uanMiLCJub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L2NvbnQuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L2Zpbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvaHR0cC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvd3MuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvdGljazQyLWxvZ2dlci9saWJyYXJ5L2xvZ2dlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbG9nZ2VyL25vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbG9nZ2VyL25vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvdHJhbnNwb3J0cy9oYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbG9nZ2VyL25vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvdHJhbnNwb3J0cy9odHRwLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1sb2dnZXIvbm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS90cmFuc3BvcnRzL3dzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1sb2dnZXIvbm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1sb2dnZXIvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9icmlkZ2UvbWV0cmljU2VyaWFsaXplci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvYnJpZGdlL3RyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy9hZGRyZXNzTWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL2NvdW50TWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL21ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy9udW1iZXJNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3Mvb2JqZWN0TWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL3JhdGVNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3Mvc3RhdGlzdGljc01ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy9zdHJpbmdNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3MvdGltZXNwYW5NZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3MvdGltZXN0YW1wTWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9yZXBvc2l0b3J5LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9zeXN0ZW0uanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9tZXRyaWNzTW9kdWxlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL25vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL2xpYnJhcnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9ub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L3RyYW5zcG9ydHMvaGMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3Mvbm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS90cmFuc3BvcnRzL2h0dHAuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3Mvbm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS90cmFuc3BvcnRzL3dzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL25vZGVfbW9kdWxlcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy90aWNrNDItd2luZG93cy9saWJyYXJ5L2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLXdpbmRvd3MvbGlicmFyeS93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvdGljazQyLXdpbmRvd3MvbGlicmFyeS93aW5kb3dzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi13aW5kb3dzL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy91cmwtc2VhcmNoLXBhcmFtcy9idWlsZC91cmwtc2VhcmNoLXBhcmFtcy5ub2RlLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvd3MvbGliL2Jyb3dzZXIuanMiLCJwYWNrYWdlLmpzb24iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6b0JBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2poRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDclZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdlJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gRG8gbm90IGRvIGFueXRoaW5nIGlmIHRoZXJlIGlzIG5vIHN1cHBvcnQgb2YgRUNNQVNjcmlwdCA1XG4gICAgaWYgKHR5cGVvZiBbXS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcXVpcmUoJ2VzNS1zaGltJyk7XG4gICAgICAgIHJlcXVpcmUoJ2VzNS1zaGltL2VzNS1zaGFtJyk7XG4gICAgfVxuXG4gICAgdmFyIG1ldHJpY3MgPSByZXF1aXJlKCd0aWNrNDItbWV0cmljcycpO1xuICAgIHZhciBhZ20gPSByZXF1aXJlKCd0aWNrNDItYWdtJyk7XG4gICAgdmFyIGdhdGV3YXlDb25uZWN0aW9uID0gcmVxdWlyZSgndGljazQyLWdhdGV3YXktY29ubmVjdGlvbicpO1xuICAgIHZhciBsb2dnZXIgPSByZXF1aXJlKCd0aWNrNDItbG9nZ2VyJyk7XG4gICAgdmFyIGFwcGNvbmZpZyA9IHJlcXVpcmUoJ3RpY2s0Mi1hcHBjb25maWcnKTtcbiAgICB2YXIgd2luZG93cyA9IHJlcXVpcmUoJ3RpY2s0Mi13aW5kb3dzJyk7XG4gICAgdmFyIGFwcE1hbmFnZXIgPSByZXF1aXJlKCd0aWNrNDItYXBwLW1hbmFnZXInKTtcbiAgICB2YXIgYWN0aXZpdHkgPSByZXF1aXJlKCd0aWNrNDItYWN0aXZpdHknKTtcblx0dmFyIGNvbnRleHRzID0gcmVxdWlyZSgndGljazQyLWNvbnRleHRzJyk7XG4gICAgdmFyIHBqc29uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG4gICAgdmFyIGN1aWQgPSByZXF1aXJlKCdjdWlkJyk7XG5cbiAgICAvLyBEbyBub3QgZG8gYW55dGhpbmcgaWYgdGhlIHVzZXIgdHVybmVkIG9mZiB0aGUgYXV0byBpbml0aWFsaXphdGlvblxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5nbHVlX2F1dG9faW5pdGlhbGl6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluaXQgdGhlIEdMVUUgbmFtZXNwYWNlXG4gICAgdmFyIGdsdWUgPSB7fTtcbiAgICBnbHVlLnZlcnNpb24gPSBwanNvbi52ZXJzaW9uO1xuICAgIC8vIEJhc2UgY29uZmlndXJhdGlvbnMuIExhdGVyIHRoZXkgYXJlIHVwZGF0ZWQgZGVwZW5kaW5nIG9uIHRoZSBydW50aW1lLlxuICAgIHZhciBsb2dnZXJDb25maWd1cmF0aW9uID0geyBpZGVudGl0eTogeyBzeXN0ZW06ICdUaWNrNDInIH0gfTtcbiAgICB2YXIgbWV0cmljc0NvbmZpZ3VyYXRpb24gPSB7IGlkZW50aXR5OiB7IHN5c3RlbTogJ1RpY2s0MicgfSB9O1xuICAgIHZhciBhZ21Db25maWd1cmF0aW9uID0geyBpbnN0YW5jZToge30sIHNlcnZlcjogeyBwcmVzZW5jZV9pbnRlcnZhbDogMzAwMCB9IH07XG5cbiAgICAvLyBIZXJlIHdlIHdpbGwgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIGNvbm5lY3Rpb24gd2l0aCB0aGUgU2VydmljZSBQcm92aWRlclxuICAgIGdsdWUuY29ubmVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB2YXIgYXBwTmFtZTtcblxuICAgIC8vIElmIHdlIGFyZSBydW5uaW5nIGluIGFuIEhUTUwgQ29udGFpbmVyLCB1c2UgdGhlIEhUTUwgQ29udGFpbmVyIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaHRtbENvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIEFHTSBhcHAgbmFtZVxuICAgICAgICBhcHBOYW1lID0gd2luZG93LmFnbV9hcHBsaWNhdGlvbiB8fCB3aW5kb3cuaHRtbENvbnRhaW5lci5jb250YWluZXJOYW1lICsgJy4nICsgd2luZG93Lmh0bWxDb250YWluZXIuYnJvd3NlcldpbmRvd05hbWU7XG5cbiAgICAgICAgLy8gRmlsbCBsb2dnZXIgY29uZmlndXJhdGlvbnMgd2l0aCBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICBhZ21Db25maWd1cmF0aW9uLmluc3RhbmNlLmFwcGxpY2F0aW9uID0gYXBwTmFtZTtcbiAgICAgICAgbG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zeXN0ZW0gPSAnSHRtbENvbnRhaW5lci4nICsgd2luZG93Lmh0bWxDb250YWluZXIuY29udGFpbmVyTmFtZTtcbiAgICAgICAgbG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zZXJ2aWNlID0gJ0pTLicgKyB3aW5kb3cuaHRtbENvbnRhaW5lci5icm93c2VyV2luZG93TmFtZTtcbiAgICAgICAgbG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5pbnN0YW5jZSA9ICd+JyArIHdpbmRvdy5odG1sQ29udGFpbmVyLm1hY2hpbmVOYW1lO1xuXG4gICAgICAgIGlmICh3aW5kb3cuaHRtbENvbnRhaW5lci5hcHBDb25maWdGYWNhZGUgIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cuaHRtbENvbnRhaW5lci5hcHBDb25maWdGYWNhZGUuY29uZmlnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgQXBwQ29uZmlnXG4gICAgICAgICAgICBnbHVlLmFwcGNvbmZpZyA9IGFwcGNvbmZpZygpO1xuICAgICAgICAgICAgZ2x1ZS5hcHBjb25maWcuaW5pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3VwcGxhbnQodGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xceyhbXnt9XSopXFx9L2csIGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LnNwbGl0KCcuJykuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHdpbmRvdy5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZS5jb25maWc7XG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aXR5ID0ge307XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2V0dGluZ3MuaWRlbnRpdHkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdXBwbGFudChzZXR0aW5ncy5pZGVudGl0eVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHlba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXQgdGhlIENvbm5lY3Rpb25cbiAgICAgICAgZ2x1ZS5jb25uZWN0aW9uID0gZ2F0ZXdheUNvbm5lY3Rpb24oKTtcblxuICAgICAgICAvLyBJZiB3ZSBhcmUgcnVubmluZyBpbiBub3JtYWwgYnJvd3NlciwgY29ubmVjdCB2aWEgV2Vic29ja2V0XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25Db25maWcgPSB7fTtcbiAgICAgICAgdmFyIHVpZFByZWZpeDtcbiAgICAgICAgaWYgKHJlcXVpcmUoJ2RldGVjdC1ub2RlJykgfHwgKCdXZWJTb2NrZXQnIGluIHdpbmRvdyAmJiB3aW5kb3cuV2ViU29ja2V0LkNMT1NJTkcgPT09IDIpKSB7XG4gICAgICAgICAgICB1aWRQcmVmaXggPSAnV1MnO1xuICAgICAgICAgICAgLy8gV2Vic29ja2V0IFVSTCAodGhpcyBpcyB0aGUgZGVmYXVsdCB0aGF0IGlzIHVzZWQgaW4gdGhlIGRlbW8gV1Mgc2VydmVyKSBEZWZhdWx0cyB0byBpbnNlY3VyZS5cbiAgICAgICAgICAgIHZhciBkZWZhdWx0V3NVcmwgPSAnd3M6Ly9sb2NhbGhvc3Q6MjIwMzcnO1xuICAgICAgICAgICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHMnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdzVXJsID0gJ3dzczovL2xvY2FsaG9zdDoyMjAzNydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rpb25Db25maWcud2Vic29ja2V0X3VybCA9ICh3aW5kb3cgJiYgd2luZG93LmdsdWVfd3NfdXJsKSB8fCBkZWZhdWx0V3NVcmw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBubyBzdXBwb3J0IGZvciBXZWJTb2NrZXQgdXNlIEhUVFBcbiAgICAgICAgICAgIHVpZFByZWZpeCA9ICdIVFRQJztcbiAgICAgICAgICAgIC8vIGRvbid0IG1ha2UgaW5zZWN1cmUgcmVxdWVzdHMgZnJvbSBzZWN1cmUgZW52XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEh0dHBVcmwgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicgPyAnaHR0cDovL2xvY2FsaG9zdDoyMjAzNycgOiAnaHR0cHM6Ly9sb2NhbGhvc3Q6MjIwMzcnO1xuICAgICAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5odHRwX3VybCA9IHdpbmRvdy5nbHVlX2h0dHBfdXJsIHx8IGRlZmF1bHRIdHRwVXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgYXBwbGljYXRpb24gVUlEIHRvIGFsbG93IGZvciB0aGUgc2FtZSBhcHBsaWNhdGlvbiB0byBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgICAgIHZhciB1aWQgPSB1aWRQcmVmaXggKyBjdWlkKCk7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgQUdNIGFwcCBuYW1lXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LnRpdGxlKSB7XG4gICAgICAgICAgICBhcHBOYW1lID0gIGRvY3VtZW50LnRpdGxlICsgdWlkXG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93ICYmIHdpbmRvdy5hZ21fYXBwbGljYXRpb24pIHtcbiAgICAgICAgICAgIGFwcE5hbWUgPSB3aW5kb3cuYWdtX2FwcGxpY2F0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXBwTmFtZSA9IHVpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbGwgY29uZmlndXJhdGlvbnMgd2l0aCBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICBhZ21Db25maWd1cmF0aW9uLmluc3RhbmNlLmFwcGxpY2F0aW9uID0gYXBwTmFtZTtcbiAgICAgICAgbG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zeXN0ZW0gPSAnQnJvd3Nlcic7XG4gICAgICAgIGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHkuc2VydmljZSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC50aXRsZSB8fCAndW5rbm93bicgOiAndW5rbm93bic7XG4gICAgICAgIGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHkuaW5zdGFuY2UgPSAnficgKyB1aWQ7XG5cbiAgICAgICAgLy8gSW5pdCB0aGUgQ29ubmVjdGlvbiBhbmQgc3BlY2lmeSB0aGUgVVJMIG9mIHRoZSBXZWIgU29ja2V0IHNlcnZlciB0aGF0IHdlIGFyZSBjb25uZWN0aW5nIHRvLlxuICAgICAgICBnbHVlLmNvbm5lY3Rpb24gPSBnYXRld2F5Q29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBQbGFjZSB0aGUgQ29ubmVjdGlvbiwgYXMgcGFydCBvZiB0aGUgY29tcG9uZW50cycgY29uZmlndXJhdGlvblxuICAgIGxvZ2dlckNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiA9IGdsdWUuY29ubmVjdGlvbjtcbiAgICBtZXRyaWNzQ29uZmlndXJhdGlvbi5jb25uZWN0aW9uID0gZ2x1ZS5jb25uZWN0aW9uO1xuICAgIGFnbUNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiA9IGdsdWUuY29ubmVjdGlvbjtcblxuICAgIC8vIE92ZXJyaWRlIHNvbWUgcHJvcHMgd2l0aCBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIGlmIHByb3ZpZGVkXG4gICAgbG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zeXN0ZW0gPSAod2luZG93ICYmIHdpbmRvdy5nbHVlX21ldHJpY19zeXN0ZW0pIHx8IGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHkuc3lzdGVtO1xuICAgIGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHkuc2VydmljZSA9ICh3aW5kb3cgJiYgd2luZG93LmdsdWVfbWV0cmljX3NlcnZpY2UpIHx8IGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHkuc2VydmljZTtcbiAgICBsb2dnZXJDb25maWd1cmF0aW9uLmlkZW50aXR5Lmluc3RhbmNlID0gKHdpbmRvdyAmJiB3aW5kb3cuZ2x1ZV9tZXRyaWNfaW5zdGFuY2UpIHx8IGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHkuaW5zdGFuY2U7XG5cbiAgICAvLyBJbml0aWFsaXplIExvZ2dlciAodXNlcyB0aGUgc2FtZSBjb25maWd1cmF0aW9uIGFzIE1ldHJpY3MpXG4gICAgZ2x1ZS5sb2dnZXIgPSBsb2dnZXIobG9nZ2VyQ29uZmlndXJhdGlvbik7XG5cbiAgICAvLyBGaWxsIG1ldHJpY3MgY29uZmlndXJhdGlvbiB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgbWV0cmljcyBjb25maWd1cmF0aW9uc1xuICAgIG1ldHJpY3NDb25maWd1cmF0aW9uLmlkZW50aXR5ID0gbG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eTtcbiAgICBtZXRyaWNzQ29uZmlndXJhdGlvbi5sb2dnZXIgPSBnbHVlLmxvZ2dlci5zdWJMb2dnZXIoJ21ldHJpY3MnKTtcblxuICAgIC8vIEluaXRpYWxpemUgTWV0cmljcyBhbmQgc2F2ZSBpbnRvIHRoZSAnZ2x1ZScgZ2xvYmFsIHZhcmlhYmxlXG4gICAgdmFyIHJvb3RNZXRyaWNzID0gbWV0cmljcyhtZXRyaWNzQ29uZmlndXJhdGlvbik7XG4gICAgZ2x1ZS5tZXRyaWNzID0gcm9vdE1ldHJpY3Muc3ViU3lzdGVtKCdBcHAnKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIG1ldHJpY3Mgc3lzdGVtIGluIHRoZSBsb2dnZXIncyBcIm1ldHJpY3NfbGV2ZWxcIiBtZXRob2RcbiAgICBnbHVlLmxvZ2dlci5tZXRyaWNzTGV2ZWwoJ3dhcm4nLCBnbHVlLm1ldHJpY3MucGFyZW50LnN1YlN5c3RlbSgnTG9nRXZlbnRzJykpO1xuXG4gICAgYWdtQ29uZmlndXJhdGlvbi5pbnN0YW5jZS5hcHBsaWNhdGlvbiA9ICh3aW5kb3cgJiYgd2luZG93LmdsdWVfYWdtX2FwcGxpY2F0aW9uKSB8fCBhZ21Db25maWd1cmF0aW9uLmluc3RhbmNlLmFwcGxpY2F0aW9uO1xuXG4gICAgLy8gSW5jbHVkZSB0aGUgbWV0cmljIHJlcG8gaW4gdGhlIEFHTSBjb25maWd1cmF0aW9uIChzbyB0aGF0IEFHTSBjYW4gYnJvYWRjYXN0IG1ldHJpY3MpXG4gICAgYWdtQ29uZmlndXJhdGlvbi5tZXRyaWNzID0gcm9vdE1ldHJpY3Muc3ViU3lzdGVtKCdBR00nKTtcblxuICAgIC8vIEluaXRpYWxpemUgQUdNIHNhdmUgaW50byB0aGUgJ2dsdWUnIGdsb2JhbCB2YXJpYWJsZVxuICAgIGdsdWUuYWdtID0gYWdtKGFnbUNvbmZpZ3VyYXRpb24pO1xuXG4gICAgLy8gQWRkIGFjdGl2aXR5IGluIHRoZSBjb250YWluZXIgb25seVxuICAgIHZhciBhY3Rpdml0aWVzRmFjYWRlID0gd2luZG93ICYmIHdpbmRvdy5odG1sQ29udGFpbmVyID8gd2luZG93Lmh0bWxDb250YWluZXIuYWN0aXZpdHlGYWNhZGUgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiBhY3Rpdml0aWVzRmFjYWRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgYWN0aXZpdHlMb2dnZXIgPSBnbHVlLmxvZ2dlci5zdWJMb2dnZXIoJ2FjdGl2aXR5Jyk7XG4gICAgICAgIGFjdGl2aXR5TG9nZ2VyLnB1Ymxpc2hMZXZlbCgnZGVidWcnKTtcbiAgICAgICAgYWN0aXZpdHlMb2dnZXIuY29uc29sZUxldmVsKCdpbmZvJyk7XG4gICAgICAgIGFjdGl2aXR5TG9nZ2VyLm1ldHJpY3NMZXZlbCgnb2ZmJyk7XG4gICAgICAgIGdsdWUuYWN0aXZpdGllcyA9IGFjdGl2aXR5KHsgYWdtOiBnbHVlLmFnbSwgbG9nZ2VyOiBhY3Rpdml0eUxvZ2dlciB9KTtcbiAgICB9XG5cbiAgICBnbHVlLndpbmRvd3MgPSB3aW5kb3dzKGdsdWUuYWdtKTtcblxuICAgIC8vIGNhbWVsIGNhc2UgZm9yIEFwcCBNYW5hZ2VyXG4gICAgZ2x1ZS5hcHBNYW5hZ2VyID0gYXBwTWFuYWdlcihnbHVlLmFnbSwgZ2x1ZS53aW5kb3dzKTtcblxuXHRnbHVlLmNvbnRleHRzID0gY29udGV4dHMoKTtcblxuICAgIGdsdWUuaW5mbyA9IHtcblx0XHRcdGdsdWVWZXJzaW9uOiBwanNvbi52ZXJzaW9uLFxuXHRcdFx0YWN0aXZpdGllczogZ2x1ZS5hY3Rpdml0aWVzID8gZ2x1ZS5hY3Rpdml0aWVzLnZlcnNpb24gOiAndW5rbm93bicsXG5cdFx0XHRtZXRyaWNzOiBnbHVlLm1ldHJpY3MucmVwby52ZXJzaW9uLFxuXHRcdFx0YWdtOiBnbHVlLmFnbS52ZXJzaW9uLFxuXHRcdFx0d2luZG93czogZ2x1ZS53aW5kb3dzLnZlcnNpb24sXG5cdFx0XHRsb2dnZXI6IGdsdWUubG9nZ2VyLnZlcnNpb24sXG5cdFx0XHRhcHBNYW5hZ2VyOiBnbHVlLmFwcE1hbmFnZXIudmVyc2lvbixcblx0XHRcdGNvbm5lY3Rpb246IGdsdWUuY29ubmVjdGlvbi52ZXJzaW9uLFxuXHRcdFx0Y29udGV4dHM6IGdsdWUuY29udGV4dHMudmVyc2lvbixcblx0XHR9O1xuXG4gICAgLy8gbm8gY29uZmxpY3QgZnVuY3Rpb25cbiAgICB2YXIgb3JpZ2luYWxHbHVlID0gd2luZG93ICYmIHdpbmRvdy5nbHVlO1xuICAgIGdsdWUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZ2x1ZSA9IG9yaWdpbmFsR2x1ZTtcbiAgICAgICAgcmV0dXJuIGdsdWU7XG4gICAgfTtcblxuICAgIC8vIGZlZWRiYWNrIG9wdGlvblxuICAgIGdsdWUuZmVlZGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFnbHVlLmFnbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x1ZS5hZ20uaW52b2tlKCdUNDIuQUNTLkZlZWRiYWNrJywge30sICdiZXN0Jyk7XG4gICAgfTtcblxuICAgIC8vIEV4cG9ydCBHTFVFXG4gICAgaWYgKHdpbmRvdykge1xuICAgICAgICB3aW5kb3cuZ2x1ZSA9IGdsdWU7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gZ2x1ZTtcbn0oKSk7XG4iLCIvKipcbiAqIChjKSAyMDEzIEJlYXUgU29yZW5zZW5cbiAqIE1JVCBMaWNlbnNlZFxuICogRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3NvcmVuc2VuL2FzY2lpLXRhYmxlXG4gKi9cblxuOyhmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICwgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbi8qKlxuICogQXNjaWlUYWJsZSBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdGl0bGUgb3IgSlNPTiB0YWJsZVxuICogQHBhcmFtIHtPYmplY3R9IHRhYmxlIG9wdGlvbnNcbiAqICAtIGBwcmVmaXhgIC0gc3RyaW5nIHByZWZpeCBhZGRlZCB0byBlYWNoIGxpbmUgb24gcmVuZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQXNjaWlUYWJsZShuYW1lLCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdGhpcy5yZXNldChuYW1lKVxufVxuXG4vKiFcbiAqIEN1cnJlbnQgbGlicmFyeSB2ZXJzaW9uLCBzaG91bGQgbWF0Y2ggYHBhY2thZ2UuanNvbmBcbiAqL1xuXG5Bc2NpaVRhYmxlLlZFUlNJT04gPSAnMC4wLjgnXG5cbi8qIVxuICogQWxpZ25tZW50IGNvbnN0YW50c1xuICovXG5cbkFzY2lpVGFibGUuTEVGVCA9IDBcbkFzY2lpVGFibGUuQ0VOVEVSID0gMVxuQXNjaWlUYWJsZS5SSUdIVCA9IDJcblxuLyohXG4gKiBTdGF0aWMgbWV0aG9kc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRhYmxlIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB0aXRsZSBvciBKU09OIHRhYmxlXG4gKiBAcGFyYW0ge09iamVjdH0gdGFibGUgb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLmZhY3RvcnkgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQXNjaWlUYWJsZShuYW1lLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEFsaWduIHRoZSBhIHN0cmluZyBhdCB0aGUgZ2l2ZW4gbGVuZ3RoXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbnB1dFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmluZyBsZW5ndGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBwYWRkaW5nIGNoYXJhY3RlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLmFsaWduID0gZnVuY3Rpb24oZGlyLCBzdHIsIGxlbiwgcGFkKSB7XG4gIGlmIChkaXIgPT09IEFzY2lpVGFibGUuTEVGVCkgcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25MZWZ0KHN0ciwgbGVuLCBwYWQpXG4gIGlmIChkaXIgPT09IEFzY2lpVGFibGUuUklHSFQpIHJldHVybiBBc2NpaVRhYmxlLmFsaWduUmlnaHQoc3RyLCBsZW4sIHBhZClcbiAgaWYgKGRpciA9PT0gQXNjaWlUYWJsZS5DRU5URVIpIHJldHVybiBBc2NpaVRhYmxlLmFsaWduQ2VudGVyKHN0ciwgbGVuLCBwYWQpXG4gIHJldHVybiBBc2NpaVRhYmxlLmFsaWduQXV0byhzdHIsIGxlbiwgcGFkKVxufVxuXG4vKipcbiAqIExlZnQgYWxpZ24gYSBzdHJpbmcgYnkgcGFkZGluZyBpdCBhdCBhIGdpdmVuIGxlbmd0aFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpbmcgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFkZGluZyBjaGFyYWN0ZXIgKG9wdGlvbmFsLCBkZWZhdWx0ICcnKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLmFsaWduTGVmdCA9IGZ1bmN0aW9uKHN0ciwgbGVuLCBwYWQpIHtcbiAgaWYgKCFsZW4gfHwgbGVuIDwgMCkgcmV0dXJuICcnXG4gIGlmIChzdHIgPT09IHVuZGVmaW5lZCB8fCBzdHIgPT09IG51bGwpIHN0ciA9ICcnXG4gIGlmICh0eXBlb2YgcGFkID09PSAndW5kZWZpbmVkJykgcGFkID0gJyAnXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgc3RyID0gc3RyLnRvU3RyaW5nKClcbiAgdmFyIGFsZW4gPSBsZW4gKyAxIC0gc3RyLmxlbmd0aFxuICBpZiAoYWxlbiA8PSAwKSByZXR1cm4gc3RyXG4gIHJldHVybiBzdHIgKyBBcnJheShsZW4gKyAxIC0gc3RyLmxlbmd0aCkuam9pbihwYWQpXG59XG5cbi8qKlxuICogQ2VudGVyIGFsaWduIGEgc3RyaW5nIGJ5IHBhZGRpbmcgaXQgYXQgYSBnaXZlbiBsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaW5nIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHBhZGRpbmcgY2hhcmFjdGVyIChvcHRpb25hbCwgZGVmYXVsdCAnJylcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5hbGlnbkNlbnRlciA9IGZ1bmN0aW9uKHN0ciwgbGVuLCBwYWQpIHtcbiAgaWYgKCFsZW4gfHwgbGVuIDwgMCkgcmV0dXJuICcnXG4gIGlmIChzdHIgPT09IHVuZGVmaW5lZCB8fCBzdHIgPT09IG51bGwpIHN0ciA9ICcnXG4gIGlmICh0eXBlb2YgcGFkID09PSAndW5kZWZpbmVkJykgcGFkID0gJyAnXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgc3RyID0gc3RyLnRvU3RyaW5nKClcbiAgdmFyIG5MZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBoYWxmID0gTWF0aC5mbG9vcihsZW4gLyAyIC0gbkxlbiAvIDIpXG4gICAgLCBvZGRzID0gTWF0aC5hYnMoKG5MZW4gJSAyKSAtIChsZW4gJSAyKSlcbiAgICAsIGxlbiA9IHN0ci5sZW5ndGhcblxuICByZXR1cm4gQXNjaWlUYWJsZS5hbGlnblJpZ2h0KCcnLCBoYWxmLCBwYWQpIFxuICAgICsgc3RyXG4gICAgKyBBc2NpaVRhYmxlLmFsaWduTGVmdCgnJywgaGFsZiArIG9kZHMsIHBhZClcbn1cblxuLyoqXG4gKiBSaWdodCBhbGlnbiBhIHN0cmluZyBieSBwYWRkaW5nIGl0IGF0IGEgZ2l2ZW4gbGVuZ3RoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmluZyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWRkaW5nIGNoYXJhY3RlciAob3B0aW9uYWwsIGRlZmF1bHQgJycpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUuYWxpZ25SaWdodCA9IGZ1bmN0aW9uKHN0ciwgbGVuLCBwYWQpIHtcbiAgaWYgKCFsZW4gfHwgbGVuIDwgMCkgcmV0dXJuICcnXG4gIGlmIChzdHIgPT09IHVuZGVmaW5lZCB8fCBzdHIgPT09IG51bGwpIHN0ciA9ICcnXG4gIGlmICh0eXBlb2YgcGFkID09PSAndW5kZWZpbmVkJykgcGFkID0gJyAnXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgc3RyID0gc3RyLnRvU3RyaW5nKClcbiAgdmFyIGFsZW4gPSBsZW4gKyAxIC0gc3RyLmxlbmd0aFxuICBpZiAoYWxlbiA8PSAwKSByZXR1cm4gc3RyXG4gIHJldHVybiBBcnJheShsZW4gKyAxIC0gc3RyLmxlbmd0aCkuam9pbihwYWQpICsgc3RyXG59XG5cbi8qKlxuICogQXV0byBhbGlnbiBzdHJpbmcgdmFsdWUgYmFzZWQgb24gb2JqZWN0IHR5cGVcbiAqXG4gKiBAcGFyYW0ge0FueX0gb2JqZWN0IHRvIHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmluZyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWRkaW5nIGNoYXJhY3RlciAob3B0aW9uYWwsIGRlZmF1bHQgJycpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUuYWxpZ25BdXRvID0gZnVuY3Rpb24oc3RyLCBsZW4sIHBhZCkge1xuICBpZiAoc3RyID09PSB1bmRlZmluZWQgfHwgc3RyID09PSBudWxsKSBzdHIgPSAnJ1xuICB2YXIgdHlwZSA9IHRvU3RyaW5nLmNhbGwoc3RyKVxuICBwYWQgfHwgKHBhZCA9ICcgJylcbiAgbGVuID0gK2xlblxuICBpZiAodHlwZSAhPT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICB9XG4gIGlmIChzdHIubGVuZ3RoIDwgbGVuKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6IHJldHVybiBBc2NpaVRhYmxlLmFsaWduUmlnaHQoc3RyLCBsZW4sIHBhZClcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBBc2NpaVRhYmxlLmFsaWduTGVmdChzdHIsIGxlbiwgcGFkKVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbi8qKlxuICogRmlsbCBhbiBhcnJheSBhdCBhIGdpdmVuIHNpemUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYXJyYXkgc2l6ZVxuICogQHBhcmFtIHtBbnl9IGZpbGwgdmFsdWVcbiAqIEByZXR1cm4ge0FycmF5fSBmaWxsZWQgYXJyYXlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5hcnJheUZpbGwgPSBmdW5jdGlvbihsZW4sIGZpbGwpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheShsZW4pXG4gIGZvciAodmFyIGkgPSAwOyBpICE9PSBsZW47IGkrKykge1xuICAgIGFycltpXSA9IGZpbGw7XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG4vKiFcbiAqIEluc3RhbmNlIG1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFJlc2V0IHRoZSB0YWJsZSBzdGF0ZSBiYWNrIHRvIGRlZmF1bHRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB0aXRsZSBvciBKU09OIHRhYmxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnJlc2V0ID0gXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdGhpcy5fX25hbWUgPSAnJ1xuICB0aGlzLl9fbmFtZUFsaWduID0gQXNjaWlUYWJsZS5DRU5URVJcbiAgdGhpcy5fX3Jvd3MgPSBbXVxuICB0aGlzLl9fbWF4Q2VsbHMgPSAwXG4gIHRoaXMuX19hbGlnbnMgPSBbXVxuICB0aGlzLl9fY29sTWF4ZXMgPSBbXVxuICB0aGlzLl9fc3BhY2luZyA9IDFcbiAgdGhpcy5fX2hlYWRpbmcgPSBudWxsXG4gIHRoaXMuX19oZWFkaW5nQWxpZ24gPSBBc2NpaVRhYmxlLkNFTlRFUlxuICB0aGlzLnNldEJvcmRlcigpXG5cbiAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgdGhpcy5fX25hbWUgPSBuYW1lXG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICB0aGlzLmZyb21KU09OKG5hbWUpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHRhYmxlIGJvcmRlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBob3Jpem9udGFsIGVkZ2VzIChvcHRpb25hbCwgZGVmYXVsdCBgfGApXG4gKiBAcGFyYW0ge1N0cmluZ30gdmVydGljYWwgZWRnZXMgKG9wdGlvbmFsLCBkZWZhdWx0IGAtYClcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b3AgY29ybmVycyAob3B0aW9uYWwsIGRlZmF1bHQgYC5gKVxuICogQHBhcmFtIHtTdHJpbmd9IGJvdHRvbSBjb3JuZXJzIChvcHRpb25hbCwgZGVmYXVsdCBgJ2ApXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNldEJvcmRlciA9IGZ1bmN0aW9uKGVkZ2UsIGZpbGwsIHRvcCwgYm90dG9tKSB7XG4gIHRoaXMuX19ib3JkZXIgPSB0cnVlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZmlsbCA9IHRvcCA9IGJvdHRvbSA9IGVkZ2VcbiAgfVxuICB0aGlzLl9fZWRnZSA9IGVkZ2UgfHwgJ3wnXG4gIHRoaXMuX19maWxsID0gZmlsbCB8fCAnLSdcbiAgdGhpcy5fX3RvcCA9IHRvcCB8fCAnLidcbiAgdGhpcy5fX2JvdHRvbSA9IGJvdHRvbSB8fCBcIidcIlxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbGwgdGFibGUgYm9yZGVyc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUucmVtb3ZlQm9yZGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19ib3JkZXIgPSBmYWxzZVxuICB0aGlzLl9fZWRnZSA9ICcgJ1xuICB0aGlzLl9fZmlsbCA9ICcgJ1xuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFNldCB0aGUgY29sdW1uIGFsaWdubWVudCBhdCBhIGdpdmVuIGluZGV4XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtbiBpbmRleFxuICogQHBhcmFtIHtOdW1iZXJ9IGFsaWdubWVudCBkaXJlY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc2V0QWxpZ24gPSBmdW5jdGlvbihpZHgsIGRpcikge1xuICB0aGlzLl9fYWxpZ25zW2lkeF0gPSBkaXJcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHRpdGxlIG9mIHRoZSB0YWJsZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdGhpcy5fX25hbWUgPSBuYW1lXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogR2V0IHRoZSB0aXRsZSBvZiB0aGUgdGFibGVcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRpdGxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fbmFtZVxufVxuXG4vKipcbiAqIFNldCB0YWJsZSB0aXRsZSBhbGlnbm1lbnRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNldFRpdGxlQWxpZ24gPSBmdW5jdGlvbihkaXIpIHtcbiAgdGhpcy5fX25hbWVBbGlnbiA9IGRpclxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEFzY2lpVGFibGUgc29ydGluZyBzaG9ydGN1dCB0byBzb3J0IHJvd3NcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0aW5nIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gIHRoaXMuX19yb3dzLnNvcnQobWV0aG9kKVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFNvcnQgcm93cyBiYXNlZCBvbiBzb3J0IG1ldGhvZCBmb3IgZ2l2ZW4gY29sdW1uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtbiBpbmRleFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydGluZyBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc29ydENvbHVtbiA9IGZ1bmN0aW9uKGlkeCwgbWV0aG9kKSB7XG4gIHRoaXMuX19yb3dzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBtZXRob2QoYVtpZHhdLCBiW2lkeF0pXG4gIH0pXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogU2V0IHRhYmxlIGhlYWRpbmcgZm9yIGNvbHVtbnNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNldEhlYWRpbmcgPSBmdW5jdGlvbihyb3cpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxIHx8IHRvU3RyaW5nLmNhbGwocm93KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJvdyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICB9XG4gIHRoaXMuX19oZWFkaW5nID0gcm93XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogR2V0IHRhYmxlIGhlYWRpbmcgZm9yIGNvbHVtbnNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gY29weSBvZiBoZWFkaW5nc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5nZXRIZWFkaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9faGVhZGluZy5zbGljZSgpXG59XG5cbi8qKlxuICogU2V0IGhlYWRpbmcgYWxpZ25tZW50XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zZXRIZWFkaW5nQWxpZ24gPSBmdW5jdGlvbihkaXIpIHtcbiAgdGhpcy5fX2hlYWRpbmdBbGlnbiA9IGRpclxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEFkZCBhIHJvdyBvZiBpbmZvcm1hdGlvbiB0byB0aGUgdGFibGVcbiAqIFxuICogQHBhcmFtIHsuLi58QXJyYXl9IGFyZ3VtZW50IHZhbHVlcyBpbiBvcmRlciBvZiBjb2x1bW5zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLmFkZFJvdyA9IGZ1bmN0aW9uKHJvdykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgfHwgdG9TdHJpbmcuY2FsbChyb3cpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcm93ID0gc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIH1cbiAgdGhpcy5fX21heENlbGxzID0gTWF0aC5tYXgodGhpcy5fX21heENlbGxzLCByb3cubGVuZ3RoKVxuICB0aGlzLl9fcm93cy5wdXNoKHJvdylcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBHZXQgYSBjb3B5IG9mIGFsbCByb3dzIG9mIHRoZSB0YWJsZVxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBjb3B5IG9mIHJvd3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuZ2V0Um93cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3Jvd3Muc2xpY2UoKS5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgcmV0dXJuIHJvdy5zbGljZSgpXG4gIH0pXG59XG5cbi8qKlxuICogQWRkIHJvd3MgaW4gdGhlIGZvcm1hdCBvZiBhIHJvdyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSByb3cgbWF0cml4XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLmFkZFJvd01hdHJpeCA9IGZ1bmN0aW9uKHJvd3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5hZGRSb3cocm93c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEFkZCByb3dzIGZyb20gdGhlIGdpdmVuIGRhdGEgYXJyYXksIHByb2Nlc3NlZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcm93Q2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICogQHBhcmFtIChGdW5jdGlvbikgcm93Q2FsbGJhY2tcbiAqIEBwYXJhbSAoQm9vbGVhbikgYXNNYXRyaXggLSBjb250cm9scyBpZiB0aGUgcm93IGNyZWF0ZWQgYnkgcm93Q2FsbGJhY2sgc2hvdWxkIGJlIGFzc2lnbmVkIGFzIHJvdyBtYXRyaXhcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuYWRkRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIHJvd0NhbGxiYWNrLCBhc01hdHJpeCkge1xuICBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZvciAodmFyIGluZGV4ID0gMCwgbGltaXQgPSBkYXRhLmxlbmd0aDsgaW5kZXggPCBsaW1pdDsgaW5kZXgrKykge1xuICAgIHZhciByb3cgPSByb3dDYWxsYmFjayhkYXRhW2luZGV4XSk7XG4gICAgaWYoYXNNYXRyaXgpIHtcbiAgICAgIHRoaXMuYWRkUm93TWF0cml4KHJvdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkUm93KHJvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbiAgLyoqXG4gKiBSZXNldCB0aGUgY3VycmVudCByb3cgc3RhdGVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLmNsZWFyUm93cyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcm93cyA9IFtdXG4gIHRoaXMuX19tYXhDZWxscyA9IDBcbiAgdGhpcy5fX2NvbE1heGVzID0gW11cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBBcHBseSBhbiBldmVuIHNwYWNlZCBjb2x1bW4ganVzdGlmaWNhdGlvblxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb24gLyBvZmZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc2V0SnVzdGlmeSA9IGZ1bmN0aW9uKHZhbCkge1xuICBhcmd1bWVudHMubGVuZ3RoID09PSAwICYmICh2YWwgPSB0cnVlKVxuICB0aGlzLl9fanVzdGlmeSA9ICEhdmFsXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgY3VycmVudCBpbnN0YW5jZSB0byBhIEpTT04gc3RydWN0dXJlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBqc29uIHJlcHJlc2VudGF0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHRpdGxlOiB0aGlzLmdldFRpdGxlKClcbiAgLCBoZWFkaW5nOiB0aGlzLmdldEhlYWRpbmcoKVxuICAsIHJvd3M6IHRoaXMuZ2V0Um93cygpXG4gIH1cbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSB0aGUgdGFibGUgZnJvbSBhIEpTT04gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGpzb24gcmVwcmVzZW50YXRpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUucGFyc2UgPSBcbkFzY2lpVGFibGUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0aGlzXG4gICAgLmNsZWFyKClcbiAgICAuc2V0VGl0bGUob2JqLnRpdGxlKVxuICAgIC5zZXRIZWFkaW5nKG9iai5oZWFkaW5nKVxuICAgIC5hZGRSb3dNYXRyaXgob2JqLnJvd3MpXG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSB0YWJsZSB3aXRoIHRoZSBjdXJyZW50IGluZm9ybWF0aW9uXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgdGFibGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUucmVuZGVyID1cbkFzY2lpVGFibGUucHJvdG90eXBlLnZhbHVlT2YgPVxuQXNjaWlUYWJsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBib2R5ID0gW11cbiAgICAsIG1MZW4gPSB0aGlzLl9fbWF4Q2VsbHNcbiAgICAsIG1heCA9IEFzY2lpVGFibGUuYXJyYXlGaWxsKG1MZW4sIDApXG4gICAgLCB0b3RhbCA9IG1MZW4gKiAzXG4gICAgLCByb3dzID0gdGhpcy5fX3Jvd3NcbiAgICAsIGp1c3RpZnlcbiAgICAsIGJvcmRlciA9IHRoaXMuX19ib3JkZXJcbiAgICAsIGFsbCA9IHRoaXMuX19oZWFkaW5nIFxuICAgICAgICA/IFt0aGlzLl9faGVhZGluZ10uY29uY2F0KHJvd3MpXG4gICAgICAgIDogcm93c1xuXG4gIC8vIENhbGN1bGF0ZSBtYXggdGFibGUgY2VsbCBsZW5ndGhzIGFjcm9zcyBhbGwgcm93c1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByb3cgPSBhbGxbaV1cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG1MZW47IGsrKykge1xuICAgICAgdmFyIGNlbGwgPSByb3dba11cbiAgICAgIG1heFtrXSA9IE1hdGgubWF4KG1heFtrXSwgY2VsbCA/IGNlbGwudG9TdHJpbmcoKS5sZW5ndGggOiAwKVxuICAgIH1cbiAgfVxuICB0aGlzLl9fY29sTWF4ZXMgPSBtYXhcbiAganVzdGlmeSA9IHRoaXMuX19qdXN0aWZ5ID8gTWF0aC5tYXguYXBwbHkobnVsbCwgbWF4KSA6IDBcblxuICAvLyBHZXQgXG4gIG1heC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICB0b3RhbCArPSBqdXN0aWZ5ID8ganVzdGlmeSA6IHggKyBzZWxmLl9fc3BhY2luZ1xuICB9KVxuICBqdXN0aWZ5ICYmICh0b3RhbCArPSBtYXgubGVuZ3RoKVxuICB0b3RhbCAtPSB0aGlzLl9fc3BhY2luZ1xuXG4gIC8vIEhlYWRpbmdcbiAgYm9yZGVyICYmIGJvZHkucHVzaCh0aGlzLl9zZXBlcmF0b3IodG90YWwgLSBtTGVuICsgMSwgdGhpcy5fX3RvcCkpXG4gIGlmICh0aGlzLl9fbmFtZSkge1xuICAgIGJvZHkucHVzaCh0aGlzLl9yZW5kZXJUaXRsZSh0b3RhbCAtIG1MZW4gKyAxKSlcbiAgICBib3JkZXIgJiYgYm9keS5wdXNoKHRoaXMuX3NlcGVyYXRvcih0b3RhbCAtIG1MZW4gKyAxKSlcbiAgfVxuICBpZiAodGhpcy5fX2hlYWRpbmcpIHtcbiAgICBib2R5LnB1c2godGhpcy5fcmVuZGVyUm93KHRoaXMuX19oZWFkaW5nLCAnICcsIHRoaXMuX19oZWFkaW5nQWxpZ24pKVxuICAgIGJvZHkucHVzaCh0aGlzLl9yb3dTZXBlcmF0b3IobUxlbiwgdGhpcy5fX2ZpbGwpKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fX3Jvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBib2R5LnB1c2godGhpcy5fcmVuZGVyUm93KHRoaXMuX19yb3dzW2ldLCAnICcpKVxuICB9XG4gIGJvcmRlciAmJiBib2R5LnB1c2godGhpcy5fc2VwZXJhdG9yKHRvdGFsIC0gbUxlbiArIDEsIHRoaXMuX19ib3R0b20pKVxuXG4gIHZhciBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnXG4gIHJldHVybiBwcmVmaXggKyBib2R5LmpvaW4oJ1xcbicgKyBwcmVmaXgpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbGluZSBzZXBlcmF0b3JcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaW5nIHNpemVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlIHZhbHVlcyAoZGVmYXVsdCAnfCcpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5fc2VwZXJhdG9yID0gZnVuY3Rpb24obGVuLCBzZXApIHtcbiAgc2VwIHx8IChzZXAgPSB0aGlzLl9fZWRnZSlcbiAgcmV0dXJuIHNlcCArIEFzY2lpVGFibGUuYWxpZ25SaWdodChzZXAsIGxlbiwgdGhpcy5fX2ZpbGwpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcm93IHNlcGVyYXRvclxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gc2VwZXJhdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5fcm93U2VwZXJhdG9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciBibGFua3MgPSBBc2NpaVRhYmxlLmFycmF5RmlsbCh0aGlzLl9fbWF4Q2VsbHMsIHRoaXMuX19maWxsKVxuICByZXR1cm4gdGhpcy5fcmVuZGVyUm93KGJsYW5rcywgdGhpcy5fX2ZpbGwpXG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSB0YWJsZSB0aXRsZSBpbiBhIGNlbnRlcmVkIGJveFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpbmcgc2l6ZVxuICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgdGl0bGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLl9yZW5kZXJUaXRsZSA9IGZ1bmN0aW9uKGxlbikge1xuICB2YXIgbmFtZSA9ICcgJyArIHRoaXMuX19uYW1lICsgJyAnXG4gICAgLCBzdHIgPSBBc2NpaVRhYmxlLmFsaWduKHRoaXMuX19uYW1lQWxpZ24sIG5hbWUsIGxlbiAtIDEsICcgJylcbiAgcmV0dXJuIHRoaXMuX19lZGdlICsgc3RyICsgdGhpcy5fX2VkZ2Vcbn1cblxuLyoqXG4gKiBSZW5kZXIgYW4gaW52ZGl2aWR1YWwgcm93XG4gKlxuICogQHBhcmFtIHtBcnJheX0gcm93XG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1uIHNlcGVyYXRvclxuICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsIHJvdyBhbGlnbm1lbnQgKG9wdGlvbmFsLCBkZWZhdWx0IGBhdXRvYClcbiAqIEByZXR1cm4ge1N0cmluZ30gZm9ybWF0dGVkIHJvd1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuX3JlbmRlclJvdyA9IGZ1bmN0aW9uKHJvdywgc3RyLCBhbGlnbikge1xuICB2YXIgdG1wID0gWycnXVxuICAgICwgbWF4ID0gdGhpcy5fX2NvbE1heGVzXG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLl9fbWF4Q2VsbHM7IGsrKykge1xuICAgIHZhciBjZWxsID0gcm93W2tdXG4gICAgICAsIGp1c3QgPSB0aGlzLl9fanVzdGlmeSA/IE1hdGgubWF4LmFwcGx5KG51bGwsIG1heCkgOiBtYXhba11cbiAgICAgIC8vICwgcGFkID0gayA9PT0gdGhpcy5fX21heENlbGxzIC0gMSA/IGp1c3QgOiBqdXN0ICsgdGhpcy5fX3NwYWNpbmdcbiAgICAgICwgcGFkID0ganVzdFxuICAgICAgLCBjQWxpZ24gPSB0aGlzLl9fYWxpZ25zW2tdXG4gICAgICAsIHVzZSA9IGFsaWduXG4gICAgICAsIG1ldGhvZCA9ICdhbGlnbkF1dG8nXG4gIFxuICAgIGlmICh0eXBlb2YgYWxpZ24gPT09ICd1bmRlZmluZWQnKSB1c2UgPSBjQWxpZ25cblxuICAgIGlmICh1c2UgPT09IEFzY2lpVGFibGUuTEVGVCkgbWV0aG9kID0gJ2FsaWduTGVmdCdcbiAgICBpZiAodXNlID09PSBBc2NpaVRhYmxlLkNFTlRFUikgbWV0aG9kID0gJ2FsaWduQ2VudGVyJ1xuICAgIGlmICh1c2UgPT09IEFzY2lpVGFibGUuUklHSFQpIG1ldGhvZCA9ICdhbGlnblJpZ2h0J1xuXG4gICAgdG1wLnB1c2goQXNjaWlUYWJsZVttZXRob2RdKGNlbGwsIHBhZCwgc3RyKSlcbiAgfVxuICB2YXIgZnJvbnQgPSB0bXAuam9pbihzdHIgKyB0aGlzLl9fZWRnZSArIHN0cilcbiAgZnJvbnQgPSBmcm9udC5zdWJzdHIoMSwgZnJvbnQubGVuZ3RoKVxuICByZXR1cm4gZnJvbnQgKyBzdHIgKyB0aGlzLl9fZWRnZVxufVxuXG4vKiFcbiAqIEFsaWFzZXNcbiAqL1xuXG4vLyBDcmVhdGUgbWV0aG9kIHNob3J0Y3V0cyB0byBhbGwgYWxpZ25tZW50IG1ldGhvZHMgZm9yIGVhY2ggZGlyZWN0aW9uXG47WydMZWZ0JywgJ1JpZ2h0JywgJ0NlbnRlciddLmZvckVhY2goZnVuY3Rpb24oZGlyKSB7XG4gIHZhciBjb25zdGFudCA9IEFzY2lpVGFibGVbZGlyLnRvVXBwZXJDYXNlKCldXG5cbiAgO1snc2V0QWxpZ24nLCAnc2V0VGl0bGVBbGlnbicsICdzZXRIZWFkaW5nQWxpZ24nXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIC8vIENhbGwgdGhlIGJhc2UgbWV0aG9kIHdpdGggdGhlIGRpcmVjdGlvbiBjb25zdGFudCBhcyB0aGUgbGFzdCBhcmd1bWVudFxuICAgIEFzY2lpVGFibGUucHJvdG90eXBlW21ldGhvZCArIGRpcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLmNvbmNhdChjb25zdGFudClcbiAgICAgIHJldHVybiB0aGlzW21ldGhvZF0uYXBwbHkodGhpcywgYXJncylcbiAgICB9XG4gIH0pXG59KVxuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBBc2NpaVRhYmxlXG59IGVsc2Uge1xuICB0aGlzLkFzY2lpVGFibGUgPSBBc2NpaVRhYmxlXG59XG5cbn0pLmNhbGwodGhpcyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYXNjaWktdGFibGUnKSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHR2YXIgY2FsbGJhY2tzID0ge307XHJcblxyXG5cdGZ1bmN0aW9uIGFkZChrZXksIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgY2FsbGJhY2tzRm9yS2V5ID0gY2FsbGJhY2tzW2tleV07XHJcblxyXG5cdFx0aWYgKCFjYWxsYmFja3NGb3JLZXkpIHtcclxuXHRcdFx0Y2FsbGJhY2tzRm9yS2V5ID0gW107XHJcblx0XHRcdGNhbGxiYWNrc1trZXldID0gY2FsbGJhY2tzRm9yS2V5O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdMZW4gPSBjYWxsYmFja3NGb3JLZXkucHVzaChjYWxsYmFjayk7XHJcblx0XHR2YXIgaXRlbUluZGV4ID0gbmV3TGVuIC0gMTtcclxuXHJcblx0XHQvLyBjYWxsYmFjayBpZCBpcyBmb3JtZWQgYXMgPGl0ZW0taW5kZXg+XzxrZXk+LCB3ZSB1c2UgdGhhdCBpZCB0byByZW1vdmUgdGhlIGNhbGxiYWNrIFxyXG5cdFx0cmV0dXJuIGl0ZW1JbmRleCArICdfJyArIGtleTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbW92ZShjYWxsYmFja0lkKSB7XHJcblx0XHR2YXIgcGFydHMgPSBjYWxsYmFja0lkLnNwbGl0KCdfJyk7XHJcblx0XHRpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW5kZXggPSBwYXJ0c1swXTtcclxuXHRcdHZhciBrZXkgPSBwYXJ0c1sxXTtcclxuXHRcdFxyXG5cdFx0dmFyIGNhbGxiYWNrQXJyYXkgPSBjYWxsYmFja3Nba2V5XTtcclxuXHRcdGlmICghY2FsbGJhY2tBcnJheSB8fCBjYWxsYmFja0FycmF5Lmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIGNhbGxiYWNrQXJyYXlbaW5kZXhdO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBleGVjdXRlKGtleSwgYXJndW1lbnRzQXJyKSB7XHJcblx0XHR2YXIgY2FsbGJhY2tzRm9yS2V5ID0gY2FsbGJhY2tzW2tleV07XHJcblx0XHRpZiAoIWNhbGxiYWNrc0ZvcktleSB8fCBjYWxsYmFja3NGb3JLZXkubGVuZ3RoID09PSAwKXtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhcmdzID0gW10uc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0XHRjYWxsYmFja3NGb3JLZXkuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuXHRcdFx0Y2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGFkZDogYWRkLFxyXG5cdFx0cmVtb3ZlOiByZW1vdmUsXHJcblx0XHRleGVjdXRlOiBleGVjdXRlXHJcblx0fTtcclxufTtcclxuIiwiLyoqXG4gKiBjdWlkLmpzXG4gKiBDb2xsaXNpb24tcmVzaXN0YW50IFVJRCBnZW5lcmF0b3IgZm9yIGJyb3dzZXJzIGFuZCBub2RlLlxuICogU2VxdWVudGlhbCBmb3IgZmFzdCBkYiBsb29rdXBzIGFuZCByZWNlbmN5IHNvcnRpbmcuXG4gKiBTYWZlIGZvciBlbGVtZW50IElEcyBhbmQgc2VydmVyLXNpZGUgbG9va3Vwcy5cbiAqXG4gKiBFeHRyYWN0ZWQgZnJvbSBDTENUUlxuICpcbiAqIENvcHlyaWdodCAoYykgRXJpYyBFbGxpb3R0IDIwMTJcbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxuLypnbG9iYWwgd2luZG93LCBuYXZpZ2F0b3IsIGRvY3VtZW50LCByZXF1aXJlLCBwcm9jZXNzLCBtb2R1bGUgKi9cbihmdW5jdGlvbiAoYXBwKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIG5hbWVzcGFjZSA9ICdjdWlkJyxcbiAgICBjID0gMCxcbiAgICBibG9ja1NpemUgPSA0LFxuICAgIGJhc2UgPSAzNixcbiAgICBkaXNjcmV0ZVZhbHVlcyA9IE1hdGgucG93KGJhc2UsIGJsb2NrU2l6ZSksXG5cbiAgICBwYWQgPSBmdW5jdGlvbiBwYWQobnVtLCBzaXplKSB7XG4gICAgICB2YXIgcyA9IFwiMDAwMDAwMDAwXCIgKyBudW07XG4gICAgICByZXR1cm4gcy5zdWJzdHIocy5sZW5ndGgtc2l6ZSk7XG4gICAgfSxcblxuICAgIHJhbmRvbUJsb2NrID0gZnVuY3Rpb24gcmFuZG9tQmxvY2soKSB7XG4gICAgICByZXR1cm4gcGFkKChNYXRoLnJhbmRvbSgpICpcbiAgICAgICAgICAgIGRpc2NyZXRlVmFsdWVzIDw8IDApXG4gICAgICAgICAgICAudG9TdHJpbmcoYmFzZSksIGJsb2NrU2l6ZSk7XG4gICAgfSxcblxuICAgIHNhZmVDb3VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgYyA9IChjIDwgZGlzY3JldGVWYWx1ZXMpID8gYyA6IDA7XG4gICAgICBjKys7IC8vIHRoaXMgaXMgbm90IHN1YmxpbWluYWxcbiAgICAgIHJldHVybiBjIC0gMTtcbiAgICB9LFxuXG4gICAgYXBpID0gZnVuY3Rpb24gY3VpZCgpIHtcbiAgICAgIC8vIFN0YXJ0aW5nIHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyIG1ha2VzXG4gICAgICAvLyBpdCBIVE1MIGVsZW1lbnQgSUQgZnJpZW5kbHkuXG4gICAgICB2YXIgbGV0dGVyID0gJ2MnLCAvLyBoYXJkLWNvZGVkIGFsbG93cyBmb3Igc2VxdWVudGlhbCBhY2Nlc3NcblxuICAgICAgICAvLyB0aW1lc3RhbXBcbiAgICAgICAgLy8gd2FybmluZzogdGhpcyBleHBvc2VzIHRoZSBleGFjdCBkYXRlIGFuZCB0aW1lXG4gICAgICAgIC8vIHRoYXQgdGhlIHVpZCB3YXMgY3JlYXRlZC5cbiAgICAgICAgdGltZXN0YW1wID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKS50b1N0cmluZyhiYXNlKSxcblxuICAgICAgICAvLyBQcmV2ZW50IHNhbWUtbWFjaGluZSBjb2xsaXNpb25zLlxuICAgICAgICBjb3VudGVyLFxuXG4gICAgICAgIC8vIEEgZmV3IGNoYXJzIHRvIGdlbmVyYXRlIGRpc3RpbmN0IGlkcyBmb3IgZGlmZmVyZW50XG4gICAgICAgIC8vIGNsaWVudHMgKHNvIGRpZmZlcmVudCBjb21wdXRlcnMgYXJlIGZhciBsZXNzXG4gICAgICAgIC8vIGxpa2VseSB0byBnZW5lcmF0ZSB0aGUgc2FtZSBpZClcbiAgICAgICAgZmluZ2VycHJpbnQgPSBhcGkuZmluZ2VycHJpbnQoKSxcblxuICAgICAgICAvLyBHcmFiIHNvbWUgbW9yZSBjaGFycyBmcm9tIE1hdGgucmFuZG9tKClcbiAgICAgICAgcmFuZG9tID0gcmFuZG9tQmxvY2soKSArIHJhbmRvbUJsb2NrKCk7XG5cbiAgICAgICAgY291bnRlciA9IHBhZChzYWZlQ291bnRlcigpLnRvU3RyaW5nKGJhc2UpLCBibG9ja1NpemUpO1xuXG4gICAgICByZXR1cm4gIChsZXR0ZXIgKyB0aW1lc3RhbXAgKyBjb3VudGVyICsgZmluZ2VycHJpbnQgKyByYW5kb20pO1xuICAgIH07XG5cbiAgYXBpLnNsdWcgPSBmdW5jdGlvbiBzbHVnKCkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoMzYpLFxuICAgICAgY291bnRlcixcbiAgICAgIHByaW50ID0gYXBpLmZpbmdlcnByaW50KCkuc2xpY2UoMCwxKSArXG4gICAgICAgIGFwaS5maW5nZXJwcmludCgpLnNsaWNlKC0xKSxcbiAgICAgIHJhbmRvbSA9IHJhbmRvbUJsb2NrKCkuc2xpY2UoLTIpO1xuXG4gICAgICBjb3VudGVyID0gc2FmZUNvdW50ZXIoKS50b1N0cmluZygzNikuc2xpY2UoLTQpO1xuXG4gICAgcmV0dXJuIGRhdGUuc2xpY2UoLTIpICtcbiAgICAgIGNvdW50ZXIgKyBwcmludCArIHJhbmRvbTtcbiAgfTtcblxuICBhcGkuZ2xvYmFsQ291bnQgPSBmdW5jdGlvbiBnbG9iYWxDb3VudCgpIHtcbiAgICAvLyBXZSB3YW50IHRvIGNhY2hlIHRoZSByZXN1bHRzIG9mIHRoaXNcbiAgICB2YXIgY2FjaGUgPSAoZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgY291bnQgPSAwO1xuXG4gICAgICAgIGZvciAoaSBpbiB3aW5kb3cpIHtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgfSgpKTtcblxuICAgIGFwaS5nbG9iYWxDb3VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9O1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICBhcGkuZmluZ2VycHJpbnQgPSBmdW5jdGlvbiBicm93c2VyUHJpbnQoKSB7XG4gICAgcmV0dXJuIHBhZCgobmF2aWdhdG9yLm1pbWVUeXBlcy5sZW5ndGggK1xuICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5sZW5ndGgpLnRvU3RyaW5nKDM2KSArXG4gICAgICBhcGkuZ2xvYmFsQ291bnQoKS50b1N0cmluZygzNiksIDQpO1xuICB9O1xuXG4gIC8vIGRvbid0IGNoYW5nZSBhbnl0aGluZyBmcm9tIGhlcmUgZG93bi5cbiAgaWYgKGFwcC5yZWdpc3Rlcikge1xuICAgIGFwcC5yZWdpc3RlcihuYW1lc3BhY2UsIGFwaSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGFwaTtcbiAgfSBlbHNlIHtcbiAgICBhcHBbbmFtZXNwYWNlXSA9IGFwaTtcbiAgfVxuXG59KHRoaXMpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cbi8vIE9ubHkgTm9kZS5KUyBoYXMgYSBwcm9jZXNzIHZhcmlhYmxlIHRoYXQgaXMgb2YgW1tDbGFzc11dIHByb2Nlc3NcbnRyeSB7XG4gbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScgXG59IGNhdGNoKGUpIHt9XG4iLCIvKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuICogQGxpY2Vuc2UgZXM1LXNoaW0gQ29weXJpZ2h0IDIwMDktMjAxNSBieSBjb250cmlidXRvcnMsIE1JVCBMaWNlbnNlXG4gKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG4vLyB2aW06IHRzPTQgc3RzPTQgc3c9NCBleHBhbmR0YWJcblxuLy8gQWRkIHNlbWljb2xvbiB0byBwcmV2ZW50IElJRkUgZnJvbSBiZWluZyBwYXNzZWQgYXMgYXJndW1lbnQgdG8gY29uY2F0ZW5hdGVkIGNvZGUuXG47XG5cbi8vIFVNRCAoVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uKVxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvdGVtcGxhdGVzL3JldHVybkV4cG9ydHMuanNcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGdsb2JhbCBkZWZpbmUsIGV4cG9ydHMsIG1vZHVsZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGNhbGwgPSBGdW5jdGlvbi5jYWxsO1xuICAgIHZhciBwcm90b3R5cGVPZk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyIG93bnMgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuaGFzT3duUHJvcGVydHkpO1xuICAgIHZhciBpc0VudW1lcmFibGUgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUpO1xuICAgIHZhciB0b1N0ciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC50b1N0cmluZyk7XG5cbiAgICAvLyBJZiBKUyBlbmdpbmUgc3VwcG9ydHMgYWNjZXNzb3JzIGNyZWF0aW5nIHNob3J0Y3V0cy5cbiAgICB2YXIgZGVmaW5lR2V0dGVyO1xuICAgIHZhciBkZWZpbmVTZXR0ZXI7XG4gICAgdmFyIGxvb2t1cEdldHRlcjtcbiAgICB2YXIgbG9va3VwU2V0dGVyO1xuICAgIHZhciBzdXBwb3J0c0FjY2Vzc29ycyA9IG93bnMocHJvdG90eXBlT2ZPYmplY3QsICdfX2RlZmluZUdldHRlcl9fJyk7XG4gICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG4gICAgICAgIGRlZmluZUdldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZUdldHRlcl9fKTtcbiAgICAgICAgZGVmaW5lU2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18pO1xuICAgICAgICBsb29rdXBHZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBHZXR0ZXJfXyk7XG4gICAgICAgIGxvb2t1cFNldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cFNldHRlcl9fKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuICAgIH1cblxuICAgIHZhciBpc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG8pIHtcbiAgICAgICAgcmV0dXJuIG8gPT0gbnVsbCB8fCAodHlwZW9mIG8gIT09ICdvYmplY3QnICYmIHR5cGVvZiBvICE9PSAnZnVuY3Rpb24nKTtcbiAgICB9O1xuXG4gICAgLy8gRVM1IDE1LjIuMy4yXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjJcbiAgICBpZiAoIU9iamVjdC5nZXRQcm90b3R5cGVPZikge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzI2lzc3VlLzJcbiAgICAgICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL29iamVjdGdldHByb3RvdHlwZW9mL1xuICAgICAgICAvLyByZWNvbW1lbmRlZCBieSBmc2NoYWVmZXIgb24gZ2l0aHViXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHN1cmUsIGFuZCB3ZWJyZWZsZWN0aW9uIHNheXMgXl9eXG4gICAgICAgIC8vIC4uLiB0aGlzIHdpbGwgbmVyZXZlciBwb3NzaWJseSByZXR1cm4gbnVsbFxuICAgICAgICAvLyAuLi4gT3BlcmEgTWluaSBicmVha3MgaGVyZSB3aXRoIGluZmluaXRlIGxvb3BzXG4gICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKG9iamVjdCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgICAgIHZhciBwcm90byA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICBpZiAocHJvdG8gfHwgcHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvU3RyKG9iamVjdC5jb25zdHJ1Y3RvcikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb3JyZWN0bHkgcmV0dXJuIG51bGwgZm9yIE9iamVjdHMgY3JlYXRlZCB3aXRoIGBPYmplY3QuY3JlYXRlKG51bGwpYFxuICAgICAgICAgICAgICAgIC8vIChzaGFtbWVkIG9yIG5hdGl2ZSkgb3IgYHsgX19wcm90b19fOiBudWxsfWAuICBBbHNvIHJldHVybnMgbnVsbCBmb3JcbiAgICAgICAgICAgICAgICAvLyBjcm9zcy1yZWFsbSBvYmplY3RzIG9uIGJyb3dzZXJzIHRoYXQgbGFjayBgX19wcm90b19fYCBzdXBwb3J0IChsaWtlXG4gICAgICAgICAgICAgICAgLy8gSUUgPDExKSwgYnV0IHRoYXQncyB0aGUgYmVzdCB3ZSBjYW4gZG8uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy4zXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjNcblxuICAgIHZhciBkb2VzR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29yayA9IGZ1bmN0aW9uIGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKG9iamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqZWN0LnNlbnRpbmVsID0gMDtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgJ3NlbnRpbmVsJykudmFsdWUgPT09IDA7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHdvcmtzIGlmIGl0J3MgZ2l2ZW4uIE90aGVyd2lzZSwgc2hpbSBwYXJ0aWFsbHkuXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29ya3NPbk9iamVjdCA9IGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKHt9KTtcbiAgICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmtzT25Eb20gPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgaWYgKCFnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3Jrc09uRG9tIHx8ICFnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3Jrc09uT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRmFsbGJhY2sgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHx8IGdldE93blByb3BlcnR5RGVzY3JpcHRvckZhbGxiYWNrKSB7XG4gICAgICAgIHZhciBFUlJfTk9OX09CSkVDVCA9ICdPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIGNhbGxlZCBvbiBhIG5vbi1vYmplY3Q6ICc7XG5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1QgKyBvYmplY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICAgICAgICAgIC8vIGZvciBJOCdzIERPTSBlbGVtZW50cy5cbiAgICAgICAgICAgIGlmIChnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgICAgICAgICAgLy8gSWYgb2JqZWN0IGRvZXMgbm90IG93bnMgcHJvcGVydHkgcmV0dXJuIHVuZGVmaW5lZCBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIGlmICghb3ducyhvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBvYmplY3QgaGFzIGEgcHJvcGVydHkgdGhlbiBpdCdzIGZvciBzdXJlIGBjb25maWd1cmFibGVgLCBhbmRcbiAgICAgICAgICAgIC8vIHByb2JhYmx5IGBlbnVtZXJhYmxlYC4gRGV0ZWN0IGVudW1lcmFiaWxpdHkgdGhvdWdoLlxuICAgICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBpc0VudW1lcmFibGUob2JqZWN0LCBwcm9wZXJ0eSksXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBJZiBKUyBlbmdpbmUgc3VwcG9ydHMgYWNjZXNzb3IgcHJvcGVydGllcyB0aGVuIHByb3BlcnR5IG1heSBiZSBhXG4gICAgICAgICAgICAvLyBnZXR0ZXIgb3Igc2V0dGVyLlxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSBgX19sb29rdXBHZXR0ZXJfX2Agd2lsbCByZXR1cm4gYSBnZXR0ZXIgZXZlblxuICAgICAgICAgICAgICAgIC8vIGlmIG9iamVjdCBoYXMgb3duIG5vbiBnZXR0ZXIgcHJvcGVydHkgYWxvbmcgd2l0aCBhIHNhbWUgbmFtZWRcbiAgICAgICAgICAgICAgICAvLyBpbmhlcml0ZWQgZ2V0dGVyLiBUbyBhdm9pZCBtaXNiZWhhdmlvciB3ZSB0ZW1wb3JhcnkgcmVtb3ZlXG4gICAgICAgICAgICAgICAgLy8gYF9fcHJvdG9fX2Agc28gdGhhdCBgX19sb29rdXBHZXR0ZXJfX2Agd2lsbCByZXR1cm4gZ2V0dGVyIG9ubHlcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIG93bmVkIGJ5IGFuIG9iamVjdC5cbiAgICAgICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gb2JqZWN0Ll9fcHJvdG9fXztcbiAgICAgICAgICAgICAgICB2YXIgbm90UHJvdG90eXBlT2ZPYmplY3QgPSBvYmplY3QgIT09IHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHJlY3Vyc2lvbiBwcm9ibGVtLCBicmVha2luZyBpbiBPcGVyYSBNaW5pIHdoZW5cbiAgICAgICAgICAgICAgICAvLyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycpXG4gICAgICAgICAgICAgICAgLy8gb3IgYW55IG90aGVyIE9iamVjdC5wcm90b3R5cGUgYWNjZXNzb3JcbiAgICAgICAgICAgICAgICBpZiAobm90UHJvdG90eXBlT2ZPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgdmFyIHNldHRlciA9IGxvb2t1cFNldHRlcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmIChub3RQcm90b3R5cGVPZk9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIHdlIGhhdmUgZ2V0dGVyIGFuZCBzZXR0ZXIgd2UgY2FuIHB1dCB2YWx1ZXMgYmFjay5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyIHx8IHNldHRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGdldHRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNldCA9IHNldHRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCB3YXMgYWNjZXNzb3IgcHJvcGVydHkgd2UncmUgZG9uZSBhbmQgcmV0dXJuIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgYWRkaW5nIGB2YWx1ZWAgdG8gdGhlIGRlc2NyaXB0b3IuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHdlIGtub3cgdGhhdCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB0aGF0IGlzXG4gICAgICAgICAgICAvLyBub3QgYW4gYWNjZXNzb3Igc28gd2Ugc2V0IGl0IGFzIGEgdmFsdWUgYW5kIHJldHVybiBkZXNjcmlwdG9yLlxuICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy40XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjRcbiAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuNVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy41XG4gICAgaWYgKCFPYmplY3QuY3JlYXRlKSB7XG5cbiAgICAgICAgLy8gQ29udHJpYnV0ZWQgYnkgQnJhbmRvbiBCZW52aWUsIE9jdG9iZXIsIDIwMTJcbiAgICAgICAgdmFyIGNyZWF0ZUVtcHR5O1xuICAgICAgICB2YXIgc3VwcG9ydHNQcm90byA9ICEoeyBfX3Byb3RvX186IG51bGwgfSBpbnN0YW5jZW9mIE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBwcm9kdWNlcyBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBPcGVyYSBNaW5pID0+IG5vdCBhIHJlbGlhYmxlIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0LnByb3RvdHlwZS5fX3Byb3RvX18gPT09IG51bGxcblxuICAgICAgICAvLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4gICAgICAgIC8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4gICAgICAgIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG4gICAgICAgIHZhciBzaG91bGRVc2VBY3RpdmVYID0gZnVuY3Rpb24gc2hvdWxkVXNlQWN0aXZlWCgpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBlYXJseSBpZiBkb2N1bWVudC5kb21haW4gbm90IHNldFxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5kb21haW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGhpcyBzdXBwb3J0cyBJRTggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgdXNlZFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbiAgICAgICAgLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbiAgICAgICAgdmFyIGdldEVtcHR5VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIGdldEVtcHR5VmlhQWN0aXZlWCgpIHtcbiAgICAgICAgICAgIHZhciBlbXB0eTtcbiAgICAgICAgICAgIHZhciB4RG9jO1xuXG4gICAgICAgICAgICB4RG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSAnc2NyaXB0JztcbiAgICAgICAgICAgIHhEb2Mud3JpdGUoJzwnICsgc2NyaXB0ICsgJz48LycgKyBzY3JpcHQgKyAnPicpO1xuICAgICAgICAgICAgeERvYy5jbG9zZSgpO1xuXG4gICAgICAgICAgICBlbXB0eSA9IHhEb2MucGFyZW50V2luZG93Lk9iamVjdC5wcm90b3R5cGU7XG4gICAgICAgICAgICB4RG9jID0gbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiB1c2luZyBhbiBpZnJhbWVcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBhY3RpdmV4IGFwcHJvYWNoIHdhcyBhZGRlZFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbiAgICAgICAgdmFyIGdldEVtcHR5VmlhSUZyYW1lID0gZnVuY3Rpb24gZ2V0RW1wdHlWaWFJRnJhbWUoKSB7XG4gICAgICAgICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgZW1wdHk7XG5cbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zY3JpcHQtdXJsICovXG4gICAgICAgICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JztcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2NyaXB0LXVybCAqL1xuXG4gICAgICAgICAgICBlbXB0eSA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdC5wcm90b3R5cGU7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKiBnbG9iYWwgZG9jdW1lbnQgKi9cbiAgICAgICAgaWYgKHN1cHBvcnRzUHJvdG8gfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY3JlYXRlRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgX19wcm90b19fOiBudWxsIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gb2xkIElFIF9fcHJvdG9fXyBjYW4ndCBiZSB1c2VkIHRvIG1hbnVhbGx5IHNldCBgbnVsbGAsIG5vciBkb2VzXG4gICAgICAgICAgICAvLyBhbnkgb3RoZXIgbWV0aG9kIGV4aXN0IHRvIG1ha2UgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBub3RoaW5nLFxuICAgICAgICAgICAgLy8gYXNpZGUgZnJvbSBPYmplY3QucHJvdG90eXBlIGl0c2VsZi4gSW5zdGVhZCwgY3JlYXRlIGEgbmV3IGdsb2JhbFxuICAgICAgICAgICAgLy8gb2JqZWN0IGFuZCAqc3RlYWwqIGl0cyBPYmplY3QucHJvdG90eXBlIGFuZCBzdHJpcCBpdCBiYXJlLiBUaGlzIGlzXG4gICAgICAgICAgICAvLyB1c2VkIGFzIHRoZSBwcm90b3R5cGUgdG8gY3JlYXRlIG51bGxhcnkgb2JqZWN0cy5cbiAgICAgICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBhcHByb2FjaCB0byB1c2VcbiAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbiAgICAgICAgICAgICAgICB2YXIgZW1wdHkgPSBzaG91bGRVc2VBY3RpdmVYKCkgPyBnZXRFbXB0eVZpYUFjdGl2ZVgoKSA6IGdldEVtcHR5VmlhSUZyYW1lKCk7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgZW1wdHkuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVtcHR5Lmhhc093blByb3BlcnR5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW1wdHkuaXNQcm90b3R5cGVPZjtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW1wdHkudG9Mb2NhbGVTdHJpbmc7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVtcHR5LnRvU3RyaW5nO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS52YWx1ZU9mO1xuXG4gICAgICAgICAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBlbXB0eTtcbiAgICAgICAgICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IGZ1dHVyZSBjYWxsc1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcblxuICAgICAgICAgICAgdmFyIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBUeXBlID0gZnVuY3Rpb24gVHlwZSgpIHt9OyAvLyBBbiBlbXB0eSBjb25zdHJ1Y3Rvci5cblxuICAgICAgICAgICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IGNyZWF0ZUVtcHR5KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcm90b3R5cGUgIT09IG51bGwgJiYgaXNQcmltaXRpdmUocHJvdG90eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uIGBwYXJlbnRgIGNhbiBiZSBgbnVsbGBcbiAgICAgICAgICAgICAgICAgICAgLy8gT1IgKmFueSogYGluc3RhbmNlb2YgT2JqZWN0YCAgKE9iamVjdHxGdW5jdGlvbnxBcnJheXxSZWdFeHB8ZXRjKVxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYHR5cGVvZmAgdGhvLCBiL2MgaW4gb2xkIElFLCBET00gZWxlbWVudHMgYXJlIG5vdCBgaW5zdGFuY2VvZiBPYmplY3RgXG4gICAgICAgICAgICAgICAgICAgIC8vIGxpa2UgdGhleSBhcmUgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2luZyBgT2JqZWN0LmNyZWF0ZWAgb24gRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzLi4uZXJyLi4ucHJvYmFibHkgaW5hcHByb3ByaWF0ZSwgYnV0IHRoZSBuYXRpdmUgdmVyc2lvbiBhbGxvd3MgZm9yIGl0LlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgcHJvdG90eXBlIG1heSBvbmx5IGJlIGFuIE9iamVjdCBvciBudWxsJyk7IC8vIHNhbWUgbXNnIGFzIENocm9tZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVHlwZSgpO1xuICAgICAgICAgICAgICAgIC8vIElFIGhhcyBubyBidWlsdC1pbiBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmdldFByb3RvdHlwZU9mYFxuICAgICAgICAgICAgICAgIC8vIG5laXRoZXIgYF9fcHJvdG9fX2AsIGJ1dCB0aGlzIG1hbnVhbGx5IHNldHRpbmcgYF9fcHJvdG9fX2Agd2lsbFxuICAgICAgICAgICAgICAgIC8vIGd1YXJhbnRlZSB0aGF0IGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIHdpbGwgd29yayBhcyBleHBlY3RlZCB3aXRoXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIGBPYmplY3QuY3JlYXRlYFxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuNlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy42XG5cbiAgICAvLyBQYXRjaCBmb3IgV2ViS2l0IGFuZCBJRTggc3RhbmRhcmQgbW9kZVxuICAgIC8vIERlc2lnbmVkIGJ5IGhheCA8aGF4LmdpdGh1Yi5jb20+XG4gICAgLy8gcmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3VlcyNpc3N1ZS81XG4gICAgLy8gSUU4IFJlZmVyZW5jZTpcbiAgICAvLyAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RkMjgyOTAwLmFzcHhcbiAgICAvLyAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RkMjI5OTE2LmFzcHhcbiAgICAvLyBXZWJLaXQgQnVnczpcbiAgICAvLyAgICAgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTM2NDIzXG5cbiAgICB2YXIgZG9lc0RlZmluZVByb3BlcnR5V29yayA9IGZ1bmN0aW9uIGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsob2JqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2VudGluZWwnLCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gJ3NlbnRpbmVsJyBpbiBvYmplY3Q7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgZGVmaW5lUHJvcGVydHkgd29ya3MgaWYgaXQncyBnaXZlbi4gT3RoZXJ3aXNlLFxuICAgIC8vIHNoaW0gcGFydGlhbGx5LlxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdCA9IGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoe30pO1xuICAgICAgICB2YXIgZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgZG9lc0RlZmluZVByb3BlcnR5V29yayhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgIGlmICghZGVmaW5lUHJvcGVydHlXb3Jrc09uT2JqZWN0IHx8ICFkZWZpbmVQcm9wZXJ0eVdvcmtzT25Eb20pIHtcbiAgICAgICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXNGYWxsYmFjayA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZGVmaW5lUHJvcGVydHlGYWxsYmFjaykge1xuICAgICAgICB2YXIgRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiA9ICdQcm9wZXJ0eSBkZXNjcmlwdGlvbiBtdXN0IGJlIGFuIG9iamVjdDogJztcbiAgICAgICAgdmFyIEVSUl9OT05fT0JKRUNUX1RBUkdFVCA9ICdPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbGVkIG9uIG5vbi1vYmplY3Q6ICc7XG4gICAgICAgIHZhciBFUlJfQUNDRVNTT1JTX05PVF9TVVBQT1JURUQgPSAnZ2V0dGVycyAmIHNldHRlcnMgY2FuIG5vdCBiZSBkZWZpbmVkIG9uIHRoaXMgamF2YXNjcmlwdCBlbmdpbmUnO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZShvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVF9UQVJHRVQgKyBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVF9ERVNDUklQVE9SICsgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBkZWZpbmVQcm9wZXJ0eVxuICAgICAgICAgICAgLy8gZm9yIEk4J3MgRE9NIGVsZW1lbnRzLlxuICAgICAgICAgICAgaWYgKGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHlGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBpdCdzIGEgZGF0YSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICAvLyBmYWlsIHNpbGVudGx5IGlmICd3cml0YWJsZScsICdlbnVtZXJhYmxlJywgb3IgJ2NvbmZpZ3VyYWJsZSdcbiAgICAgICAgICAgICAgICAvLyBhcmUgcmVxdWVzdGVkIGJ1dCBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAvLyBhbHRlcm5hdGUgYXBwcm9hY2g6XG4gICAgICAgICAgICAgICAgaWYgKCAvLyBjYW4ndCBpbXBsZW1lbnQgdGhlc2UgZmVhdHVyZXM7IGFsbG93IGZhbHNlIGJ1dCBub3QgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAoJ3dyaXRhYmxlJyBpbiBkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLndyaXRhYmxlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoJ2VudW1lcmFibGUnIGluIGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCdjb25maWd1cmFibGUnIGluIGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKVxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RoaXMgaW1wbGVtZW50YXRpb24gb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5IGRvZXMgbm90IHN1cHBvcnQgY29uZmlndXJhYmxlLCBlbnVtZXJhYmxlLCBvciB3cml0YWJsZS4nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycyAmJiAobG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcGVydHkpIHx8IGxvb2t1cFNldHRlcihvYmplY3QsIHByb3BlcnR5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXMgYWNjZXNzb3JzIGFyZSBzdXBwb3J0ZWQgb25seSBvbiBlbmdpbmVzIGltcGxlbWVudGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBgX19wcm90b19fYCB3ZSBjYW4gc2FmZWx5IG92ZXJyaWRlIGBfX3Byb3RvX19gIHdoaWxlIGRlZmluaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcHJvcGVydHkgdG8gbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgaGl0IGFuIGluaGVyaXRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3Nvci5cbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRpbmcgYSBwcm9wZXJ0eSBhbnl3YXkgc2luY2UgZ2V0dGVyIC8gc2V0dGVyIG1heSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZpbmVkIG9uIG9iamVjdCBpdHNlbGYuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyBvcmlnaW5hbCBgX19wcm90b19fYCBiYWNrIG5vdy5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0dldHRlciA9ICdnZXQnIGluIGRlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1NldHRlciA9ICdzZXQnIGluIGRlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0FjY2Vzc29ycyAmJiAoaGFzR2V0dGVyIHx8IGhhc1NldHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ290IHRoYXQgZmFyIHRoZW4gZ2V0dGVycyBhbmQgc2V0dGVycyBjYW4gYmUgZGVmaW5lZCAhIVxuICAgICAgICAgICAgICAgIGlmIChoYXNHZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lR2V0dGVyKG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NldHRlcikge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVTZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvci5zZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy43XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjdcbiAgICBpZiAoIU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIHx8IGRlZmluZVByb3BlcnRpZXNGYWxsYmFjaykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBkZWZpbmVQcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnRpZXNGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBzaGltIGlmIHRoZSByZWFsIG9uZSBkb2Vzbid0IHdvcmtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgcHJvcGVydGllc1twcm9wZXJ0eV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjhcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuOFxuICAgIGlmICghT2JqZWN0LnNlYWwpIHtcbiAgICAgICAgT2JqZWN0LnNlYWwgPSBmdW5jdGlvbiBzZWFsKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Quc2VhbCBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbWlzbGVhZGluZyBhbmQgYnJlYWtzIGZlYXR1cmUtZGV0ZWN0aW9uLCBidXRcbiAgICAgICAgICAgIC8vIGFsbG93cyBcInNlY3VyYWJsZVwiIGNvZGUgdG8gXCJncmFjZWZ1bGx5XCIgZGVncmFkZSB0byB3b3JraW5nXG4gICAgICAgICAgICAvLyBidXQgaW5zZWN1cmUgY29kZS5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy45XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjlcbiAgICBpZiAoIU9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZShvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmZyZWV6ZSBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbWlzbGVhZGluZyBhbmQgYnJlYWtzIGZlYXR1cmUtZGV0ZWN0aW9uLCBidXRcbiAgICAgICAgICAgIC8vIGFsbG93cyBcInNlY3VyYWJsZVwiIGNvZGUgdG8gXCJncmFjZWZ1bGx5XCIgZGVncmFkZSB0byB3b3JraW5nXG4gICAgICAgICAgICAvLyBidXQgaW5zZWN1cmUgY29kZS5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IGEgUmhpbm8gYnVnIGFuZCBwYXRjaCBpdFxuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKCkge30pO1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICBPYmplY3QuZnJlZXplID0gKGZ1bmN0aW9uIChmcmVlemVPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBmcmVlemUob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJlZXplT2JqZWN0KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfShPYmplY3QuZnJlZXplKSk7XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy4xMFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xMFxuICAgIGlmICghT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG4gICAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QucHJldmVudEV4dGVuc2lvbnMgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIE9iamVjdHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1pc2xlYWRpbmcgYW5kIGJyZWFrcyBmZWF0dXJlLWRldGVjdGlvbiwgYnV0XG4gICAgICAgICAgICAvLyBhbGxvd3MgXCJzZWN1cmFibGVcIiBjb2RlIHRvIFwiZ3JhY2VmdWxseVwiIGRlZ3JhZGUgdG8gd29ya2luZ1xuICAgICAgICAgICAgLy8gYnV0IGluc2VjdXJlIGNvZGUuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuMTFcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTFcbiAgICBpZiAoIU9iamVjdC5pc1NlYWxlZCkge1xuICAgICAgICBPYmplY3QuaXNTZWFsZWQgPSBmdW5jdGlvbiBpc1NlYWxlZChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmlzU2VhbGVkIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuMTJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTJcbiAgICBpZiAoIU9iamVjdC5pc0Zyb3plbikge1xuICAgICAgICBPYmplY3QuaXNGcm96ZW4gPSBmdW5jdGlvbiBpc0Zyb3plbihvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmlzRnJvemVuIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuMTNcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTNcbiAgICBpZiAoIU9iamVjdC5pc0V4dGVuc2libGUpIHtcbiAgICAgICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIDEuIElmIFR5cGUoTykgaXMgbm90IE9iamVjdCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgICBpZiAoT2JqZWN0KG9iamVjdCkgIT09IG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5pc0V4dGVuc2libGUgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIE9iamVjdHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyLiBSZXR1cm4gdGhlIEJvb2xlYW4gdmFsdWUgb2YgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIE8uXG4gICAgICAgICAgICB2YXIgbmFtZSA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKG93bnMob2JqZWN0LCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJz8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0W25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG93bnMob2JqZWN0LCBuYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG59KSk7XG4iLCIvKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuICogQGxpY2Vuc2UgZXM1LXNoaW0gQ29weXJpZ2h0IDIwMDktMjAxNSBieSBjb250cmlidXRvcnMsIE1JVCBMaWNlbnNlXG4gKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG4vLyB2aW06IHRzPTQgc3RzPTQgc3c9NCBleHBhbmR0YWJcblxuLy8gQWRkIHNlbWljb2xvbiB0byBwcmV2ZW50IElJRkUgZnJvbSBiZWluZyBwYXNzZWQgYXMgYXJndW1lbnQgdG8gY29uY2F0ZW5hdGVkIGNvZGUuXG47XG5cbi8vIFVNRCAoVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uKVxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvdGVtcGxhdGVzL3JldHVybkV4cG9ydHMuanNcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGdsb2JhbCBkZWZpbmUsIGV4cG9ydHMsIG1vZHVsZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEJyaW5ncyBhbiBlbnZpcm9ubWVudCBhcyBjbG9zZSB0byBFQ01BU2NyaXB0IDUgY29tcGxpYW5jZVxuICAgICAqIGFzIGlzIHBvc3NpYmxlIHdpdGggdGhlIGZhY2lsaXRpZXMgb2YgZXJzdHdoaWxlIGVuZ2luZXMuXG4gICAgICpcbiAgICAgKiBBbm5vdGF0ZWQgRVM1OiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vIChzcGVjaWZpYyBsaW5rcyBiZWxvdylcbiAgICAgKiBFUzUgU3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VjbWEtMjYyLnBkZlxuICAgICAqIFJlcXVpcmVkIHJlYWRpbmc6IGh0dHA6Ly9qYXZhc2NyaXB0d2VibG9nLndvcmRwcmVzcy5jb20vMjAxMS8xMi8wNS9leHRlbmRpbmctamF2YXNjcmlwdC1uYXRpdmVzL1xuICAgICAqL1xuXG4gICAgLy8gU2hvcnRjdXQgdG8gYW4gb2Z0ZW4gYWNjZXNzZWQgcHJvcGVydGllcywgaW4gb3JkZXIgdG8gYXZvaWQgbXVsdGlwbGVcbiAgICAvLyBkZXJlZmVyZW5jZSB0aGF0IGNvc3RzIHVuaXZlcnNhbGx5LiBUaGlzIGFsc28gaG9sZHMgYSByZWZlcmVuY2UgdG8ga25vd24tZ29vZFxuICAgIC8vIGZ1bmN0aW9ucy5cbiAgICB2YXIgJEFycmF5ID0gQXJyYXk7XG4gICAgdmFyIEFycmF5UHJvdG90eXBlID0gJEFycmF5LnByb3RvdHlwZTtcbiAgICB2YXIgJE9iamVjdCA9IE9iamVjdDtcbiAgICB2YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xuICAgIHZhciBGdW5jdGlvblByb3RvdHlwZSA9ICRGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgdmFyICRTdHJpbmcgPSBTdHJpbmc7XG4gICAgdmFyIFN0cmluZ1Byb3RvdHlwZSA9ICRTdHJpbmcucHJvdG90eXBlO1xuICAgIHZhciAkTnVtYmVyID0gTnVtYmVyO1xuICAgIHZhciBOdW1iZXJQcm90b3R5cGUgPSAkTnVtYmVyLnByb3RvdHlwZTtcbiAgICB2YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcbiAgICB2YXIgYXJyYXlfc3BsaWNlID0gQXJyYXlQcm90b3R5cGUuc3BsaWNlO1xuICAgIHZhciBhcnJheV9wdXNoID0gQXJyYXlQcm90b3R5cGUucHVzaDtcbiAgICB2YXIgYXJyYXlfdW5zaGlmdCA9IEFycmF5UHJvdG90eXBlLnVuc2hpZnQ7XG4gICAgdmFyIGFycmF5X2NvbmNhdCA9IEFycmF5UHJvdG90eXBlLmNvbmNhdDtcbiAgICB2YXIgYXJyYXlfam9pbiA9IEFycmF5UHJvdG90eXBlLmpvaW47XG4gICAgdmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuICAgIHZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWluID0gTWF0aC5taW47XG5cbiAgICAvLyBIYXZpbmcgYSB0b1N0cmluZyBsb2NhbCB2YXJpYWJsZSBuYW1lIGJyZWFrcyBpbiBPcGVyYSBzbyB1c2UgdG9fc3RyaW5nLlxuICAgIHZhciB0b19zdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAvKiBnbG9iYWwgU3ltYm9sICovXG4gICAgLyogZXNsaW50LWRpc2FibGUgb25lLXZhci1kZWNsYXJhdGlvbi1wZXItbGluZSwgbm8tcmVkZWNsYXJlLCBtYXgtc3RhdGVtZW50cy1wZXItbGluZSAqL1xuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG4gICAgdmFyIGlzQ2FsbGFibGU7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1jYWxsYWJsZSAqLyB2YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZywgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzIC8sIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGbih2YWx1ZSkgeyB0cnkgeyB2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpOyB2YXIgc2luZ2xlU3RyaXBwZWQgPSBmblN0ci5yZXBsYWNlKC9cXC9cXC8uKlxcbi9nLCAnJyk7IHZhciBtdWx0aVN0cmlwcGVkID0gc2luZ2xlU3RyaXBwZWQucmVwbGFjZSgvXFwvXFwqWy5cXHNcXFNdKlxcKlxcLy9nLCAnJyk7IHZhciBzcGFjZVN0cmlwcGVkID0gbXVsdGlTdHJpcHBlZC5yZXBsYWNlKC9cXG4vbWcsICcgJykucmVwbGFjZSgvIHsyfS9nLCAnICcpOyByZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KHNwYWNlU3RyaXBwZWQpOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgLyogbm90IGEgZnVuY3Rpb24gKi8gfSB9LCB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKSB7IHRyeSB7IGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfSBmblRvU3RyLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJywgaXNDYWxsYWJsZSA9IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHsgaWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH0gaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfSBpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfSBpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH0gdmFyIHN0ckNsYXNzID0gdG9fc3RyaW5nLmNhbGwodmFsdWUpOyByZXR1cm4gc3RyQ2xhc3MgPT09IGZuQ2xhc3MgfHwgc3RyQ2xhc3MgPT09IGdlbkNsYXNzOyB9O1xuXG4gICAgdmFyIGlzUmVnZXg7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1yZWdleCAqLyB2YXIgcmVnZXhFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjLCB0cnlSZWdleEV4ZWMgPSBmdW5jdGlvbiB0cnlSZWdleEV4ZWModmFsdWUpIHsgdHJ5IHsgcmVnZXhFeGVjLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgcmVnZXhDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nOyBpc1JlZ2V4ID0gZnVuY3Rpb24gaXNSZWdleCh2YWx1ZSkgeyBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH0gcmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5UmVnZXhFeGVjKHZhbHVlKSA6IHRvX3N0cmluZy5jYWxsKHZhbHVlKSA9PT0gcmVnZXhDbGFzczsgfTtcbiAgICB2YXIgaXNTdHJpbmc7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1zdHJpbmcgKi8gdmFyIHN0clZhbHVlID0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLCB0cnlTdHJpbmdPYmplY3QgPSBmdW5jdGlvbiB0cnlTdHJpbmdPYmplY3QodmFsdWUpIHsgdHJ5IHsgc3RyVmFsdWUuY2FsbCh2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9LCBzdHJpbmdDbGFzcyA9ICdbb2JqZWN0IFN0cmluZ10nOyBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7IGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7IHJldHVybiB0cnVlOyB9IGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfSByZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlTdHJpbmdPYmplY3QodmFsdWUpIDogdG9fc3RyaW5nLmNhbGwodmFsdWUpID09PSBzdHJpbmdDbGFzczsgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG9uZS12YXItZGVjbGFyYXRpb24tcGVyLWxpbmUsIG5vLXJlZGVjbGFyZSwgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmUgKi9cblxuICAgIC8qIGlubGluZWQgZnJvbSBodHRwOi8vbnBtanMuY29tL2RlZmluZS1wcm9wZXJ0aWVzICovXG4gICAgdmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSAkT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgXyBpbiBvYmopIHsgLy8ganNjczppZ25vcmUgZGlzYWxsb3dVbnVzZWRWYXJpYWJsZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqLnggPT09IG9iajtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSgpKTtcbiAgICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IChmdW5jdGlvbiAoaGFzKSB7XG4gICAgICAgIC8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlLCBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbiAgICAgICAgLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbiAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5O1xuICAgICAgICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzLmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSkpO1xuXG4gICAgLy9cbiAgICAvLyBVdGlsXG4gICAgLy8gPT09PT09XG4gICAgLy9cblxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCAvaGVscGVycy9pc1ByaW1pdGl2ZSAqL1xuICAgIHZhciBpc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKGlucHV0KSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IG51bGwgfHwgKHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGUgIT09ICdmdW5jdGlvbicpO1xuICAgIH07XG5cbiAgICB2YXIgaXNBY3R1YWxOYU4gPSAkTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIGlzQWN0dWFsTmFOKHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT09IHg7XG4gICAgfTtcblxuICAgIHZhciBFUyA9IHtcbiAgICAgICAgLy8gRVM1IDkuNFxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbiAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuICAgICAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvSW50ZWdlciAqL1xuICAgICAgICBUb0ludGVnZXI6IGZ1bmN0aW9uIFRvSW50ZWdlcihudW0pIHtcbiAgICAgICAgICAgIHZhciBuID0gK251bTtcbiAgICAgICAgICAgIGlmIChpc0FjdHVhbE5hTihuKSkge1xuICAgICAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcbiAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub1ByaW1pdGl2ZSAqL1xuICAgICAgICBUb1ByaW1pdGl2ZTogZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB2YWwsIHZhbHVlT2YsIHRvU3RyO1xuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlT2YgPSBpbnB1dC52YWx1ZU9mO1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGUodmFsdWVPZikpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZU9mLmNhbGwoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9TdHIgPSBpbnB1dC50b1N0cmluZztcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlKHRvU3RyKSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHRvU3RyLmNhbGwoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEVTNSA5LjlcbiAgICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS45XG4gICAgICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9PYmplY3QgKi9cbiAgICAgICAgVG9PYmplY3Q6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICBpZiAobyA9PSBudWxsKSB7IC8vIHRoaXMgbWF0Y2hlcyBib3RoIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJE9iamVjdChvKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvVWludDMyICovXG4gICAgICAgIFRvVWludDMyOiBmdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgICAgICAgICByZXR1cm4geCA+Pj4gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIEZ1bmN0aW9uXG4gICAgLy8gPT09PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVMtNSAxNS4zLjQuNVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbiAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuXG4gICAgZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgICAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgICAgIHZhciBib3VuZDtcbiAgICAgICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjIgW1tDb25zdHJ1Y3RdXVxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBJZiB0YXJnZXQgaGFzIG5vIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLCBhXG4gICAgICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhcHBseS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X2NvbmNhdC5jYWxsKGFyZ3MsIGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBseS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X2NvbmNhdC5jYWxsKGFyZ3MsIGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgICAgIHZhciBib3VuZExlbmd0aCA9IG1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheV9wdXNoLmNhbGwoYm91bmRBcmdzLCAnJCcgKyBpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgQ29udGVudCBTZWN1cml0eSBQb2xpY2llcyBlbmFibGVkIChDaHJvbWUgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgICAgICAvLyBhbmQgc28gdGhpcyBjb2RlIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQuXG4gICAgICAgICAgICBib3VuZCA9ICRGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGFycmF5X2pvaW4uY2FsbChib3VuZEFyZ3MsICcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgICAgICAvLyAyMC4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAgICAgLy8gICBmYWxzZS5cbiAgICAgICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAgICAgLy8gICBbW1NldF1dOiB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSxcbiAgICAgICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyBOT1RFIEZ1bmN0aW9uIG9iamVjdHMgY3JlYXRlZCB1c2luZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBkbyBub3RcbiAgICAgICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgICAgIC8vIFhYWCBjYW4ndCBkZWxldGUgcHJvdG90eXBlIGluIHB1cmUtanMuXG5cbiAgICAgICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgICAgIHJldHVybiBib3VuZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gX1BsZWFzZSBub3RlOiBTaG9ydGN1dHMgYXJlIGRlZmluZWQgYWZ0ZXIgYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBhcyB3ZVxuICAgIC8vIHVzZSBpdCBpbiBkZWZpbmluZyBzaG9ydGN1dHMuXG4gICAgdmFyIG93bnMgPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiAgICB2YXIgdG9TdHIgPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nKTtcbiAgICB2YXIgYXJyYXlTbGljZSA9IGNhbGwuYmluZChhcnJheV9zbGljZSk7XG4gICAgdmFyIGFycmF5U2xpY2VBcHBseSA9IGFwcGx5LmJpbmQoYXJyYXlfc2xpY2UpO1xuICAgIHZhciBzdHJTbGljZSA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuc2xpY2UpO1xuICAgIHZhciBzdHJTcGxpdCA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuc3BsaXQpO1xuICAgIHZhciBzdHJJbmRleE9mID0gY2FsbC5iaW5kKFN0cmluZ1Byb3RvdHlwZS5pbmRleE9mKTtcbiAgICB2YXIgcHVzaENhbGwgPSBjYWxsLmJpbmQoYXJyYXlfcHVzaCk7XG4gICAgdmFyIGlzRW51bSA9IGNhbGwuYmluZChPYmplY3RQcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xuICAgIHZhciBhcnJheVNvcnQgPSBjYWxsLmJpbmQoQXJyYXlQcm90b3R5cGUuc29ydCk7XG5cbiAgICAvL1xuICAgIC8vIEFycmF5XG4gICAgLy8gPT09PT1cbiAgICAvL1xuXG4gICAgdmFyIGlzQXJyYXkgPSAkQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgLy8gRVM1IDE1LjQuNC4xMlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xM1xuICAgIC8vIFJldHVybiBsZW4rYXJnQ291bnQuXG4gICAgLy8gW2J1Z2ZpeCwgaWVsdDhdXG4gICAgLy8gSUUgPCA4IGJ1ZzogW10udW5zaGlmdCgwKSA9PT0gdW5kZWZpbmVkIGJ1dCBzaG91bGQgYmUgXCIxXCJcbiAgICB2YXIgaGFzVW5zaGlmdFJldHVyblZhbHVlQnVnID0gW10udW5zaGlmdCgwKSAhPT0gMTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFycmF5X3Vuc2hpZnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sIGhhc1Vuc2hpZnRSZXR1cm5WYWx1ZUJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuNC4zLjJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKCRBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG4gICAgLy8gVGhlIElzQ2FsbGFibGUoKSBjaGVjayBpbiB0aGUgQXJyYXkgZnVuY3Rpb25zXG4gICAgLy8gaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHN0cmljdCBjaGVjayBvbiB0aGVcbiAgICAvLyBpbnRlcm5hbCBjbGFzcyBvZiB0aGUgb2JqZWN0IHRvIHRyYXAgY2FzZXMgd2hlcmVcbiAgICAvLyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2FzIGFjdHVhbGx5IGEgcmVndWxhclxuICAgIC8vIGV4cHJlc3Npb24gbGl0ZXJhbCwgd2hpY2ggaW4gVjggYW5kXG4gICAgLy8gSmF2YVNjcmlwdENvcmUgaXMgYSB0eXBlb2YgXCJmdW5jdGlvblwiLiAgT25seSBpblxuICAgIC8vIFY4IGFyZSByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHMgcGVybWl0dGVkIGFzXG4gICAgLy8gcmVkdWNlIHBhcmFtZXRlcnMsIHNvIGl0IGlzIGRlc2lyYWJsZSBpbiB0aGVcbiAgICAvLyBnZW5lcmFsIGNhc2UgZm9yIHRoZSBzaGltIHRvIG1hdGNoIHRoZSBtb3JlXG4gICAgLy8gc3RyaWN0IGFuZCBjb21tb24gYmVoYXZpb3Igb2YgcmVqZWN0aW5nIHJlZ3VsYXJcbiAgICAvLyBleHByZXNzaW9ucy5cblxuICAgIC8vIEVTNSAxNS40LjQuMThcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMThcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9hcnJheS9mb3JFYWNoXG5cbiAgICAvLyBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KVxuICAgIC8vIGFuZCBmYWlsdXJlIG9mIGAwIGluIGJveGVkU3RyaW5nYCAoUmhpbm8pXG4gICAgdmFyIGJveGVkU3RyaW5nID0gJE9iamVjdCgnYScpO1xuICAgIHZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcblxuICAgIHZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgICAgIHZhciBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgICAgICB2YXIgdGhyZXdFeGNlcHRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtZXRob2QuY2FsbCgnZm9vJywgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgIH0sICd4Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyZXdFeGNlcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIW1ldGhvZCAmJiAhdGhyZXdFeGNlcHRpb24gJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xuICAgIH07XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBUO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5mb3JFYWNoIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTlcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTlcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L21hcFxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICRBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgdmFyIFQ7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLm1hcCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLm1hcCkpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4yMFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvZmlsdGVyXG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmlsdGVyIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGZbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFja2ZuKHZhbHVlLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHZhbHVlLCBpLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZmlsdGVyKSk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjE2XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE2XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZXZlcnlcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZXZlcnkgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmICEodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5ldmVyeSkpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4xN1xuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xN1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWVcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbi8qLCB0aGlzQXJnICovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBUO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5zb21lIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5zb21lKSk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjIxXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIxXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9yZWR1Y2VcbiAgICB2YXIgcmVkdWNlQ29lcmNlc1RvT2JqZWN0ID0gZmFsc2U7XG4gICAgaWYgKEFycmF5UHJvdG90eXBlLnJlZHVjZSkge1xuICAgICAgICByZWR1Y2VDb2VyY2VzVG9PYmplY3QgPSB0eXBlb2YgQXJyYXlQcm90b3R5cGUucmVkdWNlLmNhbGwoJ2VzNScsIGZ1bmN0aW9uIChfLCBfXywgX19fLCBsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfSkgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4vKiwgaW5pdGlhbFZhbHVlKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUgYW5kIGFuIGVtcHR5IGFycmF5XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGZbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYXJyYXkgY29udGFpbnMgbm8gdmFsdWVzLCBubyBpbml0aWFsIHZhbHVlIHRvIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoKytpID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrZm4ocmVzdWx0LCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sICFyZWR1Y2VDb2VyY2VzVG9PYmplY3QpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4yMlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvcmVkdWNlUmlnaHRcbiAgICB2YXIgcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QgPSBmYWxzZTtcbiAgICBpZiAoQXJyYXlQcm90b3R5cGUucmVkdWNlUmlnaHQpIHtcbiAgICAgICAgcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QgPSB0eXBlb2YgQXJyYXlQcm90b3R5cGUucmVkdWNlUmlnaHQuY2FsbCgnZXM1JywgZnVuY3Rpb24gKF8sIF9fLCBfX18sIGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9KSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4vKiwgaW5pdGlhbCovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUsIGVtcHR5IGFycmF5XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHZhciBpID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpLS1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFja2ZuKHJlc3VsdCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSwgIXJlZHVjZVJpZ2h0Q29lcmNlc1RvT2JqZWN0KTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG4gICAgdmFyIGhhc0ZpcmVmb3gySW5kZXhPZkJ1ZyA9IEFycmF5UHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50LyosIGZyb21JbmRleCAqLykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaSA9IEVTLlRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBtYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjE1XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE1XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGFzdEluZGV4T2ZcbiAgICB2YXIgaGFzRmlyZWZveDJMYXN0SW5kZXhPZkJ1ZyA9IEFycmF5UHJvdG90eXBlLmxhc3RJbmRleE9mICYmIFswLCAxXS5sYXN0SW5kZXhPZigwLCAtMykgIT09IC0xO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQvKiwgZnJvbUluZGV4ICovKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSBsZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaSA9IG1pbihpLCBFUy5Ub0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBsZW5ndGggLSBNYXRoLmFicyhpKTtcbiAgICAgICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VhcmNoRWxlbWVudCA9PT0gc2VsZltpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9LCBoYXNGaXJlZm94Mkxhc3RJbmRleE9mQnVnKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTJcbiAgICB2YXIgc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSBbMSwgMl07XG4gICAgICAgIHZhciByZXN1bHQgPSBhLnNwbGljZSgpO1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IDIgJiYgaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPT09IDA7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIC8vIFNhZmFyaSA1LjAgYnVnIHdoZXJlIC5zcGxpY2UoKSByZXR1cm5zIHVuZGVmaW5lZFxuICAgICAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlfc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCAhc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5KTtcblxuICAgIHZhciBzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgQXJyYXlQcm90b3R5cGUuc3BsaWNlLmNhbGwob2JqLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIG9iai5sZW5ndGggPT09IDE7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbWF4KEVTLlRvSW50ZWdlcih0aGlzLmxlbmd0aCksIDApO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBkZWxldGVDb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwoYXJncywgdGhpcy5sZW5ndGggLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSA9IEVTLlRvSW50ZWdlcihkZWxldGVDb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH0sICFzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCk7XG4gICAgdmFyIHNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMjk1XG4gICAgICAgIC8vIFNhZmFyaSA3LzggYnJlYWtzIHdpdGggc3BhcnNlIGFycmF5cyBvZiBzaXplIDFlNSBvciBncmVhdGVyXG4gICAgICAgIHZhciBhcnIgPSBuZXcgJEFycmF5KDFlNSk7XG4gICAgICAgIC8vIG5vdGU6IHRoZSBpbmRleCBNVVNUIGJlIDggb3IgbGFyZ2VyIG9yIHRoZSB0ZXN0IHdpbGwgZmFsc2UgcGFzc1xuICAgICAgICBhcnJbOF0gPSAneCc7XG4gICAgICAgIGFyci5zcGxpY2UoMSwgMSk7XG4gICAgICAgIC8vIG5vdGU6IHRoaXMgdGVzdCBtdXN0IGJlIGRlZmluZWQgKmFmdGVyKiB0aGUgaW5kZXhPZiBzaGltXG4gICAgICAgIC8vIHBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzMxM1xuICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YoJ3gnKSA9PT0gNztcbiAgICB9KCkpO1xuICAgIHZhciBzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzI5NVxuICAgICAgICAvLyBPcGVyYSAxMi4xNSBicmVha3Mgb24gdGhpcywgbm8gaWRlYSB3aHkuXG4gICAgICAgIHZhciBuID0gMjU2O1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIGFycltuXSA9ICdhJztcbiAgICAgICAgYXJyLnNwbGljZShuICsgMSwgMCwgJ2InKTtcbiAgICAgICAgcmV0dXJuIGFycltuXSA9PT0gJ2EnO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBPID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgQSA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IEVTLlRvVWludDMyKE8ubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gRVMuVG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxTdGFydCA9IHJlbGF0aXZlU3RhcnQgPCAwID8gbWF4KChsZW4gKyByZWxhdGl2ZVN0YXJ0KSwgMCkgOiBtaW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgoRVMuVG9JbnRlZ2VyKGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcblxuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgdmFyIGZyb207XG4gICAgICAgICAgICB3aGlsZSAoayA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9ICRTdHJpbmcoYWN0dWFsU3RhcnQgKyBrKTtcbiAgICAgICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBBW2tdID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgayArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICB2YXIgaXRlbUNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRvO1xuICAgICAgICAgICAgaWYgKGl0ZW1Db3VudCA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgayA9IGFjdHVhbFN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBtYXhLID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPCBtYXhLKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gJFN0cmluZyhrICsgaXRlbUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG93bnMoTywgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBPW3RvXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBrICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsgPSBsZW47XG4gICAgICAgICAgICAgICAgdmFyIG1pbksgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGl0ZW1Db3VudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA+IG1pbkspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9bayAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBrIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtQ291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgICAgIGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA+IGFjdHVhbFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB0byA9ICRTdHJpbmcoayArIGl0ZW1Db3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9bdG9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrID0gYWN0dWFsU3RhcnQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgT1trXSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE8ubGVuZ3RoID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpdGVtQ291bnQ7XG5cbiAgICAgICAgICAgIHJldHVybiBBO1xuICAgICAgICB9XG4gICAgfSwgIXNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzIHx8ICFzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyk7XG5cbiAgICB2YXIgb3JpZ2luYWxKb2luID0gQXJyYXlQcm90b3R5cGUuam9pbjtcbiAgICB2YXIgaGFzU3RyaW5nSm9pbkJ1ZztcbiAgICB0cnkge1xuICAgICAgICBoYXNTdHJpbmdKb2luQnVnID0gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbCgnMTIzJywgJywnKSAhPT0gJzEsMiwzJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhc1N0cmluZ0pvaW5CdWcgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGFzU3RyaW5nSm9pbkJ1Zykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgICAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBzZXAgPSB0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyA/ICcsJyA6IHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxKb2luLmNhbGwoaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiB0aGlzLCBzZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYXNTdHJpbmdKb2luQnVnKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzSm9pblVuZGVmaW5lZEJ1ZyA9IFsxLCAyXS5qb2luKHVuZGVmaW5lZCkgIT09ICcxLDInO1xuICAgIGlmIChoYXNKb2luVW5kZWZpbmVkQnVnKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcCA9IHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnID8gJywnIDogc2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEpvaW4uY2FsbCh0aGlzLCBzZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYXNKb2luVW5kZWZpbmVkQnVnKTtcbiAgICB9XG5cbiAgICB2YXIgcHVzaFNoaW0gPSBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICAgICAgdmFyIE8gPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIG4gPSBFUy5Ub1VpbnQzMihPLmxlbmd0aCk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBPW24gKyBpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBPLmxlbmd0aCA9IG4gKyBpO1xuICAgICAgICByZXR1cm4gbiArIGk7XG4gICAgfTtcblxuICAgIHZhciBwdXNoSXNOb3RHZW5lcmljID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnB1c2guY2FsbChvYmosIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgb2JqLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2Ygb2JqWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhvYmosIDApO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5X3B1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdXNoU2hpbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSwgcHVzaElzTm90R2VuZXJpYyk7XG5cbiAgICAvLyBUaGlzIGZpeGVzIGEgdmVyeSB3ZWlyZCBidWcgaW4gT3BlcmEgMTAuNiB3aGVuIHB1c2hpbmcgYHVuZGVmaW5lZFxuICAgIHZhciBwdXNoVW5kZWZpbmVkSXNXZWlyZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFyci5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgYXJyLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgYXJyWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhhcnIsIDApO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwgeyBwdXNoOiBwdXNoU2hpbSB9LCBwdXNoVW5kZWZpbmVkSXNXZWlyZCk7XG5cbiAgICAvLyBFUzUgMTUuMi4zLjE0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMTBcbiAgICAvLyBGaXggYm94ZWQgc3RyaW5nIGJ1Z1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgc2xpY2U6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5U2xpY2VBcHBseShhcnIsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LCBzcGxpdFN0cmluZyk7XG5cbiAgICB2YXIgc29ydElnbm9yZXNOb25GdW5jdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWzEsIDJdLnNvcnQobnVsbCk7XG4gICAgICAgICAgICBbMSwgMl0uc29ydCh7fSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0oKSk7XG4gICAgdmFyIHNvcnRUaHJvd3NPblJlZ2V4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIHByb2JsZW0gaW4gRmlyZWZveCA0LCBpbiB3aGljaCBgdHlwZW9mIC9hLyA9PT0gJ2Z1bmN0aW9uJ2BcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFsxLCAyXS5zb3J0KC9hLyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0oKSk7XG4gICAgdmFyIHNvcnRJZ25vcmVzVW5kZWZpbmVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYXBwbGllcyBpbiBJRSA4LCBmb3Igb25lLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWzEsIDJdLnNvcnQodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZUZuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmVGbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlTb3J0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNvbXBhcmVGbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuc29ydCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheVNvcnQodGhpcywgY29tcGFyZUZuKTtcbiAgICAgICAgfVxuICAgIH0sIHNvcnRJZ25vcmVzTm9uRnVuY3Rpb25zIHx8ICFzb3J0SWdub3Jlc1VuZGVmaW5lZCB8fCAhc29ydFRocm93c09uUmVnZXgpO1xuXG4gICAgLy9cbiAgICAvLyBPYmplY3RcbiAgICAvLyA9PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVM1IDE1LjIuMy4xNFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xNFxuXG4gICAgLy8gaHR0cDovL3doYXR0aGVoZWFkc2FpZC5jb20vMjAxMC8xMC9hLXNhZmVyLW9iamVjdC1rZXlzLWNvbXBhdGliaWxpdHktaW1wbGVtZW50YXRpb25cbiAgICB2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtKHsgJ3RvU3RyaW5nJzogbnVsbCB9LCAndG9TdHJpbmcnKTtcbiAgICB2YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG4gICAgdmFyIGhhc1N0cmluZ0VudW1CdWcgPSAhb3ducygneCcsICcwJyk7XG4gICAgdmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbiAgICB9O1xuICAgIHZhciBibGFja2xpc3RlZEtleXMgPSB7XG4gICAgICAgICR3aW5kb3c6IHRydWUsXG4gICAgICAgICRjb25zb2xlOiB0cnVlLFxuICAgICAgICAkcGFyZW50OiB0cnVlLFxuICAgICAgICAkc2VsZjogdHJ1ZSxcbiAgICAgICAgJGZyYW1lOiB0cnVlLFxuICAgICAgICAkZnJhbWVzOiB0cnVlLFxuICAgICAgICAkZnJhbWVFbGVtZW50OiB0cnVlLFxuICAgICAgICAkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuICAgICAgICAkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG4gICAgICAgICRleHRlcm5hbDogdHJ1ZVxuICAgIH07XG4gICAgdmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGdsb2JhbHMgd2luZG93ICovXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGsgaW4gd2luZG93KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghYmxhY2tsaXN0ZWRLZXlzWyckJyArIGtdICYmIG93bnMod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0oKSk7XG4gICAgdmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcbiAgICAgICAgICAgIHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZG9udEVudW1zID0gW1xuICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAndmFsdWVPZicsXG4gICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICAgJ2NvbnN0cnVjdG9yJ1xuICAgIF07XG4gICAgdmFyIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbiAgICAvLyB0YWtlbiBkaXJlY3RseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvaXMtYXJndW1lbnRzL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gICAgLy8gY2FuIGJlIHJlcGxhY2VkIHdpdGggcmVxdWlyZSgnaXMtYXJndW1lbnRzJykgaWYgd2UgZXZlciB1c2UgYSBidWlsZCBwcm9jZXNzIGluc3RlYWRcbiAgICB2YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cih2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuICAgIH07XG4gICAgdmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICAgICAgICFpc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICAgICAgaXNDYWxsYWJsZSh2YWx1ZS5jYWxsZWUpO1xuICAgIH07XG4gICAgdmFyIGlzQXJndW1lbnRzID0gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuXG4gICAgZGVmaW5lUHJvcGVydGllcygkT2JqZWN0LCB7XG4gICAgICAgIGtleXM6IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaXNGbiA9IGlzQ2FsbGFibGUob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciBpc0FyZ3MgPSBpc0FyZ3VtZW50cyhvYmplY3QpO1xuICAgICAgICAgICAgdmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuICAgICAgICAgICAgdmFyIGlzU3RyID0gaXNPYmplY3QgJiYgaXNTdHJpbmcob2JqZWN0KTtcblxuICAgICAgICAgICAgaWYgKCFpc09iamVjdCAmJiAhaXNGbiAmJiAhaXNBcmdzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGhlS2V5cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0ZuO1xuICAgICAgICAgICAgaWYgKChpc1N0ciAmJiBoYXNTdHJpbmdFbnVtQnVnKSB8fCBpc0FyZ3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbCh0aGVLZXlzLCAkU3RyaW5nKGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNBcmdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBvd25zKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKHRoZUtleXMsICRTdHJpbmcobmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb250RW51bXNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9udEVudW0gPSBkb250RW51bXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgb3ducyhvYmplY3QsIGRvbnRFbnVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwodGhlS2V5cywgZG9udEVudW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoZUtleXM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gJE9iamVjdC5rZXlzICYmIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNhZmFyaSA1LjAgYnVnXG4gICAgICAgIHJldHVybiAkT2JqZWN0LmtleXMoYXJndW1lbnRzKS5sZW5ndGggPT09IDI7XG4gICAgfSgxLCAyKSk7XG4gICAgdmFyIGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcgPSAkT2JqZWN0LmtleXMgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ0tleXMgPSAkT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggIT09IDEgfHwgYXJnS2V5cy5sZW5ndGggIT09IDEgfHwgYXJnS2V5c1swXSAhPT0gMTtcbiAgICB9KDEpKTtcbiAgICB2YXIgb3JpZ2luYWxLZXlzID0gJE9iamVjdC5rZXlzO1xuICAgIGRlZmluZVByb3BlcnRpZXMoJE9iamVjdCwge1xuICAgICAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxLZXlzKGFycmF5U2xpY2Uob2JqZWN0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sICFrZXlzV29ya3NXaXRoQXJndW1lbnRzIHx8IGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcpO1xuXG4gICAgLy9cbiAgICAvLyBEYXRlXG4gICAgLy8gPT09PVxuICAgIC8vXG5cbiAgICB2YXIgaGFzTmVnYXRpdmVNb250aFllYXJCdWcgPSBuZXcgRGF0ZSgtMzUwOTgyNzMyOTYwMDI5MikuZ2V0VVRDTW9udGgoKSAhPT0gMDtcbiAgICB2YXIgYU5lZ2F0aXZlVGVzdERhdGUgPSBuZXcgRGF0ZSgtMTUwOTg0MjI4OTYwMDI5Mik7XG4gICAgdmFyIGFQb3NpdGl2ZVRlc3REYXRlID0gbmV3IERhdGUoMTQ0OTY2MjQwMDAwMCk7XG4gICAgdmFyIGhhc1RvVVRDU3RyaW5nRm9ybWF0QnVnID0gYU5lZ2F0aXZlVGVzdERhdGUudG9VVENTdHJpbmcoKSAhPT0gJ01vbiwgMDEgSmFuIC00NTg3NSAxMTo1OTo1OSBHTVQnO1xuICAgIHZhciBoYXNUb0RhdGVTdHJpbmdGb3JtYXRCdWc7XG4gICAgdmFyIGhhc1RvU3RyaW5nRm9ybWF0QnVnO1xuICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IGFOZWdhdGl2ZVRlc3REYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgaWYgKHRpbWVab25lT2Zmc2V0IDwgLTcyMCkge1xuICAgICAgICBoYXNUb0RhdGVTdHJpbmdGb3JtYXRCdWcgPSBhTmVnYXRpdmVUZXN0RGF0ZS50b0RhdGVTdHJpbmcoKSAhPT0gJ1R1ZSBKYW4gMDIgLTQ1ODc1JztcbiAgICAgICAgaGFzVG9TdHJpbmdGb3JtYXRCdWcgPSAhKC9eVGh1IERlYyAxMCAyMDE1IFxcZFxcZDpcXGRcXGQ6XFxkXFxkIEdNVFstXFwrXVxcZFxcZFxcZFxcZCg/OiB8JCkvKS50ZXN0KGFQb3NpdGl2ZVRlc3REYXRlLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1RvRGF0ZVN0cmluZ0Zvcm1hdEJ1ZyA9IGFOZWdhdGl2ZVRlc3REYXRlLnRvRGF0ZVN0cmluZygpICE9PSAnTW9uIEphbiAwMSAtNDU4NzUnO1xuICAgICAgICBoYXNUb1N0cmluZ0Zvcm1hdEJ1ZyA9ICEoL15XZWQgRGVjIDA5IDIwMTUgXFxkXFxkOlxcZFxcZDpcXGRcXGQgR01UWy1cXCtdXFxkXFxkXFxkXFxkKD86IHwkKS8pLnRlc3QoYVBvc2l0aXZlVGVzdERhdGUudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsR2V0RnVsbFllYXIgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0RnVsbFllYXIpO1xuICAgIHZhciBvcmlnaW5hbEdldE1vbnRoID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldE1vbnRoKTtcbiAgICB2YXIgb3JpZ2luYWxHZXREYXRlID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldERhdGUpO1xuICAgIHZhciBvcmlnaW5hbEdldFVUQ0Z1bGxZZWFyID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldFVUQ0Z1bGxZZWFyKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENNb250aCA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENNb250aCk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDRGF0ZSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENEYXRlKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENEYXkgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDRGF5KTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENIb3VycyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENIb3Vycyk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDTWludXRlcyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENNaW51dGVzKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENTZWNvbmRzID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldFVUQ1NlY29uZHMpO1xuICAgIHZhciBvcmlnaW5hbEdldFVUQ01pbGxpc2Vjb25kcyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENNaWxsaXNlY29uZHMpO1xuICAgIHZhciBkYXlOYW1lID0gWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXTtcbiAgICB2YXIgbW9udGhOYW1lID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xuICAgIHZhciBkYXlzSW5Nb250aCA9IGZ1bmN0aW9uIGRheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEdldERhdGUobmV3IERhdGUoeWVhciwgbW9udGgsIDApKTtcbiAgICB9O1xuXG4gICAgZGVmaW5lUHJvcGVydGllcyhEYXRlLnByb3RvdHlwZSwge1xuICAgICAgICBnZXRGdWxsWWVhcjogZnVuY3Rpb24gZ2V0RnVsbFllYXIoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldEZ1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHllYXIgPCAwICYmIG9yaWdpbmFsR2V0TW9udGgodGhpcykgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5ZWFyICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5ZWFyO1xuICAgICAgICB9LFxuICAgICAgICBnZXRNb250aDogZnVuY3Rpb24gZ2V0TW9udGgoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldEZ1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRNb250aCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBtb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERhdGU6IGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldEZ1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRNb250aCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBkYXRlID0gb3JpZ2luYWxHZXREYXRlKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHllYXIgPCAwICYmIG1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGF5cyA9IGRheXNJbk1vbnRoKDAsIHllYXIgKyAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRheXMgLSBkYXRlKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VVRDRnVsbFllYXI6IGZ1bmN0aW9uIGdldFVUQ0Z1bGxZZWFyKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBvcmlnaW5hbEdldFVUQ01vbnRoKHRoaXMpID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWVhciArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWVhcjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VVRDTW9udGg6IGZ1bmN0aW9uIGdldFVUQ01vbnRoKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgICAgICBpZiAoeWVhciA8IDAgJiYgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgICAgICB9LFxuICAgICAgICBnZXRVVENEYXRlOiBmdW5jdGlvbiBnZXRVVENEYXRlKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsR2V0VVRDRGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBtb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRheXMgPSBkYXlzSW5Nb250aCgwLCB5ZWFyICsgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkYXlzIC0gZGF0ZSkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICB9LCBoYXNOZWdhdGl2ZU1vbnRoWWVhckJ1Zyk7XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGUucHJvdG90eXBlLCB7XG4gICAgICAgIHRvVVRDU3RyaW5nOiBmdW5jdGlvbiB0b1VUQ1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF5ID0gb3JpZ2luYWxHZXRVVENEYXkodGhpcyk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsR2V0VVRDRGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgICAgICB2YXIgaG91ciA9IG9yaWdpbmFsR2V0VVRDSG91cnModGhpcyk7XG4gICAgICAgICAgICB2YXIgbWludXRlID0gb3JpZ2luYWxHZXRVVENNaW51dGVzKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlY29uZCA9IG9yaWdpbmFsR2V0VVRDU2Vjb25kcyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBkYXlOYW1lW2RheV0gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAoZGF0ZSA8IDEwID8gJzAnICsgZGF0ZSA6IGRhdGUpICsgJyAnICtcbiAgICAgICAgICAgICAgICBtb250aE5hbWVbbW9udGhdICsgJyAnICtcbiAgICAgICAgICAgICAgICB5ZWFyICsgJyAnICtcbiAgICAgICAgICAgICAgICAoaG91ciA8IDEwID8gJzAnICsgaG91ciA6IGhvdXIpICsgJzonICtcbiAgICAgICAgICAgICAgICAobWludXRlIDwgMTAgPyAnMCcgKyBtaW51dGUgOiBtaW51dGUpICsgJzonICtcbiAgICAgICAgICAgICAgICAoc2Vjb25kIDwgMTAgPyAnMCcgKyBzZWNvbmQgOiBzZWNvbmQpICsgJyBHTVQnO1xuICAgICAgICB9XG4gICAgfSwgaGFzTmVnYXRpdmVNb250aFllYXJCdWcgfHwgaGFzVG9VVENTdHJpbmdGb3JtYXRCdWcpO1xuXG4gICAgLy8gT3BlcmEgMTIgaGFzIGAsYFxuICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICAgICAgdG9EYXRlU3RyaW5nOiBmdW5jdGlvbiB0b0RhdGVTdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheSA9IHRoaXMuZ2V0RGF5KCk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5nZXRNb250aCgpO1xuICAgICAgICAgICAgdmFyIHllYXIgPSB0aGlzLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICByZXR1cm4gZGF5TmFtZVtkYXldICsgJyAnICtcbiAgICAgICAgICAgICAgICBtb250aE5hbWVbbW9udGhdICsgJyAnICtcbiAgICAgICAgICAgICAgICAoZGF0ZSA8IDEwID8gJzAnICsgZGF0ZSA6IGRhdGUpICsgJyAnICtcbiAgICAgICAgICAgICAgICB5ZWFyO1xuICAgICAgICB9XG4gICAgfSwgaGFzTmVnYXRpdmVNb250aFllYXJCdWcgfHwgaGFzVG9EYXRlU3RyaW5nRm9ybWF0QnVnKTtcblxuICAgIC8vIGNhbid0IHVzZSBkZWZpbmVQcm9wZXJ0aWVzIGhlcmUgYmVjYXVzZSBvZiB0b1N0cmluZyBlbnVtZXJhdGlvbiBpc3N1ZSBpbiBJRSA8PSA4XG4gICAgaWYgKGhhc05lZ2F0aXZlTW9udGhZZWFyQnVnIHx8IGhhc1RvU3RyaW5nRm9ybWF0QnVnKSB7XG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheSA9IHRoaXMuZ2V0RGF5KCk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5nZXRNb250aCgpO1xuICAgICAgICAgICAgdmFyIHllYXIgPSB0aGlzLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICB2YXIgaG91ciA9IHRoaXMuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgIHZhciBtaW51dGUgPSB0aGlzLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgIHZhciBzZWNvbmQgPSB0aGlzLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgIHZhciB0aW1lem9uZU9mZnNldCA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBob3Vyc09mZnNldCA9IE1hdGguZmxvb3IoTWF0aC5hYnModGltZXpvbmVPZmZzZXQpIC8gNjApO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZXNPZmZzZXQgPSBNYXRoLmZsb29yKE1hdGguYWJzKHRpbWV6b25lT2Zmc2V0KSAlIDYwKTtcbiAgICAgICAgICAgIHJldHVybiBkYXlOYW1lW2RheV0gKyAnICcgK1xuICAgICAgICAgICAgICAgIG1vbnRoTmFtZVttb250aF0gKyAnICcgK1xuICAgICAgICAgICAgICAgIChkYXRlIDwgMTAgPyAnMCcgKyBkYXRlIDogZGF0ZSkgKyAnICcgK1xuICAgICAgICAgICAgICAgIHllYXIgKyAnICcgK1xuICAgICAgICAgICAgICAgIChob3VyIDwgMTAgPyAnMCcgKyBob3VyIDogaG91cikgKyAnOicgK1xuICAgICAgICAgICAgICAgIChtaW51dGUgPCAxMCA/ICcwJyArIG1pbnV0ZSA6IG1pbnV0ZSkgKyAnOicgK1xuICAgICAgICAgICAgICAgIChzZWNvbmQgPCAxMCA/ICcwJyArIHNlY29uZCA6IHNlY29uZCkgKyAnIEdNVCcgK1xuICAgICAgICAgICAgICAgICh0aW1lem9uZU9mZnNldCA+IDAgPyAnLScgOiAnKycpICtcbiAgICAgICAgICAgICAgICAoaG91cnNPZmZzZXQgPCAxMCA/ICcwJyArIGhvdXJzT2Zmc2V0IDogaG91cnNPZmZzZXQpICtcbiAgICAgICAgICAgICAgICAobWludXRlc09mZnNldCA8IDEwID8gJzAnICsgbWludXRlc09mZnNldCA6IG1pbnV0ZXNPZmZzZXQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuOS41LjQzXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS41LjQzXG4gICAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgU3RyaW5nIHZhbHVlIHJlcHJlc2VudCB0aGUgaW5zdGFuY2UgaW4gdGltZVxuICAgIC8vIHJlcHJlc2VudGVkIGJ5IHRoaXMgRGF0ZSBvYmplY3QuIFRoZSBmb3JtYXQgb2YgdGhlIFN0cmluZyBpcyB0aGUgRGF0ZSBUaW1lXG4gICAgLy8gc3RyaW5nIGZvcm1hdCBkZWZpbmVkIGluIDE1LjkuMS4xNS4gQWxsIGZpZWxkcyBhcmUgcHJlc2VudCBpbiB0aGUgU3RyaW5nLlxuICAgIC8vIFRoZSB0aW1lIHpvbmUgaXMgYWx3YXlzIFVUQywgZGVub3RlZCBieSB0aGUgc3VmZml4IFouIElmIHRoZSB0aW1lIHZhbHVlIG9mXG4gICAgLy8gdGhpcyBvYmplY3QgaXMgbm90IGEgZmluaXRlIE51bWJlciBhIFJhbmdlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICB2YXIgbmVnYXRpdmVEYXRlID0gLTYyMTk4NzU1MjAwMDAwO1xuICAgIHZhciBuZWdhdGl2ZVllYXJTdHJpbmcgPSAnLTAwMDAwMSc7XG4gICAgdmFyIGhhc05lZ2F0aXZlRGF0ZUJ1ZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmIG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9JU09TdHJpbmcoKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgPT09IC0xO1xuICAgIHZhciBoYXNTYWZhcmk1MURhdGVCdWcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiBuZXcgRGF0ZSgtMSkudG9JU09TdHJpbmcoKSAhPT0gJzE5NjktMTItMzFUMjM6NTk6NTkuOTk5Wic7XG5cbiAgICB2YXIgZ2V0VGltZSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRUaW1lKTtcblxuICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICAgICAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZSh0aGlzKSB8fCAhaXNGaW5pdGUoZ2V0VGltZSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBZG9wZSBQaG90b3Nob3AgcmVxdWlyZXMgdGhlIHNlY29uZCBjaGVjay5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgY2FsbGVkIG9uIG5vbi1maW5pdGUgdmFsdWUuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcblxuICAgICAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRVVENNb250aCh0aGlzKTtcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzExMVxuICAgICAgICAgICAgeWVhciArPSBNYXRoLmZsb29yKG1vbnRoIC8gMTIpO1xuICAgICAgICAgICAgbW9udGggPSAobW9udGggJSAxMiArIDEyKSAlIDEyO1xuXG4gICAgICAgICAgICAvLyB0aGUgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQgaXMgc3BlY2lmaWVkIGluIDE1LjkuMS4xNS5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbbW9udGggKyAxLCBvcmlnaW5hbEdldFVUQ0RhdGUodGhpcyksIG9yaWdpbmFsR2V0VVRDSG91cnModGhpcyksIG9yaWdpbmFsR2V0VVRDTWludXRlcyh0aGlzKSwgb3JpZ2luYWxHZXRVVENTZWNvbmRzKHRoaXMpXTtcbiAgICAgICAgICAgIHllYXIgPSAoXG4gICAgICAgICAgICAgICAgKHllYXIgPCAwID8gJy0nIDogKHllYXIgPiA5OTk5ID8gJysnIDogJycpKSArXG4gICAgICAgICAgICAgICAgc3RyU2xpY2UoJzAwMDAwJyArIE1hdGguYWJzKHllYXIpLCAoMCA8PSB5ZWFyICYmIHllYXIgPD0gOTk5OSkgPyAtNCA6IC02KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBwYWQgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgdG8gaGF2ZSB0d28gZGlnaXRzLlxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHN0clNsaWNlKCcwMCcgKyByZXN1bHRbaV0sIC0yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBhZCBtaWxsaXNlY29uZHMgdG8gaGF2ZSB0aHJlZSBkaWdpdHMuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHllYXIgKyAnLScgKyBhcnJheVNsaWNlKHJlc3VsdCwgMCwgMikuam9pbignLScpICtcbiAgICAgICAgICAgICAgICAnVCcgKyBhcnJheVNsaWNlKHJlc3VsdCwgMikuam9pbignOicpICsgJy4nICtcbiAgICAgICAgICAgICAgICBzdHJTbGljZSgnMDAwJyArIG9yaWdpbmFsR2V0VVRDTWlsbGlzZWNvbmRzKHRoaXMpLCAtMykgKyAnWidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LCBoYXNOZWdhdGl2ZURhdGVCdWcgfHwgaGFzU2FmYXJpNTFEYXRlQnVnKTtcblxuICAgIC8vIEVTNSAxNS45LjUuNDRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjUuNDRcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRGF0ZSBvYmplY3QgZm9yIHVzZSBieVxuICAgIC8vIEpTT04uc3RyaW5naWZ5ICgxNS4xMi4zKS5cbiAgICB2YXIgZGF0ZVRvSlNPTklzU3VwcG9ydGVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b0pTT04gJiZcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsICYmXG4gICAgICAgICAgICAgICAgbmV3IERhdGUobmVnYXRpdmVEYXRlKS50b0pTT04oKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoeyAvLyBnZW5lcmljXG4gICAgICAgICAgICAgICAgICAgIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG4gICAgaWYgKCFkYXRlVG9KU09OSXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgdG9KU09OIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCBhcmd1bWVudCBrZXksIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcblxuICAgICAgICAgICAgLy8gMS4gIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCwgZ2l2aW5nIGl0IHRoZSB0aGlzXG4gICAgICAgICAgICAvLyB2YWx1ZSBhcyBpdHMgYXJndW1lbnQuXG4gICAgICAgICAgICAvLyAyLiBMZXQgdHYgYmUgRVMuVG9QcmltaXRpdmUoTywgaGludCBOdW1iZXIpLlxuICAgICAgICAgICAgdmFyIE8gPSAkT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHR2ID0gRVMuVG9QcmltaXRpdmUoTyk7XG4gICAgICAgICAgICAvLyAzLiBJZiB0diBpcyBhIE51bWJlciBhbmQgaXMgbm90IGZpbml0ZSwgcmV0dXJuIG51bGwuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR2ID09PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUodHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA0LiBMZXQgdG9JU08gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0dldF1dIGludGVybmFsIG1ldGhvZCBvZlxuICAgICAgICAgICAgLy8gTyB3aXRoIGFyZ3VtZW50IFwidG9JU09TdHJpbmdcIi5cbiAgICAgICAgICAgIHZhciB0b0lTTyA9IE8udG9JU09TdHJpbmc7XG4gICAgICAgICAgICAvLyA1LiBJZiBJc0NhbGxhYmxlKHRvSVNPKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKHRvSVNPKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RvSVNPU3RyaW5nIHByb3BlcnR5IGlzIG5vdCBjYWxsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mXG4gICAgICAgICAgICAvLyAgdG9JU08gd2l0aCBPIGFzIHRoZSB0aGlzIHZhbHVlIGFuZCBhbiBlbXB0eSBhcmd1bWVudCBsaXN0LlxuICAgICAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoTyk7XG5cbiAgICAgICAgICAgIC8vIE5PVEUgMSBUaGUgYXJndW1lbnQgaXMgaWdub3JlZC5cblxuICAgICAgICAgICAgLy8gTk9URSAyIFRoZSB0b0pTT04gZnVuY3Rpb24gaXMgaW50ZW50aW9uYWxseSBnZW5lcmljOyBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgLy8gcmVxdWlyZSB0aGF0IGl0cyB0aGlzIHZhbHVlIGJlIGEgRGF0ZSBvYmplY3QuIFRoZXJlZm9yZSwgaXQgY2FuIGJlXG4gICAgICAgICAgICAvLyB0cmFuc2ZlcnJlZCB0byBvdGhlciBraW5kcyBvZiBvYmplY3RzIGZvciB1c2UgYXMgYSBtZXRob2QuIEhvd2V2ZXIsXG4gICAgICAgICAgICAvLyBpdCBkb2VzIHJlcXVpcmUgdGhhdCBhbnkgc3VjaCBvYmplY3QgaGF2ZSBhIHRvSVNPU3RyaW5nIG1ldGhvZC4gQW5cbiAgICAgICAgICAgIC8vIG9iamVjdCBpcyBmcmVlIHRvIHVzZSB0aGUgYXJndW1lbnQga2V5IHRvIGZpbHRlciBpdHNcbiAgICAgICAgICAgIC8vIHN0cmluZ2lmaWNhdGlvbi5cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuOS40LjJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuMlxuICAgIC8vIGJhc2VkIG9uIHdvcmsgc2hhcmVkIGJ5IERhbmllbCBGcmllc2VuIChkYW50bWFuKVxuICAgIC8vIGh0dHA6Ly9naXN0LmdpdGh1Yi5jb20vMzAzMjQ5XG4gICAgdmFyIHN1cHBvcnRzRXh0ZW5kZWRZZWFycyA9IERhdGUucGFyc2UoJyswMzM2NTgtMDktMjdUMDE6NDY6NDAuMDAwWicpID09PSAxZTE1O1xuICAgIHZhciBhY2NlcHRzSW52YWxpZERhdGVzID0gIWlzTmFOKERhdGUucGFyc2UoJzIwMTItMDQtMDRUMjQ6MDA6MDAuNTAwWicpKSB8fCAhaXNOYU4oRGF0ZS5wYXJzZSgnMjAxMi0xMS0zMVQyMzo1OTo1OS4wMDBaJykpIHx8ICFpc05hTihEYXRlLnBhcnNlKCcyMDEyLTEyLTMxVDIzOjU5OjYwLjAwMFonKSk7XG4gICAgdmFyIGRvZXNOb3RQYXJzZVkyS05ld1llYXIgPSBpc05hTihEYXRlLnBhcnNlKCcyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSk7XG4gICAgaWYgKGRvZXNOb3RQYXJzZVkyS05ld1llYXIgfHwgYWNjZXB0c0ludmFsaWREYXRlcyB8fCAhc3VwcG9ydHNFeHRlbmRlZFllYXJzKSB7XG4gICAgICAgIC8vIFhYWCBnbG9iYWwgYXNzaWdubWVudCB3b24ndCB3b3JrIGluIGVtYmVkZGluZ3MgdGhhdCB1c2VcbiAgICAgICAgLy8gYW4gYWx0ZXJuYXRlIG9iamVjdCBmb3IgdGhlIGNvbnRleHQuXG4gICAgICAgIC8qIGdsb2JhbCBEYXRlOiB0cnVlICovXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgICAgIHZhciBtYXhTYWZlVW5zaWduZWQzMkJpdCA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG4gICAgICAgIHZhciBoYXNTYWZhcmlTaWduZWRJbnRCdWcgPSBpc0FjdHVhbE5hTihuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCAwLCAwLCBtYXhTYWZlVW5zaWduZWQzMkJpdCArIDEpLmdldFRpbWUoKSk7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWltcGxpY2l0LWdsb2JhbHMgKi9cbiAgICAgICAgRGF0ZSA9IChmdW5jdGlvbiAoTmF0aXZlRGF0ZSkge1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWltcGxpY2l0LWdsb2JhbHMgKi9cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuICAgICAgICAgICAgLy8gRGF0ZS5sZW5ndGggPT09IDdcbiAgICAgICAgICAgIHZhciBEYXRlU2hpbSA9IGZ1bmN0aW9uIERhdGUoWSwgTSwgRCwgaCwgbSwgcywgbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE5hdGl2ZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWlsbGlzID0gbXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNTYWZhcmlTaWduZWRJbnRCdWcgJiYgbGVuZ3RoID49IDcgJiYgbXMgPiBtYXhTYWZlVW5zaWduZWQzMkJpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtcyAvIG1heFNhZmVVbnNpZ25lZDMyQml0KSAqIG1heFNhZmVVbnNpZ25lZDMyQml0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtc1RvU2hpZnQgLyAxZTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbGxpcyAtPSBzVG9TaGlmdCAqIDFlMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbGVuZ3RoID09PSAxICYmICRTdHJpbmcoWSkgPT09IFkgPyAvLyBpc1N0cmluZyhZKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZXhwbGljaXRseSBwYXNzIGl0IHRocm91Z2ggcGFyc2U6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTmF0aXZlRGF0ZShEYXRlU2hpbS5wYXJzZShZKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBtYW51YWxseSBtYWtlIGNhbGxzIGRlcGVuZGluZyBvbiBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA3ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCwgbSwgc2Vjb25kcywgbWlsbGlzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNiA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0sIHNlY29uZHMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA1ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCwgbSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDQgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gMyA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSAyID8gbmV3IE5hdGl2ZURhdGUoWSwgTSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDEgPyBuZXcgTmF0aXZlRGF0ZShZIGluc3RhbmNlb2YgTmF0aXZlRGF0ZSA/ICtZIDogWSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTmF0aXZlRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBOYXRpdmVEYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNQcmltaXRpdmUoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBtaXh1cHMgd2l0aCB1bmZpeGVkIERhdGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMoZGF0ZSwgeyBjb25zdHJ1Y3RvcjogRGF0ZVNoaW0gfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMTUuOS4xLjE1IERhdGUgVGltZSBTdHJpbmcgRm9ybWF0LlxuICAgICAgICAgICAgdmFyIGlzb0RhdGVFeHByZXNzaW9uID0gbmV3IFJlZ0V4cCgnXicgK1xuICAgICAgICAgICAgICAgICcoXFxcXGR7NH18WystXVxcXFxkezZ9KScgKyAvLyBmb3VyLWRpZ2l0IHllYXIgY2FwdHVyZSBvciBzaWduICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDYtZGlnaXQgZXh0ZW5kZWQgeWVhclxuICAgICAgICAgICAgICAgICcoPzotKFxcXFxkezJ9KScgKyAvLyBvcHRpb25hbCBtb250aCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyg/Oi0oXFxcXGR7Mn0pJyArIC8vIG9wdGlvbmFsIGRheSBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyg/OicgKyAvLyBjYXB0dXJlIGhvdXJzOm1pbnV0ZXM6c2Vjb25kcy5taWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgJ1QoXFxcXGR7Mn0pJyArIC8vIGhvdXJzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIG1pbnV0ZXMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9wdGlvbmFsIDpzZWNvbmRzLm1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIHNlY29uZHMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OihcXFxcLlxcXFxkezEsfSkpPycgKyAvLyBtaWxsaXNlY29uZHMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKT8nICtcbiAgICAgICAgICAgICAgICAnKCcgKyAvLyBjYXB0dXJlIFVUQyBvZmZzZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICdafCcgKyAvLyBVVEMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9mZnNldCBzcGVjaWZpZXIgKy8taG91cnM6bWludXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhbLStdKScgKyAvLyBzaWduIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICcoXFxcXGR7Mn0pJyArIC8vIGhvdXJzIG9mZnNldCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gbWludXRlcyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKScgK1xuICAgICAgICAgICAgICAgICcpPyk/KT8pPycgK1xuICAgICAgICAgICAgJyQnKTtcblxuICAgICAgICAgICAgdmFyIG1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCwgMzY1XTtcblxuICAgICAgICAgICAgdmFyIGRheUZyb21Nb250aCA9IGZ1bmN0aW9uIGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gbW9udGggPiAxID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzW21vbnRoXSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxOTY5ICsgdCkgLyA0KSAtXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxOTAxICsgdCkgLyAxMDApICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcigoeWVhciAtIDE2MDEgKyB0KSAvIDQwMCkgK1xuICAgICAgICAgICAgICAgICAgICAzNjUgKiAoeWVhciAtIDE5NzApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0b1VUQyA9IGZ1bmN0aW9uIHRvVVRDKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIG1zID0gdDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2FmYXJpU2lnbmVkSW50QnVnICYmIG1zID4gbWF4U2FmZVVuc2lnbmVkMzJCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc1RvU2hpZnQgPSBNYXRoLmZsb29yKG1zIC8gbWF4U2FmZVVuc2lnbmVkMzJCaXQpICogbWF4U2FmZVVuc2lnbmVkMzJCaXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzVG9TaGlmdCA9IE1hdGguZmxvb3IobXNUb1NoaWZ0IC8gMWUzKTtcbiAgICAgICAgICAgICAgICAgICAgcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgbXMgLT0gc1RvU2hpZnQgKiAxZTM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkTnVtYmVyKG5ldyBOYXRpdmVEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIHMsIG1zKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDb3B5IGFueSBjdXN0b20gbWV0aG9kcyBhIDNyZCBwYXJ0eSBsaWJyYXJ5IG1heSBoYXZlIGFkZGVkXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gTmF0aXZlRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvd25zKE5hdGl2ZURhdGUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgRGF0ZVNoaW1ba2V5XSA9IE5hdGl2ZURhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvcHkgXCJuYXRpdmVcIiBtZXRob2RzIGV4cGxpY2l0bHk7IHRoZXkgbWF5IGJlIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGVTaGltLCB7XG4gICAgICAgICAgICAgICAgbm93OiBOYXRpdmVEYXRlLm5vdyxcbiAgICAgICAgICAgICAgICBVVEM6IE5hdGl2ZURhdGUuVVRDXG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIERhdGVTaGltLnByb3RvdHlwZSA9IE5hdGl2ZURhdGUucHJvdG90eXBlO1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogRGF0ZVNoaW1cbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBVcGdyYWRlIERhdGUucGFyc2UgdG8gaGFuZGxlIHNpbXBsaWZpZWQgSVNPIDg2MDEgc3RyaW5nc1xuICAgICAgICAgICAgdmFyIHBhcnNlU2hpbSA9IGZ1bmN0aW9uIHBhcnNlKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGlzb0RhdGVFeHByZXNzaW9uLmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlIGRlZmF1bHQgdmFsdWVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgVVRDIG9mZnNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHllYXIgPSAkTnVtYmVyKG1hdGNoWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gJE51bWJlcihtYXRjaFsyXSB8fCAxKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkgPSAkTnVtYmVyKG1hdGNoWzNdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgPSAkTnVtYmVyKG1hdGNoWzRdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlID0gJE51bWJlcihtYXRjaFs1XSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZCA9ICROdW1iZXIobWF0Y2hbNl0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IE1hdGguZmxvb3IoJE51bWJlcihtYXRjaFs3XSB8fCAwKSAqIDEwMDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aW1lIHpvbmUgaXMgbWlzc2VkLCBsb2NhbCBvZmZzZXQgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChFUyA1LjEgYnVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVncy5lY21hc2NyaXB0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xvY2FsVGltZSA9IEJvb2xlYW4obWF0Y2hbNF0gJiYgIW1hdGNoWzhdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25PZmZzZXQgPSBtYXRjaFs5XSA9PT0gJy0nID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCA9ICROdW1iZXIobWF0Y2hbMTBdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlT2Zmc2V0ID0gJE51bWJlcihtYXRjaFsxMV0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNNaW51dGVzT3JTZWNvbmRzT3JNaWxsaXNlY29uZHMgPSBtaW51dGUgPiAwIHx8IHNlY29uZCA+IDAgfHwgbWlsbGlzZWNvbmQgPiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VyIDwgKGhhc01pbnV0ZXNPclNlY29uZHNPck1pbGxpc2Vjb25kcyA/IDI0IDogMjUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW51dGUgPCA2MCAmJiBzZWNvbmQgPCA2MCAmJiBtaWxsaXNlY29uZCA8IDEwMDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID4gLTEgJiYgbW9udGggPCAxMiAmJiBob3VyT2Zmc2V0IDwgMjQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZU9mZnNldCA8IDYwICYmIC8vIGRldGVjdCBpbnZhbGlkIG9mZnNldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkgPCAoZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoICsgMSkgLSBkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoKSArIGRheSkgKiAyNCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ciArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCAqIHNpZ25PZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICkgKiA2MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0ICsgbWludXRlICsgbWludXRlT2Zmc2V0ICogc2lnbk9mZnNldCkgKiA2MCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kXG4gICAgICAgICAgICAgICAgICAgICAgICApICogMTAwMCArIG1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9VVEMocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtOC42NGUxNSA8PSByZXN1bHQgJiYgcmVzdWx0IDw9IDguNjRlMTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBOYXRpdmVEYXRlLnBhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbSwgeyBwYXJzZTogcGFyc2VTaGltIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRGF0ZVNoaW07XG4gICAgICAgIH0oRGF0ZSkpO1xuICAgICAgICAvKiBnbG9iYWwgRGF0ZTogZmFsc2UgKi9cbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuOS40LjRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuNFxuICAgIGlmICghRGF0ZS5ub3cpIHtcbiAgICAgICAgRGF0ZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBOdW1iZXJcbiAgICAvLyA9PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVM1LjEgMTUuNy40LjVcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS43LjQuNVxuICAgIHZhciBoYXNUb0ZpeGVkQnVncyA9IE51bWJlclByb3RvdHlwZS50b0ZpeGVkICYmIChcbiAgICAgICgwLjAwMDA4KS50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gICAgICAoMC45KS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgICAgICgxLjI1NSkudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gICAgICAoMTAwMDAwMDAwMDAwMDAwMDEyOCkudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4gICAgKTtcblxuICAgIHZhciB0b0ZpeGVkSGVscGVycyA9IHtcbiAgICAgICAgYmFzZTogMWU3LFxuICAgICAgICBzaXplOiA2LFxuICAgICAgICBkYXRhOiBbMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiBtdWx0aXBseShuLCBjKSB7XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgdmFyIGMyID0gYztcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCB0b0ZpeGVkSGVscGVycy5zaXplKSB7XG4gICAgICAgICAgICAgICAgYzIgKz0gbiAqIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGF0YVtpXSA9IGMyICUgdG9GaXhlZEhlbHBlcnMuYmFzZTtcbiAgICAgICAgICAgICAgICBjMiA9IE1hdGguZmxvb3IoYzIgLyB0b0ZpeGVkSGVscGVycy5iYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbiBkaXZpZGUobikge1xuICAgICAgICAgICAgdmFyIGkgPSB0b0ZpeGVkSGVscGVycy5zaXplO1xuICAgICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYyArPSB0b0ZpeGVkSGVscGVycy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gPSBNYXRoLmZsb29yKGMgLyBuKTtcbiAgICAgICAgICAgICAgICBjID0gKGMgJSBuKSAqIHRvRml4ZWRIZWxwZXJzLmJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG51bVRvU3RyaW5nOiBmdW5jdGlvbiBudW1Ub1N0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBpID0gdG9GaXhlZEhlbHBlcnMuc2l6ZTtcbiAgICAgICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCB0b0ZpeGVkSGVscGVycy5kYXRhW2ldICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gJFN0cmluZyh0b0ZpeGVkSGVscGVycy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gdDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gc3RyU2xpY2UoJzAwMDAwMDAnLCAwLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LFxuICAgICAgICBwb3c6IGZ1bmN0aW9uIHBvdyh4LCBuLCBhY2MpIHtcbiAgICAgICAgICAgIHJldHVybiAobiA9PT0gMCA/IGFjYyA6IChuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvZzogZnVuY3Rpb24gbG9nKHgpIHtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIHZhciB4MiA9IHg7XG4gICAgICAgICAgICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgICAgICAgICAgICAgIG4gKz0gMTI7XG4gICAgICAgICAgICAgICAgeDIgLz0gNDA5NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgICAgIHgyIC89IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdG9GaXhlZFNoaW0gPSBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIHZhciBmLCB4LCBzLCBtLCBlLCB6LCBqLCBrO1xuXG4gICAgICAgIC8vIFRlc3QgZm9yIE5hTiBhbmQgcm91bmQgZnJhY3Rpb25EaWdpdHMgZG93blxuICAgICAgICBmID0gJE51bWJlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgICAgIGYgPSBpc0FjdHVhbE5hTihmKSA/IDAgOiBNYXRoLmZsb29yKGYpO1xuXG4gICAgICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOdW1iZXIudG9GaXhlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIG51bWJlciBvZiBkZWNpbWFscycpO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9ICROdW1iZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKGlzQWN0dWFsTmFOKHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ05hTic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyB0b28gYmlnIG9yIHNtYWxsLCByZXR1cm4gdGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgbnVtYmVyXG4gICAgICAgIGlmICh4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSkge1xuICAgICAgICAgICAgcmV0dXJuICRTdHJpbmcoeCk7XG4gICAgICAgIH1cblxuICAgICAgICBzID0gJyc7XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICBzID0gJy0nO1xuICAgICAgICAgICAgeCA9IC14O1xuICAgICAgICB9XG5cbiAgICAgICAgbSA9ICcwJztcblxuICAgICAgICBpZiAoeCA+IDFlLTIxKSB7XG4gICAgICAgICAgICAvLyAxZS0yMSA8IHggPCAxZTIxXG4gICAgICAgICAgICAvLyAtNzAgPCBsb2cyKHgpIDwgNzBcbiAgICAgICAgICAgIGUgPSB0b0ZpeGVkSGVscGVycy5sb2coeCAqIHRvRml4ZWRIZWxwZXJzLnBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICAgICAgICB6ID0gKGUgPCAwID8geCAqIHRvRml4ZWRIZWxwZXJzLnBvdygyLCAtZSwgMSkgOiB4IC8gdG9GaXhlZEhlbHBlcnMucG93KDIsIGUsIDEpKTtcbiAgICAgICAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDsgLy8gTWF0aC5wb3coMiwgNTIpO1xuICAgICAgICAgICAgZSA9IDUyIC0gZTtcblxuICAgICAgICAgICAgLy8gLTE4IDwgZSA8IDEyMlxuICAgICAgICAgICAgLy8geCA9IHogLyAyIF4gZVxuICAgICAgICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMCwgeik7XG4gICAgICAgICAgICAgICAgaiA9IGY7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gNztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSh0b0ZpeGVkSGVscGVycy5wb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgICAgICAgICBqID0gZSAtIDE7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDEgPDwgaik7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMSwgMSk7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDIpO1xuICAgICAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgwLCB6KTtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgxIDw8ICgtZSksIDApO1xuICAgICAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAyLCAyICsgZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZiA+IDApIHtcbiAgICAgICAgICAgIGsgPSBtLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGsgPD0gZikge1xuICAgICAgICAgICAgICAgIG0gPSBzICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDAsIGYgLSBrICsgMikgKyBtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtID0gcyArIHN0clNsaWNlKG0sIDAsIGsgLSBmKSArICcuJyArIHN0clNsaWNlKG0sIGsgLSBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0gPSBzICsgbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHsgdG9GaXhlZDogdG9GaXhlZFNoaW0gfSwgaGFzVG9GaXhlZEJ1Z3MpO1xuXG4gICAgdmFyIGhhc1RvUHJlY2lzaW9uVW5kZWZpbmVkQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAxLjAudG9QcmVjaXNpb24odW5kZWZpbmVkKSA9PT0gJzEnO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG4gICAgdmFyIG9yaWdpbmFsVG9QcmVjaXNpb24gPSBOdW1iZXJQcm90b3R5cGUudG9QcmVjaXNpb247XG4gICAgZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHtcbiAgICAgICAgdG9QcmVjaXNpb246IGZ1bmN0aW9uIHRvUHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwcmVjaXNpb24gPT09ICd1bmRlZmluZWQnID8gb3JpZ2luYWxUb1ByZWNpc2lvbi5jYWxsKHRoaXMpIDogb3JpZ2luYWxUb1ByZWNpc2lvbi5jYWxsKHRoaXMsIHByZWNpc2lvbik7XG4gICAgICAgIH1cbiAgICB9LCBoYXNUb1ByZWNpc2lvblVuZGVmaW5lZEJ1Zyk7XG5cbiAgICAvL1xuICAgIC8vIFN0cmluZ1xuICAgIC8vID09PT09PVxuICAgIC8vXG5cbiAgICAvLyBFUzUgMTUuNS40LjE0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbiAgICAvLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4gICAgLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcbiAgICAvLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbiAgICAvLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbiAgICAvLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XG4gICAgLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbiAgICAvLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbiAgICAvLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XG4gICAgLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbiAgICAvLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbiAgICAvLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cblxuICAgIGlmIChcbiAgICAgICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XG4gICAgICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAgICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcbiAgICApIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IHR5cGVvZiAoLygpPz8vKS5leGVjKCcnKVsxXSA9PT0gJ3VuZGVmaW5lZCc7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgICB2YXIgbWF4U2FmZTMyQml0SW50ID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxuICAgICAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVnZXgoc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyU3BsaXQodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArIC8vIGluIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrIGFuZCBFUzZcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gbWF4U2FmZTMyQml0SW50XG4gICAgICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRMaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgPyBtYXhTYWZlMzJCaXRJbnQgOiBFUy5Ub1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKG91dHB1dCwgc3RyU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X3B1c2guYXBwbHkob3V0cHV0LCBhcnJheVNsaWNlKG1hdGNoLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IHNwbGl0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yQ29weS5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKG91dHB1dCwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwob3V0cHV0LCBzdHJTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBzcGxpdExpbWl0ID8gYXJyYXlTbGljZShvdXRwdXQsIDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcblxuICAgIC8vIFtidWdmaXgsIGNocm9tZV1cbiAgICAvLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuICAgIC8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuICAgIC8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbiAgICAvLyBlbGVtZW50cy5cbiAgICAvLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG4gICAgfSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0clNwbGl0KHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzdHJfcmVwbGFjZSA9IFN0cmluZ1Byb3RvdHlwZS5yZXBsYWNlO1xuICAgIHZhciByZXBsYWNlUmVwb3J0c0dyb3Vwc0NvcnJlY3RseSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBbXTtcbiAgICAgICAgJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtYXRjaCwgZ3JvdXApIHtcbiAgICAgICAgICAgIHB1c2hDYWxsKGdyb3VwcywgZ3JvdXApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyb3Vwcy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGdyb3Vwc1swXSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfSgpKTtcblxuICAgIGlmICghcmVwbGFjZVJlcG9ydHNHcm91cHNDb3JyZWN0bHkpIHtcbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBpc0ZuID0gaXNDYWxsYWJsZShyZXBsYWNlVmFsdWUpO1xuICAgICAgICAgICAgdmFyIGhhc0NhcHR1cmluZ0dyb3VwcyA9IGlzUmVnZXgoc2VhcmNoVmFsdWUpICYmICgvXFwpWyo/XS8pLnRlc3Qoc2VhcmNoVmFsdWUuc291cmNlKTtcbiAgICAgICAgICAgIGlmICghaXNGbiB8fCAhaGFzQ2FwdHVyaW5nR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cl9yZXBsYWNlLmNhbGwodGhpcywgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkUmVwbGFjZVZhbHVlID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxMYXN0SW5kZXggPSBzZWFyY2hWYWx1ZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2VhcmNoVmFsdWUuZXhlYyhtYXRjaCkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlLmxhc3RJbmRleCA9IG9yaWdpbmFsTGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbChhcmdzLCBhcmd1bWVudHNbbGVuZ3RoIC0gMl0sIGFyZ3VtZW50c1tsZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlVmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyX3JlcGxhY2UuY2FsbCh0aGlzLCBzZWFyY2hWYWx1ZSwgd3JhcHBlZFJlcGxhY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuICAgIC8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4gICAgLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuICAgIC8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuICAgIC8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG4gICAgdmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xuICAgIHZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgICAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFN0YXJ0ID0gbWF4KHRoaXMubGVuZ3RoICsgc3RhcnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbCh0aGlzLCBub3JtYWxpemVkU3RhcnQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuNS40LjIwXG4gICAgLy8gd2hpdGVzcGFjZSBmcm9tOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjUuNC4yMFxuICAgIHZhciB3cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAgICAgICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnICtcbiAgICAgICAgJ1xcdTIwMjlcXHVGRUZGJztcbiAgICB2YXIgemVyb1dpZHRoID0gJ1xcdTIwMGInO1xuICAgIHZhciB3c1JlZ2V4Q2hhcnMgPSAnWycgKyB3cyArICddJztcbiAgICB2YXIgdHJpbUJlZ2luUmVnZXhwID0gbmV3IFJlZ0V4cCgnXicgKyB3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKicpO1xuICAgIHZhciB0cmltRW5kUmVnZXhwID0gbmV3IFJlZ0V4cCh3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKiQnKTtcbiAgICB2YXIgaGFzVHJpbVdoaXRlc3BhY2VCdWcgPSBTdHJpbmdQcm90b3R5cGUudHJpbSAmJiAod3MudHJpbSgpIHx8ICF6ZXJvV2lkdGgudHJpbSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgICAgICAvLyBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvZmFzdGVyLXRyaW0tamF2YXNjcmlwdFxuICAgICAgICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS93aGl0ZXNwYWNlLWRldmlhdGlvbnMvXG4gICAgICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIHRoaXMgKyAnIHRvIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRTdHJpbmcodGhpcykucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsICcnKS5yZXBsYWNlKHRyaW1FbmRSZWdleHAsICcnKTtcbiAgICAgICAgfVxuICAgIH0sIGhhc1RyaW1XaGl0ZXNwYWNlQnVnKTtcbiAgICB2YXIgdHJpbSA9IGNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlLnRyaW0pO1xuXG4gICAgdmFyIGhhc0xhc3RJbmRleEJ1ZyA9IFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZiAmJiAnYWJj44GC44GEJy5sYXN0SW5kZXhPZign44GC44GEJywgMikgIT09IC0xO1xuICAgIGRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgUyA9ICRTdHJpbmcodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VhcmNoU3RyID0gJFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgICAgICAgICAgdmFyIG51bVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gJE51bWJlcihhcmd1bWVudHNbMV0pIDogTmFOO1xuICAgICAgICAgICAgdmFyIHBvcyA9IGlzQWN0dWFsTmFOKG51bVBvcykgPyBJbmZpbml0eSA6IEVTLlRvSW50ZWdlcihudW1Qb3MpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbWluKG1heChwb3MsIDApLCBTLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgc2VhcmNoTGVuID0gc2VhcmNoU3RyLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBrID0gc3RhcnQgKyBzZWFyY2hMZW47XG4gICAgICAgICAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgICAgICAgICAgICBrID0gbWF4KDAsIGsgLSBzZWFyY2hMZW4pO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0ckluZGV4T2Yoc3RyU2xpY2UoUywgaywgc3RhcnQgKyBzZWFyY2hMZW4pLCBzZWFyY2hTdHIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGsgKyBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9LCBoYXNMYXN0SW5kZXhCdWcpO1xuXG4gICAgdmFyIG9yaWdpbmFsTGFzdEluZGV4T2YgPSBTdHJpbmdQcm90b3R5cGUubGFzdEluZGV4T2Y7XG4gICAgZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICAgICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTGFzdEluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sIFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZi5sZW5ndGggIT09IDEpO1xuXG4gICAgLy8gRVMtNSAxNS4xLjIuMlxuICAgIC8qIGVzbGludC1kaXNhYmxlIHJhZGl4ICovXG4gICAgaWYgKHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMikge1xuICAgIC8qIGVzbGludC1lbmFibGUgcmFkaXggKi9cbiAgICAgICAgLyogZ2xvYmFsIHBhcnNlSW50OiB0cnVlICovXG4gICAgICAgIHBhcnNlSW50ID0gKGZ1bmN0aW9uIChvcmlnUGFyc2VJbnQpIHtcbiAgICAgICAgICAgIHZhciBoZXhSZWdleCA9IC9eW1xcLStdPzBbeFhdLztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRyaW0oU3RyaW5nKHN0cikpO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0ZWRSYWRpeCA9ICROdW1iZXIocmFkaXgpIHx8IChoZXhSZWdleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ1BhcnNlSW50KHN0cmluZywgZGVmYXVsdGVkUmFkaXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfShwYXJzZUludCkpO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4zXG4gICAgaWYgKDEgLyBwYXJzZUZsb2F0KCctMCcpICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgLyogZ2xvYmFsIHBhcnNlRmxvYXQ6IHRydWUgKi9cbiAgICAgICAgcGFyc2VGbG9hdCA9IChmdW5jdGlvbiAob3JpZ1BhcnNlRmxvYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dFN0cmluZyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlnUGFyc2VGbG9hdChpbnB1dFN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJTbGljZShpbnB1dFN0cmluZywgMCwgMSkgPT09ICctJyA/IC0wIDogcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfShwYXJzZUZsb2F0KSk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZyhuZXcgUmFuZ2VFcnJvcigndGVzdCcpKSAhPT0gJ1JhbmdlRXJyb3I6IHRlc3QnKSB7XG4gICAgICAgIHZhciBlcnJvclRvU3RyaW5nU2hpbSA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzID09PSAndW5kZWZpbmVkJyB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnRXJyb3InO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gJFN0cmluZyhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtc2cgPSB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAkU3RyaW5nKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lICsgJzogJyArIG1zZztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY2FuJ3QgdXNlIGRlZmluZVByb3BlcnRpZXMgaGVyZSBiZWNhdXNlIG9mIHRvU3RyaW5nIGVudW1lcmF0aW9uIGlzc3VlIGluIElFIDw9IDhcbiAgICAgICAgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZXJyb3JUb1N0cmluZ1NoaW07XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgdmFyIGVuc3VyZU5vbkVudW1lcmFibGUgPSBmdW5jdGlvbiAob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoaXNFbnVtKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICdtZXNzYWdlJyk7XG4gICAgICAgIGlmIChFcnJvci5wcm90b3R5cGUubWVzc2FnZSAhPT0gJycpIHtcbiAgICAgICAgICAgIEVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICduYW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZygvYS9taWcpICE9PSAnL2EvZ2ltJykge1xuICAgICAgICB2YXIgcmVnZXhUb1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIHN0ciA9ICcvJyArIHRoaXMuc291cmNlICsgJy8nO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICdnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJ2knO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICdtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNhbid0IHVzZSBkZWZpbmVQcm9wZXJ0aWVzIGhlcmUgYmVjYXVzZSBvZiB0b1N0cmluZyBlbnVtZXJhdGlvbiBpc3N1ZSBpbiBJRSA8PSA4XG4gICAgICAgIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcgPSByZWdleFRvU3RyaW5nO1xuICAgIH1cbn0pKTtcbiIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4zLjFcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIF9pc0FycmF5ID0gdW5kZWZpbmVkO1xuaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB1bmRlZmluZWQ7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB1bmRlZmluZWQ7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHt9KS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdW5kZWZpbmVkO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblxuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gIGlmIChfc3RhdGUpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gX2FyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbnZhciBHRVRfVEhFTl9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIEdFVF9USEVOX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJCkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJCA9PT0gR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJCkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGdldFRoZW4odmFsdWUpKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB1bmRlZmluZWQsXG4gICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIEVycm9yT2JqZWN0KCkge1xuICB0aGlzLmVycm9yID0gbnVsbDtcbn1cblxudmFyIFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkLFxuICAgICAgZXJyb3IgPSB1bmRlZmluZWQsXG4gICAgICBzdWNjZWVkZWQgPSB1bmRlZmluZWQsXG4gICAgICBmYWlsZWQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdmFsdWUgPSB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIF9yZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgIHRoaXMuX2VudW1lcmF0ZSgpO1xuICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX3JlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB2YXIgX2lucHV0ID0gdGhpcy5faW5wdXQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2VhY2hFbnRyeShfaW5wdXRbaV0sIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgdmFyIHJlc29sdmUkJCA9IGMucmVzb2x2ZTtcblxuICBpZiAocmVzb2x2ZSQkID09PSByZXNvbHZlKSB7XG4gICAgdmFyIF90aGVuID0gZ2V0VGhlbihlbnRyeSk7XG5cbiAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UpIHtcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlJCQoZW50cnkpO1xuICAgICAgfSksIGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkKGVudHJ5KSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiAoc3RhdGUsIGksIHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gIH0pO1xufTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgfVxufVxuXG5Qcm9taXNlLmFsbCA9IGFsbDtcblByb21pc2UucmFjZSA9IHJhY2U7XG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5Qcm9taXNlLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UuX2FzYXAgPSBhc2FwO1xuXG5Qcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFByb21pc2UsXG5cbiAgLyoqXG4gICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQ2hhaW5pbmdcbiAgICAtLS0tLS0tLVxuICBcbiAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICB9KTtcbiAgXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgfSk7XG4gICAgYGBgXG4gICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFzc2ltaWxhdGlvblxuICAgIC0tLS0tLS0tLS0tLVxuICBcbiAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBTaW1wbGUgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCByZXN1bHQ7XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCBhdXRob3IsIGJvb2tzO1xuICBcbiAgICB0cnkge1xuICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gIFxuICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgXG4gICAgfVxuICBcbiAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICBcbiAgICB9XG4gIFxuICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZEF1dGhvcigpLlxuICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCB0aGVuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIHRoZW46IHRoZW4sXG5cbiAgLyoqXG4gICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIFxuICAgIGBgYGpzXG4gICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgfVxuICBcbiAgICAvLyBzeW5jaHJvbm91c1xuICAgIHRyeSB7XG4gICAgICBmaW5kQXV0aG9yKCk7XG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfVxuICBcbiAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgZmluZEF1dGhvcigpWydjYXRjaCddKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGNhdGNoXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgJ2NhdGNoJzogZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIHZhciBsb2NhbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgIGlmIChQKSB7XG4gICAgICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2FsLlByb21pc2UgPSBQcm9taXNlO1xufVxuXG5wb2x5ZmlsbCgpO1xuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZS5Qcm9taXNlID0gUHJvbWlzZTtcblxucmV0dXJuIFByb21pc2U7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tRnJvbVNlZWQgPSByZXF1aXJlKCcuL3JhbmRvbS9yYW5kb20tZnJvbS1zZWVkJyk7XG5cbnZhciBPUklHSU5BTCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWl8tJztcbnZhciBhbHBoYWJldDtcbnZhciBwcmV2aW91c1NlZWQ7XG5cbnZhciBzaHVmZmxlZDtcblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgc2h1ZmZsZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2V0Q2hhcmFjdGVycyhfYWxwaGFiZXRfKSB7XG4gICAgaWYgKCFfYWxwaGFiZXRfKSB7XG4gICAgICAgIGlmIChhbHBoYWJldCAhPT0gT1JJR0lOQUwpIHtcbiAgICAgICAgICAgIGFscGhhYmV0ID0gT1JJR0lOQUw7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoX2FscGhhYmV0XyA9PT0gYWxwaGFiZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChfYWxwaGFiZXRfLmxlbmd0aCAhPT0gT1JJR0lOQUwubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIGFscGhhYmV0IGZvciBzaG9ydGlkIG11c3QgYmUgJyArIE9SSUdJTkFMLmxlbmd0aCArICcgdW5pcXVlIGNoYXJhY3RlcnMuIFlvdSBzdWJtaXR0ZWQgJyArIF9hbHBoYWJldF8ubGVuZ3RoICsgJyBjaGFyYWN0ZXJzOiAnICsgX2FscGhhYmV0Xyk7XG4gICAgfVxuXG4gICAgdmFyIHVuaXF1ZSA9IF9hbHBoYWJldF8uc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihpdGVtLCBpbmQsIGFycil7XG4gICAgICAgcmV0dXJuIGluZCAhPT0gYXJyLmxhc3RJbmRleE9mKGl0ZW0pO1xuICAgIH0pO1xuXG4gICAgaWYgKHVuaXF1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXN0b20gYWxwaGFiZXQgZm9yIHNob3J0aWQgbXVzdCBiZSAnICsgT1JJR0lOQUwubGVuZ3RoICsgJyB1bmlxdWUgY2hhcmFjdGVycy4gVGhlc2UgY2hhcmFjdGVycyB3ZXJlIG5vdCB1bmlxdWU6ICcgKyB1bmlxdWUuam9pbignLCAnKSk7XG4gICAgfVxuXG4gICAgYWxwaGFiZXQgPSBfYWxwaGFiZXRfO1xuICAgIHJlc2V0KCk7XG59XG5cbmZ1bmN0aW9uIGNoYXJhY3RlcnMoX2FscGhhYmV0Xykge1xuICAgIHNldENoYXJhY3RlcnMoX2FscGhhYmV0Xyk7XG4gICAgcmV0dXJuIGFscGhhYmV0O1xufVxuXG5mdW5jdGlvbiBzZXRTZWVkKHNlZWQpIHtcbiAgICByYW5kb21Gcm9tU2VlZC5zZWVkKHNlZWQpO1xuICAgIGlmIChwcmV2aW91c1NlZWQgIT09IHNlZWQpIHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcHJldmlvdXNTZWVkID0gc2VlZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNodWZmbGUoKSB7XG4gICAgaWYgKCFhbHBoYWJldCkge1xuICAgICAgICBzZXRDaGFyYWN0ZXJzKE9SSUdJTkFMKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlQXJyYXkgPSBhbHBoYWJldC5zcGxpdCgnJyk7XG4gICAgdmFyIHRhcmdldEFycmF5ID0gW107XG4gICAgdmFyIHIgPSByYW5kb21Gcm9tU2VlZC5uZXh0VmFsdWUoKTtcbiAgICB2YXIgY2hhcmFjdGVySW5kZXg7XG5cbiAgICB3aGlsZSAoc291cmNlQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICByID0gcmFuZG9tRnJvbVNlZWQubmV4dFZhbHVlKCk7XG4gICAgICAgIGNoYXJhY3RlckluZGV4ID0gTWF0aC5mbG9vcihyICogc291cmNlQXJyYXkubGVuZ3RoKTtcbiAgICAgICAgdGFyZ2V0QXJyYXkucHVzaChzb3VyY2VBcnJheS5zcGxpY2UoY2hhcmFjdGVySW5kZXgsIDEpWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldEFycmF5LmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBnZXRTaHVmZmxlZCgpIHtcbiAgICBpZiAoc2h1ZmZsZWQpIHtcbiAgICAgICAgcmV0dXJuIHNodWZmbGVkO1xuICAgIH1cbiAgICBzaHVmZmxlZCA9IHNodWZmbGUoKTtcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG59XG5cbi8qKlxuICogbG9va3VwIHNodWZmbGVkIGxldHRlclxuICogQHBhcmFtIGluZGV4XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBsb29rdXAoaW5kZXgpIHtcbiAgICB2YXIgYWxwaGFiZXRTaHVmZmxlZCA9IGdldFNodWZmbGVkKCk7XG4gICAgcmV0dXJuIGFscGhhYmV0U2h1ZmZsZWRbaW5kZXhdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjaGFyYWN0ZXJzOiBjaGFyYWN0ZXJzLFxuICAgIHNlZWQ6IHNldFNlZWQsXG4gICAgbG9va3VwOiBsb29rdXAsXG4gICAgc2h1ZmZsZWQ6IGdldFNodWZmbGVkXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFscGhhYmV0ID0gcmVxdWlyZSgnLi9hbHBoYWJldCcpO1xuXG4vKipcbiAqIERlY29kZSB0aGUgaWQgdG8gZ2V0IHRoZSB2ZXJzaW9uIGFuZCB3b3JrZXJcbiAqIE1haW5seSBmb3IgZGVidWdnaW5nIGFuZCB0ZXN0aW5nLlxuICogQHBhcmFtIGlkIC0gdGhlIHNob3J0aWQtZ2VuZXJhdGVkIGlkLlxuICovXG5mdW5jdGlvbiBkZWNvZGUoaWQpIHtcbiAgICB2YXIgY2hhcmFjdGVycyA9IGFscGhhYmV0LnNodWZmbGVkKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbjogY2hhcmFjdGVycy5pbmRleE9mKGlkLnN1YnN0cigwLCAxKSkgJiAweDBmLFxuICAgICAgICB3b3JrZXI6IGNoYXJhY3RlcnMuaW5kZXhPZihpZC5zdWJzdHIoMSwgMSkpICYgMHgwZlxuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tQnl0ZSA9IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmRvbS1ieXRlJyk7XG5cbmZ1bmN0aW9uIGVuY29kZShsb29rdXAsIG51bWJlcikge1xuICAgIHZhciBsb29wQ291bnRlciA9IDA7XG4gICAgdmFyIGRvbmU7XG5cbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgc3RyID0gc3RyICsgbG9va3VwKCAoIChudW1iZXIgPj4gKDQgKiBsb29wQ291bnRlcikpICYgMHgwZiApIHwgcmFuZG9tQnl0ZSgpICk7XG4gICAgICAgIGRvbmUgPSBudW1iZXIgPCAoTWF0aC5wb3coMTYsIGxvb3BDb3VudGVyICsgMSApICk7XG4gICAgICAgIGxvb3BDb3VudGVyKys7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWxwaGFiZXQgPSByZXF1aXJlKCcuL2FscGhhYmV0Jyk7XG52YXIgZW5jb2RlID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbnZhciBkZWNvZGUgPSByZXF1aXJlKCcuL2RlY29kZScpO1xudmFyIGlzVmFsaWQgPSByZXF1aXJlKCcuL2lzLXZhbGlkJyk7XG5cbi8vIElnbm9yZSBhbGwgbWlsbGlzZWNvbmRzIGJlZm9yZSBhIGNlcnRhaW4gdGltZSB0byByZWR1Y2UgdGhlIHNpemUgb2YgdGhlIGRhdGUgZW50cm9weSB3aXRob3V0IHNhY3JpZmljaW5nIHVuaXF1ZW5lc3MuXG4vLyBUaGlzIG51bWJlciBzaG91bGQgYmUgdXBkYXRlZCBldmVyeSB5ZWFyIG9yIHNvIHRvIGtlZXAgdGhlIGdlbmVyYXRlZCBpZCBzaG9ydC5cbi8vIFRvIHJlZ2VuZXJhdGUgYG5ldyBEYXRlKCkgLSAwYCBhbmQgYnVtcCB0aGUgdmVyc2lvbi4gQWx3YXlzIGJ1bXAgdGhlIHZlcnNpb24hXG52YXIgUkVEVUNFX1RJTUUgPSAxNDU5NzA3NjA2NTE4O1xuXG4vLyBkb24ndCBjaGFuZ2UgdW5sZXNzIHdlIGNoYW5nZSB0aGUgYWxnb3Mgb3IgUkVEVUNFX1RJTUVcbi8vIG11c3QgYmUgYW4gaW50ZWdlciBhbmQgbGVzcyB0aGFuIDE2XG52YXIgdmVyc2lvbiA9IDY7XG5cbi8vIGlmIHlvdSBhcmUgdXNpbmcgY2x1c3RlciBvciBtdWx0aXBsZSBzZXJ2ZXJzIHVzZSB0aGlzIHRvIG1ha2UgZWFjaCBpbnN0YW5jZVxuLy8gaGFzIGEgdW5pcXVlIHZhbHVlIGZvciB3b3JrZXJcbi8vIE5vdGU6IEkgZG9uJ3Qga25vdyBpZiB0aGlzIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHdoZW4gdXNpbmcgdGhpcmRcbi8vIHBhcnR5IGNsdXN0ZXIgc29sdXRpb25zIHN1Y2ggYXMgcG0yLlxudmFyIGNsdXN0ZXJXb3JrZXJJZCA9IHJlcXVpcmUoJy4vdXRpbC9jbHVzdGVyLXdvcmtlci1pZCcpIHx8IDA7XG5cbi8vIENvdW50ZXIgaXMgdXNlZCB3aGVuIHNob3J0aWQgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIG9uZSBzZWNvbmQuXG52YXIgY291bnRlcjtcblxuLy8gUmVtZW1iZXIgdGhlIGxhc3QgdGltZSBzaG9ydGlkIHdhcyBjYWxsZWQgaW4gY2FzZSBjb3VudGVyIGlzIG5lZWRlZC5cbnZhciBwcmV2aW91c1NlY29uZHM7XG5cbi8qKlxuICogR2VuZXJhdGUgdW5pcXVlIGlkXG4gKiBSZXR1cm5zIHN0cmluZyBpZFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZSgpIHtcblxuICAgIHZhciBzdHIgPSAnJztcblxuICAgIHZhciBzZWNvbmRzID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIFJFRFVDRV9USU1FKSAqIDAuMDAxKTtcblxuICAgIGlmIChzZWNvbmRzID09PSBwcmV2aW91c1NlY29uZHMpIHtcbiAgICAgICAgY291bnRlcisrO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ZXIgPSAwO1xuICAgICAgICBwcmV2aW91c1NlY29uZHMgPSBzZWNvbmRzO1xuICAgIH1cblxuICAgIHN0ciA9IHN0ciArIGVuY29kZShhbHBoYWJldC5sb29rdXAsIHZlcnNpb24pO1xuICAgIHN0ciA9IHN0ciArIGVuY29kZShhbHBoYWJldC5sb29rdXAsIGNsdXN0ZXJXb3JrZXJJZCk7XG4gICAgaWYgKGNvdW50ZXIgPiAwKSB7XG4gICAgICAgIHN0ciA9IHN0ciArIGVuY29kZShhbHBoYWJldC5sb29rdXAsIGNvdW50ZXIpO1xuICAgIH1cbiAgICBzdHIgPSBzdHIgKyBlbmNvZGUoYWxwaGFiZXQubG9va3VwLCBzZWNvbmRzKTtcblxuICAgIHJldHVybiBzdHI7XG59XG5cblxuLyoqXG4gKiBTZXQgdGhlIHNlZWQuXG4gKiBIaWdobHkgcmVjb21tZW5kZWQgaWYgeW91IGRvbid0IHdhbnQgcGVvcGxlIHRvIHRyeSB0byBmaWd1cmUgb3V0IHlvdXIgaWQgc2NoZW1hLlxuICogZXhwb3NlZCBhcyBzaG9ydGlkLnNlZWQoaW50KVxuICogQHBhcmFtIHNlZWQgSW50ZWdlciB2YWx1ZSB0byBzZWVkIHRoZSByYW5kb20gYWxwaGFiZXQuICBBTFdBWVMgVVNFIFRIRSBTQU1FIFNFRUQgb3IgeW91IG1pZ2h0IGdldCBvdmVybGFwcy5cbiAqL1xuZnVuY3Rpb24gc2VlZChzZWVkVmFsdWUpIHtcbiAgICBhbHBoYWJldC5zZWVkKHNlZWRWYWx1ZSk7XG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY2x1c3RlciB3b3JrZXIgb3IgbWFjaGluZSBpZFxuICogZXhwb3NlZCBhcyBzaG9ydGlkLndvcmtlcihpbnQpXG4gKiBAcGFyYW0gd29ya2VySWQgd29ya2VyIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlci4gIE51bWJlciBsZXNzIHRoYW4gMTYgaXMgcmVjb21tZW5kZWQuXG4gKiByZXR1cm5zIHNob3J0aWQgbW9kdWxlIHNvIGl0IGNhbiBiZSBjaGFpbmVkLlxuICovXG5mdW5jdGlvbiB3b3JrZXIod29ya2VySWQpIHtcbiAgICBjbHVzdGVyV29ya2VySWQgPSB3b3JrZXJJZDtcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8qKlxuICpcbiAqIHNldHMgbmV3IGNoYXJhY3RlcnMgdG8gdXNlIGluIHRoZSBhbHBoYWJldFxuICogcmV0dXJucyB0aGUgc2h1ZmZsZWQgYWxwaGFiZXRcbiAqL1xuZnVuY3Rpb24gY2hhcmFjdGVycyhuZXdDaGFyYWN0ZXJzKSB7XG4gICAgaWYgKG5ld0NoYXJhY3RlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbHBoYWJldC5jaGFyYWN0ZXJzKG5ld0NoYXJhY3RlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhbHBoYWJldC5zaHVmZmxlZCgpO1xufVxuXG5cbi8vIEV4cG9ydCBhbGwgb3RoZXIgZnVuY3Rpb25zIGFzIHByb3BlcnRpZXMgb2YgdGhlIGdlbmVyYXRlIGZ1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlO1xubW9kdWxlLmV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcbm1vZHVsZS5leHBvcnRzLnNlZWQgPSBzZWVkO1xubW9kdWxlLmV4cG9ydHMud29ya2VyID0gd29ya2VyO1xubW9kdWxlLmV4cG9ydHMuY2hhcmFjdGVycyA9IGNoYXJhY3RlcnM7XG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cy5pc1ZhbGlkID0gaXNWYWxpZDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbHBoYWJldCA9IHJlcXVpcmUoJy4vYWxwaGFiZXQnKTtcblxuZnVuY3Rpb24gaXNTaG9ydElkKGlkKSB7XG4gICAgaWYgKCFpZCB8fCB0eXBlb2YgaWQgIT09ICdzdHJpbmcnIHx8IGlkLmxlbmd0aCA8IDYgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2hhcmFjdGVycyA9IGFscGhhYmV0LmNoYXJhY3RlcnMoKTtcbiAgICB2YXIgbGVuID0gaWQubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47aSsrKSB7XG4gICAgICAgIGlmIChjaGFyYWN0ZXJzLmluZGV4T2YoaWRbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2hvcnRJZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyeXB0byA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmICh3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0byk7IC8vIElFIDExIHVzZXMgd2luZG93Lm1zQ3J5cHRvXG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGUoKSB7XG4gICAgaWYgKCFjcnlwdG8gfHwgIWNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikgJiAweDMwO1xuICAgIH1cbiAgICB2YXIgZGVzdCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoZGVzdCk7XG4gICAgcmV0dXJuIGRlc3RbMF0gJiAweDMwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUJ5dGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEZvdW5kIHRoaXMgc2VlZC1iYXNlZCByYW5kb20gZ2VuZXJhdG9yIHNvbWV3aGVyZVxuLy8gQmFzZWQgb24gVGhlIENlbnRyYWwgUmFuZG9taXplciAxLjMgKEMpIDE5OTcgYnkgUGF1bCBIb3VsZSAoaG91bGVAbXNjLmNvcm5lbGwuZWR1KVxuXG52YXIgc2VlZCA9IDE7XG5cbi8qKlxuICogcmV0dXJuIGEgcmFuZG9tIG51bWJlciBiYXNlZCBvbiBhIHNlZWRcbiAqIEBwYXJhbSBzZWVkXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXROZXh0VmFsdWUoKSB7XG4gICAgc2VlZCA9IChzZWVkICogOTMwMSArIDQ5Mjk3KSAlIDIzMzI4MDtcbiAgICByZXR1cm4gc2VlZC8oMjMzMjgwLjApO1xufVxuXG5mdW5jdGlvbiBzZXRTZWVkKF9zZWVkXykge1xuICAgIHNlZWQgPSBfc2VlZF87XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG5leHRWYWx1ZTogZ2V0TmV4dFZhbHVlLFxuICAgIHNlZWQ6IHNldFNlZWRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gMDtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgcHJvbWlzZUV4dGVuc2lvbnNfMSA9IHJlcXVpcmUoXCIuLy4uL2hlbHBlcnMvcHJvbWlzZUV4dGVuc2lvbnNcIik7XHJcbnZhciBhY3Rpdml0eU1hbmFnZW1lbnRBUElfMSA9IHJlcXVpcmUoXCIuL2FjdGl2aXR5TWFuYWdlbWVudEFQSVwiKTtcclxudmFyIGFjdGl2aXR5QUdNXzEgPSByZXF1aXJlKFwiLi4vY29yZS9hY3Rpdml0eUFHTVwiKTtcclxudmFyIEFjdGl2aXR5QVBJID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5QVBJKG1hbmFnZXIsIG15KSB7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCIyLjQuMlwiO1xyXG4gICAgICAgIHRoaXMuX19tZ3IgPSBtYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX215ID0gbXk7XHJcbiAgICAgICAgdGhpcy5hbGwgPSBuZXcgYWN0aXZpdHlNYW5hZ2VtZW50QVBJXzEuQWN0aXZpdHlNYW5hZ2VtZW50QVBJKG1hbmFnZXIsIG15KTtcclxuICAgIH1cclxuICAgIEFjdGl2aXR5QVBJLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9fbWdyLnJlYWR5KClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMpO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5QVBJLnByb3RvdHlwZSwgXCJteVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9teTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eUFQSS5wcm90b3R5cGUsIFwiYXdhcmVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXkud2luZG93ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlBUEkucHJvdG90eXBlLCBcImluQWN0aXZpdHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hd2FyZSAmJiB0aGlzLl9teS5hY3Rpdml0eSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5QVBJLnByb3RvdHlwZSwgXCJhZ21cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXdhcmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmluQWN0aXZpdHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYWN0aXZpdHlBR01fMS5BY3Rpdml0eUFHTShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXkuYWN0aXZpdHkuYWdtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5QVBJO1xyXG59KCkpO1xyXG5leHBvcnRzLkFjdGl2aXR5QVBJID0gQWN0aXZpdHlBUEk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5QVBJLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLy4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIEFjdGl2aXR5TWFuYWdlbWVudEFQSSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eU1hbmFnZW1lbnRBUEkobWFuYWdlciwgbXkpIHtcclxuICAgICAgICB0aGlzLl9tID0gbWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9teSA9IG15O1xyXG4gICAgICAgIHRoaXMuYWN0aXZpdHlUeXBlcyA9IHtcclxuICAgICAgICAgICAgZ2V0OiB0aGlzLl9nZXRBY3Rpdml0eVR5cGVzV3JhcHBlci5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICByZWdpc3RlcjogdGhpcy5fbS5yZWdpc3RlckFjdGl2aXR5VHlwZS5iaW5kKHRoaXMuX20pLFxyXG4gICAgICAgICAgICB1bnJlZ2lzdGVyOiB0aGlzLl9tLnVucmVnaXN0ZXJBY3Rpdml0eVR5cGUuYmluZCh0aGlzLl9tKSxcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiB0aGlzLl9tLnN1YnNjcmliZUFjdGl2aXR5VHlwZUV2ZW50cy5iaW5kKHRoaXMuX20pLFxyXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBpbml0aWF0ZTogdGhpcy5fbS5pbml0aWF0ZS5iaW5kKHRoaXMuX20pXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLndpbmRvd1R5cGVzID0ge1xyXG4gICAgICAgICAgICBnZXQ6IHRoaXMuX2dldFdpbmRvd1R5cGVzV3JhcHBlci5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICByZWdpc3RlckZhY3Rvcnk6IHRoaXMuX20ucmVnaXN0ZXJXaW5kb3dGYWN0b3J5LmJpbmQodGhpcy5fbSksXHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJGYWN0b3J5OiB0aGlzLl9tLnVucmVnaXN0ZXJXaW5kb3dGYWN0b3J5LmJpbmQodGhpcy5fbSksXHJcbiAgICAgICAgICAgIHN1YnNjcmliZTogdGhpcy5fbS5zdWJzY3JpYmVXaW5kb3dUeXBlRXZlbnRzLmJpbmQodGhpcy5fbSksXHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiB1bmRlZmluZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMud2luZG93cyA9IHtcclxuICAgICAgICAgICAgZ2V0OiB0aGlzLl9tLmdldFdpbmRvd3MuYmluZCh0aGlzLl9tKSxcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiB0aGlzLl9tLnN1YnNjcmliZVdpbmRvd0V2ZW50cy5iaW5kKHRoaXMuX20pLFxyXG4gICAgICAgICAgICBhbm5vdW5jZTogdGhpcy5fbS5hbm5vdW5jZVdpbmRvdy5iaW5kKHRoaXMuX20pLFxyXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjcmVhdGU6IHRoaXMuX20uY3JlYXRlV2luZG93LmJpbmQodGhpcy5fbSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0ge1xyXG4gICAgICAgICAgICBnZXQ6IHRoaXMuX20uZ2V0QWN0aXZpdGllcy5iaW5kKHRoaXMuX20pLFxyXG4gICAgICAgICAgICBzdWJzY3JpYmU6IHRoaXMuX20uc3Vic2NyaWJlQWN0aXZpdHlFdmVudHMuYmluZCh0aGlzLl9tKSxcclxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6IHVuZGVmaW5lZFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBBY3Rpdml0eU1hbmFnZW1lbnRBUEkucHJvdG90eXBlLl9nZXRBY3Rpdml0eVR5cGVzV3JhcHBlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQobmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX20uZ2V0QWN0aXZpdHlUeXBlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbS5nZXRBY3Rpdml0eVR5cGUobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VtZW50QVBJLnByb3RvdHlwZS5fZ2V0V2luZG93VHlwZXNXcmFwcGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbS5nZXRXaW5kb3dUeXBlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbS5nZXRXaW5kb3dUeXBlKG5hbWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eU1hbmFnZW1lbnRBUEk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQWN0aXZpdHlNYW5hZ2VtZW50QVBJID0gQWN0aXZpdHlNYW5hZ2VtZW50QVBJO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eU1hbmFnZW1lbnRBUEkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLy4uL2hlbHBlcnMvbG9nZ2VyXCIpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLy4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIEFjdGl2aXR5TXkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlNeShtYW5hZ2VyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9teUFjdGl2aXR5Sm9pbmVkQ2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgdGhpcy5fbXlBY3Rpdml0eVJlbW92ZWRDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9teUNvbnRleHRVcGRhdGVDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXJfMS5Mb2dnZXIuR2V0KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX20gPSBtYW5hZ2VyO1xyXG4gICAgICAgIG1hbmFnZXIucmVhZHkoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYW0pIHtcclxuICAgICAgICAgICAgYW0uc3Vic2NyaWJlQWN0aXZpdHlDb250ZXh0Q2hhbmdlZChfdGhpcy5fc3Vic2NyaWJlTXlDb250ZXh0Q2hhbmdlZC5iaW5kKF90aGlzKSk7XHJcbiAgICAgICAgICAgIGFtLnN1YnNjcmliZVdpbmRvd0V2ZW50cyhfdGhpcy5fc3Vic2NyaWJlTXlXaW5kb3dFdmVudC5iaW5kKF90aGlzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlNeS5wcm90b3R5cGUsIFwid2luZG93XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fdykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbm5vdW5jZWRXaW5kb3dzID0gdGhpcy5fbS5hbm5vdW5jZWRXaW5kb3dzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFubm91bmNlZFdpbmRvd3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3cgPSBhbm5vdW5jZWRXaW5kb3dzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5TXkucHJvdG90eXBlLCBcImFjdGl2aXR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG15V2luID0gdGhpcy53aW5kb3c7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG15V2luKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbXlXaW4uYWN0aXZpdHk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5jcmVhdGVXaW5kb3cgPSBmdW5jdGlvbiAod2luZG93VHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tLmNyZWF0ZVdpbmRvdyh0aGlzLmFjdGl2aXR5LCB3aW5kb3dUeXBlKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5jcmVhdGVTdGFja2VkV2luZG93cyA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlcywgdGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tLmNyZWF0ZVN0YWNrZWRXaW5kb3dzKHRoaXMuYWN0aXZpdHksIHdpbmRvd1R5cGVzLCB0aW1lb3V0KTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlNeS5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpdml0eSA9IHRoaXMuYWN0aXZpdHk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhY3Rpdml0eS5jb250ZXh0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlNeS5wcm90b3R5cGUub25BY3Rpdml0eUpvaW5lZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX215QWN0aXZpdHlKb2luZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgdmFyIG15V2luID0gdGhpcy53aW5kb3c7XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG15V2luKSAmJiAhdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChteVdpbi5hY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sobXlXaW4uYWN0aXZpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5vbkFjdGl2aXR5TGVmdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX215QWN0aXZpdHlSZW1vdmVkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9teUNvbnRleHRVcGRhdGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgdmFyIG15V2luID0gdGhpcy53aW5kb3c7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwobXlXaW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFjdGl2aXR5ID0gbXlXaW4uYWN0aXZpdHk7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FsbGJhY2soYWN0aXZpdHkuY29udGV4dCwgYWN0aXZpdHkuY29udGV4dCwgW10sIGFjdGl2aXR5KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5fc3Vic2NyaWJlTXlDb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgY29udGV4dCwgZGVsdGEsIHJlbW92ZWQpIHtcclxuICAgICAgICB2YXIgbXlXaW4gPSB0aGlzLndpbmRvdztcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChteVdpbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbXlBY3Rpdml0eSA9IG15V2luLmFjdGl2aXR5O1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG15QWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFjdGl2aXR5LmlkICE9PSBteUFjdGl2aXR5LmlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbm90aWZ5TXlDb250ZXh0Q2hhbmdlZChhY3Rpdml0eSwgY29udGV4dCwgZGVsdGEsIHJlbW92ZWQpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLl9zdWJzY3JpYmVNeVdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCB3aW5kb3csIGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy53aW5kb3cpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMud2luZG93LmlkICE9PSB3aW5kb3cuaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnQgPT09IFwiam9pbmVkXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbm90aWZ5T25Kb2luZWQoYWN0aXZpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbm90aWZ5TXlXaW5kb3dFdmVudChhY3Rpdml0eSwgdGhpcy5fbXlBY3Rpdml0eVJlbW92ZWRDYWxsYmFja3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5fbm90aWZ5TXlXaW5kb3dFdmVudCA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgY2FsbGJhY2tTdG9yZSkge1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjYWxsYmFja1N0b3JlLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNhbGxiYWNrU3RvcmVbaW5kZXhdO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudChhY3Rpdml0eSwgZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybignZXJyb3IgaW4gdXNlciBjYWxsYmFjayAnICsgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNeS5wcm90b3R5cGUuX25vdGlmeU15Q29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoYWN0aXZpdHksIGNvbnRleHQsIGRlbHRhLCByZW1vdmVkKSB7XHJcbiAgICAgICAgZGVsdGEgPSBkZWx0YSB8fCB7fTtcclxuICAgICAgICByZW1vdmVkID0gcmVtb3ZlZCB8fCBbXTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fbXlDb250ZXh0VXBkYXRlQ2FsbGJhY2tzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX215Q29udGV4dFVwZGF0ZUNhbGxiYWNrc1tpbmRleF07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50KGNvbnRleHQsIGRlbHRhLCByZW1vdmVkLCBhY3Rpdml0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdlcnJvciBpbiB1c2VyIGNhbGxiYWNrICcgKyBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5fbm90aWZ5T25Kb2luZWQgPSBmdW5jdGlvbiAoYWN0aXZpdHkpIHtcclxuICAgICAgICB0aGlzLl9ub3RpZnlNeVdpbmRvd0V2ZW50KGFjdGl2aXR5LCB0aGlzLl9teUFjdGl2aXR5Sm9pbmVkQ2FsbGJhY2tzKTtcclxuICAgICAgICB0aGlzLl9ub3RpZnlNeUNvbnRleHRDaGFuZ2VkKGFjdGl2aXR5LCBhY3Rpdml0eS5jb250ZXh0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWN0aXZpdHlNeTtcclxufSgpKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5TXk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5TXlBUEkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBBY3Rpdml0eUNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eUNvbmZpZygpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBBY3Rpdml0eUNvbmZpZztcclxufSgpKTtcclxuZXhwb3J0cy5BY3Rpdml0eUNvbmZpZyA9IEFjdGl2aXR5Q29uZmlnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eUNvbmZpZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxucmVxdWlyZShcImVzNi1wcm9taXNlXCIpO1xyXG52YXIgaGNCcmlkZ2VfMSA9IHJlcXVpcmUoXCIuL2JyaWRnZXMvaGNCcmlkZ2VcIik7XHJcbnZhciBhY3Rpdml0eU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvYWN0aXZpdHlNYW5hZ2VyXCIpO1xyXG52YXIgYWN0aXZpdHlNeUFQSV8xID0gcmVxdWlyZShcIi4vQVBJL2FjdGl2aXR5TXlBUElcIik7XHJcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvbG9nZ2VyXCIpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIGFjdGl2aXR5Q29uZmlnXzEgPSByZXF1aXJlKFwiLi9hY3Rpdml0eUNvbmZpZ1wiKTtcclxudmFyIGFjdGl2aXR5QVBJXzEgPSByZXF1aXJlKFwiLi9BUEkvYWN0aXZpdHlBUElcIik7XHJcbnZhciBhY3Rpdml0eUFHTV8xID0gcmVxdWlyZShcIi4vY29yZS9hY3Rpdml0eUFHTVwiKTtcclxudmFyIGFjdGl2aXR5ID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgY29uZmlnID0gY29uZmlnIHx8IG5ldyBhY3Rpdml0eUNvbmZpZ18xLkFjdGl2aXR5Q29uZmlnO1xyXG4gICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGNvbmZpZy5sb2dMZXZlbCkpIHtcclxuICAgICAgICBsb2dnZXJfMS5Mb2dnZXIuTGV2ZWwgPSBjb25maWcubG9nTGV2ZWw7XHJcbiAgICB9XHJcbiAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwoY29uZmlnLmxvZ2dlcikpIHtcclxuICAgICAgICBsb2dnZXJfMS5Mb2dnZXIuR2x1ZUxvZ2dlciA9IGNvbmZpZy5sb2dnZXI7XHJcbiAgICB9XHJcbiAgICB2YXIgYnJpZGdlO1xyXG4gICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKHdpbmRvdy5odG1sQ29udGFpbmVyKSkge1xyXG4gICAgICAgIGJyaWRnZSA9IG5ldyBoY0JyaWRnZV8xWydkZWZhdWx0J10oKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjdGl2aXR5IG5vdCBzdXBwb3J0ZWQgaW4gaW4gYnJvd3NlclwiKTtcclxuICAgIH1cclxuICAgIGlmICghYnJpZGdlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBicmlkZ2UgdG8gbmF0aXZlIGFjdGl2aXR5IGlzIG5lZWRlZCB0byBjcmVhdGUgYWN0aXZpdHkgbGliLlwiKTtcclxuICAgIH1cclxuICAgIGFjdGl2aXR5QUdNXzEuQWN0aXZpdHlBR00uQUdNID0gY29uZmlnLmFnbTtcclxuICAgIHZhciBhY3Rpdml0eU1hbmFnZXIgPSBuZXcgYWN0aXZpdHlNYW5hZ2VyXzFbJ2RlZmF1bHQnXShicmlkZ2UsICFjb25maWcuZGlzYWJsZUF1dG9Bbm5vdW5jZSk7XHJcbiAgICB2YXIgbXkgPSBuZXcgYWN0aXZpdHlNeUFQSV8xWydkZWZhdWx0J10oYWN0aXZpdHlNYW5hZ2VyKTtcclxuICAgIHJldHVybiBuZXcgYWN0aXZpdHlBUElfMS5BY3Rpdml0eUFQSShhY3Rpdml0eU1hbmFnZXIsIG15KTtcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBhY3Rpdml0eTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlNb2R1bGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBlbnRpdHlFdmVudF8xID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0cy9lbnRpdHlFdmVudFwiKTtcclxudmFyIGFjdGl2aXR5U3RhdHVzXzEgPSByZXF1aXJlKFwiLi4vY29udHJhY3RzL2FjdGl2aXR5U3RhdHVzXCIpO1xyXG52YXIgYWN0aXZpdHlUeXBlXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvYWN0aXZpdHlUeXBlXCIpO1xyXG52YXIgd2luZG93VHlwZV8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL3dpbmRvd1R5cGVcIik7XHJcbnZhciBhY3Rpdml0eV8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2FjdGl2aXR5XCIpO1xyXG52YXIgYWN0aXZpdHlXaW5kb3dfMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9hY3Rpdml0eVdpbmRvd1wiKTtcclxudmFyIHByb3h5V2luZG93RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL2NvcmUvcHJveHlXaW5kb3dGYWN0b3J5XCIpO1xyXG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciBlbnRpdHlFdmVudF8yID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0cy9lbnRpdHlFdmVudFwiKTtcclxudmFyIHJlYWR5TWFya2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9yZWFkeU1hcmtlclwiKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgZW50aXR5RXZlbnRfMyA9IHJlcXVpcmUoXCIuLi9jb250cmFjdHMvZW50aXR5RXZlbnRcIik7XHJcbnZhciBIQ0JyaWRnZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIQ0JyaWRnZShhZ20pIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eVR5cGVFbnRpdHlOYW1lID0gXCJhY3Rpdml0eVR5cGVcIjtcclxuICAgICAgICB0aGlzLl93aW5kb3dUeXBlRW50aXR5TmFtZSA9IFwid2luZG93VHlwZVwiO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5RW50aXR5TmFtZSA9IFwiYWN0aXZpdHlcIjtcclxuICAgICAgICB0aGlzLl93aW5kb3dFbnRpdHlOYW1lID0gXCJhY3Rpdml0eVdpbmRvd1wiO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlci5HZXQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNlcSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5VHlwZUNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1R5cGVDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eUNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd0NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FnbSA9IGFnbTtcclxuICAgIH1cclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fcmVhZHlNYXJrZXIgPSBuZXcgcmVhZHlNYXJrZXJfMS5SZWFkeU1hcmtlcihcIkhDIEJyaWRnZVwiLCAxKTtcclxuICAgICAgICB0aGlzLl9odG1sQ29udGFpbmVyID0gd2luZG93Lmh0bWxDb250YWluZXIuYWN0aXZpdHlGYWNhZGU7XHJcbiAgICAgICAgdGhpcy5faHRtbENvbnRhaW5lci5pbml0KHRoaXMuX2FnbSA/IHRoaXMuX2FnbS5pbnN0YW5jZSA6IHVuZGVmaW5lZCwgdGhpcy5faGNFdmVudEhhbmRsZXIuYmluZCh0aGlzKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuc2lnbmFsKFwiSW5pdCBkb25lIGZyb20gSENcIik7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZWFkeU1hcmtlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3JlYWR5TWFya2VyLnNldENhbGxiYWNrKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIEhDIGJyaWRnZSAtIFwiICsgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoX3RoaXMuX3JlYWR5TWFya2VyLmdldEVycm9yKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX2hjRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50SnNvbikge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShldmVudEpzb24pO1xyXG4gICAgICAgIHZhciBldmVudCA9IEpTT04ucGFyc2UoZXZlbnRKc29uKTtcclxuICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnRCeVNlcShldmVudCk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9wcm9jZXNzRXZlbnRCeVNlcSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBzZXEgPSBldmVudC5zZXF1ZW5jZTtcclxuICAgICAgICBpZiAoc2VxID09PSB0aGlzLl9sYXN0U2VxICsgMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0U2VxKys7XHJcbiAgICAgICAgICAgIHZhciBuZXh0RXZlbnQgPSB0aGlzLl9ldmVudFF1ZXVlW3NlcSArIDFdO1xyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQobmV4dEV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwicmVwbGF5aW5nIG1lc3NhZ2UgbnVtYmVyIFwiICsgc2VxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudEJ5U2VxKG5leHRFdmVudCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRRdWV1ZVtzZXEgKyAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZVtzZXFdID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIkdvdCBvdXQgb2Ygb3JkZXIgZXZlbnQgd2l0aCBudW1iZXIgXCIgKyBzZXEgKyBcIi4gV2lsbCB3YWl0IGZvciBwcmV2aW91cyBldmVudChzKSBiZWZvcmUgcmVwbGF5aW5nLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9wcm9jZXNzRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgZW50aXR5VHlwZSA9IGV2ZW50LmVudGl0eVR5cGU7XHJcbiAgICAgICAgdmFyIGV2ZW50Q29udGV4dCA9IHRoaXMuX2NvbnZlcnRDb250ZXh0KGV2ZW50LmNvbnRleHQpO1xyXG4gICAgICAgIHZhciBlbnRpdHk7XHJcbiAgICAgICAgc3dpdGNoIChlbnRpdHlUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgdGhpcy5fYWN0aXZpdHlUeXBlRW50aXR5TmFtZTpcclxuICAgICAgICAgICAgICAgIGVudGl0eSA9IEhDQnJpZGdlLl9oY1RvSnNBY3Rpdml0eVR5cGUoZXZlbnQuZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3B1Ymxpc2hBY3Rpdml0eVR5cGVTdGF0dXNDaGFuZ2UoZW50aXR5LCBldmVudENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgdGhpcy5fd2luZG93VHlwZUVudGl0eU5hbWU6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSB0aGlzLl9oY1RvSnNXaW5kb3dUeXBlKGV2ZW50LmVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoV2luZG93VHlwZVN0YXR1c0NoYW5nZShlbnRpdHksIGV2ZW50Q29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSB0aGlzLl9hY3Rpdml0eUVudGl0eU5hbWU6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSB0aGlzLl9oY1RvSnNBY3Rpdml0eShldmVudC5lbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHVibGlzaEFjdGl2aXR5U3RhdHVzQ2hhbmdlKGVudGl0eSwgZXZlbnRDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHRoaXMuX3dpbmRvd0VudGl0eU5hbWU6XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSBIQ0JyaWRnZS5faGNUb0pzV2luZG93KGV2ZW50LmVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoQWN0aXZpdHlXaW5kb3dFdmVudChlbnRpdHksIGV2ZW50Q29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9jb252ZXJ0Q29udGV4dCA9IGZ1bmN0aW9uIChoY0NvbnRleHQpIHtcclxuICAgICAgICBpZiAoaGNDb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLlN0YXR1c0NoYW5nZSkge1xyXG4gICAgICAgICAgICB2YXIgb2xkU3RhdHVzID0gbmV3IGFjdGl2aXR5U3RhdHVzXzEuQWN0aXZpdHlTdGF0dXMoaGNDb250ZXh0Lm9sZFN0YXR1cy5zdGF0ZSwgaGNDb250ZXh0Lm9sZFN0YXR1cy5zdGF0dXNNZXNzYWdlLCBoY0NvbnRleHQub2xkU3RhdHVzLnN0YXR1c1RpbWUpO1xyXG4gICAgICAgICAgICB2YXIgbmV3U3RhdHVzID0gbmV3IGFjdGl2aXR5U3RhdHVzXzEuQWN0aXZpdHlTdGF0dXMoaGNDb250ZXh0Lm5ld1N0YXR1cy5zdGF0ZSwgaGNDb250ZXh0Lm5ld1N0YXR1cy5zdGF0dXNNZXNzYWdlLCBoY0NvbnRleHQubmV3U3RhdHVzLnN0YXR1c1RpbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGVudGl0eUV2ZW50XzEuRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0KG5ld1N0YXR1cywgb2xkU3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGNDb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5V2luZG93RXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGFjdCA9IHRoaXMuX2hjVG9Kc0FjdGl2aXR5KGhjQ29udGV4dC5hY3Rpdml0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgZW50aXR5RXZlbnRfMS5FbnRpdHlBY3Rpdml0eVdpbmRvd0V2ZW50Q29udGV4dChhY3QsIGhjQ29udGV4dC5ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhjQ29udGV4dC50eXBlID09PSBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eUNvbnRleHRDaGFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBlbnRpdHlFdmVudF8zLkFjdGl2aXR5Q29udGV4dENoYW5nZWRDb250ZXh0KGhjQ29udGV4dC5uZXdDb250ZXh0LCBoY0NvbnRleHQudXBkYXRlZCwgaGNDb250ZXh0LnJlbW92ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRDb250ZXh0KGhjQ29udGV4dC50eXBlKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5faGNUb0pzV2luZG93ID0gZnVuY3Rpb24gKGhjV2luZG93KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhY3Rpdml0eVdpbmRvd18xWydkZWZhdWx0J10oaGNXaW5kb3cuaWQsIGhjV2luZG93Lm5hbWUsIGhjV2luZG93LnR5cGUsIGhjV2luZG93LmFjdGl2aXR5SWQsIGhjV2luZG93Lmluc3RhbmNlLCBoY1dpbmRvdy5pc0luZGVwZW5kZW50KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX2hjVG9Kc0FjdGl2aXR5ID0gZnVuY3Rpb24gKGhjQWN0KSB7XHJcbiAgICAgICAgdmFyIHdpbmRvdyA9IGhjQWN0Lm93bmVyID8gSENCcmlkZ2UuX2hjVG9Kc1dpbmRvdyhoY0FjdC5vd25lcikgOiBudWxsO1xyXG4gICAgICAgIHZhciB3aW5kb3dJZCA9IHdpbmRvdyA/IHdpbmRvdy5pZCA6IG51bGw7XHJcbiAgICAgICAgdmFyIHN0YXR1cyA9IG5ldyBhY3Rpdml0eVN0YXR1c18xLkFjdGl2aXR5U3RhdHVzKGhjQWN0LnN0YXR1cy5zdGF0ZSwgaGNBY3Quc3RhdHVzLnN0YXR1c01lc3NhZ2UsIGhjQWN0LnN0YXR1cy5zdGF0dXNUaW1lKTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IEpTT04ucGFyc2UoaGNBY3QuY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhY3Rpdml0eV8xWydkZWZhdWx0J10oaGNBY3QuaWQsIGhjQWN0LnR5cGUubmFtZSwgc3RhdHVzLCBjb250ZXh0LCB3aW5kb3dJZCk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UuX2hjVG9Kc0FjdGl2aXR5VHlwZSA9IGZ1bmN0aW9uIChoY0FjdFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGFjdGl2aXR5VHlwZV8xWydkZWZhdWx0J10oaGNBY3RUeXBlLm5hbWUsIGhjQWN0VHlwZS5vd25lcldpbmRvd1R5cGUsIGhjQWN0VHlwZS5oZWxwZXJXaW5kb3dUeXBlcywgaGNBY3RUeXBlLmRlc2NyaXB0aW9uKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX2hjVG9Kc1dpbmRvd1R5cGUgPSBmdW5jdGlvbiAoaGNXaW5UeXBlKSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoaGNXaW5UeXBlLmZhY3RvcmllcykpIHtcclxuICAgICAgICAgICAgaGNXaW5UeXBlLmZhY3RvcmllcyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZmFjdG9yaWVzID0gaGNXaW5UeXBlLmZhY3Rvcmllcy5tYXAoZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEhDQnJpZGdlLl9oY1RvSnNXaW5kb3dUeXBlRmFjdG9yeShmKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IHdpbmRvd1R5cGVfMVsnZGVmYXVsdCddKGhjV2luVHlwZS5uYW1lLCBmYWN0b3JpZXMpO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLl9oY1RvSnNXaW5kb3dUeXBlRmFjdG9yeSA9IGZ1bmN0aW9uIChoY1dpblR5cGVGYWN0b3J5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBwcm94eVdpbmRvd0ZhY3RvcnlfMS5Qcm94eVdpbmRvd0ZhY3RvcnkoaGNXaW5UeXBlRmFjdG9yeS5kZXNjcmlwdGlvbik7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UuX2dldFVSTFBhcmFtZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCgobmV3IFJlZ0V4cCgnWz98Jl0nICsgbmFtZSArICc9JyArICcoW14mO10rPykoJnwjfDt8JCknKS5leGVjKGxvY2F0aW9uLnNlYXJjaCkgfHwgWywgXCJcIl0pWzFdLnJlcGxhY2UoL1xcKy9nLCAnJTIwJykpIHx8IG51bGw7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldEFjdGl2aXR5VHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5nZXRBY3Rpdml0eVR5cGVzKGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGluZm9zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gaW5mb3NbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBY3Rpdml0eVR5cGUgPSBIQ0JyaWRnZS5faGNUb0pzQWN0aXZpdHlUeXBlKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld0FjdGl2aXR5VHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnJlZ2lzdGVyQWN0aXZpdHlUeXBlID0gZnVuY3Rpb24gKGFjdGl2aXR5VHlwZU5hbWUsIG93bmVyV2luZG93LCBoZWxwZXJXaW5kb3dzLCBsYXlvdXRDb25maWcsIGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoaGVscGVyV2luZG93cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBoZWxwZXJXaW5kb3dzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGFjdGl2aXR5VHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBvd25lcldpbmRvd1R5cGU6IG93bmVyV2luZG93LFxyXG4gICAgICAgICAgICAgICAgaGVscGVyV2luZG93VHlwZXM6IGhlbHBlcldpbmRvd3MsXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgICBsYXlvdXRDb25maWc6IEpTT04uc3RyaW5naWZ5KGxheW91dENvbmZpZylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIucmVnaXN0ZXJBY3Rpdml0eVR5cGUoSlNPTi5zdHJpbmdpZnkoY29uZmlnKSwgZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdBY3Rpdml0eVR5cGUgPSBIQ0JyaWRnZS5faGNUb0pzQWN0aXZpdHlUeXBlKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZXdBY3Rpdml0eVR5cGUpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS51bnJlZ2lzdGVyQWN0aXZpdHlUeXBlID0gZnVuY3Rpb24gKGFjdGl2aXR5VHlwZU5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnVucmVnaXN0ZXJBY3Rpdml0eVR5cGUoYWN0aXZpdHlUeXBlTmFtZSwgZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldFdpbmRvd1R5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuZ2V0V2luZG93VHlwZXMoZnVuY3Rpb24gKGluZm9zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaW5mb3MubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBpbmZvc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1dpbmRvd1R5cGUgPSBfdGhpcy5faGNUb0pzV2luZG93VHlwZShpbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdXaW5kb3dUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUucmVnaXN0ZXJXaW5kb3dGYWN0b3J5ID0gZnVuY3Rpb24gKHdpbmRvd1R5cGVOYW1lLCBmYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dUeXBlTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIndpbmRvd1R5cGVOYW1lIHNob3VsZCBiZSBwcm92aWRlZFwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5yZWdpc3RlcldpbmRvd0ZhY3Rvcnkod2luZG93VHlwZU5hbWUsIGZhY3RvcnkuY3JlYXRlLmJpbmQoZmFjdG9yeSksIGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5pbml0aWF0ZUFjdGl2aXR5ID0gZnVuY3Rpb24gKGFjdGl2aXR5VHlwZSwgY29udGV4dCwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIndpbmRvd1R5cGVOYW1lIHNob3VsZCBiZSBwcm92aWRlZFwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmluaXRpYXRlKGFjdGl2aXR5VHlwZSwgSlNPTi5zdHJpbmdpZnkoY29udGV4dCksIGZ1bmN0aW9uIChhY3Rpdml0eUlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGFjdGl2aXR5SWQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5nZXRBbm5vdW5jZW1lbnRJbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoYyA9IHdpbmRvdy5odG1sQ29udGFpbmVyO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gaGMuZ2V0Q29udGV4dCgpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7IGFjdGl2aXR5V2luZG93SWQ6IFwiXCIsIGFjdGl2aXR5V2luZG93VHlwZTogXCJcIiwgYWN0aXZpdHlXaW5kb3dJbmRlcGVuZGVudDogZmFsc2UsIGFjdGl2aXR5V2luZG93TmFtZTogXCJcIiB9O1xyXG4gICAgICAgIHJlc3VsdC5hY3Rpdml0eVdpbmRvd1R5cGUgPSBjb250ZXh0LmFjdGl2aXR5V2luZG93VHlwZTtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChyZXN1bHQuYWN0aXZpdHlXaW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuYWN0aXZpdHlXaW5kb3dUeXBlID0gSENCcmlkZ2UuX2dldFVSTFBhcmFtZXRlcihcImFjdGl2aXR5V2luZG93VHlwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmFjdGl2aXR5V2luZG93SWQgPSBjb250ZXh0LmFjdGl2aXR5V2luZG93SWQ7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQocmVzdWx0LmFjdGl2aXR5V2luZG93SWQpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hY3Rpdml0eVdpbmRvd0lkID0gSENCcmlkZ2UuX2dldFVSTFBhcmFtZXRlcihcImFjdGl2aXR5V2luZG93SWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5hY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50ID0gY29udGV4dC5hY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50O1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHJlc3VsdC5hY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50KSkge1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuYWN0aXZpdHlXaW5kb3dOYW1lID0gY29udGV4dC5hY3Rpdml0eVdpbmRvd05hbWU7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQocmVzdWx0LmFjdGl2aXR5V2luZG93TmFtZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFjdGl2aXR5V2luZG93TmFtZSA9IEhDQnJpZGdlLl9nZXRVUkxQYXJhbWV0ZXIoXCJhY3Rpdml0eVdpbmRvd05hbWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmFubm91bmNlV2luZG93ID0gZnVuY3Rpb24gKHdpbmRvd1R5cGUsIGFjdGl2aXR5V2luZG93SWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbiBub3QgZGV0ZXJtaW5lIHdpbmRvdyB0eXBlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gbm90IGRldGVybWluZSB3aW5kb3cgYWN0aXZpdHlXaW5kb3dJZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faHRtbENvbnRhaW5lci5hbm5vdW5jZVdpbmRvdyh3aW5kb3dUeXBlLCBhY3Rpdml0eVdpbmRvd0lkLCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihcIkVycm9yIGFubm91bmNpbmcgYWN0aXZpdHkgd2luZG93IHdpdGggaWQgJ1wiICsgYWN0aXZpdHlXaW5kb3dJZCArIFwiJy4gXCIgKyBlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldEFjdGl2aXRpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLnRyYWNlKFwiRXhlY3V0aW5nIGdldEFjdGl2aXRpZXMoKVwiKTtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuZ2V0QWN0aXZpdGllcyhmdW5jdGlvbiAoYWN0aXZpdGllc1N0cikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci50cmFjZShcIkdvdCBnZXRBY3Rpdml0aWVzKCkgOlwiICsgYWN0aXZpdGllc1N0cik7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZpdGllcyA9IEpTT04ucGFyc2UoYWN0aXZpdGllc1N0cik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYWN0aXZpdGllcy5tYXAoZnVuY3Rpb24gKGFjdCkgeyByZXR1cm4gX3RoaXMuX2hjVG9Kc0FjdGl2aXR5KGFjdCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIudHJhY2UoXCJFcnJvciBpbiBnZXRBY3Rpdml0aWVzKCkgOlwiICsgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnVwZGF0ZUFjdGl2aXR5Q29udGV4dCA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgY29udGV4dCwgZnVsbFJlcGxhY2UsIHJlbW92ZWRLZXlzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChyZW1vdmVkS2V5cykpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRLZXlzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBmdWxsUmVwbGFjZTogZnVsbFJlcGxhY2UsXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkS2V5czogcmVtb3ZlZEtleXNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuc2V0QWN0aXZpdHlDb250ZXh0KGFjdGl2aXR5LmlkLCBKU09OLnN0cmluZ2lmeShjb250ZXh0KSwgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyksIGZ1bmN0aW9uIChuZXdDb250ZXh0U3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q29udGV4dCA9IEpTT04ucGFyc2UobmV3Q29udGV4dFN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ld0NvbnRleHQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIHJlamVjdChlcnJvcik7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5nZXRBY3Rpdml0eVdpbmRvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5nZXRXaW5kb3dzKGZ1bmN0aW9uICh3aW5kb3dzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gd2luZG93cy5tYXAoZnVuY3Rpb24gKHdpbmQpIHsgcmV0dXJuIEhDQnJpZGdlLl9oY1RvSnNXaW5kb3cod2luZCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5zdG9wQWN0aXZpdHkgPSBmdW5jdGlvbiAoYWN0aXZpdHkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnN0b3BBY3Rpdml0eShhY3Rpdml0eS5pZCwgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS51bnJlZ2lzdGVyV2luZG93RmFjdG9yeSA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlTmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIucmVnaXN0ZXJXaW5kb3dGYWN0b3J5KHdpbmRvd1R5cGVOYW1lLCBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuY3JlYXRlV2luZG93ID0gZnVuY3Rpb24gKGlkLCB3aW5kb3dEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5jcmVhdGVXaW5kb3coaWQsIEpTT04uc3RyaW5naWZ5KHdpbmRvd0RlZmluaXRpb24pLCBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoaWQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5jcmVhdGVTdGFja2VkV2luZG93cyA9IGZ1bmN0aW9uIChpZCwgd2luZG93RGVmaW5pdGlvbnMsIHRpbWVvdXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmNyZWF0ZVN0YWNrZWRXaW5kb3dzKGlkLCBKU09OLnN0cmluZ2lmeSh3aW5kb3dEZWZpbml0aW9ucyksIHRpbWVvdXQsIGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpZCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLm9uQWN0aXZpdHlUeXBlU3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlUeXBlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5vbldpbmRvd1R5cGVTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl93aW5kb3dUeXBlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5vbkFjdGl2aXR5U3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLm9uQWN0aXZpdHlXaW5kb3dDaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl93aW5kb3dDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmdldFdpbmRvd0JvdW5kcyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuZ2V0V2luZG93Qm91bmRzKGlkLCBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGJvdW5kcyk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuc2V0V2luZG93Qm91bmRzID0gZnVuY3Rpb24gKGlkLCBib3VuZHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnNldFdpbmRvd0JvdW5kcyhpZCwgSlNPTi5zdHJpbmdpZnkoYm91bmRzKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnJlZ2lzdGVyV2luZG93ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIGluZGVwZW5kZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5yZWdpc3RlcldpbmRvdyh0eXBlLCBuYW1lLCBpbmRlcGVuZGVudCwgZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGlkKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuY2xvc2VXaW5kb3cgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmNsb3NlV2luZG93KGlkLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuYWN0aXZhdGVXaW5kb3cgPSBmdW5jdGlvbiAoaWQsIGZvY3VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5hY3RpdmF0ZVdpbmRvdyhpZCwgZm9jdXMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5zZXRXaW5kb3dWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKGlkLCB2aXNpYmxlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5zZXRXaW5kb3dWaXNpYmlsaXR5KGlkLCB2aXNpYmxlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3B1Ymxpc2hTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoZW50aXR5LCBjb250ZXh0LCBjYWxsYmFja3MpIHtcclxuICAgICAgICB2YXIgZW50aXR5RXZlbnQgPSBuZXcgZW50aXR5RXZlbnRfMi5FbnRpdHlFdmVudChlbnRpdHksIGNvbnRleHQpO1xyXG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlbnRpdHlFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9wdWJsaXNoQWN0aXZpdHlUeXBlU3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGF0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fcHVibGlzaFN0YXR1c0NoYW5nZShhdCwgY29udGV4dCwgdGhpcy5fYWN0aXZpdHlUeXBlQ2FsbGJhY2tzKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3B1Ymxpc2hXaW5kb3dUeXBlU3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKHd0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fcHVibGlzaFN0YXR1c0NoYW5nZSh3dCwgY29udGV4dCwgdGhpcy5fd2luZG93VHlwZUNhbGxiYWNrcyk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9wdWJsaXNoQWN0aXZpdHlTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoYWN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fcHVibGlzaFN0YXR1c0NoYW5nZShhY3QsIGNvbnRleHQsIHRoaXMuX2FjdGl2aXR5Q2FsbGJhY2tzKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3B1Ymxpc2hBY3Rpdml0eVdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKHcsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9wdWJsaXNoU3RhdHVzQ2hhbmdlKHcsIGNvbnRleHQsIHRoaXMuX3dpbmRvd0NhbGxiYWNrcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhDQnJpZGdlO1xyXG59KCkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHNbJ2RlZmF1bHQnXT0gSENCcmlkZ2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhjQnJpZGdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgQWN0aXZpdHlTdGF0dXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlTdGF0dXMoc3RhdGUsIG1lc3NhZ2UsIHRpbWUpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xyXG4gICAgfVxyXG4gICAgQWN0aXZpdHlTdGF0dXMucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5U3RhdHVzLnByb3RvdHlwZS5nZXRNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlTdGF0dXMucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWN0aXZpdHlTdGF0dXM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQWN0aXZpdHlTdGF0dXMgPSBBY3Rpdml0eVN0YXR1cztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlTdGF0dXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBFbnRpdHlFdmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbnRpdHlFdmVudChlbnRpdGl5LCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5lbnRpdHkgPSBlbnRpdGl5O1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRW50aXR5RXZlbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRW50aXR5RXZlbnQgPSBFbnRpdHlFdmVudDtcclxudmFyIEVudGl0eUV2ZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbnRpdHlFdmVudENvbnRleHQoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEVudGl0eUV2ZW50Q29udGV4dDtcclxufSgpKTtcclxuZXhwb3J0cy5FbnRpdHlFdmVudENvbnRleHQgPSBFbnRpdHlFdmVudENvbnRleHQ7XHJcbnZhciBFbnRpdHlTdGF0dXNDaGFuZ2VFdmVudENvbnRleHQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVudGl0eVN0YXR1c0NoYW5nZUV2ZW50Q29udGV4dCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVudGl0eVN0YXR1c0NoYW5nZUV2ZW50Q29udGV4dChuZXdTdGF0dXMsIG9sZFN0YXR1cykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIEVudGl0eUV2ZW50VHlwZS5TdGF0dXNDaGFuZ2UpO1xyXG4gICAgICAgIHRoaXMubmV3U3RhdHVzID0gbmV3U3RhdHVzO1xyXG4gICAgICAgIHRoaXMub2xkU3RhdHVzID0gb2xkU3RhdHVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEVudGl0eVN0YXR1c0NoYW5nZUV2ZW50Q29udGV4dDtcclxufShFbnRpdHlFdmVudENvbnRleHQpKTtcclxuZXhwb3J0cy5FbnRpdHlTdGF0dXNDaGFuZ2VFdmVudENvbnRleHQgPSBFbnRpdHlTdGF0dXNDaGFuZ2VFdmVudENvbnRleHQ7XHJcbnZhciBFbnRpdHlBY3Rpdml0eVdpbmRvd0V2ZW50Q29udGV4dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRW50aXR5QWN0aXZpdHlXaW5kb3dFdmVudENvbnRleHQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFbnRpdHlBY3Rpdml0eVdpbmRvd0V2ZW50Q29udGV4dChhY3Rpdml0eSwgZXZlbnQpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBFbnRpdHlFdmVudFR5cGUuQWN0aXZpdHlXaW5kb3dFdmVudCk7XHJcbiAgICAgICAgdGhpcy5hY3Rpdml0eSA9IGFjdGl2aXR5O1xyXG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBFbnRpdHlBY3Rpdml0eVdpbmRvd0V2ZW50Q29udGV4dDtcclxufShFbnRpdHlFdmVudENvbnRleHQpKTtcclxuZXhwb3J0cy5FbnRpdHlBY3Rpdml0eVdpbmRvd0V2ZW50Q29udGV4dCA9IEVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0O1xyXG52YXIgQWN0aXZpdHlDb250ZXh0Q2hhbmdlZENvbnRleHQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFjdGl2aXR5Q29udGV4dENoYW5nZWRDb250ZXh0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlDb250ZXh0Q2hhbmdlZENvbnRleHQoY29udGV4dCwgdXBkYXRlZCwgcmVtb3ZlZCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIEVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eUNvbnRleHRDaGFuZ2UpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHVwZGF0ZWQ7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFjdGl2aXR5Q29udGV4dENoYW5nZWRDb250ZXh0O1xyXG59KEVudGl0eUV2ZW50Q29udGV4dCkpO1xyXG5leHBvcnRzLkFjdGl2aXR5Q29udGV4dENoYW5nZWRDb250ZXh0ID0gQWN0aXZpdHlDb250ZXh0Q2hhbmdlZENvbnRleHQ7XHJcbnZhciBFbnRpdHlFdmVudFR5cGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRW50aXR5RXZlbnRUeXBlKCkge1xyXG4gICAgfVxyXG4gICAgRW50aXR5RXZlbnRUeXBlLkFkZGVkID0gXCJhZGRlZFwiO1xyXG4gICAgRW50aXR5RXZlbnRUeXBlLlJlbW92ZWQgPSBcInJlbW92ZWRcIjtcclxuICAgIEVudGl0eUV2ZW50VHlwZS5VcGRhdGVkID0gXCJ1cGRhdGVkXCI7XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuRmFjdG9yeVJlZ2lzdGVyZWQgPSBcImZhY3RvcnlSZWdpc3RlcmVkXCI7XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuRmFjdG9yeVVucmVnaXN0ZXJlZCA9IFwiZmFjdG9yeVVucmVnaXN0ZXJlZFwiO1xyXG4gICAgRW50aXR5RXZlbnRUeXBlLlN0YXR1c0NoYW5nZSA9IFwic3RhdHVzQ2hhbmdlXCI7XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuQWN0aXZpdHlDb250ZXh0Q2hhbmdlID0gXCJhY3Rpdml0eUNvbnRleHRVcGRhdGVcIjtcclxuICAgIEVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eVdpbmRvd0V2ZW50ID0gXCJhY3Rpdml0eVdpbmRvd0V2ZW50XCI7XHJcbiAgICByZXR1cm4gRW50aXR5RXZlbnRUeXBlO1xyXG59KCkpO1xyXG5leHBvcnRzLkVudGl0eUV2ZW50VHlwZSA9IEVudGl0eUV2ZW50VHlwZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW50aXR5RXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIEFjdGl2aXR5QUdNID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5QUdNKGFjdGl2aXR5KSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHkgPSBhY3Rpdml0eTtcclxuICAgIH1cclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgQWN0aXZpdHlBR00uQUdNLnJlZ2lzdGVyKGRlZmluaXRpb24sIGhhbmRsZXIpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5zZXJ2ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuX2FjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpdml0eS53aW5kb3dzLm1hcChmdW5jdGlvbiAodykge1xyXG4gICAgICAgICAgICByZXR1cm4gdy5pbnN0YW5jZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUubWV0aG9kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVIYXNBZ20oKTtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLl9hY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2luZG93cyA9IHRoaXMuX2FjdGl2aXR5LndpbmRvd3M7XHJcbiAgICAgICAgdmFyIG1ldGhvZE5hbWVzID0gW107XHJcbiAgICAgICAgdmFyIG1ldGhvZHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgd2luZG93cy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgdmFyIHdpbmRvd18xID0gd2luZG93c1tpbmRleF07XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dNZXRob2RzID0gdGhpcy5tZXRob2RzRm9yV2luZG93KHdpbmRvd18xKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbWV0aG9kSW5kZXggPSAwOyBtZXRob2RJbmRleCA8IHdpbmRvd01ldGhvZHMubGVuZ3RoOyBtZXRob2RJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFdpbmRvd01ldGhvZCA9IHdpbmRvd01ldGhvZHNbbWV0aG9kSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZE5hbWVzLmluZGV4T2YoY3VycmVudFdpbmRvd01ldGhvZC5uYW1lKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2ROYW1lcy5wdXNoKGN1cnJlbnRXaW5kb3dNZXRob2QubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kcy5wdXNoKGN1cnJlbnRXaW5kb3dNZXRob2QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXRob2RzO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5tZXRob2RzRm9yV2luZG93ID0gZnVuY3Rpb24gKHdpbmRvdykge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIGlmICghd2luZG93Lmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFjdGl2aXR5QUdNLkFHTS5tZXRob2RzRm9ySW5zdGFuY2Uod2luZG93Lmluc3RhbmNlKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGFyZywgdGFyZ2V0LCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIHZhciBhY3Rpdml0eVNlcnZlcnMgPSB0aGlzLnNlcnZlcnMoKTtcclxuICAgICAgICB2YXIgc2VydmVyc1RvSW52b2tlQWdhaW5zdCA9IFtdO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0gXCJhY3Rpdml0eS5hbGxcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBcImFjdGl2aXR5LmFsbFwiKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gYWN0aXZpdHlTZXJ2ZXJzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PT0gXCJhY3Rpdml0eS5iZXN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3RlbnRpYWxUYXJnZXRzID0gYWN0aXZpdHlTZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAoc2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSBBY3Rpdml0eUFHTS5BR00ubWV0aG9kc0Zvckluc3RhbmNlKHNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLm5hbWUgPT09IG1ldGhvZE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbFRhcmdldHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlcnNUb0ludm9rZUFnYWluc3QgPSBbcG90ZW50aWFsVGFyZ2V0c1swXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBcImFsbFwiIHx8IHRhcmdldCA9PT0gXCJiZXN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBY3Rpdml0eUFHTS5BR00uaW52b2tlKG1ldGhvZE5hbWUsIGFyZywgdGFyZ2V0LCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludm9rZSB0YXJnZXQgXCIgKyB0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHV0aWwuaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdEVsZW0gPSB0YXJnZXRbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNBZ21JbnN0YW5jZShmaXJzdEVsZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyc1RvSW52b2tlQWdhaW5zdCA9IHRhcmdldC5tYXAoZnVuY3Rpb24gKGluc3RhbmNlKSB7IHJldHVybiBpbnN0YW5jZTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0FjdGl2aXR5V2luZG93KGZpcnN0RWxlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAod2luKSB7IHJldHVybiB3aW4uaW5zdGFuY2U7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0YXJnZXQgb2JqZWN0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNBZ21JbnN0YW5jZSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gW3RhcmdldF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNBY3Rpdml0eVdpbmRvdyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gW3RhcmdldC5pbnN0YW5jZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRhcmdldCBvYmplY3RcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFjdGl2aXR5QUdNLkFHTS5pbnZva2UobWV0aG9kTmFtZSwgYXJnLCBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0LCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIHJldHVybiBBY3Rpdml0eUFHTS5BR00udW5yZWdpc3RlcihkZWZpbml0aW9uKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUuY3JlYXRlU3RyZWFtID0gZnVuY3Rpb24gKG1ldGhvZERlZmluaXRpb24sIHN1YnNjcmliZXJBZGRlZEhhbmRsZXIsIHN1YnNjcmliZXJSZW1vdmVkRnVuY3Rpb24pIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVIYXNBZ20oKTtcclxuICAgICAgICBBY3Rpdml0eUFHTS5BR00uY3JlYXRlU3RyZWFtKG1ldGhvZERlZmluaXRpb24sIHN1YnNjcmliZXJBZGRlZEhhbmRsZXIsIHN1YnNjcmliZXJSZW1vdmVkRnVuY3Rpb24pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAobWV0aG9kRGVmaW5pdGlvbiwgcGFyYW1ldGVycywgdGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgdmFyIHNlcnZlcnMgPSB0aGlzLnNlcnZlcnMoKTtcclxuICAgICAgICByZXR1cm4gQWN0aXZpdHlBR00uQUdNLnN1YnNjcmliZShtZXRob2REZWZpbml0aW9uLCBwYXJhbWV0ZXJzLCBzZXJ2ZXJzKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUuX2Vuc3VyZUhhc0FnbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChBY3Rpdml0eUFHTS5BR00pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFnbSBzaG91bGQgYmUgY29uZmlndXJlZCB0byBiZSB1c2VkIGluIGFjdGl2aXR5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUuX2lzQWdtSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iai5hcHBsaWNhdGlvbiAhPSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLl9pc0FjdGl2aXR5V2luZG93ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmouaW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWN0aXZpdHlBR007XHJcbn0oKSk7XHJcbmV4cG9ydHMuQWN0aXZpdHlBR00gPSBBY3Rpdml0eUFHTTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlBR00uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBlbnRpdHlFdmVudF8xID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0cy9lbnRpdHlFdmVudFwiKTtcclxudmFyIGFjdGl2aXR5VHlwZV8xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2FjdGl2aXR5VHlwZVwiKTtcclxudmFyIHByb21pc2VFeHRlbnNpb25zXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9wcm9taXNlRXh0ZW5zaW9uc1wiKTtcclxudmFyIHJlYWR5TWFya2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9yZWFkeU1hcmtlclwiKTtcclxudmFyIGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvblwiKTtcclxudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbG9nZ2VyXCIpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3V0aWxcIik7XHJcbnZhciBsb2NhbFdpbmRvd0ZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL2xvY2FsV2luZG93RmFjdG9yeVwiKTtcclxudmFyIEFjdGl2aXR5TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eU1hbmFnZXIoYnJpZGdlLCBhdXRvQW5ub3VuY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlci5HZXQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fYW5ub3VuY2VkV2luZG93cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZSA9IGJyaWRnZTtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eVR5cGVzID0gbmV3IGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9ncmFiRW50aXR5KGUpOyB9KTtcclxuICAgICAgICB0aGlzLl93aW5kb3dUeXBlcyA9IG5ldyBlbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbl8xLkVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uKGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fZ3JhYkVudGl0eShlKTsgfSk7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdGllcyA9IG5ldyBlbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbl8xLkVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uKGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fZ3JhYkVudGl0eShlKTsgfSk7XHJcbiAgICAgICAgdGhpcy5fd2luZG93cyA9IG5ldyBlbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbl8xLkVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uKGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fZ3JhYkVudGl0eShlKTsgfSk7XHJcbiAgICAgICAgdGhpcy5fZGF0YVJlYWR5TWFya2VyID0gbmV3IHJlYWR5TWFya2VyXzEuUmVhZHlNYXJrZXIoXCJBY3Rpdml0eSBNYW5hZ2VyIERhdGFcIiwgW1wiR2V0QWN0aXZpdHlUeXBlc1wiLCBcIkdldFdpbmRvd1R5cGVzXCIsIFwiR2V0QWN0aXZpdGllc1wiLCBcIkdldFdpbmRvd3NcIl0ubGVuZ3RoKTtcclxuICAgICAgICBpZiAoYXV0b0Fubm91bmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBhbm5vdW5jZU1ha2VyID0gbmV3IHJlYWR5TWFya2VyXzEuUmVhZHlNYXJrZXIoXCJBY3Rpdml0eSBNYW5hZ2VyIEFubm91bmNlXCIsIFtcIkFubm91bmNlbWVudFwiXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeU1hcmtlciA9IGFubm91bmNlTWFrZXI7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFSZWFkeU1hcmtlci5zZXRDYWxsYmFjayhmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlYWR5TWFya2VyLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKFwiQXV0byBhbm5vdW5jaW5nIHdpbmRvd1wiKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFubm91bmNlV2luZG93KClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodykge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbm5vdW5jZWRXaW5kb3dzLnB1c2godyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlYWR5TWFya2VyLnNpZ25hbChcIlN1Y2Nlc3NmdWxseSBhbm5vdW5jZWQgd2luZG93IHdpdGggaWQgJ1wiICsgdy5pZCArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKFwiV2lsbCBub3QgYW5ub3VuY2Ugd2luZG93IC0gXCIgKyBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWFkeU1hcmtlci5zaWduYWwoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5TWFya2VyID0gdGhpcy5fZGF0YVJlYWR5TWFya2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9icmlkZ2UuaW5pdCgpO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAucmVhZHkoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYXcpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmliZUZvckRhdGEoKTtcclxuICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUsIFwiYW5ub3VuY2VkV2luZG93c1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbm5vdW5jZWRXaW5kb3dzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYWxsb3dlZFwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuc2V0Q2FsbGJhY2soZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfdGhpcy5fcmVhZHlNYXJrZXIuZ2V0RXJyb3IoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuZ2V0QWN0aXZpdHlUeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZpdHlUeXBlcy5nZXQoKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldEFjdGl2aXR5VHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2aXR5VHlwZXMuZ2V0QnlOYW1lKG5hbWUpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJBY3Rpdml0eVR5cGUgPSBmdW5jdGlvbiAoYWN0aXZpdHlUeXBlTmFtZSwgb3duZXJXaW5kb3dUeXBlLCBoZWxwZXJXaW5kb3dUeXBlcywgbGF5b3V0Q29uZmlnLCBkZXNjcmlwdGlvbiwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChhY3Rpdml0eVR5cGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiYWN0aXZpdHlUeXBlTmFtZSBhcmd1bWVudCBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcoYWN0aXZpdHlUeXBlTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcImFjdGl2aXR5VHlwZU5hbWUgc2hvdWxkIGJlIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYWN0VHlwZSA9IF90aGlzLmdldEFjdGl2aXR5VHlwZShhY3Rpdml0eVR5cGVOYW1lKTtcclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJBY3Rpdml0eSB0eXBlICdcIiArIGFjdGl2aXR5VHlwZU5hbWUgKyBcIicgYWxyZWFkeSBleGlzdHNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG93bmVyRGVmaW5pdGlvbjtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQob3duZXJXaW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiT3duZXIgd2luZG93IHR5cGUgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcob3duZXJXaW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgb3duZXJEZWZpbml0aW9uID0geyB0eXBlOiBvd25lcldpbmRvd1R5cGUsIG5hbWU6IFwiXCIsIGlzSW5kZXBlbmRlbnQ6IGZhbHNlLCBhcmd1bWVudHM6IHt9IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvd25lckRlZmluaXRpb24gPSBvd25lcldpbmRvd1R5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGhlbHBlckRlZmluaXRpb25zID0gW107XHJcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZChoZWxwZXJXaW5kb3dUeXBlcykgJiYgdXRpbC5pc0FycmF5KGhlbHBlcldpbmRvd1R5cGVzKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggaW4gaGVscGVyV2luZG93VHlwZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGhlbHBlcldpbmRvd1R5cGVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbmRlcGVuZGVudDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVUbzogXCJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlRGlyZWN0aW9uOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93U3R5bGVBdHRyaWJ1dGVzOiB7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJEZWZpbml0aW9ucy5wdXNoKGRlZmluaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyRGVmaW5pdGlvbnMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAgICAgLnJlZ2lzdGVyQWN0aXZpdHlUeXBlKGFjdGl2aXR5VHlwZU5hbWUsIG93bmVyRGVmaW5pdGlvbiwgaGVscGVyRGVmaW5pdGlvbnMsIGxheW91dENvbmZpZywgZGVzY3JpcHRpb24pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWN0aXZpdHlUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ3JhYkVudGl0eShhY3Rpdml0eVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhY3Rpdml0eVR5cGUpO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUudW5yZWdpc3RlckFjdGl2aXR5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhY3RUeXBlID0gX3RoaXMuZ2V0QWN0aXZpdHlUeXBlKHR5cGUpO1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChhY3RUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiQWN0aXZpdHkgdHlwZSAnXCIgKyB0eXBlICsgXCInIGRvZXMgbm90IGV4aXN0c1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2JyaWRnZS51bnJlZ2lzdGVyQWN0aXZpdHlUeXBlKHR5cGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuaW5pdGlhdGUgPSBmdW5jdGlvbiAoYWN0aXZpdHlUeXBlLCBjb250ZXh0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhY3RUeXBlID0gX3RoaXMuZ2V0QWN0aXZpdHlUeXBlKGFjdGl2aXR5VHlwZSk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJBY3Rpdml0eSB0eXBlICdcIiArIGFjdGl2aXR5VHlwZSArIFwiJyBkb2VzIG5vdCBleGlzdHNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAgICAgLmluaXRpYXRlQWN0aXZpdHkoYWN0aXZpdHlUeXBlLCBjb250ZXh0KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFjdElkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZpdGllc1xyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRPcldhaXQoYWN0SWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYWN0KTtcclxuICAgICAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9KTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuc3Vic2NyaWJlQWN0aXZpdHlUeXBlRXZlbnRzID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eVR5cGVzLnN1YnNjcmliZShmdW5jdGlvbiAoYXQsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaGFuZGxlcihhdCwgY29udGV4dC50eXBlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldFdpbmRvd1R5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aW5kb3dUeXBlcy5nZXQoKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldFdpbmRvd1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aW5kb3dUeXBlcy5nZXRCeU5hbWUobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlcldpbmRvd0ZhY3RvcnkgPSBmdW5jdGlvbiAod2luZG93VHlwZSwgZmFjdG9yeU1ldGhvZCwgZGVzY3JpcHRpb24sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIm5vIHdpbmRvd1R5cGUgc3BlY2lmaWVkXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3dUeXBlID0gd2luZG93VHlwZS5nZXROYW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXV0aWwuaXNTdHJpbmcod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIndpbmRvd1R5cGUgc2hvdWxkIGJlIHN0cmluZyBvciBvYmplY3QgdGhhdCBoYXMgZ2V0TmFtZSBtZXRob2RcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZhY3RvcnkgPSBuZXcgbG9jYWxXaW5kb3dGYWN0b3J5XzEuTG9jYWxXaW5kb3dGYWN0b3J5KGZhY3RvcnlNZXRob2QsIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAgICAgLnJlZ2lzdGVyV2luZG93RmFjdG9yeSh3aW5kb3dUeXBlLCBmYWN0b3J5KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodik7XHJcbiAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnVucmVnaXN0ZXJXaW5kb3dGYWN0b3J5ID0gZnVuY3Rpb24gKHdpbmRvd1R5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIm5vIHdpbmRvd1R5cGUgc3BlY2lmaWVkXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwid2luZG93VHlwZSBzaG91bGQgYmUgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAgICAgLnVucmVnaXN0ZXJXaW5kb3dGYWN0b3J5KHdpbmRvd1R5cGUpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh2KTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuZ2V0QWN0aXZpdGllcyA9IGZ1bmN0aW9uIChhY3Rpdml0eVR5cGUpIHtcclxuICAgICAgICB2YXIgYWN0ID0gdGhpcy5fYWN0aXZpdGllcy5nZXQoKTtcclxuICAgICAgICBpZiAoIWFjdGl2aXR5VHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdHlwZXMgPSBhY3Rpdml0eVR5cGU7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcoYWN0aXZpdHlUeXBlKSkge1xyXG4gICAgICAgICAgICB0eXBlcyA9IFthY3Rpdml0eVR5cGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpdml0eVR5cGUgaW5zdGFuY2VvZiBhY3Rpdml0eVR5cGVfMVsnZGVmYXVsdCddKSB7XHJcbiAgICAgICAgICAgIHR5cGVzID0gW2FjdGl2aXR5VHlwZS5uYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aXZpdHlUeXBlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgYXJndW1lbnQgJ2FjdGl2aXR5VHlwZScgPSBcIiArIGFjdGl2aXR5VHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY3QuZmlsdGVyKGZ1bmN0aW9uIChhY3QpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBhY3QudHlwZTtcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWwuc29tZSh0eXBlcywgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLmlkID09IHQuaWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuZ2V0QWN0aXZpdHlCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2aXRpZXMuZ2V0QnlOYW1lKGlkKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmFubm91bmNlV2luZG93ID0gZnVuY3Rpb24gKGFjdGl2aXR5V2luZG93SWQsIHdpbmRvd1R5cGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgYW5ub3VuY2VtZW50SW5mbyA9IF90aGlzLl9icmlkZ2UuZ2V0QW5ub3VuY2VtZW50SW5mbygpO1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChhY3Rpdml0eVdpbmRvd0lkKSkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZpdHlXaW5kb3dJZCA9IGFubm91bmNlbWVudEluZm8uYWN0aXZpdHlXaW5kb3dJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93VHlwZSA9IGFubm91bmNlbWVudEluZm8uYWN0aXZpdHlXaW5kb3dUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFubm91bmNlIC0gdW5rbm93biB3aW5kb3dUeXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5V2luZG93SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKFwiUmVnaXN0ZXJpbmcgd2luZG93IHdpdGggdHlwZTonXCIgKyB3aW5kb3dUeXBlICsgXCInLCBuYW1lOidcIiArIGFubm91bmNlbWVudEluZm8uYWN0aXZpdHlXaW5kb3dOYW1lICsgXCInLCBpbmQuOidcIiArIGFubm91bmNlbWVudEluZm8uYWN0aXZpdHlXaW5kb3dJbmRlcGVuZGVudCArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9icmlkZ2UucmVnaXN0ZXJXaW5kb3cod2luZG93VHlwZSwgYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd05hbWUsIGFubm91bmNlbWVudEluZm8uYWN0aXZpdHlXaW5kb3dJbmRlcGVuZGVudClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihfdGhpcy5fd2luZG93cy5nZXRPcldhaXQuYmluZChfdGhpcy5fd2luZG93cykpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHcpO1xyXG4gICAgICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5kZWJ1ZyhcIkFubm91bmNpbmcgd2luZG93IHdpdGggaWQgJ1wiICsgYWN0aXZpdHlXaW5kb3dJZCArIFwiJyBhbmQgdHlwZSAnXCIgKyB3aW5kb3dUeXBlICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRXaW5kb3cgPSBfdGhpcy5fd2luZG93cy5nZXRCeU5hbWUoYWN0aXZpdHlXaW5kb3dJZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwoY3VycmVudFdpbmRvdykpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKFwiV2luZG93IHdpdGggaWQgJ1wiICsgYWN0aXZpdHlXaW5kb3dJZCArIFwiJyBhbHJlYWR5IGFubm91bmNlZCAtIHJldXNpbmcgdGhlIHdpbmRvd1wiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGN1cnJlbnRXaW5kb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB3aW5kb3dFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoYSwgdywgZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpdml0eVdpbmRvd0lkID09PSB3LmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlID09PSBcImpvaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aXZpdHkgPSB3LmFjdGl2aXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiVU5ERUZJTkVEIEFDVElWSVRZXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci50cmFjZShcIkdvdCBqb2luZWQgZXZlbnQgZm9yIGlkICdcIiArIGFjdGl2aXR5V2luZG93SWQgKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5zdWJzY3JpYmVXaW5kb3dFdmVudHMod2luZG93RXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zdWJzY3JpYmVXaW5kb3dFdmVudHMod2luZG93RXZlbnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIudHJhY2UoXCJXYWl0aW5nIGZvciBqb2luZWQgZXZlbnQgZm9yIGlkICdcIiArIGFjdGl2aXR5V2luZG93SWQgKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYnJpZGdlLmFubm91bmNlV2luZG93KHdpbmRvd1R5cGUsIGFjdGl2aXR5V2luZG93SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdWJzY3JpYmVXaW5kb3dUeXBlRXZlbnRzID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl93aW5kb3dUeXBlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHd0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIod3QsIGNvbnRleHQudHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpdml0eUV2ZW50cyA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdGllcy5zdWJzY3JpYmUoZnVuY3Rpb24gKGFjdCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC50eXBlID09PSBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5TdGF0dXNDaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoYWN0LCBwLm5ld1N0YXR1cywgcC5vbGRTdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdWJzY3JpYmVXaW5kb3dFdmVudHMgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd3Muc3Vic2NyaWJlKGZ1bmN0aW9uICh3aW5kb3csIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQudHlwZSA9PT0gZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudFR5cGUuQWN0aXZpdHlXaW5kb3dFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcih3aW5kb3cuYWN0aXZpdHksIHdpbmRvdywgcC5ldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dC50eXBlID09PSAncmVtb3ZlZCcpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIod2luZG93LmFjdGl2aXR5LCB3aW5kb3csIGNvbnRleHQudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlV2luZG93RXZlbnRzID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZVdpbmRvdyA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgd2luZG93VHlwZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChhY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcImFjdGl2aXR5IGlzIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwid2luZG93VHlwZSBpcyB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHdpbmRvd0RlZmluaXRpb247XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3dEZWZpbml0aW9uID0geyB0eXBlOiB3aW5kb3dUeXBlLCBuYW1lOiBcIlwiLCBpc0luZGVwZW5kZW50OiBmYWxzZSwgYXJndW1lbnRzOiB7fSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2luZG93RGVmaW5pdGlvbiA9IHdpbmRvd1R5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlVG9XaW5kb3c7XHJcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dEZWZpbml0aW9uLnJlbGF0aXZlVG8pKSB7XHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvV2luZG93ID0gd2luZG93RGVmaW5pdGlvbi5yZWxhdGl2ZVRvO1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmVUb1dpbmRvdykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93cyA9IF90aGlzLmdldFdpbmRvd3MoeyB0eXBlOiByZWxhdGl2ZVRvV2luZG93IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dzKSAmJiB3aW5kb3dzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93RGVmaW5pdGlvbi5yZWxhdGl2ZVRvID0gd2luZG93c1swXS5pZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChyZWxhdGl2ZVRvV2luZG93LnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd3MgPSBfdGhpcy5nZXRXaW5kb3dzKHsgdHlwZTogcmVsYXRpdmVUb1dpbmRvdy50eXBlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dzKSAmJiB3aW5kb3dzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93RGVmaW5pdGlvbi5yZWxhdGl2ZVRvID0gd2luZG93c1swXS5pZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChyZWxhdGl2ZVRvV2luZG93LndpbmRvd0lkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0RlZmluaXRpb24ucmVsYXRpdmVUbyA9IHJlbGF0aXZlVG9XaW5kb3cud2luZG93SWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZS5jcmVhdGVXaW5kb3coYWN0aXZpdHkuaWQsIHdpbmRvd0RlZmluaXRpb24pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAod2lkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKFwiV2luZG93IGNyZWF0ZWQsIHdhaXRpbmcgZm9yIHdpbmRvdyBlbnRpdHkgd2l0aCBpZCBcIiArIHdpZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uICh3aW5kb3csIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmlkID09PSB3aWQgJiYgd2luZG93LmFjdGl2aXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIkdvdCBlbnRpdHkgd2luZG93IHdpdGggaWQgXCIgKyB3aWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpbmRvd3MudW5zdWJzY3JpYmUoaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfS5iaW5kKF90aGlzKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl93aW5kb3dzLnN1YnNjcmliZShoYW5kbGVyKTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuY3JlYXRlU3RhY2tlZFdpbmRvd3MgPSBmdW5jdGlvbiAoYWN0aXZpdHksIHJlbGF0aXZlV2luZG93VHlwZXMsIHRpbWVvdXQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJhY3Rpdml0eSBpcyB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwocmVsYXRpdmVXaW5kb3dUeXBlcykpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcInJlbGF0aXZlV2luZG93VHlwZXMgaXMgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWxhdGl2ZVdpbmRvd1R5cGVzKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwicmVsYXRpdmVXaW5kb3dUeXBlcyBoYXMgdG8gYmUgYXJyYXlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwodGltZW91dCkpIHtcclxuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSAyMDAwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVXaW5kb3dzID0gW107XHJcbiAgICAgICAgICAgIHJlbGF0aXZlV2luZG93VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpbmRvd0RlZmluaXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0RlZmluaXRpb24gPSB7IHR5cGU6IGVsZW1lbnQsIG5hbWU6IFwiXCIsIGlzSW5kZXBlbmRlbnQ6IGZhbHNlLCBhcmd1bWVudHM6IHt9IH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dEZWZpbml0aW9uID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZWxhdGl2ZVRvV2luZG93O1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd0RlZmluaXRpb24ucmVsYXRpdmVUbykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVRvV2luZG93ID0gd2luZG93RGVmaW5pdGlvbi5yZWxhdGl2ZVRvO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChyZWxhdGl2ZVRvV2luZG93LnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0RlZmluaXRpb24ucmVsYXRpdmVUbyA9IHJlbGF0aXZlVG9XaW5kb3cudHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwocmVsYXRpdmVUb1dpbmRvdy53aW5kb3dJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd3MgPSBfdGhpcy5nZXRXaW5kb3dzKHsgaWQ6IHJlbGF0aXZlVG9XaW5kb3cud2luZG93SWQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dzKSAmJiB3aW5kb3dzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0RlZmluaXRpb24ucmVsYXRpdmVUbyA9IHdpbmRvd3NbMF0udHlwZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93RGVmaW5pdGlvbi51c2VFeGlzdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVdpbmRvd3MucHVzaCh3aW5kb3dEZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2UuY3JlYXRlU3RhY2tlZFdpbmRvd3MoYWN0aXZpdHkuaWQsIHJlbGF0aXZlV2luZG93cywgdGltZW91dClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh3aWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhY3Rpdml0eVdpbmRvd3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5Q3JlYXRlZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAod2luZG93LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpZC5pbmRleE9mKHdpbmRvdy5pZCkgPj0gMCAmJiBhbHJlYWR5Q3JlYXRlZC5pbmRleE9mKHdpbmRvdy5pZCkgPCAwICYmIHdpbmRvdy5hY3Rpdml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJHb3QgZW50aXR5IHdpbmRvdyB3aXRoIGlkIFwiICsgd2lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlXaW5kb3dzLnB1c2god2luZG93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUNyZWF0ZWQucHVzaCh3aW5kb3cuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZpdHlXaW5kb3dzLmxlbmd0aCA9PSB3aWQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGFjdGl2aXR5V2luZG93cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93aW5kb3dzLnVuc3Vic2NyaWJlKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfS5iaW5kKF90aGlzKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl93aW5kb3dzLnN1YnNjcmliZShoYW5kbGVyKTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuam9pbldpbmRvd1RvQWN0aXZpdHkgPSBmdW5jdGlvbiAoYWN0aXZpdHksIHdpbmRvdywgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUubGVhdmVXaW5kb3dGcm9tQWN0aXZpdHkgPSBmdW5jdGlvbiAoYWN0aXZpdHksIHdpbmRvdywgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuc2V0QWN0aXZpdHlDb250ZXh0ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCBjb250ZXh0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiYWN0aXZpdHkgY2FuIG5vdCBiZSBudWxsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2VcclxuICAgICAgICAgICAgICAgIC51cGRhdGVBY3Rpdml0eUNvbnRleHQoYWN0aXZpdHksIGNvbnRleHQsIHRydWUpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKG9iaik7XHJcbiAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUFjdGl2aXR5Q29udGV4dCA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgY29udGV4dCwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChhY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcImFjdGl2aXR5IGNhbiBub3QgYmUgbnVsbFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZEtleXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lmhhc093blByb3BlcnR5KGtleSkgJiYgY29udGV4dFtrZXldID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2VcclxuICAgICAgICAgICAgICAgIC51cGRhdGVBY3Rpdml0eUNvbnRleHQoYWN0aXZpdHksIGNvbnRleHQsIGZhbHNlLCByZW1vdmVkS2V5cylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUob2JqKTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuc3Vic2NyaWJlQWN0aXZpdHlDb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdGllcy5zdWJzY3JpYmUoZnVuY3Rpb24gKGFjdCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC50eXBlID09PSBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eUNvbnRleHRDaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoYWN0LCB1cGRhdGVDb250ZXh0LmNvbnRleHQsIHVwZGF0ZUNvbnRleHQudXBkYXRlZCwgdXBkYXRlQ29udGV4dC5yZW1vdmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuc3RvcEFjdGl2aXR5ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fYnJpZGdlLnN0b3BBY3Rpdml0eShhY3Rpdml0eSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRXaW5kb3dzID0gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGZpbHRlcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpbmRvd3MuZ2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZChmaWx0ZXIuaWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5fd2luZG93cy5nZXRCeU5hbWUoZmlsdGVyLmlkKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhbGxXaW5kb3dzID0gdGhpcy5fd2luZG93cy5nZXQoKTtcclxuICAgICAgICByZXR1cm4gYWxsV2luZG93cy5maWx0ZXIoZnVuY3Rpb24gKHcpIHtcclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGZpbHRlci50eXBlKSAmJiB3LnR5cGUuaWQgIT09IGZpbHRlci50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGZpbHRlci5uYW1lKSAmJiB3Lm5hbWUgIT09IGZpbHRlci5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGZpbHRlci5hY3Rpdml0eUlkKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwody5hY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAody5hY3Rpdml0eS5pZCAhPT0gZmlsdGVyLmFjdGl2aXR5SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5fZ3JhYkVudGl0eSA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICBlbnRpdHkubWFuYWdlciA9IHRoaXM7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5fc3Vic2NyaWJlRm9yRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIlN0YXJ0IGdldHRpbmcgaW5pdGlhbCBkYXRhLi4uXCIpO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5vbkFjdGl2aXR5VHlwZVN0YXR1c0NoYW5nZShmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2FjdGl2aXR5VHlwZXMucHJvY2VzcyhldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlLmdldEFjdGl2aXR5VHlwZXMoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYXQpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2FjdGl2aXR5VHlwZXMuYWRkKGF0KTtcclxuICAgICAgICAgICAgX3RoaXMuX2RhdGFSZWFkeU1hcmtlci5zaWduYWwoXCJHb3QgYWN0IHR5cGVzXCIpO1xyXG4gICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgX3RoaXMuX2RhdGFSZWFkeU1hcmtlci5lcnJvcihcIkNhbiBub3QgaW5pdGlhbGl6ZSBBY3Rpdml0eU1hbmFnZXIgLSBlcnJvciBnZXR0aW5nIGFjdGl2aXR5IHR5cGVzIC1cIiArIGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2Uub25XaW5kb3dUeXBlU3RhdHVzQ2hhbmdlKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fd2luZG93VHlwZXMucHJvY2VzcyhldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlLmdldFdpbmRvd1R5cGVzKClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHd0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl93aW5kb3dUeXBlcy5hZGQod3QpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLnNpZ25hbChcIkdvdCB3aW5kb3cgdHlwZXNcIik7XHJcbiAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLmVycm9yKFwiQ2FuIG5vdCBpbml0aWFsaXplIEFjdGl2aXR5TWFuYWdlciAtIGVycm9yIGdldHRpbmcgd2luZG93IHR5cGVzICBcIiArIGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2Uub25BY3Rpdml0eVN0YXR1c0NoYW5nZShmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2FjdGl2aXRpZXMucHJvY2VzcyhldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlLmdldEFjdGl2aXRpZXMoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWMpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2FjdGl2aXRpZXMuYWRkKGFjKTtcclxuICAgICAgICAgICAgX3RoaXMuX2RhdGFSZWFkeU1hcmtlci5zaWduYWwoXCJHb3QgYWN0aXZpdGllc1wiKTtcclxuICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpemUgQWN0aXZpdHlNYW5hZ2VyIC0gZXJyb3IgZ2V0dGluZyBhY3Rpdml0eSBpbnN0YW5jZXMgLVwiICsgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5vbkFjdGl2aXR5V2luZG93Q2hhbmdlKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fd2luZG93cy5wcm9jZXNzKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2UuZ2V0QWN0aXZpdHlXaW5kb3dzKClcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGF3KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl93aW5kb3dzLmFkZChhdyk7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuc2lnbmFsKFwiR290IHdpbmRvd3NcIik7XHJcbiAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLmVycm9yKFwiQ2FuIG5vdCBpbml0aWFsaXplIEFjdGl2aXR5TWFuYWdlciAtIGVycm9yIGdldHRpbmcgYWN0aXZpdHkgd2luZG93cyAtXCIgKyBlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRXaW5kb3dCb3VuZHMgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnJpZGdlLmdldFdpbmRvd0JvdW5kcyhpZCk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zZXRXaW5kb3dCb3VuZHMgPSBmdW5jdGlvbiAoaWQsIGJvdW5kcywgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlLnNldFdpbmRvd0JvdW5kcyhpZCwgYm91bmRzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSgpOyB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZVdpbmRvdyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9icmlkZ2UuY2xvc2VXaW5kb3coaWQpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuYWN0aXZhdGVXaW5kb3cgPSBmdW5jdGlvbiAoaWQsIGZvY3VzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JyaWRnZS5hY3RpdmF0ZVdpbmRvdyhpZCwgZm9jdXMpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuc2V0V2luZG93VmlzaWJpbGl0eSA9IGZ1bmN0aW9uIChpZCwgdmlzaWJsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9icmlkZ2Uuc2V0V2luZG93VmlzaWJpbGl0eShpZCwgdmlzaWJsZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5TWFuYWdlcjtcclxufSgpKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5TWFuYWdlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgTG9jYWxXaW5kb3dGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvY2FsV2luZG93RmFjdG9yeShjcmVhdGVGdW5jdGlvbiwgZGVzY3JpcHRpb24pIHtcclxuICAgICAgICB0aGlzLl9jcmVhdGVGdW5jdGlvbiA9IGNyZWF0ZUZ1bmN0aW9uO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICB9XHJcbiAgICBMb2NhbFdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVdpbmRvd0lkLCBjb250ZXh0LCBsYXlvdXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlRnVuY3Rpb24oYWN0aXZpdHlXaW5kb3dJZCwgY29udGV4dCwgbGF5b3V0KTtcclxuICAgIH07XHJcbiAgICBMb2NhbFdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTG9jYWxXaW5kb3dGYWN0b3J5O1xyXG59KCkpO1xyXG5leHBvcnRzLkxvY2FsV2luZG93RmFjdG9yeSA9IExvY2FsV2luZG93RmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxXaW5kb3dGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgUHJveHlXaW5kb3dGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3h5V2luZG93RmFjdG9yeShkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICB9XHJcbiAgICBQcm94eVdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVdpbmRvd0lkLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBQcm94eVdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJveHlXaW5kb3dGYWN0b3J5O1xyXG59KCkpO1xyXG5leHBvcnRzLlByb3h5V2luZG93RmFjdG9yeSA9IFByb3h5V2luZG93RmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJveHlXaW5kb3dGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYWN0aXZpdHlFbnRpdHlfMSA9IHJlcXVpcmUoXCIuL2FjdGl2aXR5RW50aXR5XCIpO1xyXG52YXIgYWN0aXZpdHlBR01fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2FjdGl2aXR5QUdNXCIpO1xyXG52YXIgQWN0aXZpdHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFjdGl2aXR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHkoaWQsIGFjdFR5cGUsIHN0YXR1cywgY29udGV4dCwgb3duZXJJZCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGlkKTtcclxuICAgICAgICB0aGlzLl9pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuX2FjdFR5cGUgPSBhY3RUeXBlO1xyXG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9vd25lcklkID0gb3duZXJJZDtcclxuICAgICAgICB0aGlzLl9hZ20gPSBuZXcgYWN0aXZpdHlBR01fMS5BY3Rpdml0eUFHTSh0aGlzKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0QWN0aXZpdHlUeXBlKHRoaXMuX2FjdFR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHkucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwib3duZXJcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX293bmVySWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93cyh7IGlkOiB0aGlzLl9vd25lcklkIH0pWzBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5LnByb3RvdHlwZSwgXCJ3aW5kb3dzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRXaW5kb3dzKHsgYWN0aXZpdHlJZDogdGhpcy5faWQgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHkucHJvdG90eXBlLCBcImFnbVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZ207XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh3aW5kb3csIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5qb2luV2luZG93VG9BY3Rpdml0eSh0aGlzLCB3aW5kb3csIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuY3JlYXRlV2luZG93ID0gZnVuY3Rpb24gKHdpbmRvd1R5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5jcmVhdGVXaW5kb3codGhpcywgd2luZG93VHlwZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5jcmVhdGVTdGFja2VkV2luZG93cyA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlcywgdGltZW91dCwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmNyZWF0ZVN0YWNrZWRXaW5kb3dzKHRoaXMsIHdpbmRvd1R5cGVzLCB0aW1lb3V0LCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKHdpbmRvdywgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmxlYXZlV2luZG93RnJvbUFjdGl2aXR5KHRoaXMsIHdpbmRvdywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5nZXRXaW5kb3dzQnlUeXBlID0gZnVuY3Rpb24gKHdpbmRvd1R5cGUpIHtcclxuICAgICAgICB2YXIgZmlsdGVyID0geyBhY3Rpdml0eUlkOiB0aGlzLl9pZCwgdHlwZTogd2luZG93VHlwZSB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93cyhmaWx0ZXIpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5zZXRBY3Rpdml0eUNvbnRleHQodGhpcywgY29udGV4dCwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci51cGRhdGVBY3Rpdml0eUNvbnRleHQodGhpcywgY29udGV4dCwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5vblN0YXR1c0NoYW5nZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc3Vic2NyaWJlQWN0aXZpdHlFdmVudHMoZnVuY3Rpb24gKGEsIG5zLCBvcykge1xyXG4gICAgICAgICAgICBpZiAoYS5pZCA9PT0gX3RoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoYSwgbnMsIG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5vbldpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5zdWJzY3JpYmVXaW5kb3dFdmVudHMoZnVuY3Rpb24gKGEsIHcsIGUpIHtcclxuICAgICAgICAgICAgaWYgKGEuaWQgPT09IF90aGlzLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGEsIHcsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnN1YnNjcmliZUFjdGl2aXR5Q29udGV4dENoYW5nZWQoZnVuY3Rpb24gKGFjdCwgY29udGV4dCwgZGVsdGEsIHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgaWYgKGFjdC5pZCA9PT0gX3RoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoY29udGV4dCwgZGVsdGEsIHJlbW92ZWQsIGFjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBoYW5kbGVyKHRoaXMuY29udGV4dCwgdGhpcy5jb250ZXh0LCBbXSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc3RvcEFjdGl2aXR5KHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS51cGRhdGVDb3JlID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVDb3JlLmNhbGwodGhpcywgYWN0aXZpdHkpO1xyXG4gICAgICAgIHRoaXMuX2FjdFR5cGUgPSBhY3Rpdml0eS5fYWN0VHlwZTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gYWN0aXZpdHkuX2NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gYWN0aXZpdHkuX3N0YXR1cztcclxuICAgICAgICB0aGlzLl9vd25lcklkID0gYWN0aXZpdHkuX293bmVySWQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5O1xyXG59KGFjdGl2aXR5RW50aXR5XzFbJ2RlZmF1bHQnXSkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHNbJ2RlZmF1bHQnXT0gQWN0aXZpdHk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGl2aXR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgQWN0aXZpdHlFbnRpdHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlFbnRpdHkoaWQpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLCBcImlkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLm9uVXBkYXRlZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUVudGl0eS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyLl9pZCAhPSB0aGlzLl9pZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbiBub3QgdXBkYXRlIGZyb20gZW50aXR5IHdpdGggZGlmZmVyZW50IGlkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVDb3JlKG90aGVyKTtcclxuICAgICAgICB0aGlzLm5vdGlmeSgpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5RW50aXR5LnByb3RvdHlwZS51cGRhdGVDb3JlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMubGlzdGVuZXJzW2luZGV4XTtcclxuICAgICAgICAgICAgbGlzdGVuZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eUVudGl0eTtcclxufSgpKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5RW50aXR5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eUVudGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFjdGl2aXR5RW50aXR5XzEgPSByZXF1aXJlKFwiLi9hY3Rpdml0eUVudGl0eVwiKTtcclxudmFyIEFjdGl2aXR5VHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWN0aXZpdHlUeXBlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlUeXBlKG5hbWUsIG93bmVyV2luZG93LCBoZWxwZXJXaW5kb3dzLCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICAgICAgdGhpcy5fb3duZXJXaW5kb3cgPSBvd25lcldpbmRvdztcclxuICAgICAgICB0aGlzLl9oZWxwZXJXaW5kb3dzID0gaGVscGVyV2luZG93cyB8fCBbXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVR5cGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVR5cGUucHJvdG90eXBlLCBcImRlc2NyaXB0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2NyaXB0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5VHlwZS5wcm90b3R5cGUsIFwiaGVscGVyV2luZG93c1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWxwZXJXaW5kb3dzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5VHlwZS5wcm90b3R5cGUsIFwib3duZXJXaW5kb3dcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3duZXJXaW5kb3c7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eVR5cGUucHJvdG90eXBlLnN1YnNjcmliZUFjdGl2aXR5U3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5VHlwZS5wcm90b3R5cGUuaW5pdGlhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmluaXRpYXRlKHRoaXMuX25hbWUsIGNvbnRleHQsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eVR5cGUucHJvdG90eXBlLnVwZGF0ZUNvcmUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlQ29yZS5jYWxsKHRoaXMsIHR5cGUpO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gdHlwZS5fZGVzY3JpcHRpb247XHJcbiAgICAgICAgdGhpcy5fb3duZXJXaW5kb3cgPSB0eXBlLl9vd25lcldpbmRvdztcclxuICAgICAgICB0aGlzLl9oZWxwZXJXaW5kb3dzID0gdHlwZS5faGVscGVyV2luZG93cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWN0aXZpdHlUeXBlO1xyXG59KGFjdGl2aXR5RW50aXR5XzFbJ2RlZmF1bHQnXSkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHNbJ2RlZmF1bHQnXT0gQWN0aXZpdHlUeXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eVR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhY3Rpdml0eUVudGl0eV8xID0gcmVxdWlyZShcIi4vYWN0aXZpdHlFbnRpdHlcIik7XHJcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2xvZ2dlclwiKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgQWN0aXZpdHlXaW5kb3cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFjdGl2aXR5V2luZG93LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlXaW5kb3coaWQsIG5hbWUsIHR5cGUsIGFjdGl2aXR5SWQsIGluc3RhbmNlLCBpc0luZGVwZW5kZW50KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaWQpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlci5HZXQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlJZCA9IGFjdGl2aXR5SWQ7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICB0aGlzLl9pc0luZGVwZW5kZW50ID0gaXNJbmRlcGVuZGVudDtcclxuICAgIH1cclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRXaW5kb3dCb3VuZHModGhpcy5pZCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLCBcImlzSW5kZXBlbmRlbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNJbmRlcGVuZGVudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUsIFwidHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93VHlwZSh0aGlzLl90eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJhY3Rpdml0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHRoaXMuX2FjdGl2aXR5SWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0QWN0aXZpdHlCeUlkKHRoaXMuX2FjdGl2aXR5SWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJpc093bmVyXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFjdCA9IHRoaXMuYWN0aXZpdHk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWN0Lm93bmVyLmlkID09PSB0aGlzLmlkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoaXNWaXNpYmxlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuc2V0V2luZG93VmlzaWJpbGl0eSh0aGlzLmlkLCBpc1Zpc2libGUpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChmb2N1cykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuYWN0aXZhdGVXaW5kb3codGhpcy5pZCwgZm9jdXMpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uICh0aXRsZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5zZXRCb3VuZHMgPSBmdW5jdGlvbiAoYm91bmRzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuc2V0V2luZG93Qm91bmRzKHRoaXMuaWQsIGJvdW5kcywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmNsb3NlV2luZG93KHRoaXMuaWQpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUsIFwiaW5zdGFuY2VcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUub25BY3Rpdml0eUpvaW5lZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZUZvckFjdGl2aXR5V2luZG93RXZlbnQoXCJqb2luZWRcIiwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5vbkFjdGl2aXR5UmVtb3ZlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZUZvckFjdGl2aXR5V2luZG93RXZlbnQoXCJyZW1vdmVkXCIsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUudXBkYXRlQ29yZSA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5SWQgPSBvdGhlci5fYWN0aXZpdHlJZDtcclxuICAgICAgICB0aGlzLl9pc0luZGVwZW5kZW50ID0gb3RoZXIuX2lzSW5kZXBlbmRlbnQ7XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG90aGVyLl9pbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBvdGhlci5faW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5fc3Vic2NyaWJlRm9yQWN0aXZpdHlXaW5kb3dFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc3Vic2NyaWJlV2luZG93RXZlbnRzKGZ1bmN0aW9uIChhY3Rpdml0eSwgd2luZG93LCBldmVudCkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmlkICE9PSBfdGhpcy5pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhhY3Rpdml0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWN0aXZpdHlXaW5kb3c7XHJcbn0oYWN0aXZpdHlFbnRpdHlfMVsnZGVmYXVsdCddKSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0c1snZGVmYXVsdCddPSBBY3Rpdml0eVdpbmRvdztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlXaW5kb3cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhY3Rpdml0eUVudGl0eV8xID0gcmVxdWlyZShcIi4vYWN0aXZpdHlFbnRpdHlcIik7XHJcbnZhciBXaW5kb3dUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhXaW5kb3dUeXBlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gV2luZG93VHlwZShuYW1lLCBmYWN0b3JpZXMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLl9mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2luZG93VHlwZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpbmRvd1R5cGUucHJvdG90eXBlLCBcImZhY3Rvcmllc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWN0b3JpZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2luZG93VHlwZS5wcm90b3R5cGUsIFwid2luZG93c1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93cyh7IHR5cGU6IHRoaXMuX25hbWUgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBXaW5kb3dUeXBlLnByb3RvdHlwZS5yZWdpc3RlckZhY3RvcnkgPSBmdW5jdGlvbiAoZmFjdG9yeSwgZmFjdG9yeU1ldGhvZCwgZGVzY3JpcHRpb24sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5yZWdpc3RlcldpbmRvd0ZhY3RvcnkodGhpcywgZmFjdG9yeU1ldGhvZCwgZGVzY3JpcHRpb24pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBXaW5kb3dUeXBlO1xyXG59KGFjdGl2aXR5RW50aXR5XzFbJ2RlZmF1bHQnXSkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHNbJ2RlZmF1bHQnXT0gV2luZG93VHlwZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93VHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIGVudGl0eUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vY29udHJhY3RzL2VudGl0eUV2ZW50XCIpO1xyXG52YXIgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ocHJvY2Vzc05ldykge1xyXG4gICAgICAgIHRoaXMuX2l0ZW1zID0ge307XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc05ldyA9IHByb2Nlc3NOZXc7XHJcbiAgICB9XHJcbiAgICBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkT25lID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLmFkZChbaXRlbV0pO1xyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaXRlbXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaXRlbXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gaXRlbXNbaW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3MobmV3IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnQoZWxlbWVudCwgbmV3IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRDb250ZXh0KGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFkZGVkKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gZXZlbnQuY29udGV4dDtcclxuICAgICAgICB2YXIgdHlwZSA9IGNvbnRleHQudHlwZTtcclxuICAgICAgICB2YXIgZW50aXR5ID0gZXZlbnQuZW50aXR5O1xyXG4gICAgICAgIHZhciBpbnRlcm5hbEVudGl0eSA9IHRoaXMuX3VwZGF0ZUludGVybmFsQ29sbGVjdGlvbnMoZW50aXR5LCB0eXBlKTtcclxuICAgICAgICB0aGlzLl9ub3RpZnlMaXN0ZW5lcnMoaW50ZXJuYWxFbnRpdHksIGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9pdGVtcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXRlbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9pdGVtc1trZXldO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0QnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5faXRlbXMpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0T3JXYWl0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5QWRkZWRIYW5kbGVyID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudGl0eS5pZCAhPT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnVuc3Vic2NyaWJlKGVudGl0eUFkZGVkSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZShlbnRpdHlBZGRlZEhhbmRsZXIpO1xyXG4gICAgICAgICAgICB2YXIgd2luZG93ID0gX3RoaXMuZ2V0QnlOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAod2luZG93KSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5faXRlbXMpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9pdGVtc1trZXldO1xyXG4gICAgICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIG5ldyBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50Q29udGV4dChlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5BZGRlZC50b1N0cmluZygpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YoaGFuZGxlcik7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbi5wcm90b3R5cGUuX25vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uIChlbnRpdHksIGNvbnRleHQpIHtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9saXN0ZW5lcnNbaW5kZXhdO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZW50aXR5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlSW50ZXJuYWxDb2xsZWN0aW9ucyA9IGZ1bmN0aW9uIChlbnRpdHksIHR5cGUpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudFR5cGUuUmVtb3ZlZCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faXRlbXNbZW50aXR5LmlkXTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc05ldyhlbnRpdHkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZW50aXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGVudGl0eS5pZDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzTmV3KGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtc1tlbnRpdHkuaWRdID0gZW50aXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXNbZW50aXR5LmlkXS51cGRhdGUoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbZW50aXR5LmlkXTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24gPSBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcclxudmFyIExvZ0xldmVsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvZ0xldmVsKCkge1xyXG4gICAgfVxyXG4gICAgTG9nTGV2ZWwuVHJhY2UgPSBcInRyYWNlXCI7XHJcbiAgICBMb2dMZXZlbC5EZWJ1ZyA9IFwiZGVidWdcIjtcclxuICAgIExvZ0xldmVsLkluZm8gPSBcImluZm9cIjtcclxuICAgIExvZ0xldmVsLldhcm4gPSBcIndhcm5cIjtcclxuICAgIExvZ0xldmVsLkVycm9yID0gXCJlcnJvclwiO1xyXG4gICAgcmV0dXJuIExvZ0xldmVsO1xyXG59KCkpO1xyXG5leHBvcnRzLkxvZ0xldmVsID0gTG9nTGV2ZWw7XHJcbnZhciBMb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUpIHtcclxuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwoTG9nZ2VyLkdsdWVMb2dnZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsdWVMb2dnZXIgPSBMb2dnZXIuR2x1ZUxvZ2dlci5zdWJMb2dnZXIobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgTG9nZ2VyLkdldE5hbWVkID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcihuYW1lKTtcclxuICAgIH07XHJcbiAgICBMb2dnZXIuR2V0ID0gZnVuY3Rpb24gKG93bmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIoTG9nZ2VyLkdldFR5cGVOYW1lKG93bmVyKSk7XHJcbiAgICB9O1xyXG4gICAgTG9nZ2VyLnByb3RvdHlwZS50cmFjZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuX2dsdWVMb2dnZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsdWVMb2dnZXIudHJhY2UobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoTG9nZ2VyLkxldmVsID09PSBMb2dMZXZlbC5UcmFjZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKHRoaXMuX2dldE1lc3NhZ2UobWVzc2FnZSwgTG9nTGV2ZWwuVHJhY2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fZ2x1ZUxvZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2x1ZUxvZ2dlci5kZWJ1ZyhtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLkRlYnVnIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLlRyYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8odGhpcy5fZ2V0TWVzc2FnZShtZXNzYWdlLCBMb2dMZXZlbC5EZWJ1ZykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuX2dsdWVMb2dnZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsdWVMb2dnZXIuaW5mbyhtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLkRlYnVnIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLlRyYWNlIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLkluZm8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyh0aGlzLl9nZXRNZXNzYWdlKG1lc3NhZ2UsIExvZ0xldmVsLkluZm8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLl9nbHVlTG9nZ2VyKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbHVlTG9nZ2VyLndhcm4obWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoTG9nZ2VyLkxldmVsID09PSBMb2dMZXZlbC5EZWJ1ZyB8fFxyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLkxldmVsID09PSBMb2dMZXZlbC5UcmFjZSB8fFxyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLkxldmVsID09PSBMb2dMZXZlbC5JbmZvIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLldhcm4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyh0aGlzLl9nZXRNZXNzYWdlKG1lc3NhZ2UsIExvZ0xldmVsLkluZm8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMb2dnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fZ2x1ZUxvZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2x1ZUxvZ2dlci5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5fZ2V0TWVzc2FnZShtZXNzYWdlLCBMb2dMZXZlbC5FcnJvcikpO1xyXG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dlci5wcm90b3R5cGUuX2dldE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgbGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBsZXZlbCArIFwiXSBcIiArIHRoaXMuX25hbWUgKyBcIiAtIFwiICsgbWVzc2FnZTtcclxuICAgIH07XHJcbiAgICBMb2dnZXIuR2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIGZ1bmNOYW1lUmVnZXggPSAvZnVuY3Rpb24gKC57MSx9KVxcKC87XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSAoZnVuY05hbWVSZWdleCkuZXhlYyhvYmplY3QuY29uc3RydWN0b3IudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSkgPyByZXN1bHRzWzFdIDogXCJcIjtcclxuICAgIH07XHJcbiAgICBMb2dnZXIuTGV2ZWwgPSBMb2dMZXZlbC5JbmZvO1xyXG4gICAgcmV0dXJuIExvZ2dlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgbmV4dFRpY2sgPSBmdW5jdGlvbiAoY2IpIHsgc2V0VGltZW91dChjYiwgMCk7IH07XHJcbmZ1bmN0aW9uIG5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spIHtcclxuICAgIGlmICghdXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XHJcbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLm5vZGVpZnkgPSBub2RlaWZ5O1xyXG47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2VFeHRlbnNpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIFJlYWR5TWFya2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlYWR5TWFya2VyKG5hbWUsIHNpZ25hbHNUb1dhaXQpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXJfMS5Mb2dnZXIuR2V0TmFtZWQoXCJSZWFkeU1hcmtlciBbXCIgKyBuYW1lICsgXCJdXCIpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIkluaXRpYWxpemluZyByZWFkeSBtYXJrZXIgZm9yICdcIiArIG5hbWUgKyBcIicgd2l0aCBcIiArIHNpZ25hbHNUb1dhaXQgKyBcIiBzaWduYWxzIHRvIHdhaXRcIik7XHJcbiAgICAgICAgaWYgKHNpZ25hbHNUb1dhaXQgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hbCBudW1iZXIuIFNob3VsZCBiZSA+IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NpZ25hbHMgPSBzaWduYWxzVG9XYWl0O1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgfVxyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLnNldENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTZXQoKSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNFcnJvcigpKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuX2Vycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiU2lnbmFsZWQgLSBcIiArIG1lc3NhZ2UgKyBcIiAtIHNpZ25hbHMgbGVmdCBcIiArICh0aGlzLl9zaWduYWxzIC0gMSkpO1xyXG4gICAgICAgIHRoaXMuX3NpZ25hbHMtLTtcclxuICAgICAgICBpZiAodGhpcy5fc2lnbmFscyA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gcmVhZHkgbWFya2VyICdcIiArIHRoaXMuX25hbWUgKyBcIiAtIHNpZ25hbHMgYXJlIFwiICsgdGhpcy5fc2lnbmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzU2V0KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSZWFkeU1hcmtlci5wcm90b3R5cGUuaXNTZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFcnJvcigpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbHMgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF1dGlsLmlzVW5kZWZpbmVkKHRoaXMuX2Vycm9yKTtcclxuICAgIH07XHJcbiAgICBSZWFkeU1hcmtlci5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWFkeU1hcmtlcjtcclxufSgpKTtcclxuZXhwb3J0cy5SZWFkeU1hcmtlciA9IFJlYWR5TWFya2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkeU1hcmtlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XHJcbn1cclxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xyXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcclxufVxyXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcclxufVxyXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XHJcbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG59XHJcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XHJcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xyXG59XHJcbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcclxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwoYXJnKSB7XHJcbiAgICByZXR1cm4gIWFyZyB8fCB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcclxufVxyXG5leHBvcnRzLmlzVW5kZWZpbmVkT3JOdWxsID0gaXNVbmRlZmluZWRPck51bGw7XHJcbmZ1bmN0aW9uIGlzRW1wdHkoYXJnKSB7XHJcbiAgICBmb3IgKHZhciBwcm9wIGluIGFyZykge1xyXG4gICAgICAgIGlmIChhcmcuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XHJcbiAgICByZXR1cm4gISEoYXJnICYmIGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY2FsbCAmJiBhcmcuYXBwbHkpO1xyXG59XHJcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XHJcbjtcclxuZnVuY3Rpb24gc29tZShhcnJheSwgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5zb21lID0gc29tZTtcclxuZnVuY3Rpb24gZmlyc3QoYXJyYXksIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmV4cG9ydHMuZmlyc3QgPSBmaXJzdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJ2YXIgY29ubmVjdGlvbiA9IHJlcXVpcmUoJ3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24nKTtcbnZhciBjbGllbnQgPSByZXF1aXJlKCcuL2FnbV9jbGllbnQnKTtcbnZhciBzZXJ2ZXIgPSByZXF1aXJlKCcuL2FnbV9zZXJ2ZXInKTtcbnZhciBpbnN0YW5jZSA9IHJlcXVpcmUoJy4vYWdtX2luc3RhbmNlJyk7XG52YXIgbmF0aXZlQWdtID0gcmVxdWlyZSgnLi9hZ21fbmF0aXZlJyk7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKTtcbnZhciBwanNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuLy8gdmFyIGFkZF9zdWdhcj0gcmVxdWlyZShcIi4vYWdtX3N1Z2FyXCIpO1xuLy8gSW5pdCBuYW1lc3BhY2UgaWYgbm90IGFscmVhZHkgdGhlcmVcblxuLy8gQWRkIGEgZ2xvYmFsIGZ1bmN0aW9uIHRoYXQgbWFrZXMgYW4gQUdNIGluc3RhbmNlXG5hZ20gPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIFdlIHdpbGwgc3RvcmUgdGhlIGxpYnJhcnkgaGVyZVxuICAgIHZhciBhZ20gPSB7fTtcblxuICAgIGFnbS52ZXJzaW9uID0gcGpzb24udmVyc2lvbjtcblxuICAgIC8vIEluaXQgZGVidWdcbiAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBJbml0IGNoaWxkIGNvbmZpZ3VyYXRpb24gaWYgaXQgaXMgbm90IGFscmVhZHkgcGFzc2VkIGJ5IHVzZXJcbiAgICB2YXIgY2hpbGRDb25maWd1cmF0aW9ucyA9IFsnY29ubmVjdGlvbicsICdjbGllbnQnLCAnc2VydmVyJ107XG4gICAgY2hpbGRDb25maWd1cmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb25mKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbltjb25mXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25bY29uZl0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgZGVidWcgaWYgZ2xvYmFsIGRlYnVnIGlzIG5vdCBzZXQ6XG4gICAgICAgIGlmIChjb25maWd1cmF0aW9uLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uW2NvbmZdLmRlYnVnID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdCBjb25uZWN0aW9uXG4gICAgdmFyIGMgPSBjb25maWd1cmF0aW9uLmNvbm5lY3Rpb247XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHdlIGFyZSBnaXZlbiBhIGNvbm5lY3Rpb24gb2JqZWN0LiBJZiBub3QsIGNyZWF0ZSBpdCBvdXJzZWx2ZXM6XG4gICAgYWdtLmNvbm5lY3Rpb24gPSAodHlwZW9mIGMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjLnNlbmQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGMub24gPT09ICdmdW5jdGlvbicpID8gYyA6IGNvbm5lY3Rpb24oY29uZmlndXJhdGlvbi5jb25uZWN0aW9uKTtcblxuICAgIC8vIENyZWF0ZSBhIGNvbm5lY3Rpb24gcHJveHkgd2hpY2ggc2V0cyB0aGUgcHJvZHVjdCBuYW1lIGF1dG9tYXRpY2FsbHlcbiAgICB2YXIgcHJvZHVjdE5hbWUgPSAnYWdtJztcbiAgICB2YXIgYWdtRW5hYmxlZENvbm5lY3Rpb24gPSB7XG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBhZ20uY29ubmVjdGlvbi5zZW5kKHByb2R1Y3ROYW1lLCB0eXBlLCBtZXNzYWdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbjogZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGFnbS5jb25uZWN0aW9uLm9uKHByb2R1Y3ROYW1lLCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgc3lzdGVtIG9iamVjdCB0aGF0IHdlIGFyZSBnaXZlblxuICAgIHZhciBtZXRyaWNzUm9vdCA9IGNvbmZpZ3VyYXRpb24ubWV0cmljcztcblxuICAgIC8vIENyZWF0ZSBzdWJzeXN0ZW1zIGZvciBvdXIgbW9kdWxlcyBhbmQgc2F2ZSB0aGVtIGluIHRoZWlyIGNvbmZpZ3VyYXRpb24uXG4gICAgaWYgKG1ldHJpY3NSb290ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5jbGllbnQubWV0cmljcyA9IG1ldHJpY3NSb290LnN1YlN5c3RlbSgnQ2xpZW50Jyk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uc2VydmVyLm1ldHJpY3MgPSBtZXRyaWNzUm9vdC5zdWJTeXN0ZW0oJ1NlcnZlcicpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgb3VyIG1vZHVsZXNcbiAgICBhZ20uaW5zdGFuY2UgPSBpbnN0YW5jZShjb25maWd1cmF0aW9uLmluc3RhbmNlLCBhZ21FbmFibGVkQ29ubmVjdGlvbik7XG4gICAgYWdtLmNsaWVudCA9IGNsaWVudChhZ21FbmFibGVkQ29ubmVjdGlvbiwgYWdtLmluc3RhbmNlLCBjb25maWd1cmF0aW9uLmNsaWVudCk7XG4gICAgYWdtLnNlcnZlciA9IHNlcnZlcihhZ21FbmFibGVkQ29ubmVjdGlvbiwgYWdtLmluc3RhbmNlLCBjb25maWd1cmF0aW9uLnNlcnZlcik7XG5cbiAgICAvLyBBZGQgbWV0aG9kIGFsaWFzZXNcbiAgICBhZ20uaW52b2tlID0gYWdtLmNsaWVudC5pbnZva2U7XG4gICAgYWdtLnJlZ2lzdGVyID0gYWdtLnNlcnZlci5yZWdpc3RlcjtcbiAgICBhZ20ucmVnaXN0ZXJBc3luYyA9IGFnbS5zZXJ2ZXIucmVnaXN0ZXJBc3luYztcbiAgICBhZ20udW5yZWdpc3RlciA9IGFnbS5zZXJ2ZXIudW5yZWdpc3RlcjtcbiAgICBhZ20uY3JlYXRlU3RyZWFtID0gYWdtLnNlcnZlci5jcmVhdGVTdHJlYW07XG4gICAgYWdtLnN1YnNjcmliZSA9IGFnbS5jbGllbnQuc3Vic2NyaWJlO1xuICAgIGFnbS5zZXJ2ZXJzID0gYWdtLmNsaWVudC5zZXJ2ZXJzO1xuICAgIGFnbS5tZXRob2RzID0gYWdtLmNsaWVudC5tZXRob2RzO1xuICAgIGFnbS5tZXRob2RzX2Zvcl9pbnN0YW5jZSA9IGRlcHJlY2F0ZShhZ20uY2xpZW50Lm1ldGhvZHNfZm9yX2luc3RhbmNlLCAnZ2x1ZS5hZ20uY2xpZW50Lm1ldGhvZHNfZm9yX2luc3RhbmNlKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgZ2x1ZS5hZ20uY2xpZW50Lm1ldGhvZHNGb3JJbnN0YW5jZSgpIGluc3RlYWQnKTtcbiAgICBhZ20ubWV0aG9kc0Zvckluc3RhbmNlID0gYWdtLmNsaWVudC5tZXRob2RzX2Zvcl9pbnN0YW5jZTtcbiAgICBhZ20ubWV0aG9kID0gYWdtLmNsaWVudC5tZXRob2Q7XG4gICAgYWdtLm1ldGhvZF9hZGRlZCA9IGRlcHJlY2F0ZShhZ20uY2xpZW50Lm1ldGhvZF9hZGRlZCwgJ2dsdWUuYWdtLm1ldGhvZF9hZGRlZCgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGdsdWUuYWdtLm1ldGhvZEFkZGVkKCkgaW5zdGVhZCcpO1xuICAgIGFnbS5tZXRob2RBZGRlZCA9IGFnbS5jbGllbnQubWV0aG9kX2FkZGVkO1xuICAgIGFnbS5tZXRob2RfcmVtb3ZlZCA9IGRlcHJlY2F0ZShhZ20uY2xpZW50Lm1ldGhvZF9yZW1vdmVkLCAnZ2x1ZS5hZ20ubWV0aG9kX3JlbW92ZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBnbHVlLmFnbS5tZXRob2RSZW1vdmVkKCkgaW5zdGVhZCcpO1xuICAgIGFnbS5tZXRob2RSZW1vdmVkID0gYWdtLmNsaWVudC5tZXRob2RfcmVtb3ZlZDtcblxuICAgIGFnbS5zZXJ2ZXJfbWV0aG9kX2FkZGVkID0gZGVwcmVjYXRlKGFnbS5jbGllbnQuc2VydmVyX21ldGhvZF9hZGRlZCwgJ2dsdWUuYWdtLnNlcnZlcl9tZXRob2RfYWRkZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBnbHVlLmFnbS5zZXJ2ZXJNZXRob2RBZGRlZCgpIGluc3RlYWQnKTtcbiAgICBhZ20uc2VydmVyTWV0aG9kQWRkZWQgPSBhZ20uY2xpZW50LnNlcnZlcl9tZXRob2RfYWRkZWQ7XG4gICAgYWdtLnNlcnZlcl9tZXRob2RfcmVtb3ZlZCA9IGRlcHJlY2F0ZShhZ20uY2xpZW50LnNlcnZlcl9tZXRob2RfcmVtb3ZlZCwgJ2dsdWUuYWdtLnNlcnZlcl9tZXRob2RfcmVtb3ZlZCgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGdsdWUuYWdtLnNlcnZlck1ldGhvZFJlbW92ZWQoKSBpbnN0ZWFkJyk7XG4gICAgYWdtLnNlcnZlck1ldGhvZFJlbW92ZWQgPSBhZ20uY2xpZW50LnNlcnZlcl9tZXRob2RfcmVtb3ZlZDtcblxuICAgIGFnbS5zZXJ2ZXJfYWRkZWQgPSBkZXByZWNhdGUoYWdtLmNsaWVudC5zZXJ2ZXJfYWRkZWQsICdnbHVlLmFnbS5zZXJ2ZXJfYWRkZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBnbHVlLmFnbS5zZXJ2ZXJBZGRlZCgpIGluc3RlYWQnKTtcbiAgICBhZ20uc2VydmVyQWRkZWQgPSBhZ20uY2xpZW50LnNlcnZlcl9hZGRlZDtcbiAgICBhZ20uc2VydmVyX3JlbW92ZWQgPSBkZXByZWNhdGUoYWdtLmNsaWVudC5zZXJ2ZXJfcmVtb3ZlZCwgJ2dsdWUuYWdtLnNlcnZlcl9yZW1vdmVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgZ2x1ZS5hZ20uc2VydmVyUmVtb3ZlZCgpIGluc3RlYWQnKTtcbiAgICBhZ20uc2VydmVyUmVtb3ZlZCA9IGFnbS5jbGllbnQuc2VydmVyX3JlbW92ZWQ7XG5cbiAgICBhZ20uc3RhcnQgPSBhZ20uc2VydmVyLnN0YXJ0O1xuICAgIGFnbS5zdG9wID0gYWdtLnNlcnZlci5zdG9wO1xuXG4gICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgYWdtLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBR00gc3RhcnRlZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWdtO1xuICAgIC8vIHJldHVybiBhZGRfc3VnYXIoYWdtKTtcblxufTtcblxuYWdtID0gZ2xvYmFsLmh0bWxDb250YWluZXIgIT09IHVuZGVmaW5lZCA/IG5hdGl2ZUFnbSA6IGFnbTtcblxuLy8gRXhwb3J0IGZvciBicm93c2Vyc1xuaWYgKGdsb2JhbC50aWNrNDIgPT09IHVuZGVmaW5lZCkge1xuICAgIGdsb2JhbC50aWNrNDIgPSB7fTtcbn1cblxuZ2xvYmFsLnRpY2s0Mi5hZ20gPSBhZ207XG5cbm1vZHVsZS5leHBvcnRzID0gYWdtO1xuXG4iLCIvKlxuIFRoZSBBR00gQ2xpZW50IGFuYWx5c2VzIHNlcnZlciBwcmVzZW5jZXMsIGNvbGxlY3RzIGluZm9ybWF0aW9uIGFib3V0IHRoZWlyIG1ldGhvZHMgYW5kIGFsbG93cyB1c2VycyB0byBpbnZva2UgdGhlc2UgbWV0aG9kcy5cbiAqL1xudmFyIGNsaWVudFNlcnZlcnN0YXRlID0gcmVxdWlyZSgnLi9hZ21fY2xpZW50X3NlcnZlcnN0YXRlJyk7XG52YXIgY2xpZW50SW52b2NhdGlvbnNzdGF0ZSA9IHJlcXVpcmUoJy4vYWdtX2NsaWVudF9pbnZvY2F0aW9uc3N0YXRlJyk7XG52YXIgY2xpZW50U3Vic2NyaXB0aW9uc3RhdGUgPSByZXF1aXJlKCcuL2FnbV9jbGllbnRfc3Vic2NyaXB0aW9uc3RhdGUnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9hZ21faGVscGVycycpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGluc3RhbmNlLCBjb25maWd1cmF0aW9uKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFZhbGlkYXRlIGNvbmZpZ3VyYXRpb25cbiAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGFuIEFHTSBjbGllbnQgd2l0aCBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24ucmVtb3ZlX3NlcnZlcl9vbl9uX21pc3NpbmdfaGVhcnRiZWF0cyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5yZW1vdmVfc2VydmVyX29uX25fbWlzc2luZ19oZWFydGJlYXRzID0gMztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24ubWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24ubWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXQgPSAzMDAwO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbi53YWl0X2Zvcl9tZXRob2RfdGltZW91dCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi53YWl0X2Zvcl9tZXRob2RfdGltZW91dCA9IDMwMDA7XG4gICAgfVxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBtb2R1bGUgd2hpY2gga2VlcHMgdHJhY2sgb2YgYWxsIGF2YWlsYWJsZSBzZXJ2ZXJzIGFuZCBtZXRob2RzXG4gICAgdmFyIHNlcnZlcnMgPSBjbGllbnRTZXJ2ZXJzdGF0ZShjb25maWd1cmF0aW9uLCBpbnN0YW5jZSk7XG4gICAgLy8gLi5hbmQgd2hlbiB5b3UgcmVjZWl2ZSBhIGhlYXJ0YmVhdC9wcmVzZW5jZSBmcm9tIGEgc2VydmVyLCBkZWxlZ2F0ZSBpdHMgcHJvY2Vzc2luZyB0byB0aGUgbW9kdWxlOlxuICAgIGNvbm5lY3Rpb24ub24oJ1NlcnZlclByZXNlbmNlTWVzc2FnZScsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgc2VydmVycy5wcm9jZXNzX3ByZXNlbmNlKG1zZywgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBjb25uZWN0aW9uLm9uKCdTZXJ2ZXJIZWFydGJlYXRNZXNzYWdlJywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBzZXJ2ZXJzLnByb2Nlc3NfcHJlc2VuY2UobXNnLCBmYWxzZSk7XG4gICAgfSk7XG4gICAgLy8gSW5zdGFudGlhdGUgdGhlIG1vZHVsZSB0aGF0IGhhbmRsZXMgbWV0aG9kIGV4ZWN1dGlvbiBhbmQgcmVzcG9uc2VzXG4gICAgdmFyIHJlc3BvbnNlID0gY2xpZW50SW52b2NhdGlvbnNzdGF0ZShcbiAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5zZW5kKCdNZXRob2RJbnZvY2F0aW9uUmVxdWVzdE1lc3NhZ2UnLCBtKTtcbiAgICAgIH0pO1xuICAgIC8vIC4uYW5kIGluc3RhbnRpYXRlIHRoZSBtb2R1bGUgdGhhdCBoYW5kbGVzIHN1YnNjcmlwdGlvbiB0byBTdHJlYW1pbmcgbWV0aG9kc1xuICAgIHZhciBzdWJTdGF0ZSA9IGNsaWVudFN1YnNjcmlwdGlvbnN0YXRlKFxuICAgICAgY29uZmlndXJhdGlvbixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICBjb25uZWN0aW9uLnNlbmQoJ01ldGhvZEludm9jYXRpb25SZXF1ZXN0TWVzc2FnZScsIG0pO1xuICAgICAgfSk7XG4gICAgLy8gLi5hbmQgZGVsZWdhdGUgcmVzcG9uc2VzIHRvIHRoZW0uXG4gICAgY29ubmVjdGlvbi5vbignTWV0aG9kSW52b2NhdGlvblJlc3VsdE1lc3NhZ2UnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmIChtc2cgJiYgbXNnLkV2ZW50U3RyZWFtQWN0aW9uICYmIG1zZy5FdmVudFN0cmVhbUFjdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgc3ViU3RhdGUucHJvY2Vzc1B1Ymxpc2hlck1zZyhtc2cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UucHJvY2Vzc19tZXRob2RfcmVzcG9uc2UobXNnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gICAvL0FkZHMgY2xpZW50IGNhbGxiYWNrcyB3aGljaCBhcmUgZXhlY3V0ZWQgd2hlbiBhIG5ldyBtZXRob2QgaXMgYWRkZWQgb3Igc3RvcHMgYmVpbmcgYXZhaWxhYmxlXG4gICAgLy8gICBmdW5jdGlvbiBtZXRob2RfYWRkZWQoY2FsbGJhY2spIHtcbiAgICAvLyAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgICAgIC8vQWRkIHRoZSBjYWxsYmFja1xuICAgIC8vICAgICAgIGNvbmZpZ3VyYXRpb24ub25fbWV0aG9kX2FkZGVkID0gY2FsbGJhY2s7XG4gICAgLy8gICAgICAgLy9DYWxsIHRoZSBjYWxsYmFjayBmb3IgYWxsIHRoZSBtZXRob2Qgd2hpY2ggd2VyZSBhZGRlZCBiZWZvcmUgdGhlIGNhbGxiYWNrIHdhcyByZWdpc3RlcmVkLlxuICAgIC8vICAgICAgIHNlcnZlcnMuZ2V0X21ldGhvZHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAvLyAgICAgICAgIGNhbGxiYWNrKG1ldGhvZCk7XG4gICAgLy8gICAgICAgfSk7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgdGhyb3cgJ1xcJ21ldGhvZF9hZGRlZFxcJyBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgZnVuY3Rpb24gYXMgYW4gYXJndW1lbnQnO1xuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy8gICBmdW5jdGlvbiBtZXRob2RfcmVtb3ZlZChjYWxsYmFjaykge1xuICAgIC8vICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgICAgLy9BZGQgdGhlIGNhbGxiYWNrXG4gICAgLy8gICAgICAgY29uZmlndXJhdGlvbi5vbl9tZXRob2RfcmVtb3ZlZCA9IGNhbGxiYWNrO1xuICAgIC8vICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgIHRocm93ICdcXCdtZXRob2RfcmVtb3ZlZFxcJyBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgZnVuY3Rpb24gYXMgYW4gYXJndW1lbnQnO1xuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG5cbiAgICAvLyAgIC8vQWRkcyBjbGllbnQgY2FsbGJhY2tzIHdoaWNoIGFyZSBleGVjdXRlZCB3aGVuIGEgbmV3IG1ldGhvZCBpcyBhZGRlZCBvciBzdG9wcyBiZWluZyBhdmFpbGFibGVcbiAgICAvLyAgIGZ1bmN0aW9uIHNlcnZlcl9hZGRlZChjYWxsYmFjaykge1xuICAgIC8vICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgICAgLy9BZGQgdGhlIGNhbGxiYWNrXG4gICAgLy8gICAgICAgY29uZmlndXJhdGlvbi5vbl9zZXJ2ZXJfYWRkZWQgPSBjYWxsYmFjaztcbiAgICAvLyAgICAgICAvL0NhbGwgdGhlIGNhbGxiYWNrIGZvciBhbGwgdGhlIG1ldGhvZCB3aGljaCB3ZXJlIGFkZGVkIGJlZm9yZSB0aGUgY2FsbGJhY2sgd2FzIHJlZ2lzdGVyZWQuXG4gICAgLy8gICAgICAgc2VydmVycy5nZXRfc2VydmVycygpLmZvckVhY2goZnVuY3Rpb24gKHNlcnZlcikge1xuICAgIC8vICAgICAgICAgY2FsbGJhY2soc2VydmVyKTtcbiAgICAvLyAgICAgICB9KTtcbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICB0aHJvdyAnXFwnc2VydmVyX2FkZGVkXFwnIG11c3QgYmUgY2FsbGVkIHdpdGggYSBmdW5jdGlvbiBhcyBhbiBhcmd1bWVudCc7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyAgIGZ1bmN0aW9uIHNlcnZlcl9yZW1vdmVkKGNhbGxiYWNrKSB7XG4gICAgLy8gICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAgICAgICAvL0FkZCB0aGUgY2FsbGJhY2tcbiAgICAvLyAgICAgICBjb25maWd1cmF0aW9uLm9uX3NlcnZlcl9yZW1vdmVkID0gY2FsbGJhY2s7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgdGhyb3cgJ1xcJ3NlcnZlcl9yZW1vdmVkXFwnIG11c3QgYmUgY2FsbGVkIHdpdGggYSBmdW5jdGlvbiBhcyBhbiBhcmd1bWVudCc7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShuYW1lLCBvcHRpb25zLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgLy8gb3B0aW9ucyBjYW4gaGF2ZSBhcmd1bWVudHM6e30sIHRhcmdldDogJ2Jlc3QnLydhbGwnL3tzZXJ2ZXJfaW5zdGFuY2V9LCB3YWl0VGltZW91dE1zOjMwMDBcblxuICAgICAgICBmdW5jdGlvbiBjYWxsU3Vic3RhdGVTdWJzY3JpYmUodGFyZ2V0U2VydmVycywgbmFtZSwgb3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJz4+PiBTdWJzY3JpYmluZyB0byBcIicgKyBuYW1lICsgJ1wiIG9uICcgKyB0YXJnZXRTZXJ2ZXJzLmxlbmd0aCArICcgc2VydmVycycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJTdGF0ZS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgIHsgbmFtZTogbmFtZSB9LFxuICAgICAgICAgICAgICBvcHRpb25zLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdGFyZ2V0U2VydmVycyxcbiAgICAgICAgICAgICAgeyBtZXRob2RfcmVzcG9uc2VfdGltZW91dDogb3B0aW9ucy53YWl0VGltZW91dE1zIH0sXG4gICAgICAgICAgICAgIHN1Y2Nlc3NQcm94eSxcbiAgICAgICAgICAgICAgZXJyb3JQcm94eVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICB2YXIgc3VjY2Vzc1Byb3h5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGVycm9yUHJveHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgIHJlamVjdChhcmdzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9ICdiZXN0JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnICYmIHRhcmdldCAhPT0gJ2FsbCcgJiYgdGFyZ2V0ICE9PSAnYmVzdCcpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoeyBtZXNzYWdlOiAnXCInICsgdGFyZ2V0ICsgJ1wiIGlzIG5vdCBhIHZhbGlkIHRhcmdldC4gVmFsaWQgdGFyZ2V0cyBhcmUgXCJhbGxcIiwgXCJiZXN0XCIsIG9yIGFuIGluc3RhbmNlLicgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53YWl0VGltZW91dE1zICE9PSAnbnVtYmVyJyB8fCBvcHRpb25zLndhaXRUaW1lb3V0TXMgIT09IG9wdGlvbnMud2FpdFRpbWVvdXRNcyAvKiBOYU4gKi8pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLndhaXRUaW1lb3V0TXMgPSBjb25maWd1cmF0aW9uLndhaXRfZm9yX21ldGhvZF90aW1lb3V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudFNlcnZlcnMgPSBzZXJ2ZXJzRm9yTWV0aG9kQW5kVGFyZ2V0KG5hbWUsIHRhcmdldCk7XG5cbiAgICAgICAgICAgIC8vIC4uLmluY2x1ZGluZyB0aGUgTWV0aG9kUmVxdWVzdFN1YmplY3QgZm9yIHRoZSBzdHJlYW1pbmcgbWV0aG9kXG4gICAgICAgICAgICAvLyBkb24ndCBjaGVjayBpZiB0aGUgbWV0aG9kIGlzIHN0cmVhbWluZyBvciBub3QsIHN1YnNjcmliaW5nIHRvIG5vbi1zdHJlYW1pbmcgbWV0aG9kIGhhcyB0byBpbnZva2UgaXRcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF0ZVNlcnZlcnMgPSBzZXJ2ZXJzRm9yTWV0aG9kQW5kVGFyZ2V0KG5hbWUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNoYW5nZSB0byB1c2UgdGhlIG1ldGhvZEFkZGVkIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogc2V0IGFnbS5tZXRob2RBZGRlZCBhbmQgaWYod2FpdFRpbWVvdXQ+PTApe3NldFRpbWVvdXR9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxTdWJzdGF0ZVN1YnNjcmliZShsYXRlU2VydmVycywgbmFtZSwgb3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KTtcblxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMud2FpdFRpbWVvdXRNcyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbFN1YnN0YXRlU3Vic2NyaWJlKGN1cnJlbnRTZXJ2ZXJzLCBuYW1lLCBvcHRpb25zLCBzdWNjZXNzUHJveHksIGVycm9yUHJveHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaGVscGVycy5wcm9taXNpZnkocHJvbWlzZSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvLyBBYnN0cmFjdCBnZXRfbWV0aG9kIGFuZCBnZXRfc2VydmVycyBmdW5jdGlvbnNcbiAgICAvLyBUaGV5IHJlbHkgb24gIGdldF9tZXRob2QgYW5kIGdldF9zZXJ2ZXJzIGZyb20gdGhlIFwic2VydmVyc1wiIG1vZHVsZVxuICAgIC8vIEluIHRob3NlIG9uZXMgeW91IGRvbid0IG5lZWQgdG8gc3BlY2lmeSBhbGwgb2YgdGhlIG1ldGhvZCdzIHByb3BzIHRvIGZpbmQgaXQuXG4gICAgZnVuY3Rpb24gZ2V0TWV0aG9kKG1ldGhvZEZpbHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZEZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1ldGhvZEZpbHRlciA9IHsgbmFtZTogbWV0aG9kRmlsdGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGV4ZWN1dGUgZm9yIGVtcHR5IGZpbHRlclxuICAgICAgICBpZiAobWV0aG9kRmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleGFjdE1hdGNoID0gc2VydmVycy5nZXRfbWV0aG9kKG1ldGhvZEZpbHRlcik7XG4gICAgICAgIC8vIFRyeSBjYWxsaW5nIHRoZSBvcmlnaW5hbCBcImdldF9tZXRob2RcIiBmdW5jdGlvbiAoaXQgd2lsbCB3b3JrIGlmIGFsbCBtZXRob2QgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkKTpcbiAgICAgICAgaWYgKGV4YWN0TWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gVGFrZSBhbGwgYXZhaWxhYmxlIG1ldGhvZHMgYW5kIGl0ZXJhdGUgdGhlbSB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hcbiAgICAgICAgICAgIHJldHVybiBleGFjdE1hdGNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRha2VXaGlsZShzZXJ2ZXJzLmdldF9tZXRob2RzKCksIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kTWF0Y2gobWV0aG9kRmlsdGVyLCBtZXRob2QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNZXRob2RzKG1ldGhvZEZpbHRlcikge1xuICAgICAgICBpZiAobWV0aG9kRmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJzLmdldF9tZXRob2RzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZEZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1ldGhvZEZpbHRlciA9IHsgbmFtZTogbWV0aG9kRmlsdGVyIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VydmVycy5nZXRfbWV0aG9kcygpLmZpbHRlcihmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kTWF0Y2gobWV0aG9kRmlsdGVyLCBtZXRob2QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2ZXMgYWxsIHNlcnZlcnMgdGhhdCBzdXBwb3J0IGFueSBvZiBzZXZlcmFsIG1ldGhvZHMsIGxpc3RlZCBhcyBhbiBhcnJheVxuICAgIGZ1bmN0aW9uIGdldE1ldGhvZHNGb3JJbnN0YW5jZShpbnN0YW5jZUZpbHRlcikge1xuICAgICAgICB2YXIgZXhhY3RNYXRjaCA9IHNlcnZlcnMuZ2V0X21ldGhvZHMoaW5zdGFuY2VGaWx0ZXIpO1xuICAgICAgICAvLyBUcnkgY2FsbGluZyB0aGUgb3JpZ2luYWwgXCJnZXRfbWV0aG9kc1wiIGZ1bmN0aW9uIChpdCB3aWxsIHdvcmsgaWYgYWxsIGluc3RhbmNlIHByb3BlcnRpZXMgYXJlIHNwZWNpZmllZCk6XG4gICAgICAgIGlmIChleGFjdE1hdGNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4YWN0TWF0Y2g7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kSWRzID0gZ2V0U2VydmVycygpLmZpbHRlcihmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNl0JxhdGNoKGluc3RhbmNlRmlsdGVyLCBzZXJ2ZXIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChtZXRob2RzLCBzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVycy5nZXRfbWV0aG9kSWRzKHNlcnZlcikuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZHNbbWV0aG9kSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgICAgICAgICAgICAgfSwge30pO1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobWV0aG9kSWRzKS5tYXAoZnVuY3Rpb24gKG1ldGhvZElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcnZlcnMuZ2V0X21ldGhvZChtZXRob2RJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHJpZXZlcyBhbGwgc2VydmVycyB0aGF0IHN1cHBvcnQgYSBnaXZlbiBtZXRob2RcbiAgICBmdW5jdGlvbiBnZXRTZXJ2ZXJzKG1ldGhvZEZpbHRlcikge1xuICAgICAgICAvLyBObyBtZXRob2QgLSBnZXQgYWxsIHNlcnZlcnNcbiAgICAgICAgaWYgKG1ldGhvZEZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VydmVycy5nZXRfc2VydmVycygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vbi1leGlzdGluZyBtZXRob2QgLSByZXR1cm4gYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChtZXRob2RGaWx0ZXIpO1xuICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlLCByZXR1cm4gc2VydmVycyBmb3IgbWV0aG9kXG4gICAgICAgIHJldHVybiBzZXJ2ZXJzLmdldF9zZXJ2ZXJzKG1ldGhvZCk7XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmVzIGFsbCBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBhbnkgb2Ygc2V2ZXJhbCBtZXRob2RzLCBsaXN0ZWQgYXMgYW4gYXJyYXlcbiAgICBmdW5jdGlvbiBzZXJ2ZXJzRm9yTWV0aG9kcyhtZXRob2RzKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzLnJlZHVjZShmdW5jdGlvbiAoc29GYXIsIG1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvRmFyLmNvbmNhdChzZXJ2ZXJzLmdldF9zZXJ2ZXJzKG1ldGhvZCwgdHJ1ZSkpOy8vICh0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZXJlIGJlY2F1c2Ugd2UgYWxzbyBuZWVkIHRoZSByZXF1ZXN0IHN1YmplY3QpXG4gICAgICAgIH0sIFtdKS5zb3J0KHNlcnZlcnMuY29tcGFyZV9zZXJ2ZXJzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXJ2ZXJzRm9yTWV0aG9kQW5kVGFyZ2V0KG1ldGhvZEZpbHRlciwgdGFyZ2V0KSB7XG4gICAgICAgIC8vIEdldCB0aGUgbWV0aG9kcyB3aGljaCBtYXRjaCB0aGUgZmlsdGVyXG4gICAgICAgIHZhciBtZXRob2RzID0gZ2V0TWV0aG9kcyhtZXRob2RGaWx0ZXIpO1xuICAgICAgICAvLyBEZXRlcm1pbmUgd2hlcmUgdG8gZXhlY3V0ZSB0aGUgbWV0aG9kKHMpICh0aGUgXCJ0YXJnZXRcIiBhcmd1bWVudClcbiAgICAgICAgLy8gR2V0IGFsbCBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCB0aGUgbWV0aG9kKHMpIGFuZCBnZXQgdGhlIG9uZXMgdGhhdCBtYXRjaCB0aGUgdGFyZ2V0IGNyaXRlcmlhXG4gICAgICAgIHJldHVybiBmaWx0ZXJCeVRhcmdldCh0YXJnZXQsIHNlcnZlcnNGb3JNZXRob2RzKG1ldGhvZHMpKTtcbiAgICB9XG5cbiAgICAvLyBJbnZva2VzIGFuIEFHTSBtZXRob2QgKG1vc3RseSBpdCBkb2VzIGlucHV0IGNoZWNraW5nKSwgdGhlIGFjdHVhbCBqb2IgaXMgZG9uZSBieSBcInJlcXVlc3QuaW52b2tlXCJcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kRmlsdGVyLCBhcmd1bWVudE9iaiwgdGFyZ2V0LCBhZGRpdGlvbmFsT3B0aW9ucywgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgc3VjY2Vzc1Byb3h5O1xuICAgICAgICAgICAgdmFyIGVycm9yUHJveHk7XG5cbiAgICAgICAgICAgIHN1Y2Nlc3NQcm94eSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UoYXJncyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGVycm9yUHJveHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgIC8vIHZhciBwYXJzZWQgPSBKU09OLnBhcnNlKGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJlamVjdChhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBBZGQgZGVmYXVsdCBwYXJhbXNcbiAgICAgICAgICAgIGlmIChhcmd1bWVudE9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnRPYmogPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gJ2Jlc3QnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgJiYgdGFyZ2V0ICE9PSAnYWxsJyAmJiB0YXJnZXQgIT09ICdiZXN0Jykge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7IG1lc3NhZ2U6ICdcIicgKyB0YXJnZXQgKyAnXCIgaXMgbm90IGEgdmFsaWQgdGFyZ2V0LiBWYWxpZCB0YXJnZXRzIGFyZSBcImFsbFwiIGFuZCBcImJlc3RcIi4nIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWRkaXRpb25hbE9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsT3B0aW9ucy5tZXRob2RfcmVzcG9uc2VfdGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnMubWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXQgPSBjb25maWd1cmF0aW9uLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWRkaXRpb25hbE9wdGlvbnMud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zLndhaXRfZm9yX21ldGhvZF90aW1lb3V0ID0gY29uZmlndXJhdGlvbi53YWl0X2Zvcl9tZXRob2RfdGltZW91dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFyZ3VtZW50cyBhcmUgYW4gb2JqZWN0XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50T2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7IG1lc3NhZ2U6ICdUaGUgbWV0aG9kIGFyZ3VtZW50cyBtdXN0IGJlIGFuIG9iamVjdC4nIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZEZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBtZXRob2RGaWx0ZXIgPSB7IG5hbWU6IG1ldGhvZEZpbHRlciB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VydmVycyA9IHNlcnZlcnNGb3JNZXRob2RBbmRUYXJnZXQobWV0aG9kRmlsdGVyLCB0YXJnZXQpO1xuXG4gICAgICAgICAgICBpZiAoc2VydmVycy5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgICAgIGludm9rZVVuZXhpc3RpbmcobWV0aG9kRmlsdGVyLCBhcmd1bWVudE9iaiwgdGFyZ2V0LCBhZGRpdGlvbmFsT3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24uZGVidWcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJz4+PiBJbnZva2luZyBcIicgKyBtZXRob2RGaWx0ZXIubmFtZSArICdcIiBvbiAxIHNlcnZlcicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmludm9rZShtZXRob2RGaWx0ZXIsIGFyZ3VtZW50T2JqLCBzZXJ2ZXJzWzBdLCBhZGRpdGlvbmFsT3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+Pj4gSW52b2tpbmcgXCInICsgbWV0aG9kRmlsdGVyLm5hbWUgKyAnXCIgb24gJyArIHNlcnZlcnMubGVuZ3RoICsgJyBzZXJ2ZXJzJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW52b2tlT25BbGwobWV0aG9kRmlsdGVyLCBhcmd1bWVudE9iaiwgc2VydmVycywgYWRkaXRpb25hbE9wdGlvbnMsIHN1Y2Nlc3NQcm94eSwgZXJyb3JQcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBoZWxwZXJzLnByb21pc2lmeShwcm9taXNlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIHVzZXIgdHJpZXMgdG8gaW52b2tlIGEgbWV0aG9kIHdoaWNoIGRvZXMgbm90IGV4aXN0XG4gICAgZnVuY3Rpb24gaW52b2tlVW5leGlzdGluZyhtZXRob2RGaWx0ZXIsIGFyZ3VtZW50T2JqLCB0YXJnZXQsIGFkZGl0aW9uYWxPcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgc2VydmVyRm91bmQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoYWRkaXRpb25hbE9wdGlvbnMud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxFcnJvcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5zZXJ2ZXJfbWV0aG9kX2FkZGVkID0gY29uZmlndXJhdGlvbi5zZXJ2ZXJfbWV0aG9kX2FkZGVkLmZpbHRlcihmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICE9PSBuZXdTZXJ2ZXI7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNlcnZlckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGFkZGl0aW9uYWxPcHRpb25zLndhaXRfZm9yX21ldGhvZF90aW1lb3V0KTtcblxuICAgICAgICAgICAgcmVnaXN0ZXJDYWxsYmFjaygnc2VydmVyX21ldGhvZF9hZGRlZCcsIGlkZW50aXR5LCBuZXdTZXJ2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbmV3U2VydmVyKCkge1xuICAgICAgICAgICAgaWYgKHNlcnZlckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VydmVyID0gc2VydmVyc0Zvck1ldGhvZEFuZFRhcmdldChtZXRob2RGaWx0ZXIsIHRhcmdldClbMF07XG4gICAgICAgICAgICBpZiAoc2VydmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaW52b2tlKG1ldGhvZEZpbHRlciwgYXJndW1lbnRPYmosIHNlcnZlciwgYWRkaXRpb25hbE9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxFcnJvcigpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBtZXRob2QgZXhpc3RzIGFuZCBpZiBpdCBkb2VzbnQnLCByZXR1cm4gYW4gZXJyb3JcbiAgICAgICAgICAgIGlmIChnZXRNZXRob2RzKG1ldGhvZEZpbHRlcikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZEZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkX3dpdGg6IGFyZ3VtZW50T2JqLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSSBjb3VsZCBub3QgZmluZCBhIG1ldGhvZCB3aXRoIHRob3NlIHByb3BlcnRpZXM6ICcgKyBKU09OLnN0cmluZ2lmeShtZXRob2RGaWx0ZXIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2RGaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOiBhcmd1bWVudE9iaixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0kgY291bGQgbm90IGZpbmQgc2VydmVycyB3aXRoIHRoZXNlIHByb3BlcnRpZXM6ICcgKyBKU09OLnN0cmluZ2lmeSh0YXJnZXQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGludm9rZXMgYSBtZXRob2Qgd2l0aCBtdWx0aXBsZSB0YXJnZXRzXG4gICAgLy8gQ2FsbHMgYSBtZXRob2QgZm9yIGFsbCBzZXJ2ZXJzIGFuZCB1bmlmaWVzIHRoZSByZXN1bHRzIHRoZXkgcmV0dXJuIGludG8gb25lOlxuICAgIGZ1bmN0aW9uIGludm9rZU9uQWxsKG1ldGhvZCwgYXJndW1lbnRPYmosIHNlcnZlcnMsIGFkZGl0aW9uYWxPcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAvLyBIZXJlIHdlIHdpbGwgc3RvcmUgdGhlIHJlc3VsdHMgdGhhdCB0aGUgc2VydmVycyByZXR1cm5cbiAgICAgICAgdmFyIHN1Y2Nlc3NlcyA9IFtdO1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgY2FsbGJhY2tzXG4gICAgICAgIHZhciBzdWNjZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBzdWNjZXNzZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHN1Y2Nlc3NlcywgZXJyb3JzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXJyb3JDYWxsYmFjayA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICBzZW5kUmVzcG9uc2Uoc3VjY2Vzc2VzLCBlcnJvcnMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDYWxsIHRoZSBtZXRob2QgZm9yIGFsbCB0YXJnZXRzXG4gICAgICAgIHNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgICAgICByZXNwb25zZS5pbnZva2UobWV0aG9kLCBhcmd1bWVudE9iaiwgc2VydmVyLCBhZGRpdGlvbmFsT3B0aW9ucywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2FsbHMgdGhlIG1haW4gc3VjY2VzcyBhbmQgZXJyb3IgY2FsbGJhY2tzIHdpdGggdGhlIGFnZ3JlZ2F0ZWQgcmVzdWx0c1xuICAgICAgICBmdW5jdGlvbiBzZW5kUmVzcG9uc2UoKSB7XG4gICAgICAgICAgICAvLyB3YWl0IHRpbGwgZXZlcnlib2R5IGlzIGZpbmlzaGVkXG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzLmxlbmd0aCArIGVycm9ycy5sZW5ndGggPCBzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIFwic3VjY2Vzc1wiIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBzdWNjZXNzZXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLm1ldGhvZCA9IHN1Y2Nlc3MubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBvYmouY2FsbGVkX3dpdGggPSBzdWNjZXNzLmNhbGxlZF93aXRoO1xuICAgICAgICAgICAgICAgICAgICBvYmoucmV0dXJuZWQgPSBzdWNjZXNzLnJldHVybmVkO1xuICAgICAgICAgICAgICAgICAgICBvYmouYWxsX3JldHVybl92YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlZF9ieTogc3VjY2Vzcy5leGVjdXRlZF9ieSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkOiBzdWNjZXNzLnJldHVybmVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvYmouZXhlY3V0ZWRfYnkgPSBzdWNjZXNzLmV4ZWN1dGVkX2J5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIH0sIHsgYWxsX3JldHVybl92YWx1ZXM6IFtdIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGVycm9ycyBmcm9tIG9uZSBvZiB0aGUgc2VydmVycyBhZGQgdGhlbSB0byB0aGUgc3VjY2VzcyBvYmplY3QgdGhhdCB3aWxsIGJlIHJlc29sdmVkLlxuICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hbGxfZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hbGxfZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGVkX2J5IDogb2JqLmV4ZWN1dGVkX2J5LCAvLyB3ZSBkb24ndCBnZXQgZXhlY3V0ZWRfYnkgb2JqZWN0IGZyb20gdGhlIGVycm9yIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogb2JqLm1ldGhvZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9iai5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhyZXN1bHQpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHsgLy8gRXhlY3V0ZSB0aGUgXCJlcnJvclwiIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgZXJyb3IoZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvYmoubWV0aG9kID0gZXJyb3IubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBvYmouY2FsbGVkX3dpdGggPSBlcnJvci5jYWxsZWRfd2l0aDtcbiAgICAgICAgICAgICAgICAgICAgb2JqLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBvYmouYWxsX2Vycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVkX2J5OiBlcnJvci5leGVjdXRlZF9ieSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9iai5leGVjdXRlZF9ieSA9IHN1Y2Nlc3MuZXhlY3V0ZWRfYnk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgfSwgeyBhbGxfZXJyb3JzOiBbXSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0ZXJDYWxsYmFjayA9IGhlbHBlcnMuc2F2ZUNhbGxiYWNrSW4uYmluZCh0aGlzLCBjb25maWd1cmF0aW9uKTtcbiAgICB2YXIgYXBwbHlPblNlcnZlcnMgPSBhcHBseU9uLmJpbmQobnVsbCwgc2VydmVycy5nZXRfc2VydmVycyk7XG4gICAgdmFyIGFwcGx5T25NZXRob2RzID0gYXBwbHlPbi5iaW5kKG51bGwsIHNlcnZlcnMuZ2V0X21ldGhvZHMpO1xuICAgIHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICAgICAgaW52b2tlOiBpbnZva2UsXG4gICAgICAgIG1ldGhvZDogZ2V0TWV0aG9kLFxuICAgICAgICBzZXJ2ZXJzOiBnZXRTZXJ2ZXJzLFxuICAgICAgICBtZXRob2RzOiBnZXRNZXRob2RzLFxuICAgICAgICBtZXRob2RzX2Zvcl9pbnN0YW5jZTogZ2V0TWV0aG9kc0Zvckluc3RhbmNlLFxuICAgICAgICBtZXRob2RfYWRkZWQ6IHJlZ2lzdGVyQ2FsbGJhY2suYmluZChudWxsLCAnbWV0aG9kX2FkZGVkJywgYXBwbHlPbk1ldGhvZHMpLFxuICAgICAgICBtZXRob2RfcmVtb3ZlZDogcmVnaXN0ZXJDYWxsYmFjay5iaW5kKG51bGwsICdtZXRob2RfcmVtb3ZlZCcsIGlkZW50aXR5KSxcbiAgICAgICAgc2VydmVyX2FkZGVkOiByZWdpc3RlckNhbGxiYWNrLmJpbmQobnVsbCwgJ3NlcnZlcl9hZGRlZCcsIGFwcGx5T25TZXJ2ZXJzKSxcbiAgICAgICAgc2VydmVyX3JlbW92ZWQ6IHJlZ2lzdGVyQ2FsbGJhY2suYmluZChudWxsLCAnc2VydmVyX3JlbW92ZWQnLCBpZGVudGl0eSksXG4gICAgICAgIHNlcnZlcl9tZXRob2RfYWRkZWQ6IHJlZ2lzdGVyQ2FsbGJhY2suYmluZChudWxsLCAnc2VydmVyX21ldGhvZF9hZGRlZCcsIGlkZW50aXR5KSxcbiAgICAgICAgc2VydmVyX21ldGhvZF9yZW1vdmVkOiByZWdpc3RlckNhbGxiYWNrLmJpbmQobnVsbCwgJ3NlcnZlcl9tZXRob2RfcmVtb3ZlZCcsIGlkZW50aXR5KSxcbiAgICAgICAgcGFyc2Vfc2lnbmF0dXJlOiBoZWxwZXJzLnNpZ25hdHVyZV9wYXJzZV9mcmllbmRseVxuICAgIH07XG59O1xuXG4vLyBpbiBzZXJ2ZXJfbWV0aG9kX2FkZGVkIHdlIHRyeSB0byBjdXJyeSB0aGUgZm9sbG93aW5nOlxuLy9cdGNvbmZpZ3VyYXRpb24sIFwic2VydmVyX21ldGhvZF9hZGRlZFwiLCBmdW5jdGlvbndoaWNocmV0dXJuc2ZpcnN0YXJnXG5cbi8vIEZpbHRlcnMgYW4gYXJyYXkgb2Ygc2VydmVycyBhbmQgcmV0dXJucyB0aGUgb25lcyB3aGljaCBtYXRjaCB0aGUgdGFyZ2V0IGNyaXRlcmlhXG5mdW5jdGlvbiBmaWx0ZXJCeVRhcmdldCh0YXJnZXQsIHNlcnZlcnMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIHRhcmdldCBhcyBzdHJpbmc6XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBzZXJ2ZXJzO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gJ2Jlc3QnKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBzZXJ2ZXJzWzBdICE9PSB1bmRlZmluZWQgPyBbc2VydmVyc1swXV0gOiBbXTsgIC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCB0aGUgdGFyZ2V0IGFzIHNlcnZlciBmaWx0ZXJcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBbdGFyZ2V0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhciB1bmV4aXN0aW5nU2VydmVycyA9IFtdO1xuICAgICAgICAvLyBSZXRyaWV2ZSBhbGwgc2VydmVycyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXJzXG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5yZWR1Y2UoZnVuY3Rpb24gKG1hdGNoZXMsIGZpbHRlcikge1xuICAgICAgICAgICAgLy8gQWRkIG1hdGNoZXMgZm9yIGVhY2ggZmlsdGVyXG4gICAgICAgICAgICB2YXIgbXlNYXRjaGVzID0gc2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZdCcYXRjaChmaWx0ZXIsIHNlcnZlcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMuY29uY2F0KG15TWF0Y2hlcyk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBNYXRjaGVzIGEgc2VydmVyIGRlZmluaXRpb24gYWdhaW5zdCBhIHNlcnZlciBmaWx0ZXJcbmZ1bmN0aW9uIGluc3RhbmNl0JxhdGNoKGluc3RhbmNlRmlsdGVyLCBpbnN0YW5jZURlZmluaXRpb24pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIGNvbnRhaW5zUHJvcHMoaW5zdGFuY2VGaWx0ZXIsIGluc3RhbmNlRGVmaW5pdGlvbik7XG59XG5cbi8vIE1hdGNoZXMgYSBtZXRob2QgZGVmaW5pdGlvbiBhZ2FpbnN0IGEgbWV0aG9kIGZpbHRlclxuZnVuY3Rpb24gbWV0aG9kTWF0Y2gobWV0aG9kRmlsdGVyLCBtZXRob2REZWZpbml0aW9uKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiBjb250YWluc1Byb3BzKG1ldGhvZEZpbHRlciwgbWV0aG9kRGVmaW5pdGlvbik7XG59XG5cbi8vIEhlbHBlcnNcblxuZnVuY3Rpb24gY29udGFpbnNQcm9wcyhmaWx0ZXIsIG9iamVjdCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZmlsdGVyKS5yZWR1Y2UoZnVuY3Rpb24gKG1hdGNoLCBwcm9wKSB7XG4gICAgICAgIGlmIChmaWx0ZXJbcHJvcF0uY29uc3RydWN0b3IgPT09IFJlZ0V4cCkge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJbcHJvcF0udGVzdChvYmplY3RbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoU3RyaW5nKGZpbHRlcltwcm9wXSkudG9Mb3dlckNhc2UoKSAhPT0gU3RyaW5nKG9iamVjdFtwcm9wXSkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgc3ogPSBhcnJheS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN6OyBpbmRleCsrKSB7XG4gICAgICAgIGlmIChwcmVkKGFycmF5W2luZGV4XSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVtpbmRleF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBhcHBseU9uKG9iamVjdHMsIGZ1bmMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIG9iamVjdHMoKS5tYXAoZnVuYyk7XG59XG4iLCIvKlxuIFRoZSBJbnZjYXRpb25zc3RhdGUgbW9kdWxlIGhhbmRsZXMgQUdNIG1ldGhvZCBpbnZvY2F0aW9ucy4gdmlhIHRoZSAnaW52b2tlJyBtZXRob2RcbiBJdCBzZW5kcyBhbmQgcmVjZWl2ZXMgYWxsIGludm9jYXRpb24tcmVsYXRlZCBtZXNzYWdlcywgdmlhIHRoZSBcInByb2Nlc3NfcmVzcG9uc2VcIiBtZXRob2RcbiB0aGF0IGl0IGV4cG9zZXMgYW5kIHZpYSB0aGUgXCJzZW5kUmVxdWVzdFwiIGNhbGxiYWNrXG5cbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vYWdtX2hlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgaW5zdGFuY2UsIHNlbmRSZXF1ZXN0KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gSGVyZSB3ZSBzdG9yZSBhbGwgcGVuZGluZyBjYWxsYmFja3NcbiAgICB2YXIgcGVuZGluZ0NhbGxiYWNrcyA9IHt9O1xuXG4gICAgLy8gSW52b2tlcyBhbiBBR00gbWV0aG9kIHRvIGEgc2luZ2xlIEFHTSBzZXJ2ZXIsIGdpdmVuIHZhbGlkIGlucHV0LlxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZ3VtZW5PYmosIHRhcmdldCwgc3R1ZmYsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludm9jYXRpb24gSUQsIGZvciB0aGlzIGludm9jYXRpb25cbiAgICAgICAgdmFyIGludm9jYXRpb25JZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKTtcblxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgdXNlcidzIGNhbGxiYWNrc1xuICAgICAgICByZWdpc3Rlckludm9jYXRpb24oaW52b2NhdGlvbklkLCB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGNhbGxlZF93aXRoOiBhcmd1bWVuT2JqXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yLCBzdHVmZi5tZXRob2RfcmVzcG9uc2VfdGltZW91dCk7XG5cbiAgICAgICAgLy8gR2V0IGEgcmVzcG9uc2Ugc3ViamVjdCBmb3IgdGhpcyBpbnZvY2F0aW9uXG4gICAgICAgIGluc3RhbmNlLnJlc3BvbnNlX3N1YmplY3QobWV0aG9kLCBmdW5jdGlvbiAocmVzcG9uc2VTdWJqZWN0KSB7XG5cbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBhIG1lc3NhZ2VcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiB0YXJnZXQucmVxdWVzdF9zdWJqZWN0LFxuICAgICAgICAgICAgICAgIE1ldGhvZFJlc3BvbnNlU3ViamVjdDogcmVzcG9uc2VTdWJqZWN0LFxuICAgICAgICAgICAgICAgIENsaWVudDogaW5zdGFuY2UuaW5mbygpLFxuICAgICAgICAgICAgICAgIENvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgQXJndW1lbnRzSnNvbjogYXJndW1lbk9iaixcbiAgICAgICAgICAgICAgICAgICAgSW52b2NhdGlvbklkOiBpbnZvY2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdFR5cGU6IHN0dWZmLm9iamVjdF90eXBlLFxuICAgICAgICAgICAgICAgICAgICBEaXNwbGF5Q29udGV4dDogc3R1ZmYuZGlzcGxheV9jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBNZXRob2ROYW1lOiBtZXRob2QubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgRXhlY3V0aW9uU2VydmVyOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIFRpbWVvdXQ6IHN0dWZmLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFNlbmQgaXRcblxuICAgICAgICAgICAgc2VuZFJlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnJWM+Pj4gc2VuZGluZyBNZXRob2RJbnZvY2F0aW9uUmVxdWVzdE1lc3NhZ2UnLCAnYmFja2dyb3VuZC1jb2xvcjpoc2xhKDE5OCwgNTElLCA3OSUsIDAuNSknKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCclYycgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgJ2JhY2tncm91bmQtY29sb3I6aHNsYSgxOTgsIDUxJSwgNzklLCAwLjUpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkcyBjYWxsYmFja3MgZm9yIGEgZ2l2ZW4gaW52b2NhdGlvbiBJRFxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVySW52b2NhdGlvbihpbnZvY2F0aW9uSWQsIHJlc3BvbnNlLCBzdWNjZXNzLCBlcnJvciwgdGltZW91dCkge1xuICAgICAgICAvLyBBZGRzIHRoZSBjYWxsYmFja3NcbiAgICAgICAgcGVuZGluZ0NhbGxiYWNrc1tpbnZvY2F0aW9uSWRdID0geyByZXNwb25zZTogcmVzcG9uc2UsIHN1Y2Nlc3M6IHN1Y2Nlc3MsIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAvLyBTY2hlZHVsZXMgdG8gdGhyb3cgYSB0aW1lb3V0IGlmIG5vYm9keSBhbnN3ZXJzXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdDYWxsYmFja3NbaW52b2NhdGlvbklkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcih7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiByZXNwb25zZS5tZXRob2QsIGNhbGxlZF93aXRoOiByZXNwb25zZS5hcmd1bWVuT2JqLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaW1lb3V0IHJlYWNoZWQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nQ2FsbGJhY2tzW2ludm9jYXRpb25JZF07XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXRob2RSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgICAgIC8vIEZpbmRzIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBwZW5kaW5nQ2FsbGJhY2tzW21lc3NhZ2UuSW52b2NhdGlvbklkXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24uZGVidWcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCclYzw8PCByZWNlaXZpbmcgTWV0aG9kSW52b2NhdGlvblJlc3VsdE1lc3NhZ2UnLCAnYmFja2dyb3VuZC1jb2xvcjpoc2xhKDExOCwgNTElLCA3OSUsIDAuNSknKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCclYycgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgJ2JhY2tncm91bmQtY29sb3I6aHNsYSgxMTgsIDUxJSwgNzklLCAwLjUpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybmVkIHN1Y2Nlc3MsIGV4ZWN1dGUgdGhlIHN1Y2Nlc3MgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLlN0YXR1cyA9PT0gMCAmJiB0eXBlb2YgY2FsbGJhY2suc3VjY2VzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbWVzc2FnZS5SZXN1bHRDb250ZXh0SnNvbjtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIGFuIGVtcHR5IG9iamVjdCwgdGhlcmUgaXMgbm8gcmVzdWx0XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiBPYmplY3Qua2V5cyhyZXN1bHQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG9nIHRoYXQgd2UgcmVjZWl2ZWQgYSByZXN1bHRcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc8PDwgIFwiJyArIGNhbGxiYWNrLnJlc3BvbnNlLm1ldGhvZC5uYW1lICsgJ1wiIHdhcyBleGVjdXRlZCBieSAnICsgSlNPTi5zdHJpbmdpZnkoaGVscGVycy5wcmVwcm9jZXNzU2VydmVyKG1lc3NhZ2UuU2VydmVyKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suc3VjY2Vzcyh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogY2FsbGJhY2sucmVzcG9uc2UubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBjYWxsZWRfd2l0aDogY2FsbGJhY2sucmVzcG9uc2UuY2FsbGVkX3dpdGgsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVkX2J5OiBoZWxwZXJzLnByZXByb2Nlc3NTZXJ2ZXIobWVzc2FnZS5TZXJ2ZXIpLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5lZDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLlJlc3VsdE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGxvZ19kZXRhaWxzOiBtZXNzYWdlLlJlc3VsdExvZ0RldGFpbHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBFbHNlLCByZXR1cm4gYW4gZXJyb3JcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhbGxiYWNrLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnPDw8ICBcIicgKyBjYWxsYmFjay5yZXNwb25zZS5tZXRob2QubmFtZSArICdcIiB3YXMgZXhlY3V0ZWQgd2l0aCBlcnJvciBieSAnICsgSlNPTi5zdHJpbmdpZnkoaGVscGVycy5wcmVwcm9jZXNzU2VydmVyKG1lc3NhZ2UuU2VydmVyKSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBjYWxsYmFjay5yZXNwb25zZS5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOiBjYWxsYmFjay5yZXNwb25zZS5jYWxsZWRfd2l0aCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZS5SZXN1bHRNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBsb2dfZGV0YWlsczogbWVzc2FnZS5SZXN1bHRMb2dEZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IG1lc3NhZ2Uuc3RhdHVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCByZW1vdmUgdGhlIGNhbGxiYWNrc1xuICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdDYWxsYmFja3NbbWVzc2FnZS5JbnZvY2F0aW9uSWRdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHJvY2Vzc19tZXRob2RfcmVzcG9uc2U6IHByb2Nlc3NNZXRob2RSZXNwb25zZSwgaW52b2tlOiBpbnZva2UgfTtcbn07XG4iLCIvKlxuIFRoZSBNZXRob2RzdGF0ZSBtb2R1bGUsIGtlZXBzIHRoZSBzdGF0ZSBvZiBhdmFpbGFibGUgQUdNIG1ldGhvZHMgaW4gdGhlIG5ldHdvcmsuXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2FnbV9oZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gQSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgQUdNIG1ldGhvZHNcbiAgICB2YXIgbWV0aG9kcyA9IHt9O1xuXG4gICAgLy8gU2F2ZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBtZXRyaWMgZnVuY3Rpb24gaWYgaXQgZXhpc3RzXG4gICAgdmFyIG9iamVjdE1ldHJpYyA9IChjb25maWd1cmF0aW9uLm1ldHJpY3MgIT09IHVuZGVmaW5lZCkgPyBjb25maWd1cmF0aW9uLm1ldHJpY3MubnVtYmVyTWV0cmljLmJpbmQoY29uZmlndXJhdGlvbi5tZXRyaWNzKSA6IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuXG4gICAgLy8gQWRkcyBhIG5ldyBzZXJ2ZXIgdG8gYSBtZXRob2QuIENyZWF0ZXMgdGhlIG1ldGhvZCBpZiBpdCBpcyBub3QgY3JlYXRlZCBwcmV2aW91c2x5LlxuICAgIGZ1bmN0aW9uIGFkZFNlcnZlclRvTWV0aG9kKG1ldGhvZEluZm8sIHNlcnZlcklkLCBzZXJ2ZXJJbmZvKSB7XG4gICAgICAgIC8vIEdldCB0aGUgbWV0aG9kIElEXG4gICAgICAgIHZhciBtZXRob2RJZCA9IGdldE1ldGhvZElkKG1ldGhvZEluZm8pO1xuXG4gICAgICAgIC8vIE9uZSBtZXRob2QgY2FuIGhhdmUgc2V2ZXJhbCByZXF1ZXN0IHN1YmplY3RzIHBlciBzZXJ2ZXIuXG4gICAgICAgIC8vIFNvIHRoZSByZXF1ZXN0IHN1YmplY3QgaXMgYWN0dWFsbHkgbm90IGEgcHJvcGVydHkgb2YgdGhlIG1ldGhvZFxuICAgICAgICB2YXIgcmVxdWVzdFN1YmplY3QgPSBtZXRob2RJbmZvLnJlcXVlc3Rfc3ViamVjdDtcbiAgICAgICAgZGVsZXRlICBtZXRob2RJbmZvLnJlcXVlc3Rfc3ViamVjdDtcblxuICAgICAgICAvLyBDb3B5IHRoZSBtZXRob2QgYW5kIHNlcnZlciBvYmplY3RzIHRvIGEgZm9ybWF0IHN1aXRhYmxlIGZvciBzZW5kaW5nIHRvIHVzZXJzXG4gICAgICAgIHZhciBtZXRob2RJbmZvRnJpZW5kbHkgPSBoZWxwZXJzLmNsb25lT2JqZWN0KG1ldGhvZEluZm8pO1xuICAgICAgICB2YXIgc2VydmVySW5mb0ZyaWVuZGx5ID0gaGVscGVycy5jbG9uZU9iamVjdChzZXJ2ZXJJbmZvKTtcblxuICAgICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc1ttZXRob2RJZF07XG5cbiAgICAgICAgLy8gSWYgdGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIGl0XG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgaW5mb1xuICAgICAgICAgICAgbWV0aG9kID0gbWV0aG9kc1ttZXRob2RJZF0gPSB7IGluZm86IG1ldGhvZEluZm8sIHNlcnZlcnM6IHt9IH07XG4gICAgICAgICAgICAvLyBBZGQgcmVxdWVzdF9zdWJqZWN0XG4gICAgICAgICAgICBtZXRob2QgPSBhZGRSZXF1ZXN0U3ViamVjdChtZXRob2QsIHNlcnZlcklkLCByZXF1ZXN0U3ViamVjdCk7XG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdXNlciBjYWxsYmFja3NcbiAgICAgICAgICAgIGhlbHBlcnMuZXhlY3V0ZUFsbFdpdGgoY29uZmlndXJhdGlvbi5tZXRob2RfYWRkZWQsIG1ldGhvZEluZm9GcmllbmRseSk7XG4gICAgICAgICAgICAvLyBMb2cgYW5kIHB1Ymxpc2ggbWV0cmljc1xuICAgICAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uc29sZS50YWJsZSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24uZGVidWcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnPj4+Pj4+IE5ldyBtZXRob2QgZGV0ZWN0ZWQ6ICcgKyBKU09OLnN0cmluZ2lmeShtZXRob2RJbmZvRnJpZW5kbHkpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRhYmxlKGdldE1ldGhvZHMoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iamVjdE1ldHJpYygnTWV0aG9kcyB0b3RhbCBjb3VudCcsIE9iamVjdC5rZXlzKG1ldGhvZHMpLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFbHNlLCBqdXN0IGFkZCB0aGUgcmVxdWVzdCBzdWJqZWN0XG4gICAgICAgICAgICBtZXRob2QgPSBhZGRSZXF1ZXN0U3ViamVjdChtZXRob2QsIHNlcnZlcklkLCByZXF1ZXN0U3ViamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhlY3V0ZSB1c2VyIGNhbGxiYWNrc1xuICAgICAgICBoZWxwZXJzLmV4ZWN1dGVBbGxXaXRoKGNvbmZpZ3VyYXRpb24uc2VydmVyX21ldGhvZF9hZGRlZCwge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2RJbmZvRnJpZW5kbHksXG4gICAgICAgICAgICBzZXJ2ZXI6IHNlcnZlckluZm9GcmllbmRseVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGRzIHJlcXVlc3Qgc3ViamVjdCBmb3Igc2VydmVyIGFuZCBtZXRob2RcbiAgICBmdW5jdGlvbiBhZGRSZXF1ZXN0U3ViamVjdChtZXRob2QsIHNlcnZlcklkLCByZXF1ZXN0U3ViamVjdCkge1xuICAgICAgICBtZXRob2Quc2VydmVyc1tzZXJ2ZXJJZF0gPSByZXF1ZXN0U3ViamVjdDtcbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmVzIGEgc2VydmVyIGZyb20gYSBtZXRob2QuIERlbGV0ZXMgdGhlIG1ldGhvZCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBzZXJ2ZXJzIGxlZnQuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU2VydmVyRnJvbU1ldGhvZChtZXRob2RJZCwgc2VydmVySWQsIHNlcnZlckluZm8pIHtcbiAgICAgICAgLy8gT2J0YWluIGluZm8gYWJvdXQgdGhlIG1ldGhvZCBiZWZvcmUgcmVtb3ZpbmcgaXQuXG4gICAgICAgIHZhciBtZXRob2RJbmZvRnJpZW5kbHkgPSBnZXRNZXRob2QobWV0aG9kSWQpO1xuICAgICAgICB2YXIgc2VydmVySWluZm9GcmllbmRseSA9IGhlbHBlcnMuY2xvbmVPYmplY3Qoc2VydmVySW5mbyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZXJ2ZXIgZnJvbSB0aGUgbGlzdFxuICAgICAgICB2YXIgc2VydmVycyA9IG1ldGhvZHNbbWV0aG9kSWRdLnNlcnZlcnM7XG4gICAgICAgIGRlbGV0ZSBzZXJ2ZXJzW3NlcnZlcklkXTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBtZXRob2QgaWYgdGhlcmUgYXJlbid0IGFueSBzZXJ2ZXJzIGxlZnRcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNlcnZlcnMpLmxlbmd0aCA9PT0gMCkge1xuXG4gICAgICAgICAgICAvLyAnY2FsbGJhY2snIGlzIGRlZmluZWQgYnV0IG5ldmVyIHVzZWQuXG4gICAgICAgICAgICAvLyB2YXIgY2FsbGJhY2sgPSBjb25maWd1cmF0aW9uLm9uX21ldGhvZF9yZW1vdmVkO1xuICAgICAgICAgICAgaGVscGVycy5leGVjdXRlQWxsV2l0aChjb25maWd1cmF0aW9uLm1ldGhvZF9yZW1vdmVkLCBtZXRob2RJbmZvRnJpZW5kbHkpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG1ldGhvZFxuICAgICAgICAgICAgZGVsZXRlIG1ldGhvZHNbbWV0aG9kSWRdO1xuICAgICAgICAgICAgLy8gTG9nIGFuZCBtZXRyaWNzXG4gICAgICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25zb2xlLnRhYmxlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc8PDw8PDwgTWV0aG9kIHN0b3BwZWQgYmVpbmcgYXZhaWxhYmxlOiAnICsgSlNPTi5zdHJpbmdpZnkobWV0aG9kSW5mb0ZyaWVuZGx5KSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS50YWJsZShnZXRNZXRob2RzKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3RNZXRyaWMoJ01ldGhvZHMgdG90YWwgY291bnQnLCBPYmplY3Qua2V5cyhtZXRob2RzKS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4ZWN1dGUgdXNlciBjYWxsYmFja3NcbiAgICAgICAgaGVscGVycy5leGVjdXRlQWxsV2l0aChjb25maWd1cmF0aW9uLnNlcnZlcl9tZXRob2RfcmVtb3ZlZCwge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2RJbmZvRnJpZW5kbHksXG4gICAgICAgICAgICBzZXJ2ZXI6IHNlcnZlcklpbmZvRnJpZW5kbHlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGVzIGEgdW5pcXVlIGlmIGZvciBhIG1ldGhvZFxuICAgIGZ1bmN0aW9uIGdldE1ldGhvZElkKG0pIHtcbiAgICAgICAgLy8gU2V0dGluZyBwcm9wZXJpZXMgdG8gZGVmYXVsdHM6XG4gICAgICAgIHZhciBhY2NlcHRzID0gbS5hY2NlcHRzICE9PSB1bmRlZmluZWQgPyBtLmFjY2VwdHMgOiAnJztcbiAgICAgICAgdmFyIHJldHVybnMgPSBtLnJldHVybnMgIT09IHVuZGVmaW5lZCA/IG0ucmV0dXJucyA6ICcnO1xuICAgICAgICB2YXIgdmVyc2lvbiA9IG0udmVyc2lvbiAhPT0gdW5kZWZpbmVkID8gbS52ZXJzaW9uIDogMDtcbiAgICAgICAgcmV0dXJuIChtLm5hbWUgKyBhY2NlcHRzICsgcmV0dXJucyArIHZlcnNpb24pLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYWxsIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBnZXRNZXRob2RzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobWV0aG9kcykubWFwKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmNsb25lT2JqZWN0KG1ldGhvZHNbbWV0aG9kXS5pbmZvKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYW4gYXJyYXkgb2YgdGhlIElEJ3Mgb2YgdGhlIHNlcnZlcnMgZm9yIGEgbWV0aG9kXG4gICAgZnVuY3Rpb24gZ2V0U2VydmVyc0Zvck1ldGhvZChtZXRob2RJbmZvKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzW2dldE1ldGhvZElkKG1ldGhvZEluZm8pXTtcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLnNlcnZlcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2ZXMgYSBjb3B5IG9mIHRoZSBtZXRob2QsIGJ5IGl0cyBJRFxuICAgIGZ1bmN0aW9uIGdldE1ldGhvZChtZXRob2RJZCkge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZElkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbWV0aG9kSWQgPSBnZXRNZXRob2RJZChtZXRob2RJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kc1ttZXRob2RJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gV2UgY2xvbmUgdGhlIG1ldGhvZCBkZWZpbml0aW9uIHNvIGl0IGNhbiBiZSBtdXRhdGVkIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuY2xvbmVPYmplY3QobWV0aG9kc1ttZXRob2RJZF0uaW5mbyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRfbWV0aG9kczogZ2V0TWV0aG9kcyxcbiAgICAgICAgZ2V0X21ldGhvZDogZ2V0TWV0aG9kLFxuICAgICAgICBnZXRNZXRob2RJZDogZ2V0TWV0aG9kSWQsXG4gICAgICAgIGFkZF9zZXJ2ZXJfdG9fbWV0aG9kOiBhZGRTZXJ2ZXJUb01ldGhvZCxcbiAgICAgICAgcmVtb3ZlX3NlcnZlcl9mcm9tX21ldGhvZDogcmVtb3ZlU2VydmVyRnJvbU1ldGhvZCxcbiAgICAgICAgZ2V0X3NlcnZlcnNfZm9yX21ldGhvZDogZ2V0U2VydmVyc0Zvck1ldGhvZFxuICAgIH07XG5cbn07XG4iLCIvKlxuIFRoZSBTZXJ2ZXJzdGF0ZSBtb2R1bGUgcHJvY2Vzc2VzIHNlcnZlciBwcmVzZW5jZXMgYW5kIGtlZXBzIHRoZSBzdGF0ZSBvZiBhdmFpbGFibGUgQUdNIHNlcnZlcnMgaW4gdGhlIG5ldHdvcmsuXG4gKi9cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9hZ21faGVscGVycycpO1xudmFyIGdldFNlcnZlcklkID0gaGVscGVycy5nZXRTZXJ2ZXJJZDtcbnZhciBjbGllbnRNZXRob2RzdGF0ZSA9IHJlcXVpcmUoJy4vYWdtX2NsaWVudF9tZXRob2RzdGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBpbnN0YW5jZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIEEgbGlzdCBvZiBhbGwgdGhlIHNlcnZlcnMgaW4gdGhlIG5ldHdvcmtcbiAgICB2YXIgc2VydmVycyA9IHt9O1xuXG4gICAgLy8gSW5zdGFudGlhdGVzIHRoZSBcIm1ldGhvZHN0YXRlXCIgbW9kdWxlXG4gICAgdmFyIG1ldGhvZHMgPSBjbGllbnRNZXRob2RzdGF0ZShjb25maWd1cmF0aW9uKTtcblxuICAgIC8vIFByb2Nlc3NlcyBhIHByZXNlbmNlIG1lc3NhZ2UgZnJvbSBhIHNlcnZlclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQcmVzZW5jZShwcmVzZW5jZSwgaXNQcmVzZW5jZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhwcmVzZW5jZS5JbnN0YW5jZSlcbiAgICAgICAgLy8gR2V0IHNlcnZlciBpbmZvLlxuICAgICAgICB2YXIgc2VydmVyaW5mbyA9IGhlbHBlcnMucHJlcHJvY2Vzc1NlcnZlcihwcmVzZW5jZS5JbnN0YW5jZSk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VuY2UpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBtZXNzYWdlcyBmb3IgZGVhZCBzZXJ2ZXJzXG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhIG5ldyBzZXJ2ZXIsIHJlZ2lzdGVyIGl0LlxuICAgICAgICAgICAgaWYgKCFleGlzdHMoc2VydmVyaW5mbykpIHtcbiAgICAgICAgICAgICAgICBhZGRTZXJ2ZXIoc2VydmVyaW5mbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmVzZW5jZS5QdWJsaXNoaW5nSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICBzZXRQcmVzZW5jZVRpbWVvdXQoc2VydmVyaW5mbywgcHJlc2VuY2UuUHVibGlzaGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHksIHVwZGF0ZSB0aGUgbWV0aG9kc1xuICAgICAgICBpZiAocHJlc2VuY2UuTWV0aG9kRGVmaW5pdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlTWV0aG9kcyhzZXJ2ZXJpbmZvLCBwcmVzZW5jZS5NZXRob2REZWZpbml0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHNldHMgYSB0aW1lb3V0IHdoaWNoIHJlbW92ZXMgdGhlIHNlcnZlciB1bmxlc3NcbiAgICAvLyB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGFnYWluIGJlZm9yZSB0aGUgdGltZW91dCBpcyBvdmVyXG4gICAgZnVuY3Rpb24gc2V0UHJlc2VuY2VUaW1lb3V0KHNlcnZlcmluZm8sIGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBzZXJ2ZXJcbiAgICAgICAgdmFyIHNlcnZlcklkID0gZ2V0U2VydmVySWQoc2VydmVyaW5mbyk7XG4gICAgICAgIHZhciBzZXJ2ZXIgPSBzZXJ2ZXJzW3NlcnZlcklkXTtcbiAgICAgICAgLy8gU3RvcCB0aGUgcHJldmlvdXMgdGltZW91dFxuICAgICAgICBpZiAoc2VydmVyLmJvbWIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlcnZlci5ib21iKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYSBuZXcgb25lXG4gICAgICAgIHNlcnZlci5ib21iID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZW1vdmVTZXJ2ZXIoc2VydmVyaW5mbyk7XG4gICAgICAgIH0sIChkdXJhdGlvbiAqIGNvbmZpZ3VyYXRpb24ucmVtb3ZlX3NlcnZlcl9vbl9uX21pc3NpbmdfaGVhcnRiZWF0cykgKyAxKTtcblxuICAgIH1cblxuICAgIC8vIENoZWNrcyBpZiBhIHNlcnZlcnMgZXhpc3RzXG4gICAgZnVuY3Rpb24gZXhpc3RzKHNlcnZlcmluZm8pIHtcbiAgICAgICAgdmFyIHNlcnZlcklkID0gZ2V0U2VydmVySWQoc2VydmVyaW5mbyk7XG4gICAgICAgIHJldHVybiBzZXJ2ZXJzW3NlcnZlcklkXSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIGEgc2VydmVyXG4gICAgZnVuY3Rpb24gYWRkU2VydmVyKHNlcnZlcmluZm8pIHtcbiAgICAgICAgLy8gT2J0YWluIGEgc2VydmVyIElEIGFuZCBzdG9yZSB0aGUgbmV3IHNlcnZlclxuICAgICAgICB2YXIgc2VydmVySWQgPSBnZXRTZXJ2ZXJJZChzZXJ2ZXJpbmZvKTtcbiAgICAgICAgc2VydmVyc1tzZXJ2ZXJJZF0gPSB7IGluZm86IHNlcnZlcmluZm8sIG1ldGhvZHM6IFtdLCBib21iOiB1bmRlZmluZWQgfTtcblxuICAgICAgICAvLyBMb2cgaW4gY29uc29sZVxuICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25zb2xlLnRhYmxlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJz4+Pj4+PiBOZXcgc2VydmVyIGRldGVjdGVkOiAnICsgSlNPTi5zdHJpbmdpZnkoc2VydmVyaW5mbykpO1xuICAgICAgICAgICAgY29uc29sZS50YWJsZShnZXRTZXJ2ZXJzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhlY3V0ZSB1c2VyIGNhbGxiYWNrc1xuICAgICAgICBoZWxwZXJzLmV4ZWN1dGVBbGxXaXRoKGNvbmZpZ3VyYXRpb24uc2VydmVyX2FkZGVkLCBzZXJ2ZXJpbmZvKTtcblxuICAgICAgICByZXR1cm4gc2VydmVySWQ7XG4gICAgfVxuXG4gICAgLy8gVW5yZWdpc3RlcnMgYSBzZXJ2ZXJcbiAgICBmdW5jdGlvbiByZW1vdmVTZXJ2ZXIoc2VydmVyaW5mbykge1xuICAgICAgICAvLyBPYnRhaW4gYSBzZXJ2ZXIgSURcbiAgICAgICAgdmFyIHNlcnZlcklkID0gZ2V0U2VydmVySWQoc2VydmVyaW5mbyk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc2VydmVyJ3MgbWV0aG9kc1xuICAgICAgICBzZXJ2ZXJzW3NlcnZlcklkXS5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZElkKSB7XG4gICAgICAgICAgICBtZXRob2RzLnJlbW92ZV9zZXJ2ZXJfZnJvbV9tZXRob2QobWV0aG9kSWQsIHNlcnZlcklkLCBzZXJ2ZXJpbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc2VydmVyIGl0c2VsZlxuICAgICAgICBkZWxldGUgc2VydmVyc1tzZXJ2ZXJJZF07XG4gICAgICAgIC8vIExvZyBpbiBjb25zb2xlXG4gICAgICAgIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbnNvbGUudGFibGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnPDw8PDw8IFNlcnZlciBzdG9wcGVkIGJlaW5nIGF2YWlsYWJsZTonICsgSlNPTi5zdHJpbmdpZnkoc2VydmVyaW5mbykpO1xuICAgICAgICAgICAgY29uc29sZS50YWJsZShnZXRTZXJ2ZXJzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhlY3V0ZSB1c2VyIGNhbGxiYWNrc1xuICAgICAgICBoZWxwZXJzLmV4ZWN1dGVBbGxXaXRoKGNvbmZpZ3VyYXRpb24uc2VydmVyX3JlbW92ZWQsIHNlcnZlcmluZm8pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZXMgdGhlIG1ldGhvZHMgb2YgYSBzZXJ2ZXJcbiAgICBmdW5jdGlvbiB1cGRhdGVNZXRob2RzKHNlcnZlcmluZm8sIG5ld01ldGhvZHMpIHtcbiAgICAgICAgdmFyIHNlcnZlcklkID0gZ2V0U2VydmVySWQoc2VydmVyaW5mbyk7XG4gICAgICAgIC8vIEdldCBhbiBhcnJheSBvZiB0aGUgbWV0aG9kcyB0aGUgc2VydmVyIGhhZCBiZWZvcmUgd2Ugc3RhcnRlZCB0aGlzXG4gICAgICAgIHZhciBvbGRNZXRob2RzSWRzID0gc2VydmVyc1tzZXJ2ZXJJZF0ubWV0aG9kcztcbiAgICAgICAgLy8gR2V0IGFuIGFycmF5IG9mIHRoZSBtZXRob2RzIHRoYXQgdGhlIHNlcnZlciBoYXMgbm93XG4gICAgICAgIG5ld01ldGhvZHMgPSBuZXdNZXRob2RzLm1hcChoZWxwZXJzLnByZXByb2Nlc3NfbWV0aG9kKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgbWV0aG9kKSB7XG4gICAgICAgICAgICBvYmpbbWV0aG9kcy5nZXRNZXRob2RJZChtZXRob2QpXSA9IG1ldGhvZDtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gRm9yIGVhY2ggb2YgdGhlIG9sZCBtZXRob2RzXG4gICAgICAgIG9sZE1ldGhvZHNJZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGlzIHN0aWxsIHRoZXJlXG4gICAgICAgICAgICBpZiAobmV3TWV0aG9kc1ttZXRob2RJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzbid0LCByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICBtZXRob2RzLnJlbW92ZV9zZXJ2ZXJfZnJvbV9tZXRob2QobWV0aG9kSWQsIHNlcnZlcklkLCBzZXJ2ZXJpbmZvKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgdGhlcmUgaW4gYm90aCB0aGUgb2xkIGFycmF5IGFuZCB0aGUgbmV3IG9uZSwgd2UgZG9uJ3QgbmVlZCB0byBhZGQgaXQgYWdhaW5cbiAgICAgICAgICAgICAgICBuZXdNZXRob2RzW21ldGhvZElkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vdyBhZGQgdGhlIG5ldyBtZXRob2RzXG4gICAgICAgIHZhciBuZXdNZXRob2RzSWRzID0gT2JqZWN0LmtleXMobmV3TWV0aG9kcyk7XG4gICAgICAgIG5ld01ldGhvZHNJZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGlmIChuZXdNZXRob2RzW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kcy5hZGRfc2VydmVyX3RvX21ldGhvZChuZXdNZXRob2RzW2lkXSwgc2VydmVySWQsIHNlcnZlcmluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm93IGFsbCB3ZSBoYXZlIHRvIGRvIGlzIHJlcGxhY2UgdGhlIGxpc3Qgb2YgbWV0aG9kcyB0aGUgc2VydmVyIGhhc1xuICAgICAgICBzZXJ2ZXJzW3NlcnZlcklkXS5tZXRob2RzID0gbmV3TWV0aG9kc0lkcztcblxuICAgIH1cblxuICAgIC8vIEdldCBhbGwgc2VydmVycyBmb3IgYSBnaXZlbiBtZXRob2RcbiAgICBmdW5jdGlvbiBnZXRTZXJ2ZXJzKG1ldGhvZCwgaW5jbHVkZVJlcXVlc3RTdWJqZWN0KSB7XG4gICAgICAgIHZhciBzZXJ2ZXJJZHM7XG4gICAgICAgIHZhciBpZHNUb1JlcXVlc3RTdWJqZWN0cztcbiAgICAgICAgLy8gSWYgdGhlcmUgaXNuJ3QgYSBtZXRob2QgZ2V0IHRoZSBJRCdzIG9mIGFsbCBzZXJ2ZXJzXG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VydmVySWRzID0gT2JqZWN0LmtleXMoc2VydmVycyk7XG4gICAgICAgICAgICAvLyBFbHNlLCBnZXQgYSBsaXN0IG9mIHRoZSBzZXJ2ZXJzIHRoYXQgaGF2ZSB0aGUgbWV0aG9kXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZHNUb1JlcXVlc3RTdWJqZWN0cyA9IG1ldGhvZHMuZ2V0X3NlcnZlcnNfZm9yX21ldGhvZChtZXRob2QpO1xuICAgICAgICAgICAgc2VydmVySWRzID0gT2JqZWN0LmtleXMoaWRzVG9SZXF1ZXN0U3ViamVjdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcm1hdCB0aGUgbGlzdFxuICAgICAgICByZXR1cm4gc2VydmVySWRzLm1hcChmdW5jdGlvbiAoc2VydmVySWQpIHtcbiAgICAgICAgICAgIHZhciBzZXJ2ZXIgPSBoZWxwZXJzLmNsb25lT2JqZWN0KHNlcnZlcnNbc2VydmVySWRdLmluZm8pO1xuICAgICAgICAgICAgLy8gSW5jbHVkZSB0aGUgcmVxdWVzdCBzdWJqZWN0IGZvciBlYWNoIHNlcnZlciBmb3IgZWFjaCBtZXRob2Q6XG4gICAgICAgICAgICBpZiAoaW5jbHVkZVJlcXVlc3RTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgc2VydmVyLnJlcXVlc3Rfc3ViamVjdCA9IGlkc1RvUmVxdWVzdFN1YmplY3RzW3NlcnZlcklkXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlcjtcbiAgICAgICAgfSkuc29ydChjb21wYXJlU2VydmVycyk7XG4gICAgfVxuXG4gICAgLy8gQSBjb21wYXJlciBmdW5jdGlvbi4gU29ydHMgdGhlIHNlcnZlcnMgYmFzZWQgb24gYXZhaWxhYmlsaXR5XG4gICAgZnVuY3Rpb24gY29tcGFyZVNlcnZlcnMoc2VydmVyMSwgc2VydmVyMikge1xuICAgICAgICB2YXIgczEgPSAwO1xuICAgICAgICB2YXIgczIgPSAwO1xuICAgICAgICAvLyArMiBpZiB0aGUgc2VydmVyIGlzIG9uIHRoZSBzYW1lIG1hY2hpbmVcbiAgICAgICAgaWYgKHNlcnZlcjEubWFjaGluZSA9PT0gaW5zdGFuY2UubWFjaGluZSkge1xuICAgICAgICAgICAgczEgPSBzMSArIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VydmVyMi5tYWNoaW5lID09PSBpbnN0YW5jZS5tYWNoaW5lKSB7XG4gICAgICAgICAgICBzMiA9IHMyICsgMjtcbiAgICAgICAgfVxuICAgICAgICAvLyArMSBpZiBpdCBydW5zIHVuZGVyIHRoZSBzYW1lIHVzZXJcbiAgICAgICAgaWYgKHNlcnZlcjEudXNlciA9PT0gaW5zdGFuY2UudXNlcikge1xuICAgICAgICAgICAgczEgPSBzMSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VydmVyMi51c2VyID09PSBpbnN0YW5jZS51c2VyKSB7XG4gICAgICAgICAgICBzMiA9IHMyICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzMiAtIHMxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1ldGhvZElkcyhzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZlcnNbZ2V0U2VydmVySWQoc2VydmVyKV0ubWV0aG9kcztcbiAgICB9XG5cbiAgICAvLyBHZXQgYWxsIG1ldGhvZHMgZm9yIGEgZ2l2ZW4gc2VydmVyXG4gICAgZnVuY3Rpb24gZ2V0TWV0aG9kcyhzZXJ2ZXIpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gc2VydmVyIHNwZWNpZmllZCwgcmV0dXJuIGFsbFxuICAgICAgICBpZiAoc2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmdldF9tZXRob2RzKCk7XG4gICAgICAgICAgICAvLyBFbHNlLCBnZXQgdGhlIG1ldGhvZHMgZnJvbSB0aGUgc2VydmVyIG9iamVjdFxuICAgICAgICB9IGVsc2UgaWYgKGV4aXN0cyhzZXJ2ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TWV0aG9kSWRzKHNlcnZlcikubWFwKGZ1bmN0aW9uIChtZXRob2RJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmdldF9tZXRob2QobWV0aG9kSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGlzIHNwZWNpZmllZCwgYnV0IGl0IGRvZXMgbm90IGV4aXN0LCByZXR1cm4gYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb2Nlc3NfcHJlc2VuY2U6IHByb2Nlc3NQcmVzZW5jZSxcbiAgICAgICAgZ2V0X21ldGhvZHM6IGdldE1ldGhvZHMsXG4gICAgICAgIGdldF9tZXRob2RfaWRzOiBnZXRNZXRob2RJZHMsXG4gICAgICAgIGdldF9zZXJ2ZXJzOiBnZXRTZXJ2ZXJzLFxuICAgICAgICBnZXRfbWV0aG9kOiBtZXRob2RzLmdldF9tZXRob2QsXG4gICAgICAgIGV4aXN0czogZXhpc3RzLFxuICAgICAgICBjb21wYXJlX3NlcnZlcnM6IGNvbXBhcmVTZXJ2ZXJzXG4gICAgfTtcbn07XG4iLCIvKlxuIFRoZSBTdWJzY3JpcHRpb24tc3RhdGUgbW9kdWxlIGhhbmRsZXMgQUdNIHN0cmVhbSBzdWJzY3JpcHRpb25zIHZpYSB0aGUgJ3N1YnNjcmliZScgbWV0aG9kXG4gSXQgc2VuZHMgYW5kIHJlY2VpdmVzIGFsbCBpbnZvY2F0aW9uLXJlbGF0ZWQgbWVzc2FnZXMsIHZpYSB0aGUgXCJwcm9jZXNzX3Jlc3BvbnNlXCIgbWV0aG9kXG4gdGhhdCBpdCBleHBvc2VzIGFuZCB2aWEgdGhlIFwic2VuZFJlcXVlc3RcIiBjYWxsYmFja1xuXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2FnbV9oZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGluc3RhbmNlLCBzZW5kUmVxdWVzdCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTVEFUVVNfQVdBSVRJTkdfQUNDRVBUID0gJ2F3YWl0aW5nQWNjZXB0JzsgLy8gbm90IGV2ZW4gb25lIHNlcnZlciBoYXMgYWNjZXB0ZWQgeWV0XG4gICAgdmFyIFNUQVRVU19TVUJTQ1JJQkVEID0gJ3N1YnNjcmliZWQnOyAvLyBhdCBsZWFzdCBvbmUgc2VydmVyIGhhcyByZXNwb25kZWQgYXMgJ0FjY2VwdGluZydcbiAgICB2YXIgRVJSX01TR19TVUJfRkFJTEVEID0gJ1N1YnNjcmlwdGlvbiBmYWlsZWQuJztcbiAgICB2YXIgRVJSX01TR19TVUJfUkVKRUNURUQgPSAnU3Vic2NyaXB0aW9uIHJlamVjdGVkLic7XG4gICAgdmFyIE9OX0NMT1NFX01TR19TRVJWRVJfSU5JVCA9ICdTZXJ2ZXJJbml0aWF0ZWQnO1xuICAgIHZhciBPTl9DTE9TRV9NU0dfQ0xJRU5UX0lOSVQgPSAnQ2xpZW50SW5pdGlhdGVkJztcblxuICAgIHZhciBzdWJzY3JpcHRpb25zTGlzdCA9IHt9O1xuXG4gICAgLy8gUHJlcHMgYW5kIHNlbmRzIGEgcmVxdWVzdCB0byBzdWJzY3JpYmUgdG8gYSBzaW5nbGUgQUdNIHN0cmVhbSBwdWJsaXNoZXIuXG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKHN0cmVhbWluZ01ldGhvZCwgYXJndW1lbnRPYmosIHRhcmdldFNlcnZlcnMsIHN0dWZmLCBzdWNjZXNzLCBlcnJvcikge1xuXG4gICAgICAgIGlmICh0YXJnZXRTZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZXJyb3IoRVJSX01TR19TVUJfRkFJTEVEICsgJyBObyBhdmFpbGFibGUgc2VydmVycyBtYXRjaGVkIHRoZSB0YXJnZXQgcGFyYW1zLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBzYW1lIElkIHdpbGwgYmUgcGFzc2VkIHRvIGFsbCB0aGUgc2VydmVycyAoYXMgJ0ludm9jYXRpb25JZCcpXG4gICAgICAgIC8vIHNvIHRoZXkgY2FuIHJlc3BvbmQgYmFjayB3aXRoIGl0IGR1cmluZyB0aGUgaW5pdGlhbCBoYW5kc2hha2VcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbklkID0gJ3N1YnNjcmlwdGlvbklkXycgKyBoZWxwZXJzLmdlbmVyYXRlUmFuZG9tKCk7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIHVzZXIncyBjYWxsYmFja3NcbiAgICAgICAgdmFyIHBlbmRpbmdTdWIgPSByZWdpc3RlclN1YnNjcmlwdGlvbihcbiAgICAgICAgIHN1YnNjcmlwdGlvbklkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogc3RyZWFtaW5nTWV0aG9kLFxuICAgICAgICAgICAgICAgIGNhbGxlZF93aXRoOiBhcmd1bWVudE9ialxuICAgICAgICAgICAgfSxcbiAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICBlcnJvcixcbiAgICAgICAgIHN0dWZmLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwZW5kaW5nU3ViICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZXJyb3IoRVJSX01TR19TVUJfRkFJTEVEICsgJyBVbmFibGUgdG8gcmVnaXN0ZXIgdGhlIHVzZXIgY2FsbGJhY2tzLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VuZCBhIHN1YnNjcmlwdGlvbiByZXF1ZXN0IHRvIGVhY2ggc2VydmVyXG4gICAgICAgIHRhcmdldFNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG5cbiAgICAgICAgICAgIC8vIEdldCBhIHJlc3BvbnNlIHN1YmplY3QgZm9yIHRoaXMgaW52b2NhdGlvblxuICAgICAgICAgICAgaW5zdGFuY2UucmVzcG9uc2Vfc3ViamVjdChzdHJlYW1pbmdNZXRob2QsIGZ1bmN0aW9uIChyZXNwb25zZVN1YmplY3QpIHtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBzZXJ2ZXIgdG8gdGhlIGxpc3Qgb2Ygb25lcyB0aGUgY2xpZW50IGlzIGV4cGVjdGluZyBhIHJlc3BvbnNlIGZyb21cbiAgICAgICAgICAgICAgICBwZW5kaW5nU3ViLnRyYWNrZWRTZXJ2ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtU3ViamVjdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZFJlcXVlc3RTdWJqZWN0OiB0YXJnZXQucmVxdWVzdF9zdWJqZWN0LFxuICAgICAgICAgICAgICAgICAgICBtZXRob2RSZXNwb25zZVN1YmplY3Q6IHJlc3BvbnNlU3ViamVjdFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGEgbWVzc2FnZVxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICBFdmVudFN0cmVhbUFjdGlvbjogMSwgLy8gXCJTdWJzY3JpYmVcIiA9IGNsaWVudCB3aXNoZXMgdG8gc3Vic2NyaWJlXG4gICAgICAgICAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiB0YXJnZXQucmVxdWVzdF9zdWJqZWN0LFxuICAgICAgICAgICAgICAgICAgICBNZXRob2RSZXNwb25zZVN1YmplY3Q6IHJlc3BvbnNlU3ViamVjdCxcbiAgICAgICAgICAgICAgICAgICAgQ2xpZW50OiBpbnN0YW5jZS5pbmZvKCksXG4gICAgICAgICAgICAgICAgICAgIENvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFyZ3VtZW50c0pzb246IGFyZ3VtZW50T2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgSW52b2NhdGlvbklkOiBzdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdFR5cGU6IHN0dWZmLm9iamVjdF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgRGlzcGxheUNvbnRleHQ6IHN0dWZmLmRpc3BsYXlfY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1ldGhvZE5hbWU6IHN0cmVhbWluZ01ldGhvZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgRXhlY3V0aW9uU2VydmVyOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBUaW1lb3V0OiBzdHVmZi5tZXRob2RfcmVzcG9uc2VfdGltZW91dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFNlbmQgaXRcbiAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdChtZXNzYWdlKTtcblxuICAgICAgICAgICAgICAgIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24uZGVidWcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnJWM+Pj4gc2VuZGluZyBNZXRob2RJbnZvY2F0aW9uUmVxdWVzdE1lc3NhZ2UnLCAnYmFja2dyb3VuZC1jb2xvcjpoc2xhKDE5OCwgNTElLCA3OSUsIDAuNSknKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnJWMnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksICdiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMTk4LCA1MSUsIDc5JSwgMC41KScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uSWQsIHJlc3BvbnNlLCBzdWNjZXNzLCBlcnJvciwgdGltZW91dCkge1xuXG4gICAgICAgIHN1YnNjcmlwdGlvbnNMaXN0W3N1YnNjcmlwdGlvbklkXSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogU1RBVFVTX0FXQUlUSU5HX0FDQ0VQVCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICB0cmFja2VkU2VydmVyczogW10sXG4gICAgICAgICAgICBoYW5kbGVyczoge1xuICAgICAgICAgICAgICAgIG9uRGF0YTogW10sXG4gICAgICAgICAgICAgICAgb25DbG9zZWQ6IFtdXG4gICAgICAgICAgICAgICAgLy8gb25GYWlsZWQ6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcXVldWVkOiB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgY2xvc2VyczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lb3V0SWQ6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuXG4gICAgICAgIHN1YnNjcmlwdGlvbnNMaXN0W3N1YnNjcmlwdGlvbklkXS50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zTGlzdFtzdWJzY3JpcHRpb25JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbm8gc3VjaCBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbnNMaXN0W3N1YnNjcmlwdGlvbklkXTtcblxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zdGF0dXMgPT09IFNUQVRVU19BV0FJVElOR19BQ0NFUFQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcmVzcG9uc2UubWV0aG9kLCBjYWxsZWRfd2l0aDogcmVzcG9uc2UuY2FsbGVkX3dpdGgsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IEVSUl9NU0dfU1VCX0ZBSUxFRCArICcgU3Vic2NyaXB0aW9uIGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICcgKyB0aW1lb3V0ICsgJ21zLidcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIE5vbmUgb2YgdGhlIHRhcmdldCBzZXJ2ZXJzIGhhcyBhbnN3ZXJlZCB0aGUgc3Vic2NyaXB0aW9uIGF0dGVtcHRcbiAgICAgICAgICAgICAgICBkZWxldGUgc3Vic2NyaXB0aW9uc0xpc3Rbc3Vic2NyaXB0aW9uSWRdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN1YnNjcmlwdGlvbi5zdGF0dXMgPT09IFNUQVRVU19TVUJTQ1JJQkVEICYmIHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xlYW4gdGhlIHRyYWNrZWRTZXJ2ZXJzXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzID0gc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHNlcnZlci5zdHJlYW1JZCA9PT0gJ3N0cmluZycgJiYgc2VydmVyLnN0cmVhbUlkICE9PSAnc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udGltZW91dElkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIG9wZW4gc3RyZWFtcywgc29tZSBzZXJ2ZXJzIGFjY2VwdGVkIHRoZW4gY2xvc2VkIHZlcnkgcXVpY2tseVxuICAgICAgICAgICAgICAgICAgICAvLyAgKHRoYXQncyB3aHkgdGhlIHN0YXR1cyBjaGFuZ2VkIGJ1dCB0aGVyZSdzIG5vIGdvb2Qgc2VydmVyIHdpdGggYSBTdHJlYW1JZClcblxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBvbkNsb3NlZCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2Vyc0NvdW50ID0gc3Vic2NyaXB0aW9uLnF1ZXVlZC5jbG9zZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NpbmdTZXJ2ZXIgPSAoY2xvc2Vyc0NvdW50ID4gMCkgPyBzdWJzY3JpcHRpb24ucXVldWVkLmNsb3NlcnNbY2xvc2Vyc0NvdW50IC0gMV0gOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5oYW5kbGVycy5vbkNsb3NlZC5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogT05fQ0xPU0VfTVNHX1NFUlZFUl9JTklULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QXJndW1lbnRzOiBzdWJzY3JpcHRpb24ucmVzcG9uc2UuY2FsbGVkX3dpdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlcjogY2xvc2luZ1NlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiBzdWJzY3JpcHRpb24ucmVzcG9uc2UubWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdWJzY3JpcHRpb25zTGlzdFtzdWJzY3JpcHRpb25JZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uc0xpc3Rbc3Vic2NyaXB0aW9uSWRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQdWJsaXNoZXJNc2cobXNnKSB7XG4gICAgICAgIGlmICghKG1zZyAmJiBtc2cuRXZlbnRTdHJlYW1BY3Rpb24gJiYgbXNnLkV2ZW50U3RyZWFtQWN0aW9uICE9PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1zZy5FdmVudFN0cmVhbUFjdGlvbiA9PT0gMikge1xuXG4gICAgICAgICAgICBzZXJ2ZXJJc0tpY2tpbmdBU3Vic2NyaWJlcihtc2cpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobXNnLkV2ZW50U3RyZWFtQWN0aW9uID09PSAzKSB7XG5cbiAgICAgICAgICAgIHNlcnZlckFja25vd2xlZGdlc0dvb2RTdWJzY3JpcHRpb24obXNnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG1zZy5FdmVudFN0cmVhbUFjdGlvbiA9PT0gNSkge1xuXG4gICAgICAgICAgICBzZXJ2ZXJIYXNQdXNoZWRTb21lRGF0YUludG9UaGVTdHJlYW0obXNnKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqIG1zZyAnUmVzcG9uc2UnIEFjdGlvbnMgKi9cbiAgICAvLyBhY3Rpb24gMlxuICAgIGZ1bmN0aW9uIHNlcnZlcklzS2lja2luZ0FTdWJzY3JpYmVyKG1zZykge1xuXG4gICAgICAgIC8vIE5vdGU6IHRoaXMgbWlnaHQgYmUgZWl0aGVyIHRoZSBzZXJ2ZXIgcmVqZWN0aW5nIGEgc3Vic2NyaXB0aW9uIHJlcXVlc3QgT1IgY2xvc2luZyBhbiBleGlzdGluZyBzdWJzY3JpcHRpb25cblxuICAgICAgICAvLyBHZXQgQUxMIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdWJzY3JpcHRpb25zTGlzdCk7XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSByZWplY3Rpb24gdGhlcmUgbWF5IGJlIGFuIEludm9jYXRpb25JZCwgaXQgY2FuIG5hcnJvdyB0aGUgc2VhcmNoXG4gICAgICAgIGlmICh0eXBlb2YgbXNnLkludm9jYXRpb25JZCA9PT0gJ3N0cmluZycgJiYgbXNnLkludm9jYXRpb25JZCAhPT0gJycpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBrID09PSBtc2cuSW52b2NhdGlvbklkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsZXRpb25zTGlzdCA9IFtdO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIGtpY2tpbmcvcmVqZWN0aW5nIHNlcnZlciBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVyc1tdXG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnNMaXN0W2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zTGlzdFtrZXldLnRyYWNrZWRTZXJ2ZXJzID0gc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS50cmFja2VkU2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgICAgICAgIHZhciBpc1JlamVjdGluZyA9IHNlcnZlci5tZXRob2RSZXF1ZXN0U3ViamVjdCA9PT0gbXNnLk1ldGhvZFJlcXVlc3RTdWJqZWN0ICYmIHNlcnZlci5tZXRob2RSZXNwb25zZVN1YmplY3QgPT09IG1zZy5NZXRob2RSZXNwb25zZVN1YmplY3Q7XG4gICAgICAgICAgICAgICAgdmFyIGlzS2lja2luZyA9IChzZXJ2ZXIuc3RyZWFtSWQgPT09IG1zZy5TdHJlYW1JZCAmJiAoc2VydmVyLnN0cmVhbVN1YmplY3RzLmdsb2JhbCA9PT0gbXNnLkV2ZW50U3RyZWFtU3ViamVjdCB8fCBzZXJ2ZXIuc3RyZWFtU3ViamVjdHMucHJpdmF0ZSA9PT0gbXNnLkV2ZW50U3RyZWFtU3ViamVjdCkpO1xuICAgICAgICAgICAgICAgIHZhciBpc1JlamVjdGluZ09yS2lja2luZyA9IGlzUmVqZWN0aW5nIHx8IGlzS2lja2luZztcblxuICAgICAgICAgICAgICAgIHJldHVybiAhaXNSZWplY3RpbmdPcktpY2tpbmc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnNMaXN0W2tleV0udHJhY2tlZFNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRpb25zTGlzdC5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENhbGwgb25DbG9zZWQgT1IgZXJyb3IoKVxuICAgICAgICAvLyBhbmQgcmVtb3ZlIHRoZSBzdWJzY3JpcHRpb25cbiAgICAgICAgZGVsZXRpb25zTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uc0xpc3Rba2V5XSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25zTGlzdFtrZXldLnN0YXR1cyA9PT0gU1RBVFVTX0FXQUlUSU5HX0FDQ0VQVCAmJiB0eXBlb2Ygc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS50aW1lb3V0SWQgPT09ICdudW1iZXInKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVhc29uID0gKHR5cGVvZiBtc2cuUmVzdWx0TWVzc2FnZSA9PT0gJ3N0cmluZycgJiYgbXNnLlJlc3VsdE1lc3NhZ2UgIT09ICcnKVxuICAgICAgICAgICAgICAgICA/ICcgUHVibGlzaGVyIHNhaWQgXCInICsgbXNnLlJlc3VsdE1lc3NhZ2UgKyAnXCIuJ1xuICAgICAgICAgICAgICAgICA6ICcgTm8gcmVhc29uIGdpdmVuLic7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FsbEFyZ3MgPSB0eXBlb2Ygc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5yZXNwb25zZS5jYWxsZWRfd2l0aCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeShzdWJzY3JpcHRpb25zTGlzdFtrZXldLnJlc3BvbnNlLmNhbGxlZF93aXRoKVxuICAgICAgICAgICAgICAgICA6ICd7fSc7XG5cbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zTGlzdFtrZXldLmVycm9yKEVSUl9NU0dfU1VCX1JFSkVDVEVEICsgcmVhc29uICsgJyBDYWxsZWQgd2l0aDonICsgY2FsbEFyZ3MpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzdWJzY3JpcHRpb25zTGlzdFtrZXldLnRpbWVvdXRJZCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgdGltZW91dCBtYXkgb3IgbWF5IG5vdCBoYXZlIGV4cGlyZWQgeWV0LFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGUgc3RhdHVzIGlzICdzdWJzY3JpYmVkJyBhbmQgdHJhY2tlZFNlcnZlcnMgaXMgbm93IGVtcHR5XG5cbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zTGlzdFtrZXldLmhhbmRsZXJzLm9uQ2xvc2VkLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBPTl9DTE9TRV9NU0dfU0VSVkVSX0lOSVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFyZ3VtZW50czogc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5yZXNwb25zZS5jYWxsZWRfd2l0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXI6IG1zZy5TZXJ2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiBzdWJzY3JpcHRpb25zTGlzdFtrZXldLnJlc3BvbnNlLm1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgc3Vic2NyaXB0aW9uc0xpc3Rba2V5XTtcblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhY3Rpb24gM1xuICAgIGZ1bmN0aW9uIHNlcnZlckFja25vd2xlZGdlc0dvb2RTdWJzY3JpcHRpb24obXNnKSB7XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbklkID0gbXNnLkludm9jYXRpb25JZDtcblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uc0xpc3Rbc3Vic2NyaXB0aW9uSWRdO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjY2VwdGluZ1NlcnZlciA9IHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICBzZXJ2ZXIubWV0aG9kUmVxdWVzdFN1YmplY3QgPT09IG1zZy5NZXRob2RSZXF1ZXN0U3ViamVjdCAmJlxuICAgICAgICAgICAgIHNlcnZlci5tZXRob2RSZXNwb25zZVN1YmplY3QgPT09IG1zZy5NZXRob2RSZXNwb25zZVN1YmplY3RcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYWNjZXB0aW5nU2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzRmlyc3RSZXNwb25zZSA9IChzdWJzY3JpcHRpb24uc3RhdHVzID09PSBTVEFUVVNfQVdBSVRJTkdfQUNDRVBUKTtcblxuICAgICAgICBzdWJzY3JpcHRpb24uc3RhdHVzID0gU1RBVFVTX1NVQlNDUklCRUQ7XG5cbiAgICAgICAgdmFyIHByaXZhdGVTdHJlYW1TdWJqZWN0ID0gZ2VuZXJhdGVQcml2YXRlU3RyZWFtU3ViamVjdChzdWJzY3JpcHRpb24ucmVzcG9uc2UubWV0aG9kLm5hbWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYWNjZXB0aW5nU2VydmVyLnN0cmVhbUlkID09PSAnc3RyaW5nJyAmJiBhY2NlcHRpbmdTZXJ2ZXIuc3RyZWFtSWQgIT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgYWNjZXB0ZWQgcHJldmlvdXNseVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjZXB0aW5nU2VydmVyLnNlcnZlciA9IG1zZy5TZXJ2ZXI7XG4gICAgICAgIGFjY2VwdGluZ1NlcnZlci5zdHJlYW1JZCA9IG1zZy5TdHJlYW1JZDtcbiAgICAgICAgYWNjZXB0aW5nU2VydmVyLnN0cmVhbVN1YmplY3RzLmdsb2JhbCA9IG1zZy5FdmVudFN0cmVhbVN1YmplY3Q7XG4gICAgICAgIGFjY2VwdGluZ1NlcnZlci5zdHJlYW1TdWJqZWN0cy5wcml2YXRlID0gcHJpdmF0ZVN0cmVhbVN1YmplY3Q7XG4gICAgICAgIC8vIGFjY2VwdGluZ1NlcnZlci5tZXRob2RSZXNwb25zZVN1YmplY3Qgc3RheXMgdGhlIHNhbWVcblxuICAgICAgICB2YXIgY29uZmlybWF0b3J5UmVxdWVzdCA9IHtcbiAgICAgICAgICAgIEV2ZW50U3RyZWFtQWN0aW9uOiAzLCAvLyBcIlN1YnNjcmliZWRcIiA9IGNsaWVudCBjb25maXJtcyBpbnRlbnRpb24gdG8gc3Vic2NyaWJlXG4gICAgICAgICAgICBFdmVudFN0cmVhbVN1YmplY3Q6IHByaXZhdGVTdHJlYW1TdWJqZWN0LFxuICAgICAgICAgICAgU3RyZWFtSWQ6IG1zZy5TdHJlYW1JZCxcbiAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBtc2cuTWV0aG9kUmVxdWVzdFN1YmplY3QsXG4gICAgICAgICAgICBNZXRob2RSZXNwb25zZVN1YmplY3Q6IGFjY2VwdGluZ1NlcnZlci5tZXRob2RSZXNwb25zZVN1YmplY3QsXG4gICAgICAgICAgICBDbGllbnQ6IGluc3RhbmNlLmluZm8oKSxcbiAgICAgICAgICAgIENvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICBBcmd1bWVudHNKc29uOiBzdWJzY3JpcHRpb24ucmVzcG9uc2UuY2FsbGVkX3dpdGgsXG4gICAgICAgICAgICAgICAgTWV0aG9kTmFtZTogc3Vic2NyaXB0aW9uLnJlc3BvbnNlLm1ldGhvZC5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VuZFJlcXVlc3QoY29uZmlybWF0b3J5UmVxdWVzdCk7XG5cbiAgICAgICAgaWYgKGlzRmlyc3RSZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gUGFzcyBpbiB0aGUgc3Vic2NyaXB0aW9uIG9iamVjdFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnN1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgIG9uRGF0YTogZnVuY3Rpb24gKGRhdGFDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGRhdGEgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5vbkRhdGEucHVzaChkYXRhQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYW5kbGVycy5vbkRhdGEubGVuZ3RoID09PSAxICYmIHRoaXMucXVldWVkLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZWQuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFDYWxsYmFjayhkYXRhSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZChzdWJzY3JpcHRpb24pLFxuICAgICAgICAgICAgICAgIG9uQ2xvc2VkOiBmdW5jdGlvbiAoY2xvc2VkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjbG9zZWRDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMub25DbG9zZWQucHVzaChjbG9zZWRDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHN1YnNjcmlwdGlvbiksXG4gICAgICAgICAgICAgICAgb25GYWlsZWQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlU3Vic2NyaXB0aW9uLmJpbmQoc3Vic2NyaXB0aW9uLCBzdWJzY3JpcHRpb25JZCksXG4gICAgICAgICAgICAgICAgcmVxdWVzdEFyZ3VtZW50czogc3Vic2NyaXB0aW9uLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHNlcnZlckluc3RhbmNlOiBoZWxwZXJzLmNvbnZlcnRJbmZvVG9JbnN0YW5jZShtc2cuU2VydmVyKSxcbiAgICAgICAgICAgICAgICBzdHJlYW06IHN1YnNjcmlwdGlvbi5yZXNwb25zZS5tZXRob2RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWN0aW9uIDVcbiAgICBmdW5jdGlvbiBzZXJ2ZXJIYXNQdXNoZWRTb21lRGF0YUludG9UaGVTdHJlYW0obXNnKSB7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgc3Vic2NyaXB0aW9uIG9mIGludGVyZXN0IGJ5IHRyYXdsaW5nIHRoZSBkaWN0aW9uYXJ5XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzdWJzY3JpcHRpb25zTGlzdCkge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnNMaXN0Lmhhc093blByb3BlcnR5KGtleSkgJiYgdHlwZW9mIHN1YnNjcmlwdGlvbnNMaXN0W2tleV0gPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNQcml2YXRlRGF0YTtcblxuICAgICAgICAgICAgICAgIHZhciB0cmFja2VkU2VydmVyc0ZvdW5kID0gc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS50cmFja2VkU2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICBscy5zdHJlYW1JZCA9PT0gbXNnLlN0cmVhbUlkICYmXG4gICAgICAgICAgICAgICAgICAgICAobHMuc3RyZWFtU3ViamVjdHMuZ2xvYmFsID09PSBtc2cuRXZlbnRTdHJlYW1TdWJqZWN0IHx8IGxzLnN0cmVhbVN1YmplY3RzLnByaXZhdGUgPT09IG1zZy5FdmVudFN0cmVhbVN1YmplY3QpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICh0cmFja2VkU2VydmVyc0ZvdW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpc1ByaXZhdGVEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhY2tlZFNlcnZlcnNGb3VuZFswXS5zdHJlYW1TdWJqZWN0cy5nbG9iYWwgPT09IG1zZy5FdmVudFN0cmVhbVN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNQcml2YXRlRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhY2tlZFNlcnZlcnNGb3VuZFswXS5zdHJlYW1TdWJqZWN0cy5wcml2YXRlID09PSBtc2cuRXZlbnRTdHJlYW1TdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlzUHJpdmF0ZURhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc1ByaXZhdGVEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBhcnJpdmVkRGF0YSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVkU3RyZWFtRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1zZy5SZXN1bHRDb250ZXh0SnNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlcjogbXNnLlNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBcmd1bWVudHM6IHN1YnNjcmlwdGlvbnNMaXN0W2tleV0ucmVzcG9uc2UuY2FsbGVkX3dpdGggfHwgIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLlJlc3VsdE1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcml2YXRlOiBpc1ByaXZhdGVEYXRhXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uRGF0YUhhbmRsZXJzID0gc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5oYW5kbGVycy5vbkRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWV1ZWREYXRhID0gc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5xdWV1ZWQuZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvbkRhdGFIYW5kbGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkRhdGFIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EYXRhSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVjZWl2ZWRTdHJlYW1EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZWREYXRhLnB1c2gocmVjZWl2ZWRTdHJlYW1EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfS8vIGVuZCBmb3ItaW5cbiAgICB9XG5cbiAgICAvKiogKHN1YnNjcmlwdGlvbikgTWV0aG9kcyAqL1xuICAgIGZ1bmN0aW9uIGNsb3NlU3Vic2NyaXB0aW9uKHN1YklkKSB7XG4gICAgICAgIGluc3RhbmNlLnJlc3BvbnNlX3N1YmplY3Qoe30sIGZ1bmN0aW9uIChyZXNwb25zZVN1YmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlZFNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBFdmVudFN0cmVhbUFjdGlvbjogMixcbiAgICAgICAgICAgICAgICAgICAgQ2xpZW50OiBpbnN0YW5jZS5pbmZvKCksXG4gICAgICAgICAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBzZXJ2ZXIubWV0aG9kUmVxdWVzdFN1YmplY3QsXG4gICAgICAgICAgICAgICAgICAgIE1ldGhvZFJlc3BvbnNlU3ViamVjdDogcmVzcG9uc2VTdWJqZWN0LFxuICAgICAgICAgICAgICAgICAgICBTdHJlYW1JZDogc2VydmVyLnN0cmVhbUlkLFxuICAgICAgICAgICAgICAgICAgICBFdmVudFN0cmVhbVN1YmplY3Q6IHNlcnZlci5zdHJlYW1TdWJqZWN0cy5wcml2YXRlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIENhbGwgdGhlIG9uQ2xvc2VkIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuaGFuZGxlcnMub25DbG9zZWQuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IE9OX0NMT1NFX01TR19DTElFTlRfSU5JVCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFyZ3VtZW50czogX3RoaXMucmVzcG9uc2UuY2FsbGVkX3dpdGggfHwge30sXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlcjogX3RoaXMudHJhY2tlZFNlcnZlcnNbX3RoaXMudHJhY2tlZFNlcnZlcnMubGVuZ3RoIC0gMV0uc2VydmVyLFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW06IF90aGlzLnJlc3BvbnNlLm1ldGhvZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkZWxldGUgc3Vic2NyaXB0aW9uc0xpc3Rbc3ViSWRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlUHJpdmF0ZVN0cmVhbVN1YmplY3QobWV0aG9kTmFtZSkge1xuXG4gICAgICAgIHZhciBhcHBJbmZvID0gaW5zdGFuY2UuaW5mbygpO1xuXG4gICAgICAgIHZhciBwcml2YXRlU3RyZWFtU3ViamVjdCA9ICdFU1Nwcml2LWpzYl8nICtcbiAgICAgICAgIGFwcEluZm8uQXBwbGljYXRpb25OYW1lICtcbiAgICAgICAgICdfb25fJyArIG1ldGhvZE5hbWUgKyAnXycgK1xuICAgICAgICAgaGVscGVycy5nZW5lcmF0ZVJhbmRvbSgpO1xuXG4gICAgICAgIHJldHVybiBwcml2YXRlU3RyZWFtU3ViamVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4geyAvLyBhbiBpbnN0YW5jZSBvZiB0aGUgc3ViU3RhdGVcbiAgICAgICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgICAgIHByb2Nlc3NQdWJsaXNoZXJNc2c6IHByb2Nlc3NQdWJsaXNoZXJNc2dcbiAgICB9O1xufTtcbiIsIi8vIENvbnZlcnRzIHNlcnZlciBwcm9wZXJ0aWVzIGZyb20gY2FtZWwgdG8gc25ha2UgY2FzZVxuZnVuY3Rpb24gcHJlcHJvY2Vzc1NlcnZlcihtKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1hY2hpbmU6IG0uTWFjaGluZU5hbWUsXG4gICAgICAgIHBpZDogbS5Qcm9jZXNzSWQsXG4gICAgICAgIHN0YXJ0ZWQ6IG0uUHJvY2Vzc1N0YXJ0VGltZSxcbiAgICAgICAgdXNlcjogbS5Vc2VyTmFtZSxcbiAgICAgICAgYXBwbGljYXRpb246IG0uQXBwbGljYXRpb25OYW1lLFxuICAgICAgICBlbnZpcm9ubWVudDogbS5FbnZpcm9ubWVudCxcbiAgICAgICAgcmVnaW9uOiBtLlJlZ2lvbixcbiAgICAgICAgc2VydmljZV9uYW1lOiBtLlNlcnZpY2VOYW1lLFxuICAgICAgICBtZXRyaWNzX3JlcG9zaXRvcnlfaWQ6IG0uTWV0cmljc1JlcG9zaXRvcnlJZCxcbiAgICAgICAgc3RhdGU6IG0uU3RhdGVcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjbG9uZU9iamVjdChtZXRob2QpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIG5ld01ldGhvZCA9IHt9O1xuICAgIGZvciAodmFyIGkgaW4gbWV0aG9kKSB7XG4gICAgICAgIC8vIFJlbW92ZSB1bmRlZmluZWQgdmFsdWVzIGZyb20gb2JqZWN0IGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSB1c2VyXG4gICAgICAgIGlmIChtZXRob2RbaV0gIT09IHVuZGVmaW5lZCAmJiBtZXRob2RbaV0gIT09ICcnICYmIG1ldGhvZFtpXSAhPT0gMCkge1xuICAgICAgICAgICAgbmV3TWV0aG9kW2ldID0gbWV0aG9kW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld01ldGhvZDtcbn1cblxuLy8gSGVscGVyOiBwcmVwcm9jZXNzZXMgdGhlIG1ldGhvZCBkZWZpbml0aW9uXG5mdW5jdGlvbiBwcmVwcm9jZXNzTWV0aG9kKG1ldGhvZEluZm8pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIG1ldGhvZCA9IG1ldGhvZEluZm8uTWV0aG9kO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG1ldGhvZC5OYW1lLFxuICAgICAgICBhY2NlcHRzOiBtZXRob2QuSW5wdXRTaWduYXR1cmUsXG4gICAgICAgIHJldHVybnM6IG1ldGhvZC5SZXN1bHRTaWduYXR1cmUsXG4gICAgICAgIHJlcXVlc3Rfc3ViamVjdDogbWV0aG9kSW5mby5NZXRob2RSZXF1ZXN0U3ViamVjdCxcbiAgICAgICAgZGVzY3JpcHRpb246IG1ldGhvZC5EZXNjcmlwdGlvbixcbiAgICAgICAgZGlzcGxheV9uYW1lOiBtZXRob2QuRGlzcGxheU5hbWUsXG4gICAgICAgIHZlcnNpb246IG1ldGhvZC5WZXJzaW9uLFxuICAgICAgICBvYmplY3RfdHlwZXM6IG1ldGhvZC5PYmplY3RUeXBlUmVzdHJpY3Rpb25zLFxuICAgICAgICBzdXBwb3J0c1N0cmVhbWluZzogaXNTdHJlYW1pbmdGbGFnU2V0KG1ldGhvZC5GbGFncylcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc1N0cmVhbWluZ0ZsYWdTZXQoZmxhZ3MpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodHlwZW9mIGZsYWdzICE9PSAnbnVtYmVyJyB8fCBpc05hTihmbGFncykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWNraW5nIHRoZSBsYXJnZXN0IEJpdCB1c2luZyBiaXR3aXNlIG9wc1xuICAgIHZhciBtYXNrID0gMzI7XG4gICAgdmFyIHJlc3VsdCA9IGZsYWdzICYgbWFzaztcblxuICAgIHJldHVybiByZXN1bHQgPT09IG1hc2s7XG59XG5cbmZ1bmN0aW9uIHNhdmVDYWxsYmFja0luKGNhbGxiYWNrT2JqLCBldmVudCwgb25DYWxsYmFja0FkZCwgY2FsbGJhY2spIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFja09ialtldmVudF0gPSBjYWxsYmFja09ialtldmVudF0gfHwgW107XG4gICAgICAgIGNhbGxiYWNrT2JqW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgb25DYWxsYmFja0FkZChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBldmVudCArICdcIiBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgZnVuY3Rpb24gYXMgYW4gYXJndW1lbnQnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVBbGxXaXRoKGNhbGxiYWNrcywgaW5wdXQpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFja3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8vIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRCBmb3IgYSBzZXJ2ZXJcbmZ1bmN0aW9uIGdldFNlcnZlcklkKHNlcnZlcmluZm8pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHNlcnZlcmluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBUaGUgbWF0Y2hpbmcgaXMgY2FzZS1pbnNlbnNpdGl2ZVxuICAgIHJldHVybiAoc2VydmVyaW5mby5hcHBsaWNhdGlvbiArIHNlcnZlcmluZm8udXNlciArIHNlcnZlcmluZm8uc3RhcnRlZCArIHNlcnZlcmluZm8ucGlkKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBwcm9taXNpZnkocHJvbWlzZSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmICh0eXBlb2Ygc3VjY2Vzc0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlcnJvckNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3VjY2Vzc0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGFnbS5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3JDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGFnbS5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBbiBlcnJvciBvY2N1cnJlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb20oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMCk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRJbmZvVG9JbnN0YW5jZShpbmZvKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKHR5cGVvZiBpbmZvICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpbmZvID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXBwbGljYXRpb246IGluZm8uQXBwbGljYXRpb25OYW1lLFxuICAgICAgICBlbnZpcm9ubWVudDogaW5mby5FbnZpcm9ubWVudCxcbiAgICAgICAgbWFjaGluZTogaW5mby5NYWNoaW5lTmFtZSxcbiAgICAgICAgcGlkOiBpbmZvLlByb2Nlc3NJZCxcbiAgICAgICAgcmVnaW9uOiBpbmZvLlJlZ2lvbixcbiAgICAgICAgc2VydmljZTogaW5mby5TZXJ2aWNlTmFtZSxcbiAgICAgICAgdXNlcjogaW5mby5Vc2VyTmFtZSxcbiAgICAgICAgc3RhcnRlZDogaW5mby5Qcm9jZXNzU3RhcnRUaW1lXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRTZXJ2ZXJJZDogZ2V0U2VydmVySWQsXG4gICAgZXhlY3V0ZUFsbFdpdGg6IGV4ZWN1dGVBbGxXaXRoLFxuICAgIHNhdmVDYWxsYmFja0luOiBzYXZlQ2FsbGJhY2tJbixcbiAgICBwcmVwcm9jZXNzU2VydmVyOiBwcmVwcm9jZXNzU2VydmVyLFxuICAgIHByZXByb2Nlc3NfbWV0aG9kOiBwcmVwcm9jZXNzTWV0aG9kLFxuICAgIGNsb25lT2JqZWN0OiBjbG9uZU9iamVjdCxcbiAgICBwcm9taXNpZnk6IHByb21pc2lmeSxcbiAgICBnZW5lcmF0ZVJhbmRvbTogZ2VuZXJhdGVSYW5kb20sXG4gICAgY29udmVydEluZm9Ub0luc3RhbmNlOiBjb252ZXJ0SW5mb1RvSW5zdGFuY2Vcbn07XG4iLCIvKlxuIFRoZSBBR00gaW5zdGFuY2UgY29sbGVjdHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1hY2hpbmUgd2UgYXJlIGluLFxuIGFuZCBpbnRlcmFjdHMgd2l0aCB0aGUgLk5FVCBnYXRld2F5IGluIG90aGVyIHdheXMsXG4gdG8gZGVsaXZlciBmdWxsIEFHTSBjb21wYXRpYmlsaXR5IHRvIEFHTS5KUy5cblxuIFRvIGRvIHNvLCBpdCByZWxpZXMgb24gdGhlIGRlZmF1bHQgQUdNIGNsaWVudC5cbiAqL1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQgfHwgZ2xvYmFsLnByb2Nlc3M7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGMsIGNvbm5lY3Rpb24pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGluc3RhbmNlID0ge307XG4gICAgLy8gR2VuZXJhdGUgZGVmYXVsdCBpbnN0YW5jZSBwcm9wZXJ0aWVzXG4gICAgaW5zdGFuY2UuQXBwbGljYXRpb25OYW1lID0gZG9jdW1lbnQudGl0bGUgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwKTtcbiAgICBpbnN0YW5jZS5Qcm9jZXNzSWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwKTtcbiAgICBpbnN0YW5jZS5Qcm9jZXNzU3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBBcHBseSB1c2VyLXN1Ym1pdHRlZCBpbnN0YW5jZSBwcm9wZXJ0aWVzXG4gICAgaWYgKHR5cGVvZiBjID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoYy5hcHBsaWNhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5BcHBsaWNhdGlvbk5hbWUgPSBjLmFwcGxpY2F0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zdGFuY2UuTWFjaGluZU5hbWUgPSBjLm1hY2hpbmU7XG4gICAgICAgIGluc3RhbmNlLlVzZXJOYW1lID0gYy51c2VyO1xuICAgICAgICBpbnN0YW5jZS5FbnZpcm9ubWVudCA9IGMuZW52aXJvbm1lbnQ7XG4gICAgICAgIGluc3RhbmNlLlJlZ2lvbiA9IGMucmVnaW9uO1xuICAgICAgICBpbnN0YW5jZS5TZXJ2aWNlTmFtZSA9IGMuc2VydmljZV9uYW1lO1xuICAgICAgICBpbnN0YW5jZS5NZXRyaWNzUmVwb3NpdG9yeUlkID0gYy5tZXRyaWNzX3JlcG9zaXRvcnlfaWQ7XG4gICAgICAgIGluc3RhbmNlLlN0YXRlID0gMTtcbiAgICB9XG5cbiAgICB2YXIgaWRlbnRpdHlVcGRhdGVkID0gZmFsc2U7XG4gICAgY29ubmVjdGlvbi5vbignSW5zdGFuY2UnLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICBpZiAoaWRlbnRpdHlVcGRhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdGFuY2UuTWFjaGluZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuTWFjaGluZU5hbWUgPSBpLk1hY2hpbmVOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlLlVzZXJOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLlVzZXJOYW1lID0gaS5Vc2VyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnN0YW5jZS5FbnZpcm9ubWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5FbnZpcm9ubWVudCA9IGkuRW52aXJvbm1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdGFuY2UuUmVnaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLlJlZ2lvbiA9IGkuUmVnaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlLlNlcnZpY2VOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLlNlcnZpY2VOYW1lID0gaS5TZXJ2aWNlTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnN0YW5jZS5NZXRyaWNzUmVwb3NpdG9yeUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLk1ldHJpY3NSZXBvc2l0b3J5SWQgPSBpLk1ldHJpY3NSZXBvc2l0b3J5SWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdGFuY2UuU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuU3RhdGUgPSBpLlN0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgZ2xvYmFsLmNvbnNvbGUudGFibGUgIT09IHVuZGVmaW5lZCAmJiBhZ20uZGVidWcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBpbnN0YW5jZSB3aXRoIGluZm8gZnJvbSBHYXRld2F5LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWRlbnRpdHlVcGRhdGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICAvLyBDcmVhdGUgYSBtZXRob2QgZm9yIGFjY2Vzc2luZyBhIHByb3BlcnR5XG4gICAgZnVuY3Rpb24gY3JlYXRlR2V0dGVyKHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZVtwcm9wZXJ0eV07XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGVzIGEgcmVxdWVzdCBzdWJqZWN0IGZvciBhIG1ldGhvZFxuICAgIC8vIERlbGVnYXRlcyBpdCB0byB0aGUgLk5FVCBnYXRld2F5IGlmIGl0IGlzIG9ubGluZSxcbiAgICAvLyB0byBjcmVhdGUgc3ViamVjdHMgd2hpY2ggYXJlIHZhbGlkIGluIHRoZSBzY29wZSBvZiB0aGUgdHJhbnNwb3J0IHRoYXQgaXMgYmVpbmcgdXNlZC5cbiAgICB2YXIgcmVxU3ViamVjdCA9IDA7XG5cbiAgICBmdW5jdGlvbiByZXF1ZXN0U3ViamVjdChtZXRob2RJZGVudGlmaWVyLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygncmVxJyArIChyZXFTdWJqZWN0KyspICsgaW5zdGFuY2UuUHJvY2Vzc0lkKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZXMgYSByZXNwb25zZSBzdWJqZWN0IHN1YmplY3QgZm9yIGEgbWV0aG9kIGludm9jYXRpb25cbiAgICAvLyBEZWxlZ2F0ZXMgaXQgdG8gdGhlIC5ORVQgZ2F0ZXdheSBpZiBpdCBpcyBvbmxpbmUsXG4gICAgLy8gdG8gY3JlYXRlIHN1YmplY3RzIHdoaWNoIGFyZSB2YWxpZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHRyYW5zcG9ydCB0aGF0IGlzIGJlaW5nIHVzZWQuXG4gICAgdmFyIHJlc3BTdWJqZWN0ID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlU3ViamVjdChtZXRob2RJZGVudGlmaWVyLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygncmVzcCcgKyAocmVzcFN1YmplY3QrKykgKyBpbnN0YW5jZS5Qcm9jZXNzSWQpO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYWxsIGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICBmdW5jdGlvbiBpbmZvKCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVxdWVzdF9zdWJqZWN0OiByZXF1ZXN0U3ViamVjdCxcbiAgICAgICAgcmVzcG9uc2Vfc3ViamVjdDogcmVzcG9uc2VTdWJqZWN0LFxuICAgICAgICBpbmZvOiBpbmZvLFxuICAgICAgICBhcHBsaWNhdGlvbjogY3JlYXRlR2V0dGVyKCdBcHBsaWNhdGlvbk5hbWUnKSxcbiAgICAgICAgcGlkOiBjcmVhdGVHZXR0ZXIoJ1Byb2Nlc3NJZCcpLFxuICAgICAgICB1c2VyOiBjcmVhdGVHZXR0ZXIoJ1VzZXJOYW1lJyksXG4gICAgICAgIG1hY2hpbmU6IGNyZWF0ZUdldHRlcignTWFjaGluZU5hbWUnKVxuXG4gICAgfTtcblxufTtcbiIsInZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xudmFyIGggPSByZXF1aXJlKCcuL2FnbV9oZWxwZXJzJyk7XG52YXIgUGFja2FnZUpzb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBmdW5jdGlvbiBzdHJpbmdUb09iamVjdChwYXJhbSwgc3RyaW5nUHJvcE5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICAgIG9ialtzdHJpbmdQcm9wTmFtZV0gPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfVxuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGRhdGVzIHByb3Blcmx5XG4gICAgZnVuY3Rpb24gYWdtUGFyc2Uoc3RyKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0ciwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJlLXNlZWQgLSB0aGlzIHNob3VsZCBiZSBhIGJpdCBmYXN0ZXIgdGhhbiBpbmRleE9mXG4gICAgICAgICAgICBpZiAodlswXSAhPT0gZGF0ZVRpbWVJZGVudGlmaWVyWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2LmluZGV4T2YoZGF0ZVRpbWVJZGVudGlmaWVyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdW5peFRpbWVzdGFtcE1zID0gdi5zdWJzdHIobGVuT2ZJZGVudGl0aWZpZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodW5peFRpbWVzdGFtcE1zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgdGFyZ2V0IGFyZ3VtZW50IHRvIG9iamVjdCByZWFkeSB0byBiZSBwYXNzZWQgdG8gQWdtIGZhY2FkZVxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXJnZXRBcmdUb09iamVjdCh0YXJnZXQpIHtcblxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgJ2Jlc3QnO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gJ2FsbCcgJiYgdGFyZ2V0ICE9PSAnYmVzdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIHRhcmdldCArICdcIiBpcyBub3QgYSB2YWxpZCB0YXJnZXQuIFZhbGlkIHRhcmdldHMgYXJlIFwiYWxsXCIgYW5kIFwiYmVzdFwiLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB0YXJnZXQ6IHRhcmdldCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBbdGFyZ2V0XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0SW5zdGFuY2VUb1JlZ2V4KGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHNlcnZlckZpbHRlcjogdGFyZ2V0IH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0SW5zdGFuY2VUb1JlZ2V4KGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZUNvbnZlcnRlZCA9IHt9O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGluc3RhbmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBpbnN0YW5jZVtrZXldO1xuICAgICAgICAgICAgaW5zdGFuY2VDb252ZXJ0ZWRba2V5XSA9IHByb3BWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gZXhhY3QgbWF0Y2hpbmcgaWYgdXNlciBwYXNzZWQgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUNvbnZlcnRlZFtrZXldID0gJ14nICsgaW5zdGFuY2Vba2V5XSArICckJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2Vba2V5XS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VDb252ZXJ0ZWRba2V5XSA9IGluc3RhbmNlW2tleV0uc291cmNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUNvbnZlcnRlZFtrZXldID0gaW5zdGFuY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlQ29udmVydGVkO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXJzIGEgSmF2YVNjcmlwdCBmdW5jdGlvbiBhcyBhbiBBR00gbWV0aG9kLCB0aHVzIG1ha2luZyBpdCBhdmFpbGFibGUgb3RoZXIgQUdNIGluc3RhbmNlcyBvbiB0aGUgc2FtZSB0cmFuc3BvcnQuXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAobWV0aG9kSW5mbywgY2FsbGJhY2spIHtcblxuICAgICAgICAgICAgdmFyIHB2ID0gdGhpcy5hZ21GYWNhZGUucHJvdG9jb2xWZXJzaW9uO1xuXG4gICAgICAgICAgICBpZiAocHYgJiYgcHYgPj0gMykge1xuICAgICAgICAgICAgICAgIC8vIGZvciBuZXdlciBIQyB1c2UgdGhlIHZlcnNpb24gd2hlcmUgd2UgZG9uJ3QgcGFzcyBhcmd1bWVudHMgYXMgSlNPTiAoYmVjYXVzZSBvZiBkaWZmZXJlbnQgaXNzdWVzKVxuICAgICAgICAgICAgICAgIHRoaXMuYWdtRmFjYWRlLnJlZ2lzdGVyKEpTT04uc3RyaW5naWZ5KHN0cmluZ1RvT2JqZWN0KG1ldGhvZEluZm8sICduYW1lJykpLFxuICAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgdHJ1ZSk7IC8vIHJldHVybiBhcyBvYmplY3RzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWdtRmFjYWRlLnJlZ2lzdGVyKEpTT04uc3RyaW5naWZ5KHN0cmluZ1RvT2JqZWN0KG1ldGhvZEluZm8sICduYW1lJykpLFxuICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soSlNPTi5wYXJzZShhcmcpLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZ2lzdGVyQXN5bmM6IGZ1bmN0aW9uIChtZXRob2RJbmZvLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFnbUZhY2FkZS5yZWdpc3RlckFzeW5jKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIGluIHRoYXQgdmVyc2lvbiBvZiBIdG1sQ29udGFpbmVyJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWdtRmFjYWRlLnJlZ2lzdGVyQXN5bmMoc3RyaW5nVG9PYmplY3QobWV0aG9kSW5mbywgJ25hbWUnKSxcbiAgICAgICAgICAgICBmdW5jdGlvbiAoYXJncywgaW5zdGFuY2UsIHRyYWNrZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIHRoZSB1c2VyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3MsXG4gICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2Vzc0FyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgIHRyYWNrZXIuc3VjY2VzcyhzdWNjZXNzQXJncyk7XG4gICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICB0cmFja2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gKG1ldGhvZEZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUudW5yZWdpc3RlcihKU09OLnN0cmluZ2lmeShzdHJpbmdUb09iamVjdChtZXRob2RGaWx0ZXIsICduYW1lJykpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJbnZva2VzIGFuIEFHTSBtZXRob2QgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgIGludm9rZTogZnVuY3Rpb24gKG1ldGhvZEZpbHRlciwgYXJncywgdGFyZ2V0LCBvcHRpb25zLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcblxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHsgbWVzc2FnZTogJ1RoZSBtZXRob2QgYXJndW1lbnRzIG11c3QgYmUgYW4gb2JqZWN0LicgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRBcmdUb09iamVjdCh0YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWdtRmFjYWRlLmludm9rZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW52b2tlIHZlcjIgLSBkbyBub3Qgc3RyaW5naWZ5IGFyZ3VtZW50cyBhbmQgcmVzdWx0IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5pbnZva2UyKFxuICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc3RyaW5nVG9PYmplY3QobWV0aG9kRmlsdGVyLCAnbmFtZScpKSxcbiAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0YXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NQcm94eTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yUHJveHk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc1Byb3h5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBKU09OLnBhcnNlKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9yUHJveHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5pbnZva2UoXG4gICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzdHJpbmdUb09iamVjdChtZXRob2RGaWx0ZXIsICduYW1lJykpLFxuICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoYXJncyksXG4gICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0YXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUHJveHksXG4gICAgICAgICAgICAgICAgICAgICBlcnJvclByb3h5XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICByZXR1cm4gaC5wcm9taXNpZnkocHJvbWlzZSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBSZWdpc3RlcnMgYSBoYW5kbGVyIHdoaWNoIG5vdGlmaWVzIHlvdSB3aGVuIGEgbmV3IEFHTSBtZXRob2QgaXMgYXZhaWxhYmxlLlxuICAgICAgICBtZXRob2RBZGRlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5tZXRob2RBZGRlZChjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmVnaXN0ZXJzIGEgaGFuZGxlciB3aGljaCBub3RpZmllcyB5b3Ugd2hlbiBhbiBBR00gbWV0aG9kIHN0b3BzIGJlaW5nIGF2YWlsYWJsZS5cbiAgICAgICAgbWV0aG9kUmVtb3ZlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5tZXRob2RSZW1vdmVkKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXJ2ZXJBZGRlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5zZXJ2ZXJBZGRlZChjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VydmVyUmVtb3ZlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5zZXJ2ZXJSZW1vdmVkKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXJ2ZXJNZXRob2RBZGRlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5zZXJ2ZXJNZXRob2RBZGRlZChjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VydmVyTWV0aG9kUmVtb3ZlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmFnbUZhY2FkZS5zZXJ2ZXJNZXRob2RSZW1vdmVkKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBSZXRyaWV2ZXMgYSBsaXN0IG9mIEFHTSBzZXJ2ZXJzIChpbnN0YW5jZXMpIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgbWV0aG9kLlxuICAgICAgICBzZXJ2ZXJzOiBmdW5jdGlvbiAobWV0aG9kRmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIganNvblJlc3VsdCA9IHRoaXMuYWdtRmFjYWRlLnNlcnZlcnMoSlNPTi5zdHJpbmdpZnkobWV0aG9kRmlsdGVyKSk7XG4gICAgICAgICAgICByZXR1cm4gYWdtUGFyc2UoanNvblJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmV0cmlldmVzIGEgbGlzdCBvZiBtZXRob2RzIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIGZpbHRlci4gWW91IGNhbiB1c2UgdGhpcyB0byBjaGVjayBpZiBhIGdpdmVuIG1ldGhvZCBleGlzdHMuXG4gICAgICAgIG1ldGhvZHM6IGZ1bmN0aW9uIChtZXRob2RGaWx0ZXIpIHtcbiAgICAgICAgICAgIHZhciBqc29uUmVzdWx0ID0gdGhpcy5hZ21GYWNhZGUubWV0aG9kcyhKU09OLnN0cmluZ2lmeShtZXRob2RGaWx0ZXIpKTtcbiAgICAgICAgICAgIHJldHVybiBhZ21QYXJzZShqc29uUmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBtZXRob2RzRm9ySW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZUZpbHRlcikge1xuICAgICAgICAgICAgdmFyIGpzb25SZXN1bHQgPSB0aGlzLmFnbUZhY2FkZS5tZXRob2RzRm9ySW5zdGFuY2UoSlNPTi5zdHJpbmdpZnkoaW5zdGFuY2VGaWx0ZXIpKTtcbiAgICAgICAgICAgIHJldHVybiBhZ21QYXJzZShqc29uUmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBzdHJlYW1pbmcgc3VwcG9ydFxuICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYXJncyA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYXJndW1lbnRzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRhcmdldCA9IHRhcmdldEFyZ1RvT2JqZWN0KG9wdGlvbnMudGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWdtRmFjYWRlLnN1YnNjcmliZTIobmFtZSxcbiAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyksXG4gICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGgucHJvbWlzaWZ5KHByb21pc2UsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlU3RyZWFtOiBmdW5jdGlvbiAoc3RyZWFtRGVmLCBjYWxsYmFja3MsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1EZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbURlZiA9IHsgbmFtZTogc3RyZWFtRGVmIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5hZ21GYWNhZGUuY3JlYXRlU3RyZWFtMihcbiAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc3RyZWFtRGVmKSxcbiAgICAgICAgICAgICAgICAgLy8gVE9ETyAtIHdyYXAgdG8gdHJhbnNmb3JtIHBhcmFtc1xuICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3Vic2NyaXB0aW9uUmVxdWVzdEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgIC8vIFRPRE8gLSB3cmFwIHRvIHRyYW5zZm9ybSBwYXJhbXNcbiAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnN1YnNjcmlwdGlvbkFkZGVkSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgLy8gVE9ETyAtIHdyYXAgdG8gdHJhbnNmb3JtIHBhcmFtc1xuICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3Vic2NyaXB0aW9uUmVtb3ZlZEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3MgaGFuZGxlclxuICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgIC8vIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBoLnByb21pc2lmeShwcm9taXNlLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJlc3VsdC52ZXJzaW9uID0gUGFja2FnZUpzb24udmVyc2lvbjtcblxuICAgIC8vIGFkZCBtZXRyaWNzXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24gIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLm1ldHJpY3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWd1cmF0aW9uLm1ldHJpY3MubWV0cmljc0lkZW50aXR5ID0gY29uZmlndXJhdGlvbi5tZXRyaWNzLmlkZW50aXR5O1xuXG4gICAgICAgIC8vIHF1aWNrIGFuZCBkaXJ0eSAtIHdlIG5lZWQgdG8gc3RyaW5naWZ5IHRoZSBjb25maWd1cmF0aW9uIHNvIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgbWV0cmljcyBvYmplY3QgKHdoaWNoIGhhcyBjaXJjdWxhciByZWZlcmVuY2VzKVxuICAgICAgICAvLyB3aXRoIGFuIG9iamVjdCB0aGF0IGhvbGRzIG9ubHkgdGhlIHByb3BlcnRpZXMgbmVlZGVkXG4gICAgICAgIHZhciBtZXRyaWNzQ29uZmlnID0ge1xuICAgICAgICAgICAgbWV0cmljc0lkZW50aXR5OiBjb25maWd1cmF0aW9uLm1ldHJpY3MubWV0cmljc0lkZW50aXR5LFxuICAgICAgICAgICAgcGF0aDogY29uZmlndXJhdGlvbi5tZXRyaWNzLnBhdGhcbiAgICAgICAgfTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5tZXRyaWNzID0gbWV0cmljc0NvbmZpZztcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgbmV3IEFHTSBmYcOnYWRlIGZvciB0aGlzIGluc3RhbmNlXG4gICAgdmFyIGZhY2FkZSA9IGdsb2JhbC5odG1sQ29udGFpbmVyLmpzQWdtRmFjYWRlO1xuICAgIHZhciBjb25maWdBc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGNvbmZpZ3VyYXRpb24sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdsb2dnZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3VsdC5pbnN0YW5jZSA9IGZhY2FkZS5pbml0KGNvbmZpZ0FzU3RyaW5nKTtcbiAgICByZXN1bHQuYWdtRmFjYWRlID0gZmFjYWRlO1xuXG4gICAgLy8gZGF0ZSBwYXJzaW5nXG4gICAgdmFyIGRhdGVUaW1lSWRlbnRpZmllciA9IHJlc3VsdC5hZ21GYWNhZGUuanNvblZhbHVlRGF0ZVByZWZpeDtcbiAgICB2YXIgbGVuT2ZJZGVudGl0aWZpZXIgPSBkYXRlVGltZUlkZW50aWZpZXIubGVuZ3RoO1xuXG4gICAgLy8gZGVwcmVjYXRlZCBBUElcbiAgICByZXN1bHQuY3JlYXRlX3N0cmVhbSA9IHJlc3VsdC5jcmVhdGVTdHJlYW07XG4gICAgcmVzdWx0Lm1ldGhvZHNfZm9yX2luc3RhbmNlID0gcmVzdWx0Lm1ldGhvZHNGb3JJbnN0YW5jZTtcbiAgICByZXN1bHQubWV0aG9kX2FkZGVkID0gcmVzdWx0Lm1ldGhvZEFkZGVkO1xuICAgIHJlc3VsdC5tZXRob2RfcmVtb3ZlZCA9IHJlc3VsdC5tZXRob2RSZW1vdmVkO1xuICAgIHJlc3VsdC5zZXJ2ZXJfYWRkZWQgPSByZXN1bHQuc2VydmVyQWRkZWQ7XG4gICAgcmVzdWx0LnNlcnZlcl9yZW1vdmVkID0gcmVzdWx0LnNlcnZlclJlbW92ZWQ7XG4gICAgcmVzdWx0LnNlcnZlcl9tZXRob2RfYWRkZWQgPSByZXN1bHQuc2VydmVyTWV0aG9kQWRkZWQ7XG4gICAgcmVzdWx0LnNlcnZlcl9tZXRob2RfcmVtb3ZlZCA9IHJlc3VsdC5zZXJ2ZXJNZXRob2RSZW1vdmVkO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKlxuIFRoZSBBR00gU2VydmVyIGFsbG93cyB1c2VycyByZWdpc3RlciBBR00gbWV0aG9kcy5cbiBJdCBleHBvc2VzIHRoZXNlIG1ldGhvZHMgdG8gQUdNIGNsaWVudHMgKHVzaW5nIHByZXNlbmNlIG1lc3NhZ2VzKSBhbmQgbGlzdGVucyBmb3IgdGhlaXIgaW52b2NhdGlvblxuICovXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9hZ21faGVscGVycycpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG52YXIgc3RyZWFtUHVibGlzaGVyID0gcmVxdWlyZSgnLi9hZ21fc3RyZWFtX3B1Ymxpc2hlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBpbnN0YW5jZSwgY29uZmlndXJhdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBWYWxpZGF0ZSBjb25maWd1cmF0aW9uXG4gICAgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25maWd1cmF0aW9uID0ge307XG5cbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGFuIEFHTSBzZXJ2ZXIgd2l0aCBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIGRlZmF1bHRzXG4gICAgaWYgKHR5cGVvZiBjb25maWd1cmF0aW9uLmhlYXJ0YmVhdF9pbnRlcnZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5oZWFydGJlYXRfaW50ZXJ2YWwgPSA1MDAwO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlndXJhdGlvbi5wcmVzZW5jZV9pbnRlcnZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5wcmVzZW5jZV9pbnRlcnZhbCA9IDEwMDAwO1xuICAgIH1cblxuICAgIC8vIFNhdmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgbWV0cmljIGZ1bmN0aW9uIGlmIGl0IGV4aXN0c1xuICAgIHZhciBtZXRyaWMgPSAoY29uZmlndXJhdGlvbi5tZXRyaWNzICE9PSB1bmRlZmluZWQpID8gY29uZmlndXJhdGlvbi5tZXRyaWNzLm51bWJlck1ldHJpYy5iaW5kKGNvbmZpZ3VyYXRpb24ubWV0cmljcykgOiBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICAvLyBBbiBhcnJheSBvZiB0aGUgc2VydmVyJ3MgbWV0aG9kc1xuICAgIHZhciBtZXRob2RzID0gW107XG5cbiAgICB2YXIgcHJlc2VuY2VUaW1lcjtcblxuICAgIHZhciBoZWFydGJlYXRUaW1lcjtcblxuICAgIGlmIChoZWFydGJlYXRUaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlYXJ0YmVhdFRpbWVyID0gc2V0SW50ZXJ2YWwoc2VuZEhlYXJ0YmVhdCwgY29uZmlndXJhdGlvbi5oZWFydGJlYXRfaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpc2UgdGhlIHN0cmVhbSBwdWJsaXNoZXIgbW9kdWxlXG4gICAgdmFyIHB1Ymxpc2hlciA9IHN0cmVhbVB1Ymxpc2hlcihjb25uZWN0aW9uLCBpbnN0YW5jZSwgY29uZmlndXJhdGlvbiwgbWV0aG9kcyk7XG5cbiAgICBmdW5jdGlvbiBhbm5vdW5jZU5ld01ldGhvZChuZXdNZXRob2QpIHtcblxuICAgICAgICBtZXRob2RzLnB1c2gobmV3TWV0aG9kKTtcblxuICAgICAgICAvLyBTZW5kIHByZXNlbmNlIHNvIHRoZSBjbGllbnRzIGtub3cgd2UgaGF2ZSBpdFxuICAgICAgICBzZW5kUHJlc2VuY2UoKTtcbiAgICAgICAgLy8gU3RhcnQgc2VuZGluZyBwcmVzZW5jZSByZWd1bGFybHkgKGlmIHdlIGFyZW4ndCBhbHJlYWR5IGRvaW5nIGl0KVxuICAgICAgICBpZiAocHJlc2VuY2VUaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcmVzZW5jZVRpbWVyID0gc2V0SW50ZXJ2YWwoc2VuZFByZXNlbmNlLCBjb25maWd1cmF0aW9uLnByZXNlbmNlX2ludGVydmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1ldHJpYygnUmVnaXN0ZXJlZCBtZXRob2RzJywgbWV0aG9kcy5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIHJlZ2lzdGVycyBhIG5ldyBhZ20gbWV0aG9kXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXIobWV0aG9kRGVmaW5pdGlvbiwgY2FsbGJhY2spIHtcblxuICAgICAgICByZWdpc3RlckNvcmUobWV0aG9kRGVmaW5pdGlvbiwgZnVuY3Rpb24gKGNvbnRleHQsIHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHJlc3VsdCBhcyBkaXJlY3QgaW52b2NhdGlvbiBvZiB0aGUgY2FsbGJhY2sgYW5kIHJldHVybiBpdCB1c2luZyByZXN1bHRDYWxsYmFja1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soY29udGV4dC5hcmdzLCBjb250ZXh0Lmluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdENhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8vIHJlZ2lzdGVycyBhIG5ldyBhc3luIGFnbSBtZXRob2QgKHRoZSByZXN1bHQgY2FuIGJlIHJldHVybmVkIGluIGFzeW5jIHdheSlcbiAgICBmdW5jdGlvbiByZWdpc3RlckFzeW5jKG1ldGhvZERlZmluaXRpb24sIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgcmVnaXN0ZXJDb3JlKG1ldGhvZERlZmluaXRpb24sIGZ1bmN0aW9uIChjb250ZXh0LCByZXN1bHRDYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gaW52b2tlIHRoZSBjYWxsYmFjayBwYXNzaW5nIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjb250ZXh0LmFyZ3MsIGNvbnRleHQuaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3MgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgLy8gZXJyb3IgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdENhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjayhlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY29yZSBtZXRob2QgZm9yIHJlZ2lzdGVyaW5nIGFnbSBtZXRob2RcbiAgICBmdW5jdGlvbiByZWdpc3RlckNvcmUobWV0aG9kRGVmaW5pdGlvbiwgdGhlRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRoZSBkZWZpbml0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kRGVmaW5pdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb24gPSB7IG5hbWU6IG1ldGhvZERlZmluaXRpb24gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCBhIHJlcXVlc3Qgc3ViamVjdCBmb3IgdGhpcyBtZXRob2RcbiAgICAgICAgaW5zdGFuY2UucmVxdWVzdF9zdWJqZWN0KG1ldGhvZERlZmluaXRpb24sIGZ1bmN0aW9uIChyZXF1ZXN0U3ViamVjdCkge1xuXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gY29udmVydE1ldGhvZChtZXRob2REZWZpbml0aW9uKTtcbiAgICAgICAgICAgIG1ldGhvZC5NZXRob2RSZXF1ZXN0U3ViamVjdCA9IHJlcXVlc3RTdWJqZWN0O1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG1ldGhvZCAoc3RvcmUgdGhlIHVuZm9ybWF0dGVkIGRlZmluaXRpb24gaW4gb3JkZXIgdG8gZG8gY2hlY2t1cHMgaW4gdGhlIHVucmVnaXN0ZXIgbWV0aG9kKVxuICAgICAgICAgICAgYW5ub3VuY2VOZXdNZXRob2Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgdGhlX2Z1bmN0aW9uOiB0aGVGdW5jdGlvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtKHN0cmVhbURlZiwgY2FsbGJhY2tzLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgLy8gaW4gY2FsbGJhY2tzIHdlIGhhdmUgc3Vic2NyaXB0aW9uUmVxdWVzdEhhbmRsZXIsIHN1YnNjcmlwdGlvbkFkZGVkSGFuZGxlciwgc3Vic2NyaXB0aW9uUmVtb3ZlZEhhbmRsZXJcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtRGVmID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbURlZiA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdJbnZhbGlkIHN0cmVhbSBuYW1lLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0cmVhbURlZiA9IHsgbmFtZTogc3RyZWFtRGVmIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tzLnN1YnNjcmlwdGlvblJlcXVlc3RIYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnN1YnNjcmlwdGlvblJlcXVlc3RIYW5kbGVyID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgYSByZXF1ZXN0IHN1YmplY3QsIHNldCB0aGUgc3RyZWFtaW5nIGJpdCB0aGVuIHB1c2ggaW50byBtZXRob2RzW11cbiAgICAgICAgICAgIGluc3RhbmNlLnJlcXVlc3Rfc3ViamVjdChzdHJlYW1EZWYsIGZ1bmN0aW9uIChyZXF1ZXN0U3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJlYW1Db252ZXJ0ZWQgPSBjb252ZXJ0TWV0aG9kKHN0cmVhbURlZik7XG4gICAgICAgICAgICAgICAgc3RyZWFtQ29udmVydGVkLk1ldGhvZFJlcXVlc3RTdWJqZWN0ID0gcmVxdWVzdFN1YmplY3Q7XG4gICAgICAgICAgICAgICAgc3RyZWFtQ29udmVydGVkLk1ldGhvZC5GbGFncyA9IDMyOyAvLyAxMDAwMDAgYml0bWFzayB3aXRoIHRoZSBsYXJnZXN0IGZsYWcgKHN0cmVhbWluZzogdHJ1ZSlcblxuICAgICAgICAgICAgICAgIHZhciBuZXdTdHJlYW1pbmdNZXRob2QgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogc3RyZWFtQ29udmVydGVkLFxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRzOiBzdHJlYW1EZWYuYWNjZXB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzdHJlYW1EZWYuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogc3RyZWFtRGVmLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RyZWFtRGVmLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUeXBlczogc3RyZWFtRGVmLm9iamVjdFR5cGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuczogc3RyZWFtRGVmLnJldHVybnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c1N0cmVhbWluZzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1DYWxsYmFja3M6IGNhbGxiYWNrcyxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRTdHJlYW1TdWJqZWN0OiBzdHJlYW1EZWYubmFtZSArICcuanNTdHJlYW0uJyArIGhlbHBlcnMuZ2VuZXJhdGVSYW5kb20oKSxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogW10sXG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaEtleVRvU3RyZWFtSWRNYXA6IFtdIC8vIFsge2JyYW5jaEtleTogJycsIHN0cmVhbUlkOiAnc3Ryal9uZHM3ODZ5MjM3OHliJ30sIHsuLi59LCAuLi5dXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGFubm91bmNlTmV3TWV0aG9kKG5ld1N0cmVhbWluZ01ldGhvZCk7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaXNoZXIuZ2V0QnJhbmNoTGlzdChuZXdTdHJlYW1pbmdNZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZXIuY2xvc2VBbGxTdWJzY3JpcHRpb25zKG5ld1N0cmVhbWluZ01ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKG5ld1N0cmVhbWluZ01ldGhvZC5kZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRzOiBzdHJlYW1EZWYuYWNjZXB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzdHJlYW1EZWYuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogc3RyZWFtRGVmLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RyZWFtRGVmLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUeXBlczogc3RyZWFtRGVmLm9iamVjdFR5cGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuczogc3RyZWFtRGVmLnJldHVybnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c1N0cmVhbWluZzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdHJlYW1EZWYubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGJyYW5jaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJyYW5jaGVzICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShicmFuY2hlcykgJiYgYnJhbmNoZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBicmFuY2hlcyBzaG91bGQgYmUgc3RyaW5nIG9yIHN0cmluZyBhcnJheScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB2YWxpZGF0ZSBpZiBpcyBwbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzLiBEYXRhIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZXIucHVzaERhdGEobmV3U3RyZWFtaW5nTWV0aG9kLCBkYXRhLCBicmFuY2hlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1Ymxpc2hlci5nZXRTdWJzY3JpcHRpb25MaXN0KG5ld1N0cmVhbWluZ01ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBoZWxwZXJzLnByb21pc2lmeShwcm9taXNlLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBpbnZvY2F0aW9ucyA9IDA7XG5cbiAgICAvLyBMaXN0ZW5zIGZvciBtZXRob2QgaW52b2NhdGlvbnNcbiAgICBjb25uZWN0aW9uLm9uKCdNZXRob2RJbnZvY2F0aW9uUmVxdWVzdE1lc3NhZ2UnLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAvLyBGaW5kIHRoZSBtZXRob2RcbiAgICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5tZXRob2QuTWV0aG9kUmVxdWVzdFN1YmplY3QgPT09IG1lc3NhZ2UuTWV0aG9kUmVxdWVzdFN1YmplY3Q7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIC8vIFN0b3AgaWYgdGhlIG1lc3NhZ2UgaXNuJ3QgZm9yIHVzXG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc29tZSBsb2dnaW5nIGlmIGVuYWJsZWRcbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnJWM8PDwgcmVjZWl2aW5nIE1ldGhvZEludm9jYXRpb25SZXF1ZXN0TWVzc2FnZScsICdiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMTk4LCA1MSUsIDc5JSwgMC41KScpO1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnJWMnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksICdiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMTk4LCA1MSUsIDc5JSwgMC41KScpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWV0cmljKCdJbnZvY2F0aW9ucyBjb3VudCcsIGludm9jYXRpb25zKyspO1xuXG4gICAgICAgIC8vIFRPRE8gc2VlIGlmIGhhdmUgdG8gbW92ZSB0aGlzIGVhcmxpZXIgLSBpLmUuIGlmIHNvbWUgbWVzc2FnZXMgZnJvbSBDbGllbnQgZG9uJ3QgaGF2ZSBNZXRob2RSZXF1ZXN0U3ViamVjdFxuICAgICAgICAvLyBDaGVjayBpZiBtZXNzYWdlIGlzIHN0cmVhbS1yZWxhdGVkIDogZGVmZXIgcHVibGlzaGVyXG4gICAgICAgIGlmIChwdWJsaXNoZXIuaXNTdHJlYW1Nc2cobWVzc2FnZSwgbWV0aG9kKSkge1xuICAgICAgICAgICAgcHVibGlzaGVyLnByb2Nlc3NTdWJzY3JpYmVyTXNnKG1lc3NhZ2UsIG1ldGhvZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGVjdXRlIGl0IGFuZCBzYXZlIHRoZSByZXN1bHRcbiAgICAgICAgdmFyIGludm9raW5nQ2xpZW50ID0gaGVscGVycy5jb252ZXJ0SW5mb1RvSW5zdGFuY2UobWVzc2FnZS5DbGllbnQpO1xuXG4gICAgICAgIG1ldGhvZC50aGVfZnVuY3Rpb24oeyBhcmdzOiBtZXNzYWdlLkNvbnRleHQuQXJndW1lbnRzSnNvbiwgaW5zdGFuY2U6IGludm9raW5nQ2xpZW50IH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBlcnJvciBjYXNlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERvbid0IHNlbmQgcmVzdWx0IGlmIHRoZSBjbGllbnQgZG9lcyBub3QgcmVxdWlyZSBpdFxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWV0aG9kUmVzcG9uc2VTdWJqZWN0ID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBBR00gbGlicmFyeSBvbmx5IHRyYW5zZmVycyBvYmplY3RzLiBJZiB0aGUgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3QsIHB1dCBpdCBpbiBvbmVcbiAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnIHx8IHJlc3VsdC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geyBfcmVzdWx0OiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgTWV0aG9kUmVxdWVzdFN1YmplY3Q6IG1lc3NhZ2UuTWV0aG9kUmVxdWVzdFN1YmplY3QsXG4gICAgICAgICAgICAgICAgTWV0aG9kUmVzcG9uc2VTdWJqZWN0OiBtZXNzYWdlLk1ldGhvZFJlc3BvbnNlU3ViamVjdCxcbiAgICAgICAgICAgICAgICBNZXRob2ROYW1lOiBtZXRob2QubWV0aG9kLk1ldGhvZC5OYW1lLFxuICAgICAgICAgICAgICAgIEludm9jYXRpb25JZDogbWVzc2FnZS5Db250ZXh0Lkludm9jYXRpb25JZCxcbiAgICAgICAgICAgICAgICBSZXN1bHRDb250ZXh0SnNvbjogcmVzdWx0LFxuICAgICAgICAgICAgICAgIFNlcnZlcjogaW5zdGFuY2UuaW5mbygpLFxuICAgICAgICAgICAgICAgIFJlc3VsdE1lc3NhZ2U6IGVycixcbiAgICAgICAgICAgICAgICBTdGF0dXM6IGVyciA/IDEgOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gU2VuZCByZXN1bHRcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZCgnTWV0aG9kSW52b2NhdGlvblJlc3VsdE1lc3NhZ2UnLCByZXN1bHRNZXNzYWdlKTtcblxuICAgICAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJyVjPj4+IHNlbmRpbmcgTWV0aG9kSW52b2NhdGlvblJlc3VsdE1lc3NhZ2UnLCAnYmFja2dyb3VuZC1jb2xvcjpoc2xhKDExOCwgNTElLCA3OSUsIDAuNSknKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCclYycgKyBKU09OLnN0cmluZ2lmeShyZXN1bHRNZXNzYWdlKSwgJ2JhY2tncm91bmQtY29sb3I6aHNsYSgxMTgsIDUxJSwgNzklLCAwLjUpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gQ29uc3RydWN0cyBhIGhlYXJ0YmVhdCBtZXNzYWdlXG4gICAgZnVuY3Rpb24gY29uc3RydWN0SGVhcnRiZWF0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgUHVibGlzaGluZ0ludGVydmFsOiBjb25maWd1cmF0aW9uLmhlYXJ0YmVhdF9pbnRlcnZhbCxcbiAgICAgICAgICAgIEluc3RhbmNlOiBpbnN0YW5jZS5pbmZvKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3RzIGEgcHJlc2VuY2UgbWVzc2FnZVxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdFByZXNlbmNlKCkge1xuICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICAgIFB1Ymxpc2hpbmdJbnRlcnZhbDogY29uZmlndXJhdGlvbi5wcmVzZW5jZV9pbnRlcnZhbCxcbiAgICAgICAgICAgIEluc3RhbmNlOiBpbnN0YW5jZS5pbmZvKClcbiAgICAgICAgfTtcbiAgICAgICAgcC5NZXRob2REZWZpbml0aW9ucyA9IG1ldGhvZHMubWFwKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QubWV0aG9kO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICAvLyBUcnVlIGlmIHdlIHNob3VsZCBiZSBicm9hZGNhc3RpbmcgcHJlc2VuY2VzIGFuZCBoZWFydGJlYXRzLCBmYWxzZSBvdGhlcndpc2VcbiAgICB2YXIgYnJvYWRjYXN0aW5nID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBicm9hZGNhc3RpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIGJyb2FkY2FzdGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNlbmRzIGEgcHJlc2VuY2VcbiAgICBmdW5jdGlvbiBzZW5kUHJlc2VuY2UoKSB7XG4gICAgICAgIGlmIChicm9hZGNhc3RpbmcpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZCgnU2VydmVyUHJlc2VuY2VNZXNzYWdlJywgY29uc3RydWN0UHJlc2VuY2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZW5kcyBhIGhlYXJ0YmVhdFxuICAgIGZ1bmN0aW9uIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgICAgIGlmIChicm9hZGNhc3RpbmcpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZCgnU2VydmVySGVhcnRiZWF0TWVzc2FnZScsIGNvbnN0cnVjdEhlYXJ0YmVhdCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnZlcnRzIHRoZSBtZXRob2QgZGVmaW5pdGlvbiBmcm9tIGNhbWVsIGNhc2UgdG8gc25ha2UgY2FzZVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRNZXRob2QobWV0aG9kSWRlbnRpZmllcikge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgZ2l2ZW4gYSBzdHJpbmcgaW5zdGVhZCBvZiBhbiBvYmplY3QsIHdlIHByZXN1bWUgdGhhdCBpcyB0aGUgbWV0aG9kJ3MgbmFtZTpcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2RJZGVudGlmaWVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWV0aG9kSWRlbnRpZmllciA9IHsgbmFtZTogbWV0aG9kSWRlbnRpZmllciB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kSWRlbnRpZmllci52ZXJzaW9uICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbWV0aG9kSWRlbnRpZmllci52ZXJzaW9uID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG1ldGhvZCBkZWZpbml0aW9uIHRvIHRoZSBmb3JtYXQgdGhhdCBBR00gcmVxdWlyZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIE1ldGhvZDoge1xuICAgICAgICAgICAgICAgIE5hbWU6IG1ldGhvZElkZW50aWZpZXIubmFtZSxcbiAgICAgICAgICAgICAgICBJbnB1dFNpZ25hdHVyZTogbWV0aG9kSWRlbnRpZmllci5hY2NlcHRzLFxuICAgICAgICAgICAgICAgIFJlc3VsdFNpZ25hdHVyZTogbWV0aG9kSWRlbnRpZmllci5yZXR1cm5zLFxuICAgICAgICAgICAgICAgIERlc2NyaXB0aW9uOiBtZXRob2RJZGVudGlmaWVyLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIERpc3BsYXlOYW1lOiBtZXRob2RJZGVudGlmaWVyLmRpc3BsYXlfbmFtZSxcbiAgICAgICAgICAgICAgICBWZXJzaW9uOiBtZXRob2RJZGVudGlmaWVyLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgT2JqZWN0VHlwZVJlc3RyaWN0aW9uczogbWV0aG9kSWRlbnRpZmllci5vYmplY3RfdHlwZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWluc1Byb3BzKGZpbHRlciwgb2JqZWN0KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHRydWU7XG4gICAgICAgIE9iamVjdC5rZXlzKGZpbHRlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKGZpbHRlcltwcm9wXSAhPT0gb2JqZWN0W3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cblxuICAgIC8vIFVucmVnaXN0ZXJzIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIEFHTSBtZXRob2RcbiAgICBmdW5jdGlvbiB1bnJlZ2lzdGVyKG1ldGhvZEZpbHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZEZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1ldGhvZEZpbHRlciA9IHsgbmFtZTogbWV0aG9kRmlsdGVyIH07XG4gICAgICAgIH1cblxuICAgICAgICBtZXRob2RzID0gbWV0aG9kcy5maWx0ZXIoZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuICFjb250YWluc1Byb3BzKG1ldGhvZEZpbHRlciwgbWV0aG9kLmRlZmluaXRpb24pO1xuICAgICAgICB9KTtcblxuICAgICAgICBtZXRyaWMoJ1JlZ2lzdGVyZWQgbWV0aG9kcycsIG1ldGhvZHMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyByZWdpc3RlcjogcmVnaXN0ZXIsIHJlZ2lzdGVyQXN5bmM6IHJlZ2lzdGVyQXN5bmMsIHVucmVnaXN0ZXI6IHVucmVnaXN0ZXIsIHN0YXJ0OiBzdGFydCwgc3RvcDogc3RvcCwgY3JlYXRlU3RyZWFtOiBjcmVhdGVTdHJlYW0gfTtcbn07XG4iLCJ2YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vYWdtX2hlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29ubmVjdGlvbiwgaW5zdGFuY2UpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gc2VuZFJlc3VsdChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLlN0YXR1cyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuU3RhdHVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZCgnTWV0aG9kSW52b2NhdGlvblJlc3VsdE1lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1N0cmVhbU1zZ0ZvclN0cmVhbWluZ01ldGhvZChtc2csIG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgbXNnICYmXG4gICAgICAgICBtc2cuRXZlbnRTdHJlYW1BY3Rpb24gJiZcbiAgICAgICAgIG1zZy5FdmVudFN0cmVhbUFjdGlvbiAhPT0gMCAmJlxuICAgICAgICAgdHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcgJiYgbWV0aG9kLmRlZmluaXRpb24uc3VwcG9ydHNTdHJlYW1pbmcgPT09IHRydWVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzU3Vic2NyaWJlck1zZyhtc2csIHN0cmVhbWluZ01ldGhvZCkge1xuICAgICAgICBpZiAoIShtc2cgJiYgbXNnLkV2ZW50U3RyZWFtQWN0aW9uICYmIG1zZy5FdmVudFN0cmVhbUFjdGlvbiAhPT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtc2cuRXZlbnRTdHJlYW1BY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICAgIGNsaWVudFdpc2hlc1RvU3Vic2NyaWJlKG1zZywgc3RyZWFtaW5nTWV0aG9kKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG1zZy5FdmVudFN0cmVhbUFjdGlvbiA9PT0gMikge1xuICAgICAgICAgICAgY2xpZW50V2lzaGVzVG9VbnN1YnNjcmliZShtc2csIHN0cmVhbWluZ01ldGhvZCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtc2cuRXZlbnRTdHJlYW1BY3Rpb24gPT09IDMpIHtcbiAgICAgICAgICAgIGNsaWVudEFja25vd2xlZGdlc0l0RGlkU3Vic2NyaWJlKG1zZywgc3RyZWFtaW5nTWV0aG9kKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG1zZy5FdmVudFN0cmVhbUFjdGlvbiA9PT0gNCkge1xuICAgICAgICAgICAgY2xpZW50UGVyU3ViSGVhcnRiZWF0KG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogbXNnICdSZXF1ZXN0JyBBY3Rpb25zICovXG4gICAgLy8gYWN0aW9uIDFcbiAgICBmdW5jdGlvbiBjbGllbnRXaXNoZXNUb1N1YnNjcmliZShtc2csIHN0cmVhbWluZ01ldGhvZCkge1xuXG4gICAgICAgIGlmICghKFxuICAgICAgICAgc3RyZWFtaW5nTWV0aG9kICYmXG4gICAgICAgICBzdHJlYW1pbmdNZXRob2Quc3RyZWFtQ2FsbGJhY2tzICYmXG4gICAgICAgICB0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kLnN0cmVhbUNhbGxiYWNrcy5zdWJzY3JpcHRpb25SZXF1ZXN0SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3MtaW4gdGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgIHN0cmVhbWluZ01ldGhvZC5zdHJlYW1DYWxsYmFja3Muc3Vic2NyaXB0aW9uUmVxdWVzdEhhbmRsZXIoe1xuICAgICAgICAgICAgYWNjZXB0OiBhY2NlcHRSZXF1ZXN0T25CcmFuY2guYmluZChudWxsLCBtc2csIHN0cmVhbWluZ01ldGhvZCwgJycpLFxuICAgICAgICAgICAgYWNjZXB0T25CcmFuY2g6IGFjY2VwdFJlcXVlc3RPbkJyYW5jaC5iaW5kKG51bGwsIG1zZywgc3RyZWFtaW5nTWV0aG9kKSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogbXNnLkNvbnRleHQuQXJndW1lbnRzSnNvbiB8fCB7fSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBoZWxwZXJzLmNvbnZlcnRJbmZvVG9JbnN0YW5jZShtc2cuQ2xpZW50KSxcbiAgICAgICAgICAgIHJlamVjdDogcmVqZWN0UmVxdWVzdC5iaW5kKG51bGwsIG1zZywgc3RyZWFtaW5nTWV0aG9kKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhY3Rpb24gMlxuICAgIGZ1bmN0aW9uIGNsaWVudFdpc2hlc1RvVW5zdWJzY3JpYmUobXNnLCBzdHJlYW1pbmdNZXRob2QpIHtcblxuICAgICAgICBpZiAoIShcbiAgICAgICAgIHN0cmVhbWluZ01ldGhvZCAmJlxuICAgICAgICAgQXJyYXkuaXNBcnJheShzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucykgJiZcbiAgICAgICAgIHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbG9zZUluZGl2aWR1YWxTdWJzY3JpcHRpb24oc3RyZWFtaW5nTWV0aG9kLCBtc2cuU3RyZWFtSWQsIG1zZy5FdmVudFN0cmVhbVN1YmplY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBhY3Rpb24gM1xuICAgIGZ1bmN0aW9uIGNsaWVudEFja25vd2xlZGdlc0l0RGlkU3Vic2NyaWJlKG1zZywgc3RyZWFtaW5nTWV0aG9kKSB7XG4gICAgICAgIC8vIENsaWVudCBpbmRpY2F0ZXMgaXQgaXMgbGlzdGVuaW5nIHRvIGEgc3BlY2lmaWMgU3RyZWFtSWRcblxuICAgICAgICBpZiAodHlwZW9mIG1zZy5TdHJlYW1JZCAhPT0gJ3N0cmluZycgfHwgbXNnLlN0cmVhbUlkID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJyYW5jaEtleSA9IGdldEJyYW5jaEtleShzdHJlYW1pbmdNZXRob2QsIG1zZy5TdHJlYW1JZCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBicmFuY2hLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgYnJhbmNoS2V5OiBicmFuY2hLZXksXG4gICAgICAgICAgICBpbnN0YW5jZTogaGVscGVycy5jb252ZXJ0SW5mb1RvSW5zdGFuY2UobXNnLkNsaWVudCksXG4gICAgICAgICAgICBhcmd1bWVudHM6IG1zZy5Db250ZXh0LkFyZ3VtZW50c0pzb24sXG4gICAgICAgICAgICBzdHJlYW1JZDogbXNnLlN0cmVhbUlkLFxuICAgICAgICAgICAgcHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdDogbXNnLkV2ZW50U3RyZWFtU3ViamVjdCxcbiAgICAgICAgICAgIG1ldGhvZFJlc3BvbnNlU3ViamVjdDogbXNnLk1ldGhvZFJlc3BvbnNlU3ViamVjdFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiBiYWNrLW9iaiBpcyBzdG9yZWRcbiAgICAgICAgc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuXG4gICAgICAgIHZhciBzdWJGcm9udE9iaiA9IGNvbmp1cmVTdWJzY3JpcHRpb25Gcm9udE9iaihzdHJlYW1pbmdNZXRob2QsIHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHZhciBzdWJBZGRlZEhhbmRsZXIgPSBzdHJlYW1pbmdNZXRob2Quc3RyZWFtQ2FsbGJhY2tzLnN1YnNjcmlwdGlvbkFkZGVkSGFuZGxlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWJBZGRlZEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIFBhc3MtaW4gdGhlIHN1YnNjcmlwdGlvbiBvYmplY3RcbiAgICAgICAgICAgIHN1YkFkZGVkSGFuZGxlcihzdWJGcm9udE9iaik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhY3Rpb24gNFxuICAgIGZ1bmN0aW9uIGNsaWVudFBlclN1YkhlYXJ0YmVhdCgpIHtcbiAgICAgICAgLy8gQSBjbGllbnQgbWF5IGhhdmUgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucywgZWFjaCBvbmUgaGF2aW5nIGl0cyBvd24gaGVhcnRiZWF0XG4gICAgICAgIC8vIEN1cnJlbnRseSBub3QgaW1wbGVtZW50ZWQgYnkgdGhlIEdXIG9yIHRoZSBjbGllbnRcbiAgICB9XG5cbiAgICAvKiogKHJlcXVlc3QpIE1ldGhvZHMgKi9cbiAgICBmdW5jdGlvbiBhY2NlcHRSZXF1ZXN0T25CcmFuY2gobXNnLCBzdHJlYW1pbmdNZXRob2QsIGJyYW5jaCkge1xuICAgICAgICBpZiAodHlwZW9mIGJyYW5jaCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyYW5jaCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmVhbUlkID0gZ2V0U3RyZWFtSWQoc3RyZWFtaW5nTWV0aG9kLCBicmFuY2gpO1xuXG4gICAgICAgIHNlbmRSZXN1bHQoe1xuICAgICAgICAgICAgRXZlbnRTdHJlYW1BY3Rpb246IDMsXG4gICAgICAgICAgICBFdmVudFN0cmVhbVN1YmplY3Q6IHN0cmVhbWluZ01ldGhvZC5nbG9iYWxFdmVudFN0cmVhbVN1YmplY3QsXG4gICAgICAgICAgICBJbnZvY2F0aW9uSWQ6IG1zZy5Db250ZXh0Lkludm9jYXRpb25JZCxcbiAgICAgICAgICAgIE1ldGhvZE5hbWU6IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kLk5hbWUsXG4gICAgICAgICAgICBNZXRob2RSZXF1ZXN0U3ViamVjdDogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2RSZXF1ZXN0U3ViamVjdCxcbiAgICAgICAgICAgIE1ldGhvZFJlc3BvbnNlU3ViamVjdDogbXNnLk1ldGhvZFJlc3BvbnNlU3ViamVjdCxcbiAgICAgICAgICAgIE1ldGhvZFZlcnNpb246IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kLlZlcnNpb24sXG4gICAgICAgICAgICBSZXN1bHRNZXNzYWdlOiAnQWNjZXB0ZWQnLFxuICAgICAgICAgICAgU2VydmVyOiBpbnN0YW5jZS5pbmZvKCksXG4gICAgICAgICAgICBTdHJlYW1JZDogc3RyZWFtSWRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QnJhbmNoS2V5KHN0cmVhbWluZ01ldGhvZCwgc3RyZWFtSWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1JZCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHN0cmVhbWluZ01ldGhvZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZWVkbGUgPSBzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcC5maWx0ZXIoZnVuY3Rpb24gKGJyYW5jaCkge1xuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaC5zdHJlYW1JZCA9PT0gc3RyZWFtSWQ7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbmVlZGxlICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmVlZGxlLmtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZWVkbGUua2V5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0cmVhbUlkKHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoS2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgYnJhbmNoS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJhbmNoS2V5ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmVlZGxlQnJhbmNoID0gc3RyZWFtaW5nTWV0aG9kLmJyYW5jaEtleVRvU3RyZWFtSWRNYXAuZmlsdGVyKGZ1bmN0aW9uIChicmFuY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBicmFuY2gua2V5ID09PSBicmFuY2hLZXk7XG4gICAgICAgIH0pWzBdO1xuXG4gICAgICAgIHZhciBzdHJlYW1JZCA9IChuZWVkbGVCcmFuY2ggPyBuZWVkbGVCcmFuY2guc3RyZWFtSWQgOiB1bmRlZmluZWQpO1xuXG4gICAgICAgIGlmICh0eXBlb2ZcdHN0cmVhbUlkICE9PSAnc3RyaW5nJyB8fCBzdHJlYW1JZCA9PT0gJycpIHtcbiAgICAgICAgICAgIHN0cmVhbUlkID0gZ2VuZXJhdGVOZXdTdHJlYW1JZChzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZC5OYW1lKTtcbiAgICAgICAgICAgIHN0cmVhbWluZ01ldGhvZC5icmFuY2hLZXlUb1N0cmVhbUlkTWFwLnB1c2goeyBrZXk6IGJyYW5jaEtleSwgc3RyZWFtSWQ6IHN0cmVhbUlkIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmVhbUlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTmV3U3RyZWFtSWQoc3RyZWFtaW5nTWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgYXBwSW5mbyA9IGluc3RhbmNlLmluZm8oKTtcblxuICAgICAgICB2YXIgbmV3U3RyZWFtSWQgPSAnc3RyZWFtSWQtanNiIF9vZl8nICsgc3RyZWFtaW5nTWV0aG9kTmFtZSArICdfX2J5XycgKyBhcHBJbmZvLkFwcGxpY2F0aW9uTmFtZSArICdfJyArIGhlbHBlcnMuZ2VuZXJhdGVSYW5kb20oKTtcblxuICAgICAgICByZXR1cm4gbmV3U3RyZWFtSWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVqZWN0UmVxdWVzdChtc2csIHN0cmVhbWluZ01ldGhvZCwgcmVhc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVhc29uICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVhc29uID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBzZW5kUmVzdWx0KHtcbiAgICAgICAgICAgIEV2ZW50U3RyZWFtQWN0aW9uOiAyLFxuICAgICAgICAgICAgRXZlbnRTdHJlYW1TdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QuZ2xvYmFsRXZlbnRTdHJlYW1TdWJqZWN0LFxuICAgICAgICAgICAgLy8gSW52b2NhdGlvbklkOiBtc2cuQ29udGV4dC5JbnZvY2F0aW9uSWQsXG4gICAgICAgICAgICBNZXRob2ROYW1lOiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZC5OYW1lLFxuICAgICAgICAgICAgTWV0aG9kUmVxdWVzdFN1YmplY3Q6IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kUmVxdWVzdFN1YmplY3QsXG4gICAgICAgICAgICBNZXRob2RSZXNwb25zZVN1YmplY3Q6IG1zZy5NZXRob2RSZXNwb25zZVN1YmplY3QsXG4gICAgICAgICAgICBNZXRob2RWZXJzaW9uOiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZC5WZXJzaW9uLFxuICAgICAgICAgICAgUmVzdWx0TWVzc2FnZTogcmVhc29uLFxuICAgICAgICAgICAgU2VydmVyOiBpbnN0YW5jZS5pbmZvKCksXG4gICAgICAgICAgICBTdHJlYW1JZDogJ2RlZmF1bHRfcmVqZWN0aW9uX3N0cmVhbUlkJ1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogKHN1YnNjcmlwdGlvbikgTWV0aG9kcyAqL1xuICAgIGZ1bmN0aW9uIGNvbmp1cmVTdWJzY3JpcHRpb25Gcm9udE9iaihzdHJlYW1pbmdNZXRob2QsIHN1YnNjcmlwdGlvbikge1xuICAgICAgICAvLyBleHBvc2UgYSBzdWJzY3JpcHRpb24gdG8gdGhlIHVzZXJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFyZ3VtZW50czogc3Vic2NyaXB0aW9uLmFyZ3VtZW50cyB8fCB7fSxcbiAgICAgICAgICAgIGJyYW5jaEtleTogc3Vic2NyaXB0aW9uLmJyYW5jaEtleSxcbiAgICAgICAgICAgIGNsb3NlOiBjbG9zZUluZGl2aWR1YWxTdWJzY3JpcHRpb24uYmluZChcbiAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgIHN0cmVhbWluZ01ldGhvZCxcbiAgICAgICAgICAgICBzdWJzY3JpcHRpb24uc3RyZWFtSWQsXG4gICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnByaXZhdGVFdmVudFN0cmVhbVN1YmplY3QsXG4gICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBzdWJzY3JpcHRpb24uaW5zdGFuY2UsXG4gICAgICAgICAgICBwdXNoOiBwdXNoRGF0YVRvU2luZ2xlLmJpbmQobnVsbCwgc3RyZWFtaW5nTWV0aG9kLCBzdWJzY3JpcHRpb24pLFxuICAgICAgICAgICAgc3RyZWFtOiBzdHJlYW1pbmdNZXRob2QuZGVmaW5pdGlvblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmp1cmVCcmFuY2hGcm9udE9iaihzdHJlYW1pbmdNZXRob2QsIGJyYW5jaEtleSkge1xuICAgICAgICAvLyBleHBvc2UgYSBicmFuY2ggdG8gdGhlIHVzZXJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogYnJhbmNoS2V5LFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogZ2V0U3Vic2NyaXB0aW9uTGlzdC5iaW5kKG51bGwsIHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoS2V5KSxcbiAgICAgICAgICAgIGNsb3NlOiBjbG9zZU11bHRpcGxlU3Vic2NyaXB0aW9ucy5iaW5kKG51bGwsIHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoS2V5KSxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcHVzaFRvQnJhbmNoKHN0cmVhbWluZ01ldGhvZCwgZGF0YSwgYnJhbmNoS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZUluZGl2aWR1YWxTdWJzY3JpcHRpb24oc3RyZWFtaW5nTWV0aG9kLCBzdHJlYW1JZCwgcHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdCwgc2VuZEtpY2tNZXNzYWdlKSB7XG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoc3ViSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICBzdWJJdGVtLnByaXZhdGVFdmVudFN0cmVhbVN1YmplY3QgPT09IHByaXZhdGVFdmVudFN0cmVhbVN1YmplY3QgJiYgc3ViSXRlbS5zdHJlYW1JZCA9PT0gc3RyZWFtSWQpO1xuICAgICAgICB9KVswXTtcblxuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gdW5yZWNvZ25pc2VkIHN1YnNjcmlwdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluaXRpYWxMZW5ndGggPSBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMgPSBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHN1Ykl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiAhKFxuICAgICAgICAgICAgIHN1Ykl0ZW0ucHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdCA9PT0gc3Vic2NyaXB0aW9uLnByaXZhdGVFdmVudFN0cmVhbVN1YmplY3QgJiYgc3ViSXRlbS5zdHJlYW1JZCA9PT0gc3Vic2NyaXB0aW9uLnN0cmVhbUlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZpbHRlcmVkTGVuZ3RoID0gc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChmaWx0ZXJlZExlbmd0aCAhPT0gKGluaXRpYWxMZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyB0aGUgc3Vic2NyaXB0aW9uIHdhc24ndCByZW1vdmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VuZEtpY2tNZXNzYWdlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzZW5kUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBFdmVudFN0cmVhbUFjdGlvbjogMixcbiAgICAgICAgICAgICAgICBFdmVudFN0cmVhbVN1YmplY3Q6IHByaXZhdGVFdmVudFN0cmVhbVN1YmplY3QsXG4gICAgICAgICAgICAgICAgTWV0aG9kTmFtZTogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSxcbiAgICAgICAgICAgICAgICBNZXRob2RSZXF1ZXN0U3ViamVjdDogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2RSZXF1ZXN0U3ViamVjdCxcbiAgICAgICAgICAgICAgICBNZXRob2RSZXNwb25zZVN1YmplY3Q6IHN1YnNjcmlwdGlvbi5tZXRob2RSZXNwb25zZVN1YmplY3QsXG4gICAgICAgICAgICAgICAgTWV0aG9kVmVyc2lvbjogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuVmVyc2lvbixcbiAgICAgICAgICAgICAgICBSZXNwb25zZUNvbnRleHRKc29uOiB7fSxcbiAgICAgICAgICAgICAgICBTZXJ2ZXI6IGluc3RhbmNlLmluZm8oKSxcbiAgICAgICAgICAgICAgICBTdHJlYW1JZDogc3Vic2NyaXB0aW9uLnN0cmVhbUlkLFxuICAgICAgICAgICAgICAgIFN0YXR1czogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ViUmVtb3ZlZEhhbmRsZXIgPSBzdHJlYW1pbmdNZXRob2Quc3RyZWFtQ2FsbGJhY2tzLnN1YnNjcmlwdGlvblJlbW92ZWRIYW5kbGVyO1xuICAgICAgICBpZiAodHlwZW9mIHN1YlJlbW92ZWRIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaWJlciA9IHN1YnNjcmlwdGlvbi5pbnN0YW5jZTtcbiAgICAgICAgICAgIHN1YlJlbW92ZWRIYW5kbGVyKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2VNdWx0aXBsZVN1YnNjcmlwdGlvbnMoc3RyZWFtaW5nTWV0aG9kLCBicmFuY2hLZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1pbmdNZXRob2QgIT09ICdvYmplY3QnIHx8ICFBcnJheS5pc0FycmF5KHN0cmVhbWluZ01ldGhvZC5icmFuY2hLZXlUb1N0cmVhbUlkTWFwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmVhbUxpc3QgPSBzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcDtcblxuICAgICAgICBpZiAodHlwZW9mIGJyYW5jaEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0cmVhbUxpc3QgPSBzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcC5maWx0ZXIoZnVuY3Rpb24gKGJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgYnIgPT09ICdvYmplY3QnICYmIGJyLmtleSA9PT0gYnJhbmNoS2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgZ2V0dGluZyB0aGUgdW5pcXVlIGJyYW5jaCBrZXlzIGZyb20gJ2xpdmUgc3Vic2NyaWJlcnMnXG5cbiAgICAgICAgc3RyZWFtTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChicikge1xuICAgICAgICAgICAgdmFyIHN0cmVhbUlkID0gYnIuc3RyZWFtSWQ7XG5cbiAgICAgICAgICAgIHNlbmRSZXN1bHQoe1xuICAgICAgICAgICAgICAgIEV2ZW50U3RyZWFtQWN0aW9uOiAyLFxuICAgICAgICAgICAgICAgIEV2ZW50U3RyZWFtU3ViamVjdDogc3RyZWFtaW5nTWV0aG9kLmdsb2JhbEV2ZW50U3RyZWFtU3ViamVjdCxcbiAgICAgICAgICAgICAgICBNZXRob2ROYW1lOiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZC5OYW1lLFxuICAgICAgICAgICAgICAgIE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuICAgICAgICAgICAgICAgIFNlcnZlcjogaW5zdGFuY2UuaW5mbygpLFxuICAgICAgICAgICAgICAgIFN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICBTdGF0dXM6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoRGF0YVRvU2luZ2xlKHN0cmVhbWluZ01ldGhvZCwgc3Vic2NyaXB0aW9uLCBkYXRhKSB7XG5cbiAgICAgICAgLy8gVE9ETyB2YWxpZGF0ZSBkYXRhIGlzIGEgcGxhaW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMuIERhdGEgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZW5kUmVzdWx0KHtcbiAgICAgICAgICAgIEV2ZW50U3RyZWFtQWN0aW9uOiA1LFxuICAgICAgICAgICAgRXZlbnRTdHJlYW1TdWJqZWN0OiBzdWJzY3JpcHRpb24ucHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdCxcbiAgICAgICAgICAgIE1ldGhvZE5hbWU6IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kLk5hbWUsXG4gICAgICAgICAgICBNZXRob2RSZXF1ZXN0U3ViamVjdDogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2RSZXF1ZXN0U3ViamVjdCxcbiAgICAgICAgICAgIFJlc3VsdENvbnRleHRKc29uOiBkYXRhLFxuICAgICAgICAgICAgU2VydmVyOiBpbnN0YW5jZS5pbmZvKCksXG4gICAgICAgICAgICBTdHJlYW1JZDogc3Vic2NyaXB0aW9uLnN0cmVhbUlkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hUb0JyYW5jaChzdHJlYW1pbmdNZXRob2QsIGRhdGEsIGJyYW5jaGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kICE9PSAnb2JqZWN0JyB8fCAhQXJyYXkuaXNBcnJheShzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gdmFsaWRhdGUgZGF0YSBpcyBhIHBsYWluIG9iamVjdFxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzLiBEYXRhIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBicmFuY2hlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyYW5jaGVzID0gW2JyYW5jaGVzXTsgLy8gdXNlciB3YW50cyB0byBwdXNoIHRvIHNpbmdsZSBicmFuY2hcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShicmFuY2hlcykgfHwgYnJhbmNoZXMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIGJyYW5jaGVzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgU3RyZWFtSWQncyBmcm9tIHRoZSBtZXRob2QncyBicmFuY2ggbWFwXG4gICAgICAgIHZhciBzdHJlYW1JZExpc3QgPSBzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcFxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgIGJyYW5jaGVzID09PSBudWxsIHx8IChCb29sZWFuKGJyKSAmJiB0eXBlb2YgYnIua2V5ID09PSAnc3RyaW5nJyAmJiBicmFuY2hlcy5pbmRleE9mKGJyLmtleSkgPj0gMCkpO1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChicikge1xuICAgICAgICAgICAgICAgIHJldHVybiBici5zdHJlYW1JZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHN0cmVhbUlkTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW1JZCkge1xuXG4gICAgICAgICAgICBzZW5kUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBFdmVudFN0cmVhbUFjdGlvbjogNSxcbiAgICAgICAgICAgICAgICBFdmVudFN0cmVhbVN1YmplY3Q6IHN0cmVhbWluZ01ldGhvZC5nbG9iYWxFdmVudFN0cmVhbVN1YmplY3QsXG4gICAgICAgICAgICAgICAgTWV0aG9kTmFtZTogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSxcbiAgICAgICAgICAgICAgICBNZXRob2RSZXF1ZXN0U3ViamVjdDogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2RSZXF1ZXN0U3ViamVjdCxcbiAgICAgICAgICAgICAgICBSZXN1bHRDb250ZXh0SnNvbjogZGF0YSxcbiAgICAgICAgICAgICAgICBTZXJ2ZXI6IGluc3RhbmNlLmluZm8oKSxcbiAgICAgICAgICAgICAgICBTdHJlYW1JZDogc3RyZWFtSWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uTGlzdChzdHJlYW1pbmdNZXRob2QsIGJyYW5jaEtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0cmVhbWluZ01ldGhvZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gW107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBicmFuY2hLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zID0gc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zID0gc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViLmJyYW5jaEtleSA9PT0gYnJhbmNoS2V5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9ucy5tYXAoZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmp1cmVTdWJzY3JpcHRpb25Gcm9udE9iaihzdHJlYW1pbmdNZXRob2QsIHN1Yik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJyYW5jaExpc3Qoc3RyZWFtaW5nTWV0aG9kKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXF1ZUJyYW5jaE5hbWVzID0gZ2V0VW5pcXVlQnJhbmNoTmFtZXMoc3RyZWFtaW5nTWV0aG9kKTtcblxuICAgICAgICByZXR1cm4gdW5pcXVlQnJhbmNoTmFtZXMubWFwKGZ1bmN0aW9uIChicmFuY2hLZXkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbmp1cmVCcmFuY2hGcm9udE9iaihzdHJlYW1pbmdNZXRob2QsIGJyYW5jaEtleSk7XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VW5pcXVlQnJhbmNoTmFtZXMoc3RyZWFtaW5nTWV0aG9kKSB7XG4gICAgICAgIHZhciBrZXlzV2l0aER1cGxpY2F0ZXMgPSBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucy5tYXAoZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1YiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHN1Yi5icmFuY2hLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3ViLmJyYW5jaEtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHNlZW4gPSBbXTtcblxuICAgICAgICB2YXIgYnJhbmNoQXJyYXkgPSBrZXlzV2l0aER1cGxpY2F0ZXMuZmlsdGVyKGZ1bmN0aW9uIChiS2V5KSB7XG4gICAgICAgICAgICBpZiAoYktleSA9PT0gbnVsbCB8fCBzZWVuLmluZGV4T2YoYktleSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2Vlbi5wdXNoKGJLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBicmFuY2hBcnJheTtcbiAgICB9XG5cbiAgICByZXR1cm4geyAvLyBhbiBpbnN0YW5jZSBmbyB0aGUgcHVibGlzaGVyXG4gICAgICAgIGlzU3RyZWFtTXNnOiBpc1N0cmVhbU1zZ0ZvclN0cmVhbWluZ01ldGhvZCxcbiAgICAgICAgcHJvY2Vzc1N1YnNjcmliZXJNc2c6IHByb2Nlc3NTdWJzY3JpYmVyTXNnLFxuICAgICAgICBwdXNoRGF0YTogcHVzaFRvQnJhbmNoLFxuICAgICAgICBjbG9zZUFsbFN1YnNjcmlwdGlvbnM6IGNsb3NlTXVsdGlwbGVTdWJzY3JpcHRpb25zLFxuICAgICAgICBnZXRTdWJzY3JpcHRpb25MaXN0OiBnZXRTdWJzY3JpcHRpb25MaXN0LFxuICAgICAgICBnZXRCcmFuY2hMaXN0OiBnZXRCcmFuY2hMaXN0LFxuICAgICAgICBnZW5lcmF0ZU5ld1N0cmVhbUlkOiBnZW5lcmF0ZU5ld1N0cmVhbUlkXG4gICAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIFwidGljazQyLWFnbUBeMi4zLjVcIixcbiAgICAgIFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxkZXZcXFxcanMtZ2x1ZVwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwidGljazQyLWFnbUA+PTIuMy41IDwzLjAuMFwiLFxuICBcIl9pZFwiOiBcInRpY2s0Mi1hZ21AMi4zLjVcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi90aWNrNDItYWdtXCIsXG4gIFwiX25vZGVWZXJzaW9uXCI6IFwiNi4wLjBcIixcbiAgXCJfbnBtVXNlclwiOiB7fSxcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjMuMTAuNVwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwidGljazQyLWFnbVwiLFxuICAgIFwicmF3XCI6IFwidGljazQyLWFnbUBeMi4zLjVcIixcbiAgICBcInJhd1NwZWNcIjogXCJeMi4zLjVcIixcbiAgICBcInNjb3BlXCI6IG51bGwsXG4gICAgXCJzcGVjXCI6IFwiPj0yLjMuNSA8My4wLjBcIixcbiAgICBcInR5cGVcIjogXCJyYW5nZVwiXG4gIH0sXG4gIFwiX3JlcXVpcmVkQnlcIjogW1xuICAgIFwiL1wiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cDovLzE5Mi4xNjguMC4yMzQ6NDg3My90aWNrNDItYWdtLy0vdGljazQyLWFnbS0yLjMuNS50Z3pcIixcbiAgXCJfc2hhc3VtXCI6IFwiOTYzOWZiMDBlOThkOTQxNTViMTkwZDk3MDM3M2JiOGU1Njk5Mzg3N1wiLFxuICBcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG4gIFwiX3NwZWNcIjogXCJ0aWNrNDItYWdtQF4yLjMuNVwiLFxuICBcIl93aGVyZVwiOiBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcZGV2XFxcXGpzLWdsdWVcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIlRpY2s0MlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cDovL3d3dy50aWNrNDIuY29tXCJcbiAgfSxcbiAgXCJiaW5cIjoge1xuICAgIFwiYWdtXCI6IFwiYmluL2FnbVwiLFxuICAgIFwiYnVpbGRcIjogXCIuL2Jpbi9idWlsZC5qc1wiLFxuICAgIFwiY2xlYW5cIjogXCIuL2Jpbi9jbGVhbi5qc1wiLFxuICAgIFwiZmlsZS12ZXJzaW9uaWZ5XCI6IFwiLi9iaW4vZmlsZS12ZXJzaW9uaWZ5LmpzXCIsXG4gICAgXCJtaW5pZnlcIjogXCIuL2Jpbi9taW5pZnkuanNcIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9qaXJhLnRpY2s0Mi5jb20vYnJvd3NlL0FQUENUUkxcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJlczYtcHJvbWlzZVwiOiBcIl4zLjAuMlwiLFxuICAgIFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvblwiOiBcIl4xLjEuMlwiLFxuICAgIFwidXRpbC1kZXByZWNhdGVcIjogXCJeMS4wLjJcIlxuICB9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSmF2YVNjcmlwdCBBR01cIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmxhbmtldFwiOiBcIl4xLjEuNlwiLFxuICAgIFwiYmx1ZWJpcmRcIjogXCJeMi45LjMwXCIsXG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjEzLjAuMFwiLFxuICAgIFwiYnJvd3NlcmlmeS1yZXBsYWNpZnlcIjogXCJeMC4wLjRcIixcbiAgICBcImJyb3dzZXJpZnktdmVyc2lvbmlmeVwiOiBcIl4xLjAuNFwiLFxuICAgIFwiZXNsaW50XCI6IFwiXjMuMS4xXCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXN0YW5kYXJkXCI6IFwiXjUuMy41XCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXRpY2s0MlwiOiBcIl4xLjAuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1wcm9taXNlXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXN0YW5kYXJkXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJmc1wiOiBcIjAuMC4yXCIsXG4gICAgXCJodHRwLXNlcnZlclwiOiBcIl4wLjkuMFwiLFxuICAgIFwianNkb21cIjogXCJeOC4xLjBcIixcbiAgICBcIm1pbmlmeWlmeVwiOiBcIl43LjMuMlwiLFxuICAgIFwib25jaGFuZ2VcIjogXCJeMi4xLjJcIixcbiAgICBcInBoYW50b21qc1wiOiBcIl4xLjkuMTJcIixcbiAgICBcInF1bml0anNcIjogXCJeMS4xNS4wXCIsXG4gICAgXCJzaGVsbGpzXCI6IFwiXjAuNi4wXCJcbiAgfSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcIjk2MzlmYjAwZTk4ZDk0MTU1YjE5MGQ5NzAzNzNiYjhlNTY5OTM4NzdcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi1hZ20vLS90aWNrNDItYWdtLTIuMy41LnRnelwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcIjljMDg4N2U0NjRlMTA0NjlmNDkxYzkzOGFkNmUyNDdlMTJmYzg1NTJcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJhZ21cIixcbiAgICBcImphdmFzY3JpcHRcIixcbiAgICBcImxpYnJhcnlcIlxuICBdLFxuICBcIm1haW5cIjogXCJsaWJyYXJ5L2FnbS5qc1wiLFxuICBcIm5hbWVcIjogXCJ0aWNrNDItYWdtXCIsXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnVpbGRcIjogXCJucG0gcnVuIGVzbGludCAmJiBub2RlIGJpbi9jbGVhbi5qcyAmJiBub2RlIGJpbi9idWlsZC5qcyAmJiBub2RlIGJpbi9taW5pZnkgJiYgbm9kZSBiaW4vZmlsZS12ZXJzaW9uaWZ5XCIsXG4gICAgXCJlc2xpbnRcIjogXCJlc2xpbnQgbGlicmFyeVwiLFxuICAgIFwiZXNsaW50OmZpeFwiOiBcImVzbGludCBsaWJyYXJ5IC0tZml4XCIsXG4gICAgXCJwcmVwdWJsaXNoXCI6IFwibnBtIHVwZGF0ZSAmIG5wbSBydW4gYnVpbGRcIixcbiAgICBcInNlcnZlXCI6IFwiaHR0cC1zZXJ2ZXIgLXAgODAwMCAtYSAxMjcuMC4wLjFcIixcbiAgICBcInRlc3RcIjogXCJucG0gcnVuIGVzbGludCAmJiBtb2NoYSAtLXJlcXVpcmUgLi90ZXN0L3Rlc3RfaGVscGVyIFxcXCJ0ZXN0LyoqLyouanNcXFwiXCIsXG4gICAgXCJ3YXRjaFwiOiBcIm9uY2hhbmdlIFxcXCIuL2xpYnJhcnkvKiovKi5qc1xcXCIgLWl2IC1lIFxcXCIuL2JpblxcXCIgLS0gbnBtIHJ1biBidWlsZFwiXG4gIH0sXG4gIFwidGl0bGVcIjogXCJUaWNrNDIgQUdNXCIsXG4gIFwidmVyc2lvblwiOiBcIjIuMy41XCJcbn1cbiIsInZhciBhcHBsaWNhdGlvbiA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0aW9uXCIpO1xudmFyIGluc3RhbmNlID0gcmVxdWlyZShcIi4vaW5zdGFuY2VcIik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG52YXIgUGFja2FnZUpzb24gPSByZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpO1xudmFyIGRlcHJlY2F0ZSA9IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJyk7XG52YXIgY3VpZCA9IHJlcXVpcmUoJ2N1aWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuYXBwX21hbmFnZXIgPSBmdW5jdGlvbiBhcHBfbWFuYWdlcihhZ20sIHdpbmRvd3MpIHtcblx0dmFyIHRva2VuID0gY3VpZCgpO1xuXG5cdHZhciBpbnN0YW5jZUlkRnVuY3Rpb24gPSBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLkNvbnRleHQpIHtcblx0XHRcdGlmIChlLkNvbnRleHQuX3Q0MiAmJiBlLkNvbnRleHQuX3Q0Mi5pZCkge1xuXHRcdFx0XHRyZXR1cm4gZS5Db250ZXh0Ll90NDIuaWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRcdGlmIChlLkNvbnRleHQuZ3VpZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBlLkNvbnRleHQuZ3VpZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGUuTmFtZSArICdfJyArIGUuSWQ7XG5cdH07XG5cbiAgICAvLyBJbnRlcm5hbCBpZCBpcyB0aGUgaWQgd2UgdXNlIGZvciB0cmFja2luZ1xuICAgIHZhciBnZXRJbnRlcm5hbEluc3RhbmNlSWQgPSBmdW5jdGlvbihpbnN0YW5jZSl7XG4gICAgICAgIGlmIChpbnN0YW5jZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuY29udGV4dC5fdDQyICYmIGluc3RhbmNlLmNvbnRleHQuX3Q0Mi5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5jb250ZXh0Ll90NDIuaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5jb250ZXh0Lmd1aWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuY29udGV4dC5ndWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmFwcGxpY2F0aW9uLm5hbWUgKyAnXycgKyBpbnN0YW5jZS5pZDtcbiAgICB9O1xuXG5cdHZhciBicmFuY2hfY2hhbmdlZF9jYWxsYmFjaztcblxuXHR2YXIgYXBwcyA9IGFwcGxpY2F0aW9uKGFnbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5zdGFuY2VzO30sIHRva2VuKTtcblx0dmFyIGluc3RhbmNlcyA9IGluc3RhbmNlKGFnbSwgYXBwcywgdG9rZW4sIGluc3RhbmNlSWRGdW5jdGlvbik7XG5cdHZhciBtYW5hZ2VyID0ge1xuXHRcdHRva2VuOiB0b2tlbixcblx0XHRhcHBsaWNhdGlvbnM6IGFwcHMuYWxsLFxuXHRcdGFwcGxpY2F0aW9uOiBhcHBzLmdldF9ieV9pZCxcblx0XHRvbkFwcEFkZGVkOiBoZWxwZXJzLmFkZF9jYWxsYmFjayhcImFkZGVkXCIpLmJpbmQoYXBwcyksXG5cdFx0b25BcHBBdmFpbGFibGU6IGhlbHBlcnMuYWRkX2NhbGxiYWNrKFwiYXZhaWxhYmxlXCIpLmJpbmQoYXBwcyksXG5cdFx0b25BcHBSZW1vdmVkOiBoZWxwZXJzLmFkZF9jYWxsYmFjayhcInJlbW92ZWRcIikuYmluZChhcHBzKSxcblx0XHRvbkFwcFVuYXZhaWxhYmxlOiBoZWxwZXJzLmFkZF9jYWxsYmFjayhcInVuYXZhaWxhYmxlXCIpLmJpbmQoYXBwcyksXG5cblx0XHRpbnN0YW5jZXM6IGluc3RhbmNlcy5hbGwsXG5cdFx0b25JbnN0YW5jZVN0YXJ0ZWQ6IGhlbHBlcnMuYWRkX2NhbGxiYWNrKFwic3RhcnRlZFwiKS5iaW5kKGluc3RhbmNlcyksXG5cdFx0b25JbnN0YW5jZVN0b3BwZWQ6IGhlbHBlcnMuYWRkX2NhbGxiYWNrKFwic3RvcHBlZFwiKS5iaW5kKGluc3RhbmNlcyksXG5cdFx0b25JbnN0YW5jZVVwZGF0ZWQ6IGhlbHBlcnMuYWRkX2NhbGxiYWNrKFwidXBkYXRlZFwiKS5iaW5kKGluc3RhbmNlcyksXG5cblx0XHRnZXRCcmFuY2hlczogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5HZXRCcmFuY2hlc1wiLCB7fSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZiAoc3VjY2Vzcykge1xuXHRcdFx0XHRcdHN1Y2Nlc3MoaGVscGVycy52YWxzKGUucmV0dXJuZWQuQnJhbmNoZXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgZXJyb3IpO1xuXHRcdH0sXG5cdFx0Z2V0Q3VycmVudEJyYW5jaDogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5HZXRDdXJyZW50QnJhbmNoXCIsIHt9LCBcImJlc3RcIiwge30sIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmIChzdWNjZXNzKSB7XG5cdFx0XHRcdFx0c3VjY2VzcyhlLnJldHVybmVkLkJyYW5jaCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGVycm9yKTtcblx0XHR9LFxuXHRcdHNldEN1cnJlbnRCcmFuY2g6IGZ1bmN0aW9uIChicmFuY2gsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5TZXRDdXJyZW50QnJhbmNoXCIsIHtCcmFuY2g6IGJyYW5jaH0sIFwiYmVzdFwiLCB7fSwgc3VjY2VzcywgZXJyb3IpO1xuXHRcdH0sXG5cdFx0Y3VycmVudFVzZXI6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0VXNlclwiLCB7fSwgXCJiZXN0XCIsIHt9LCBzdWNjZXNzLCBlcnJvcik7XG5cdFx0fSxcblx0XHRnZXRGdW5jdGlvbmFsRW50aXRsZW1lbnQ6IGZ1bmN0aW9uIChmbiwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkdldEZ1bmN0aW9uYWxFbnRpdGxlbWVudFwiLCB7RnVuY3Rpb246IGZufSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZiAoc3VjY2Vzcykge1xuXHRcdFx0XHRcdHN1Y2Nlc3MoZS5yZXR1cm5lZC5FbnRpdGxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGVycm9yKTtcblx0XHR9LFxuXHRcdGdldEZ1bmN0aW9uYWxFbnRpdGxlbWVudEJyYW5jaDogZnVuY3Rpb24gKGZuLCBiciwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkdldEZ1bmN0aW9uYWxFbnRpdGxlbWVudFwiLCB7RnVuY3Rpb246IGZuLCBCcmFuY2g6IGJyfSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZiAoc3VjY2Vzcykge1xuXHRcdFx0XHRcdHN1Y2Nlc3MoZS5yZXR1cm5lZC5FbnRpdGxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGVycm9yKTtcblx0XHR9LFxuXHRcdGNhbkk6IGZ1bmN0aW9uIChmbiwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkNhbklcIiwge0Z1bmN0aW9uOiBmbn0sIFwiYmVzdFwiLCB7fSwgc3VjY2VzcywgZXJyb3IpO1xuXHRcdH0sXG5cblx0XHRjYW5JQnJhbmNoOiBmdW5jdGlvbihmbiwgYnJhbmNoLCBzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuQ2FuSVwiLCB7RnVuY3Rpb246IGZuLCBCcmFuY2g6IGJyYW5jaH0sIFwiYmVzdFwiLCB7fSwgc3VjY2VzcywgZXJyb3IpO1xuXHRcdH0sXG5cblx0XHRleGl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5TaHV0ZG93blwiLCB7fSwgXCJhbGxcIiwge30sXG5cdFx0XHRcdGZ1bmN0aW9uIChhKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coZSk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRzZXRSZWdpb246IGZ1bmN0aW9uIChyZWdpb24sIHN1Y2Nlc3MsIGVycm9yKXtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLlNldENvbmZpZ3VyYXRpb25SZWdpb25cIiwge1JlZ2lvbjogcmVnaW9ufSwgXCJiZXN0XCIsIHt9LCBzdWNjZXNzLCBlcnJvcik7XG5cdFx0fSxcblxuXHRcdGdldFJlZ2lvbjogZnVuY3Rpb24oc3VjY2VzcywgZXJyb3Ipe1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0Q29uZmlndXJhdGlvblJlZ2lvblwiLCB7fSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZiAoc3VjY2Vzcykge1xuXHRcdFx0XHRcdHN1Y2Nlc3MoZS5yZXR1cm5lZC5SZWdpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBlcnJvcik7XG5cdFx0fSxcblxuXHRcdF90cmlnZ2VyX2FwcF9ldmVudDogYXBwcy5fdHJpZ2dlcixcblx0XHRfdHJpZ2dlcl9pbnN0YW5jZV9ldmVudDogaW5zdGFuY2VzLl90cmlnZ2VyXG5cblx0fTtcblxuXG5cblx0Ly9UZWxsIHRoZSBhcHAgd2hlbiBpdHMgaW5zdGFuY2VzIGFyZSBhZGRlZC9yZW1vdmVkXG5cdG1hbmFnZXIub25JbnN0YW5jZVN0YXJ0ZWQoZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdFx0aWYgKGluc3RhbmNlLmFwcGxpY2F0aW9uKSB7XG5cdFx0XHQvL1RyaWdnZXIgXCJpbnN0YW5jZV9zdGFydGVkXCIgZXZlbnQgb24gYXBwbGljYXRpb25cblx0XHRcdG1hbmFnZXIuX3RyaWdnZXJfYXBwX2V2ZW50KFwiaW5zdGFuY2VTdGFydGVkXCIsIGluc3RhbmNlLCBpbnN0YW5jZS5hcHBsaWNhdGlvbi5uYW1lKTtcblxuXHRcdFx0Ly9UcmlnZ2VyIFwid2luZG93X29wZW5lZFwiIGV2ZW50IG9uIGluc3RhbmNlXG5cdFx0XHR2YXIgY29udGFpbmVyO1xuXHRcdFx0aWYgKHdpbmRvd3MgJiYgZ2x1ZSkge1xuXHRcdFx0XHRjb250YWluZXIgPSBpbnN0YW5jZS5hcHBsaWNhdGlvbi5jb25maWd1cmF0aW9uLmNvbnRhaW5lcjtcblx0XHRcdFx0aWYoY29udGFpbmVyICE9PSBudWxsICYmIGNvbnRhaW5lciAhPT0gXCJcIil7XG5cdFx0XHRcdFx0Z2x1ZS5hZ20uaW52b2tlKFwiVDQyLlduZC5GaW5kQnlJZFwiLCB7d2luZG93SWQ6IGluc3RhbmNlLmlkfSwge2FwcGxpY2F0aW9uOiBjb250YWluZXJ9LCB7fSwgd2luZG93X29wZW5lZCwgZnVuY3Rpb24oZSl7Y29uc29sZS5sb2coZSl9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdpbmRvd19vcGVuZWQoYSkge1xuXHRcdFx0Ly9XcmFwIHRoZSB3aW5kb3cgaW4gYSB3aW5kb3cgb2JqZWN0LCB1c2luZyB0aGUgZ2x1ZSB3aW5kb3dzIGxpYlxuXHRcdFx0dmFyIHcgPSBhLnJldHVybmVkIFtPYmplY3Qua2V5cyhhLnJldHVybmVkKVswXV07XG5cdFx0XHR2YXIgd2luID0gZ2x1ZS53aW5kb3dzLl9mcm9tX2V2ZW50KHcud2luZG93TmFtZSwgY29udGFpbmVyLCB3LnVybCwgdy53aW5kb3dJZCwgdy53aW5kb3dTdHlsZUF0dHJpYnV0ZXMsIHcud2luZG93VGl0bGUpO1xuXG5cdFx0XHQvL1RyaWdnZXIgdGhlIHdpbmRvdyBvcGVuZWQgZXZlbnRcblx0XHRcdG1hbmFnZXIuX3RyaWdnZXJfaW5zdGFuY2VfZXZlbnQoXCJ3aW5kb3dBZGRlZFwiLCB3aW4sIGlkKTtcblx0XHR9XG5cdH0pO1xuXG5cdG1hbmFnZXIub25JbnN0YW5jZVN0b3BwZWQoZnVuY3Rpb24gKGluc3RhbmNlKSB7XG5cdFx0aWYgKGluc3RhbmNlLmFwcGxpY2F0aW9uKSB7XG5cdFx0XHRtYW5hZ2VyLl90cmlnZ2VyX2FwcF9ldmVudChcImluc3RhbmNlU3RvcHBlZFwiLCBpbnN0YW5jZSwgaW5zdGFuY2UuYXBwbGljYXRpb24ubmFtZSk7XG5cblx0XHRcdHZhciBpZCA9IGdldEludGVybmFsSW5zdGFuY2VJZChpbnN0YW5jZSk7XG5cdFx0XHRtYW5hZ2VyLl90cmlnZ2VyX2luc3RhbmNlX2V2ZW50KFwid2luZG93UmVtb3ZlZFwiLCB7fSwgaWQpO1xuXG5cdFx0fVxuXHR9KTtcblxuXHRtYW5hZ2VyLm9uSW5zdGFuY2VVcGRhdGVkKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHRcdGlmIChpbnN0YW5jZS5hcHBsaWNhdGlvbikge1xuXHRcdC8vIG1hbmFnZXIuX3RyaWdnZXJfYXBwX2V2ZW50KFwiaW5zdGFuY2Vfc3RvcHBlZFwiLCBpbnN0YW5jZSwgaW5zdGFuY2UuYXBwbGljYXRpb24ubmFtZSk7XG5cblx0XHQvLyB2YXIgaWQgPSAoaW5zdGFuY2UuY29udGV4dCAmJiBpbnN0YW5jZS5jb250ZXh0Lmd1aWQpID8gaW5zdGFuY2UuY29udGV4dC5ndWlkIDogaW5zdGFuY2UuaWQ7XG5cdFx0Ly8gbWFuYWdlci5fdHJpZ2dlcl9pbnN0YW5jZV9ldmVudChcInRpdGxlX2NoYW5nZWRcIiwge30sIGlkKTtcblx0XHR9XG5cdH0pO1xuXHQvL1doZW4gYW4gYXBwIGlzIHJlbW92ZWQsIHJlbW92ZSBhbHNvIGl0cyBpbnN0YW5jZXNcblxuXHRtYW5hZ2VyLm9uQXBwUmVtb3ZlZChmdW5jdGlvbiAoYXBwKSB7XG5cdFx0YXBwLmluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9pbnN0YW5jZV9ldmVudChcInN0b3BwZWRcIiwge30sIGdldEludGVybmFsSW5zdGFuY2VJZChpbnN0YW5jZSkpO1xuXHRcdH0pO1xuXHR9KTtcblxuXHRtYW5hZ2VyLm9uQnJhbmNoZXNDaGFuZ2VkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0YnJhbmNoX2NoYW5nZWRfY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0fTtcblxuXHRmdW5jdGlvbiBvbl9icmFuY2hfY2hhbmdlZChlKSB7XG5cdFx0aWYgKHR5cGVvZiBicmFuY2hfY2hhbmdlZF9jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRicmFuY2hfY2hhbmdlZF9jYWxsYmFjayhoZWxwZXJzLnZhbHMoZSkpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZV9hcHBfcmVhZHkoYXBwKSB7XG5cdFx0aWYgKGFwcC5Jc1JlYWR5KSB7XG5cdFx0XHRtYW5hZ2VyLl90cmlnZ2VyX2FwcF9ldmVudChcImF2YWlsYWJsZVwiLCBhcHApO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1hbmFnZXIuX3RyaWdnZXJfYXBwX2V2ZW50KFwidW5hdmFpbGFibGVcIiwgYXBwKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBfZmFpbGVkKGUpIHtcblx0XHR2YXIgaWQgPSBpbnN0YW5jZUlkRnVuY3Rpb24oZSk7XG5cdFx0bWFuYWdlci5fdHJpZ2dlcl9pbnN0YW5jZV9ldmVudChcImVycm9yXCIsIGUsIGlkKTtcblx0fVxuXG5cdC8vIGRlcHJlY2F0ZXNcblx0bWFuYWdlci5jYW5faSA9IGRlcHJlY2F0ZShtYW5hZ2VyLmNhbkksICdhcHBNYW5hZ2VyLmNhbl9pIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIuY2FuSSgpIGluc3RlYWQnKTtcblx0bWFuYWdlci5jYW5faV9icmFuY2ggPSBkZXByZWNhdGUobWFuYWdlci5jYW5JYnJhbmNoLCAnYXBwTWFuYWdlci5jYW5faV9icmFuY2ggaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5jYW5JYnJhbmNoKCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLmN1cnJlbnRfdXNlciA9IGRlcHJlY2F0ZShtYW5hZ2VyLmN1cnJlbnRVc2VyLCAnYXBwTWFuYWdlci5jdXJyZW50X3VzZXIgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5jdXJyZW50VXNlcigpIGluc3RlYWQnKTtcblx0bWFuYWdlci5zZXRfY3VycmVudF9icmFuY2ggPSBkZXByZWNhdGUobWFuYWdlci5zZXRDdXJyZW50QnJhbmNoLCAnYXBwTWFuYWdlci5zZXRfY3VycmVudF9icmFuY2ggaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5zZXRDdXJyZW50QnJhbmNoKCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLmdldF9jdXJyZW50X2JyYW5jaCA9IGRlcHJlY2F0ZShtYW5hZ2VyLmdldEN1cnJlbnRCcmFuY2gsICdhcHBNYW5hZ2VyLmdldF9jdXJyZW50X2JyYW5jaCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBNYW5hZ2VyLmdldEN1cnJlbnRCcmFuY2goKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIuZ2V0X2JyYW5jaGVzID0gZGVwcmVjYXRlKG1hbmFnZXIuZ2V0QnJhbmNoZXMsICdhcHBNYW5hZ2VyLmdldF9icmFuY2hlcyBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBNYW5hZ2VyLmdldEJyYW5jaGVzKCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLmdldF9mdW5jdGlvbmFsX2VudGl0bGVtZW50X2JyYW5jaCA9IGRlcHJlY2F0ZShtYW5hZ2VyLmdldEZ1bmN0aW9uYWxFbnRpdGxlbWVudEJyYW5jaCwgJ2FwcE1hbmFnZXIuZ2V0X2Z1bmN0aW9uYWxfZW50aXRsZW1lbnRfYnJhbmNoIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIuZ2V0RnVuY3Rpb25hbEVudGl0bGVtZW50QnJhbmNoKCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLmdldF9mdW5jdGlvbmFsX2VudGl0bGVtZW50ID0gZGVwcmVjYXRlKG1hbmFnZXIuZ2V0RnVuY3Rpb25hbEVudGl0bGVtZW50LCAnYXBwTWFuYWdlci5nZXRfZnVuY3Rpb25hbF9lbnRpdGxlbWVudCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBNYW5hZ2VyLmdldEZ1bmN0aW9uYWxFbnRpdGxlbWVudCgpIGluc3RlYWQnKTtcblx0bWFuYWdlci5nZXRfcmVnaW9uID0gZGVwcmVjYXRlKG1hbmFnZXIuZ2V0UmVnaW9uLCAnYXBwTWFuYWdlci5nZXRfcmVnaW9uIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIuZ2V0UmVnaW9uKCkgaW5zdGVhZCcpO1xuXHRtYW5hZ2VyLnNldF9yZWdpb24gPSBkZXByZWNhdGUobWFuYWdlci5zZXRSZWdpb24sICdhcHBNYW5hZ2VyLnNldF9yZWdpb24gaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5zZXRSZWdpb24oKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIub25fYXBwX3VuYXZhaWxhYmxlID0gZGVwcmVjYXRlKG1hbmFnZXIub25BcHBVbmF2YWlsYWJsZSwgJ2FwcE1hbmFnZXIub25fYXBwX3VuYXZhaWxhYmxlIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIub25BcHBVbmF2YWlsYWJsZSgpIGluc3RlYWQnKTtcblx0bWFuYWdlci5vbl9hcHBfcmVtb3ZlZCA9IGRlcHJlY2F0ZShtYW5hZ2VyLm9uQXBwUmVtb3ZlZCwgJ2FwcE1hbmFnZXIub25fYXBwX3JlbW92ZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5vbkFwcFJlbW92ZWQoKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIub25fYXBwX2FkZGVkID0gZGVwcmVjYXRlKG1hbmFnZXIub25BcHBBZGRlZCwgJ2FwcE1hbmFnZXIub25fYXBwX2FkZGVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIub25BcHBBZGRlZCgpIGluc3RlYWQnKTtcblx0bWFuYWdlci5vbl9hcHBfYXZhaWxhYmxlID0gZGVwcmVjYXRlKG1hbmFnZXIub25BcHBBdmFpbGFibGUsICdhcHBNYW5hZ2VyLm9uX2FwcF9hdmFpbGFibGUgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5vbkFwcEF2YWlsYWJsZSgpIGluc3RlYWQnKTtcblx0bWFuYWdlci5vbl9icmFuY2hlc19jaGFuZ2VkID0gZGVwcmVjYXRlKG1hbmFnZXIub25CcmFuY2hlc0NoYW5nZWQsICdhcHBNYW5hZ2VyLm9uX2JyYW5jaGVzX2NoYW5nZWQgIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIub25CcmFuY2hlc0NoYW5nZWQoKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIub25faW5zdGFuY2Vfc3RhcnRlZCA9IGRlcHJlY2F0ZShtYW5hZ2VyLm9uSW5zdGFuY2VTdGFydGVkLCAnYXBwTWFuYWdlci5vbl9pbnN0YW5jZV9zdGFydGVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIub25JbnN0YW5jZVN0YXJ0ZWQoKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIub25faW5zdGFuY2Vfc3RvcHBlZCA9IGRlcHJlY2F0ZShtYW5hZ2VyLm9uSW5zdGFuY2VTdG9wcGVkLCAnYXBwTWFuYWdlci5vbl9pbnN0YW5jZV9zdG9wcGVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcE1hbmFnZXIub25JbnN0YW5jZVN0b3BwZWQoKSBpbnN0ZWFkJyk7XG5cdG1hbmFnZXIub25faW5zdGFuY2VfdXBkYXRlZD0gZGVwcmVjYXRlKG1hbmFnZXIub25JbnN0YW5jZVVwZGF0ZWQsICdhcHBNYW5hZ2VyLm9uX2luc3RhbmNlX3VwZGF0ZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwTWFuYWdlci5vbkluc3RhbmNlVXBkYXRlZCgpIGluc3RlYWQnKTtcblxuXHRpZiAoYWdtICYmIGFnbS5zdWJzY3JpYmUpIHtcblxuXHRcdG1hbmFnZXIuYWdtID0gYWdtO1xuXHRcdHZhciBoYW5kbGVycyA9IFtcblx0XHRcdHtldmVudDogXCJPbkFwcGxpY2F0aW9uQWRkZWRcIiwgdHJpZ2dlcjogXCJhZGRlZFwiLCBvbjogYXBwc30sXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvblJlbW92ZWRcIiwgdHJpZ2dlcjogXCJyZW1vdmVkXCIsIG9uOiBhcHBzfSxcblx0XHRcdHtldmVudDogXCJPbkFwcGxpY2F0aW9uQ2hhbmdlZFwiLCB0cmlnZ2VyOiBcImNoYW5nZWRcIiwgb246IGFwcHN9LFxuXHRcdFx0e2V2ZW50OiBcIk9uQXBwbGljYXRpb25TdGFydGVkXCIsIHRyaWdnZXI6IFwic3RhcnRlZFwiLCBvbjogaW5zdGFuY2VzfSxcblx0XHRcdHtldmVudDogXCJPbkFwcGxpY2F0aW9uU3RvcHBlZFwiLCB0cmlnZ2VyOiBcInN0b3BwZWRcIiwgb246IGluc3RhbmNlc30sXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvblVwZGF0ZWRcIiwgdHJpZ2dlcjogXCJ1cGRhdGVkXCIsIG9uOiBpbnN0YW5jZXN9LFxuXHRcdFx0e2V2ZW50OiBcIk9uQXBwbGljYXRpb25BZ21TZXJ2ZXJSZWFkeVwiLCB0cmlnZ2VyOiBcImFnbVJlYWR5XCIsIG9uOiBpbnN0YW5jZXN9LFxuXHRcdFx0e2V2ZW50OiBcIk9uQXBwbGljYXRpb25SZWFkeVwiLCBmdW5jOiBoYW5kbGVfYXBwX3JlYWR5fSxcblx0XHRcdHtldmVudDogXCJPbkJyYW5jaGVzTW9kaWZpZWRcIiwgZnVuYzogb25fYnJhbmNoX2NoYW5nZWR9LFxuXHRcdFx0e2V2ZW50OiBcIk9uQXBwbGljYXRpb25TdGFydEZhaWxlZFwiLCByYXdfZnVuYzogYXBwX2ZhaWxlZH1cblx0XHRdO1xuXG5cdFx0YWdtLnNlcnZlck1ldGhvZEFkZGVkKGZ1bmN0aW9uIChyZXNwKSB7XG5cdFx0XHRpZiAoKHJlc3Auc2VydmVyLmFwcGxpY2F0aW9uLmluZGV4T2YoJ0FwcE1hbmFnZXInKSAhPT0gLTEgJiYgcmVzcC5tZXRob2QubmFtZS5pbmRleE9mKCdUNDIuQUNTLk9uRXZlbnQnKSAhPT0gLTEpKSB7XG5cdFx0XHRcdGFnbS5zdWJzY3JpYmUoXCJUNDIuQUNTLk9uRXZlbnRcIiwge3RhcmdldDogXCJhbGxcIn0pXG5cdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuXHRcdFx0XHRcdFx0c3Vic2NyaXB0aW9uLm9uRGF0YShmdW5jdGlvbiAoc3RyZWFtRGF0YSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXZlbnRzID0gc3RyZWFtRGF0YS5kYXRhO1xuXHRcdFx0XHRcdFx0XHRoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG9iamVjdHMgPSBldmVudHNbaGFuZGxlci5ldmVudF07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG9iamVjdHMpIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGhhbmRsZXIucmF3X2Z1bmMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRoYW5kbGVyLnJhd19mdW5jKG9iamVjdHMpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGhlbHBlcnMudmFscyhvYmplY3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChvYmplY3QpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGhhbmRsZXIub24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGhhbmRsZXIub24uX3RyaWdnZXIoaGFuZGxlci50cmlnZ2VyLCBvYmplY3QpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGhhbmRsZXIuZnVuYyhvYmplY3QpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdG1hbmFnZXIudmVyc2lvbiA9ICBQYWNrYWdlSnNvbi52ZXJzaW9uO1xuXG5cdHJldHVybiBtYW5hZ2VyO1xufTtcblxuZ2xvYmFsLnRpY2s0MiA9IGdsb2JhbC50aWNrNDIgfHx7fTtcbmdsb2JhbC50aWNrNDIuYXBwX21hbmFnZXIgPSBnbG9iYWwuYXBwX21hbmFnZXI7XG4iLCJ2YXIgZXZlbnRfbWFuYWdlciA9IHJlcXVpcmUoXCIuL2V2ZW50X21hbmFnZXJcIik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKTtcbnZhciBjdWlkID0gcmVxdWlyZSgnY3VpZCcpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYWdtLCBpbnN0YW5jZXMsIHRva2VuKSB7XG5cdHZhciBhcHBfcHJvdG8gPSBoZWxwZXJzLmFkZF9jYWxsYmFja3Moe1xuXG5cdFx0Ly8gb3B0aW9uc1xuXHRcdC8vICAtIHVzZU15RnJhbWVDb2xvciAtIHRydWUvZmFsc2UgLSBpZiBzZXQgdGhlIHN0YXJ0ZWQgYXBwIHdpbGwgaGF2ZSB0aGUgc2FtZSBmcmFtZSBjb2xvciBhcyB0aGUgY3VycmVudFxuXHRcdC8vICAtIGZyYW1lQ29sb3IgLSBDb2xvciAtIHVzZSB0byBzZXQgYSBmcmFtZSBjb2xvciBmb3IgdGhlIG5ldyBhcHBsaWNhdGlvbi4gVGhpcyB3aWxsIG92ZXJyaWRlIHVzZU15RnJhbWVDb2xvclxuXHRcdC8vICAtIHdpblN0YXRlU3luYyA9ICd0d29XYXknLCAnb25lV2F5JywgJ29uZVdheUZyb21DaGlsZCdcblx0XHRzdGFydDogZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xuXHRcdFx0XHRjb250ZXh0Ll90NDIgPSB7fTtcblx0XHRcdFx0Ly8gdXNlIGlkIGZvciB0cmFja2luZ1xuXHRcdFx0XHRjb250ZXh0Ll90NDIuaWQgPSBjb250ZXh0Lmd1aWQgfHwgY3VpZCgpO1xuXHRcdFx0XHRjb250ZXh0Ll90NDIudG9rZW4gPSB0b2tlbjtcblxuXHRcdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdFx0dmFyIGluQ29udGFpbmVyID0gdHlwZW9mIGh0bWxDb250YWluZXIgIT09ICd1bmRlZmluZWQnO1xuXG5cdFx0XHRcdHZhciBsYXlvdXRPcHRpb25zID0ge307XG5cdFx0XHRcdGNvbnRleHQuX3Q0Mi5sYXlvdXRPcHRpb25zID0gbGF5b3V0T3B0aW9ucztcblxuXHRcdFx0XHRpZiAob3B0aW9ucy51c2VNeUZyYW1lQ29sb3IgJiYgaW5Db250YWluZXIpIHtcblx0XHRcdFx0XHRsYXlvdXRPcHRpb25zLmZyYW1lQ29sb3IgPSBodG1sQ29udGFpbmVyLmdldEZyYW1lQ29sb3IoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRpb25zLmZyYW1lQ29sb3IpIHtcblx0XHRcdFx0XHRsYXlvdXRPcHRpb25zLmZyYW1lQ29sb3IgPSBvcHRpb25zLmZyYW1lQ29sb3I7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0aW9ucy5zdGF0ZVRyYWNraW5nKXtcblx0XHRcdFx0XHRsYXlvdXRPcHRpb25zLnN0YXRlVHJhY2tpbmcgPSAge1xuXHRcdFx0XHRcdFx0bW9kZTogb3B0aW9ucy5zdGF0ZVRyYWNraW5nLFxuXHRcdFx0XHRcdFx0b3duZXJXaW5kb3dJZDogaW5Db250YWluZXIgPyBcdGh0bWxDb250YWluZXIud2luZG93SWQ6ICdicm93c2VyJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYWdtKSB7XG5cdFx0XHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuU3RhcnRBcHBsaWNhdGlvblwiLFxuXHRcdFx0XHRcdFx0e05hbWU6IG5hbWUsIENvbnRleHQ6IGNvbnRleHR9LFxuXHRcdFx0XHRcdFx0XCJiZXN0XCIsIHt9LFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXMoKS5fdHJpZ2dlcihcImNyZWF0ZVwiLCB7Q29udGV4dDogY29udGV4dH0pO1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKGluc3RhbmNlKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSwgW1wiQWRkZWRcIiwgXCJSZW1vdmVkXCIsIFwiQXZhaWxhYmxlXCIsIFwiVW5hdmFpbGFibGVcIiwgXCJJbnN0YW5jZVN0YXJ0ZWRcIiwgXCJJbnN0YW5jZVN0b3BwZWRcIiwgXCJDaGFuZ2VkXCJdLCBcIm9uXCIpO1xuXG5cdC8vZGVwcmVjYXRlZFxuXHRhcHBfcHJvdG8ub25fYWRkZWQgPSBkZXByZWNhdGUoYXBwX3Byb3RvLm9uQWRkZWQsICdhcHBsaWNhdGlvbi5vbl9hZGRlZCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBsaWNhdGlvbi5vbkFkZGVkKCkgaW5zdGVhZCcpO1xuXHRhcHBfcHJvdG8ub25fcmVtb3ZlZCA9IGRlcHJlY2F0ZShhcHBfcHJvdG8ub25SZW1vdmVkLCAnYXBwbGljYXRpb24ub25fcmVtb3ZlZCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBsaWNhdGlvbi5vblJlbW92ZWQoKSBpbnN0ZWFkJyk7XG5cdGFwcF9wcm90by5vbl9hdmFpbGFibGUgPSBkZXByZWNhdGUoYXBwX3Byb3RvLm9uQXZhaWxhYmxlLCAnYXBwbGljYXRpb24ub25fYXZhaWxhYmxlIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcGxpY2F0aW9uLm9uQXZhaWxhYmxlKCkgaW5zdGVhZCcpO1xuXHRhcHBfcHJvdG8ub25fdW5hdmFpbGFibGUgPSBkZXByZWNhdGUoYXBwX3Byb3RvLm9uVW5hdmFpbGFibGUsICdhcHBsaWNhdGlvbi5vbl91bmF2YWlsYWJsZSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBsaWNhdGlvbi5vblVuYXZhaWxhYmxlKCkgaW5zdGVhZCcpO1xuXHRhcHBfcHJvdG8ub25faW5zdGFuY2Vfc3RhcnRlZCA9IGRlcHJlY2F0ZShhcHBfcHJvdG8ub25JbnN0YW5jZVN0YXJ0ZWQsICdhcHBsaWNhdGlvbi5vbl9pbnN0YW5jZV9zdGFydGVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcGxpY2F0aW9uLm9uSW5zdGFuY2VTdGFydGVkKCkgaW5zdGVhZCcpO1xuXHRhcHBfcHJvdG8ub25faW5zdGFuY2Vfc3RvcHBlZCA9IGRlcHJlY2F0ZShhcHBfcHJvdG8ub25JbnN0YW5jZVN0b3BwZWQsICdhcHBsaWNhdGlvbi5vbl9pbnN0YW5jZV9zdG9wcGVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcGxpY2F0aW9uLm9uSW5zdGFuY2VTdG9wcGVkKCkgaW5zdGVhZCcpO1xuXHRhcHBfcHJvdG8ub25fY2hhbmdlZCA9IGRlcHJlY2F0ZShhcHBfcHJvdG8ub25DaGFuZ2VkLCAnYXBwbGljYXRpb24ub25fY2hhbmdlZCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBhcHBsaWNhdGlvbi5vbkNoYW5nZWQoKSBpbnN0ZWFkJyk7XG5cblxuXHQvL2NvbnN0cnVjdG9yLCBpbml0X2V2ZW50LCBpZF9maWVsZFxuXHRmdW5jdGlvbiB1cGRhdGVfYXBwKHByb3BzLCBvYmopIHtcblx0XHRvYmoubmFtZSA9IHByb3BzLk5hbWU7XG5cdFx0b2JqLnRpdGxlID0gcHJvcHMuVGl0bGU7XG5cdFx0b2JqLnZlcnNpb24gPSBwcm9wcy5WZXJzaW9uO1xuXHRcdG9iai5pbnN0YW5jZXMgPSBbXTtcblx0XHRvYmouY29uZmlndXJhdGlvbiA9IHt9O1xuXHRcdG9iai5jb25maWd1cmF0aW9uLmF1dG9fc3RhcnQgPSBwcm9wcy5BdXRvU3RhcnQ7XG5cdFx0b2JqLmNvbmZpZ3VyYXRpb24uY2FwdGlvbiA9IHByb3BzLkNhcHRpb247XG5cdFx0b2JqLmNvbmZpZ3VyYXRpb24uaGlkZGVuID0gcHJvcHMuSXNIaWRkZW47XG5cdFx0b2JqLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyID0gcHJvcHMuQXBwbGljYXRpb25OYW1lO1xuXHRcdG9iai5jb25maWd1cmF0aW9uLmFjdGl2aXR5VHlwZSA9IHByb3BzLkFjdGl2aXR5VHlwZTtcblx0XHQvL29iai5kaXNhYmxlZCA9IHByb3BzLklzRGlzYWJsZWQ7XG5cdFx0b2JqLmNvbmZpZ3VyYXRpb24uYWxsb3dfbXVsdGlwbGUgPSBwcm9wcy5BbGxvd011bHRpcGxlO1xuXHRcdG9iai5hdmFpbGFibGUgPSBwcm9wcy5Jc1JlYWR5IHx8IGZhbHNlO1xuXHRcdG9iai5pY29uID0gcHJvcHMuSWNvbjtcblx0XHRvYmouc29ydE9yZGVyID0gcHJvcHMuU29ydE9yZGVyO1xuXHRcdG9iai51c2VyUHJvcGVydGllcyA9IHByb3BzLlVzZXJQcm9wZXJ0aWVzO1xuXHRcdHJldHVybiBvYmo7XG5cdH1cblxuXHR2YXIgYXBwVG9FdmVudE1hbmFnZXIgPSB7XG5cdFx0Y3JlYXRlOiBmdW5jdGlvbiBjcmVhdGVfYXBwKHByb3BzKSB7XG5cdFx0XHRyZXR1cm4gdXBkYXRlX2FwcChwcm9wcywgT2JqZWN0LmNyZWF0ZShhcHBfcHJvdG8pKTtcblx0XHR9LFxuXHRcdHVwZGF0ZTogdXBkYXRlX2FwcCxcblx0XHRpbml0X2V2ZW50OiBcImFkZGVkXCIsXG5cdFx0ZXhpdF9ldmVudDogXCJyZW1vdmVkXCIsXG5cdFx0aWRfZmllbGQ6IFwiTmFtZVwiLFxuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0YXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRjaGFuZ2VkOiBmdW5jdGlvbiAocHJvcHMpIHtcblx0XHRcdFx0dGhpcy5pY29uID0gcHJvcHMuSWNvbjtcblx0XHRcdFx0dGhpcy50aXRsZSA9IHByb3BzLlRpdGxlO1xuXHRcdFx0XHR0aGlzLmNvbmZpZ3VyYXRpb24uY2FwdGlvbiA9IHByb3BzLkNhcHRpb247XG5cdFx0XHR9LFxuXHRcdFx0dW5hdmFpbGFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5hdmFpbGFibGUgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRpbnN0YW5jZVN0YXJ0ZWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHRcdFx0XHR0aGlzLmluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcblx0XHRcdH0sXG5cdFx0XHRpbnN0YW5jZVN0b3BwZWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHRcdFx0XHR0aGlzLmluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAobXlfaW5zdGFuY2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gbXlfaW5zdGFuY2UgIT09IGluc3RhbmNlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9kZXByZWNhdGVkXG5cdGFwcFRvRXZlbnRNYW5hZ2VyLmNhbGxiYWNrcy5pbnN0YW5jZV9zdGFydGVkID0gZGVwcmVjYXRlKGFwcFRvRXZlbnRNYW5hZ2VyLmNhbGxiYWNrcy5pbnN0YW5jZVN0YXJ0ZWQsICdhcHBsaWNhdGlvbi5pbnN0YW5jZV9zdGFydGVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGFwcGxpY2F0aW9uLmluc3RhbmNlU3RhcnRlZCgpIGluc3RlYWQnKTtcblx0YXBwVG9FdmVudE1hbmFnZXIuY2FsbGJhY2tzLmluc3RhbmNlX3N0b3BwZWQgPSBkZXByZWNhdGUoYXBwVG9FdmVudE1hbmFnZXIuY2FsbGJhY2tzLmluc3RhbmNlU3RvcHBlZCwgJ2FwcGxpY2F0aW9uLmluc3RhbmNlX3N0b3BwZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgYXBwbGljYXRpb24uaW5zdGFuY2VTdG9wcGVkKCkgaW5zdGVhZCcpO1xuXG5cblx0cmV0dXJuIGV2ZW50X21hbmFnZXIoYXBwVG9FdmVudE1hbmFnZXIpO1xufTtcbiIsInZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcblxuZnVuY3Rpb24gZXhlY19jYWxsYmFja3Mob2JqLCBhcnIsIHZhbCkge1xuXHRpZiAoYXJyICE9PSB1bmRlZmluZWQpIHtcblx0XHRhcnIuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrLmNhbGwob2JqLCB2YWwpO1xuXHRcdH0pO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlX2Vudmlyb25tZW50KHNldHRpbmdzKSB7XG5cdHZhciBvYmplY3RzID0ge307XG5cdHZhciBnbG9iYWxfY2FsbGJhY2tzID0ge307XG5cdHJldHVybiB7XG5cdFx0YWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gaGVscGVycy52YWxzKG9iamVjdHMpO1xuXHRcdH0sXG5cdFx0Z2V0X2J5X2lkOiBmdW5jdGlvbiAoaWQpIHtcblx0XHRcdHJldHVybiBvYmplY3RzW2lkXTtcblx0XHR9LFxuXHRcdF90cmlnZ2VyOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGlkKSB7XG5cdFx0XHRpZCA9IGlkIHx8ICggdHlwZW9mIHNldHRpbmdzLmlkX2ZpZWxkID09PSBcImZ1bmN0aW9uXCIgPyBzZXR0aW5ncy5pZF9maWVsZChwcm9wcykgOiBwcm9wc1tzZXR0aW5ncy5pZF9maWVsZF0pO1xuXG5cdFx0XHQvL1F1aXQgaWYgd2UgcmVjZWl2ZSBhbiBldmVudCBmb3IgYW4gb2JqZWN0IGJlZm9yZSBpbml0aWF0aW5nIGl0LlxuXHRcdFx0aWYgKG9iamVjdHNbaWRdID09PSB1bmRlZmluZWQgJiYgKCB0eXBlICE9PSBzZXR0aW5ncy5pbml0X2V2ZW50ICYmIHR5cGUgIT09IHNldHRpbmdzLmNyZWF0ZV9ldmVudCkpIHtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyAoXCJSZWNlaXZlZCAnXCIrdHlwZStcIicgZXZlbnQgYmVmb3JlICdcIitzZXR0aW5ncy5pbml0X2V2ZW50K1wiJ1wiKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cblx0XHRcdC8vQ3JlYXRlIG9yIHJldHJpZXZlIGFuIG9iamVjdCwgcmVwcmVzZW50aW5nIHRoZSBlbnRpdHlcblx0XHRcdHZhciBvYmogPSBvYmplY3RzW2lkXSA9IG9iamVjdHNbaWRdIHx8IGluaXRfb2JqZWN0KHNldHRpbmdzLmNyZWF0ZShwcm9wcykpO1xuXG5cdFx0XHRpZiAodHlwZSA9PT0gc2V0dGluZ3MuaW5pdF9ldmVudCkge1xuXHRcdFx0XHQvL1F1aXQgaWYgd2UgcmVjZWl2ZSBhIGluaXQgZXZlbnQgZm9yIGFuIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgYWN0aXZlXG5cdFx0XHRcdGlmIChvYmouYWN0aXZlKSB7XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyAoXCJSZWNlaXZlZCBzZWNvbmQgJ1wiK3NldHRpbmdzLmluaXRfZXZlbnQrXCInIGZvciBhcHAgXCIraWQpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHQvL0Vsc2UsIG1ha2UgaXQgYWN0aXZlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b2JqLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHRcdFx0c2V0dGluZ3MudXBkYXRlKHByb3BzLCBvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vV2hlbiB0aGUgZW50aXR5IGlzIHJlbW92ZWQsIHNldCBpdCB0byBub24tYWN0aXZlXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IHNldHRpbmdzLmV4aXRfZXZlbnQpIHtcblx0XHRcdFx0aWYgKHNldHRpbmdzLnJlbW92ZU9uRXhpdCl7XG5cdFx0XHRcdFx0ZGVsZXRlIG9iamVjdHNbaWRdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9iai5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL1doZW4gYSBjcmVhdGUgZXZlbnQgaXMgcmVjZWl2ZWQsIGp1c3QgcmV0dXJuIHRoZSBvYmplY3Qgd2l0aG91dCBkb2luZyBhbnl0aGluZyBlbHNlXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IHNldHRpbmdzLmNyZWF0ZV9ldmVudCkge1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IHNldHRpbmdzLnVwZGF0ZV9ldmVudCkge1xuXHRcdFx0XHRzZXR0aW5ncy51cGRhdGUocHJvcHMsIG9iaik7XG5cdFx0XHR9XG5cblx0XHRcdC8vRXhlY3V0ZSBzeXN0ZW0gY2FsbGJhY2tzXG5cdFx0XHRpZiAoc2V0dGluZ3MuY2FsbGJhY2tzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0c2V0dGluZ3MuY2FsbGJhY2tzW3R5cGVdLmNhbGwob2JqLCBwcm9wcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG1ha2Ugc3VyZSB0aGF0IGVycm9ycyBpbiB1c2VyIHNwZWNpZmllZCBjYWxsYmFja3MgZG9lcyBub3Rcblx0XHRcdC8vIGJyZWFrIG91ciBsaWJyYXJ5XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvL0V4ZWN1dGUgZ2xvYmFsIGNhbGxiYWNrc1xuXHRcdFx0XHRleGVjX2NhbGxiYWNrcyh1bmRlZmluZWQsIGdsb2JhbF9jYWxsYmFja3NbdHlwZV0sIG9iaik7XG5cblx0XHRcdFx0Ly9FeGVjdXRlIHVzZXItZGVmaW5lZCBjYWxsYmFja3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRleGVjX2NhbGxiYWNrcyhvYmosIG9iai5jYWxsYmFja3NbdHlwZV0sIHByb3BzKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKXtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHRcdH1cblx0XHRcdC8vV2hlbiB0aGUgZW50aXR5IGlzIHJlbW92ZWQsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIChhZnRlciB5b3UgZXhlY3V0ZSB0aGVtKVxuXHRcdFx0aWYgKHR5cGUgPT09IHNldHRpbmdzLmV4aXRfZXZlbnQpIHtcblx0XHRcdFx0b2JqLmNhbGxiYWNrcyA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblxuXHRcdH0sXG5cdFx0Ly9FeHBvc2UgdGhlIGdsb2JhbCBjYWxsYmFja3Mgb2JqZWN0IHNvIHRoYXQgdXNlciBjYW4gcmVnaXN0ZXIgc29tZVxuXHRcdGNhbGxiYWNrczogZ2xvYmFsX2NhbGxiYWNrc1xuXHR9O1xufTtcblxuZnVuY3Rpb24gaW5pdF9vYmplY3Qob2JqZWN0KSB7XG5cdG9iamVjdC5jYWxsYmFja3MgPSB7fTtcblx0b2JqZWN0LmFjdGl2ZSA9IGZhbHNlO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuIiwiZnVuY3Rpb24gbm9vcCgpe31cblxuZnVuY3Rpb24gZXhlY19pZihjb25kaXRpb24pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChhcHAsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKGNvbmRpdGlvbihhcHApKSB7XG5cdFx0XHRjYWxsYmFjay5jYWxsKGFwcCk7XG5cdFx0fVxuXHR9O1xufVxuXG5leHBvcnRzLmFkZF9jYWxsYmFja3MgPSBmdW5jdGlvbiBhZGRfY2FsbGJhY2tzKG9iamVjdCwgZXZlbnRzLCBwcmVmaXgpIHtcblx0ZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0ZXZlbnQgPSB7bmFtZTogZXZlbnQsIHRyaWdnZXJfd2hlbjogbm9vcH07XG5cdFx0fVxuXHRcdG9iamVjdFtwcmVmaXggKyBldmVudC5uYW1lXSA9IGV4cG9ydHMuYWRkX2NhbGxiYWNrKGV2ZW50Lm5hbWUsIGV4ZWNfaWYoZXZlbnQudHJpZ2dlcl93aGVuKSk7XG5cdH0pO1xuXHRyZXR1cm4gb2JqZWN0O1xuXG59O1xuXG5leHBvcnRzLmFkZF9jYWxsYmFjayA9IGZ1bmN0aW9uIGFkZF9jYWxsYmFjayhrZXksIG9uX2FkZCl7XG5cdHJldHVybiBmdW5jdGlvbihjYWxsYmFjayl7XG5cdFx0dmFyIG9iaiA9IHRoaXMuY2FsbGJhY2tzO1xuXHRcdGlmKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKXtcblx0XHRcdGtleSA9IGtleS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKTtcblx0XHR9XG5cblx0XHRpZihvYmpba2V5XT09PXVuZGVmaW5lZCl7XG5cdFx0XHRvYmpba2V5XSA9IFtjYWxsYmFja107XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0b2JqW2tleV0ucHVzaChjYWxsYmFjayk7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiBvbl9hZGQgPT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRvbl9hZGQodGhpcywgY2FsbGJhY2spO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcbn07XG5cbmV4cG9ydHMudmFscyA9IGZ1bmN0aW9uIHZhbHMob2JqKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBrZXkpIHtcblx0XHRhcnIucHVzaChvYmpba2V5XSk7XG5cdFx0cmV0dXJuIGFycjtcblx0fSwgW10pO1xufTtcbiIsInZhciBldmVudF9tYW5hZ2VyID0gcmVxdWlyZShcIi4vZXZlbnRfbWFuYWdlclwiKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFnbSwgYXBwcywgdG9rZW4sIGluc3RhbmNlSWRGdW5jdGlvbikge1xuXHR2YXIgaW5zdGFuY2VfcHJvdG8gPSBoZWxwZXJzLmFkZF9jYWxsYmFja3Moe1xuXHRcdFx0c3RvcDogZnVuY3Rpb24gKHBhcmFtcywgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuU3RvcEFwcGxpY2F0aW9uXCIsIHtOYW1lOiB0aGlzLmFwcGxpY2F0aW9uLm5hbWUsIElkOiB0aGlzLmlkfSwgXCJiZXN0XCIsIHt9LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGUpO1xuXHRcdFx0XHR9LCBlcnJvcik7XG5cdFx0XHR9LFxuXHRcdFx0YWN0aXZhdGU6IGZ1bmN0aW9uIChwYXJhbXMsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkFjdGl2YXRlQXBwbGljYXRpb25cIiwge05hbWU6IHRoaXMuYXBwbGljYXRpb24ubmFtZSwgSWQ6IHRoaXMuaWR9LCBcImJlc3RcIiwge30sIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coZSk7XG5cdFx0XHRcdH0sIGVycm9yKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBUcnVlIGlmIHRoZSBpbnN0YW5jZSBpcyBzcGF3biBmcm9tIHRoaXMgQXBwTWFuYWdlciAoYnkgY29tcGFyaW5nIHRva2Vucylcblx0XHRcdG93bjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAodGhpcy5jb250ZXh0ICYmIHRoaXMuY29udGV4dC5fdDQyICYmIHRoaXMuY29udGV4dC5fdDQyLnRva2VuKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29udGV4dC5fdDQyLnRva2VuID09PSB0b2tlbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRbXG5cdFx0XHR7XG5cdFx0XHRcdG5hbWU6IFwiV2luZG93QWRkZWRcIiwgdHJpZ2dlcl93aGVuOiBmdW5jdGlvbiAoYXBwKSB7XG5cdFx0XHRcdHJldHVybiBhcHAuYWN0aXZlICYmIGFwcC5tYWluX3dpbmRvdyAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJXaW5kb3dSZW1vdmVkXCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24gKGFwcCkge1xuXHRcdFx0XHRyZXR1cm4gYXBwLm1haW5fd2luZG93ID09PSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIlN0YXJ0ZWRcIiwgdHJpZ2dlcl93aGVuOiBmdW5jdGlvbiAoYXBwKSB7XG5cdFx0XHRcdHJldHVybiBhcHAuaWQgIT09IHVuZGVmaW5lZCAmJiBhcHAuYWN0aXZlO1xuXHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bmFtZTogXCJTdG9wcGVkXCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24gKGFwcCkge1xuXHRcdFx0XHRyZXR1cm4gYXBwLmlkICE9PSB1bmRlZmluZWQgJiYgIWFwcC5hY3RpdmU7XG5cdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIkFnbVJlYWR5XCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24gKGFwcCkge1xuXHRcdFx0XHRyZXR1cm4gYXBwLmFjdGl2ZSAmJiBhcHAuYWdtICE9PSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBcIkVycm9yXCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24gKGFwcCkge1xuXHRcdFx0XHRyZXR1cm4gYXBwLmVycm9yICE9PSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHR9LFxuXHRcdF0sIFwib25cIik7XG5cblx0Ly9kZXByZWNhdGVkXG5cdGluc3RhbmNlX3Byb3RvLm9uX3dpbmRvd19hZGRlZCA9IGRlcHJlY2F0ZShpbnN0YW5jZV9wcm90by5vbldpbmRvd0FkZGVkLCAnaW5zdGFuY2Uub25fd2luZG93X2FkZGVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGluc3RhbmNlLm9uV2luZG93QWRkZWQoKSBpbnN0ZWFkJyk7XG5cdGluc3RhbmNlX3Byb3RvLm9uX3dpbmRvd19yZW1vdmVkID0gZGVwcmVjYXRlKGluc3RhbmNlX3Byb3RvLm9uV2luZG93UmVtb3ZlZCwgJ2luc3RhbmNlLm9uX3dpbmRvd19yZW1vdmVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGluc3RhbmNlLm9uV2luZG93UmVtb3ZlZCgpIGluc3RlYWQnKTtcblx0aW5zdGFuY2VfcHJvdG8ub25fc3RhcnRlZCA9IGRlcHJlY2F0ZShpbnN0YW5jZV9wcm90by5vblN0YXJ0ZWQsICdpbnN0YW5jZS5vbl9zdGFydGVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGluc3RhbmNlLm9uU3RhcnRlZCgpIGluc3RlYWQnKTtcblx0aW5zdGFuY2VfcHJvdG8ub25fc3RvcHBlZCA9IGRlcHJlY2F0ZShpbnN0YW5jZV9wcm90by5vblN0b3BwZWQsICdpbnN0YW5jZS5vbl9zdG9wcGVkIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGluc3RhbmNlLm9uU3RvcHBlZCgpIGluc3RlYWQnKTtcblx0aW5zdGFuY2VfcHJvdG8ub25fYWdtX3JlYWR5ID0gZGVwcmVjYXRlKGluc3RhbmNlX3Byb3RvLm9uQWdtUmVhZHksICdpbnN0YW5jZS5vbl9hZ21fcmVhZHkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgaW5zdGFuY2Uub25BZ21SZWFkeSgpIGluc3RlYWQnKTtcblx0aW5zdGFuY2VfcHJvdG8ub25fZXJyb3IgPSBkZXByZWNhdGUoaW5zdGFuY2VfcHJvdG8ub25FcnJvciwgJ2luc3RhbmNlLm9uX2Vycm9yIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGluc3RhbmNlLm9uRXJyb3IoKSBpbnN0ZWFkJyk7XG5cblx0ZnVuY3Rpb24gdXBkYXRlX2luc3RhbmNlKHByb3BzLCBvYmopIHtcblx0XHRvYmouaWQgPSBwcm9wcy5JZDtcblx0XHRvYmouYXBwbGljYXRpb24gPSBhcHBzLmdldF9ieV9pZChwcm9wcy5OYW1lKTtcblx0XHRvYmouY29udGV4dCA9IHByb3BzLkNvbnRleHQ7XG5cdFx0b2JqLnRpdGxlID0gcHJvcHMuVGl0bGU7XG5cdFx0b2JqLmFjdGl2aXR5SWQgPSBwcm9wcy5BY3Rpdml0eUlkO1xuXHRcdHJldHVybiBvYmo7XG5cdH1cblxuXHR2YXIgaW5zdGFuY2VUb0V2ZW50TWFuYWdlciA9IHtcblx0XHRjcmVhdGU6IGZ1bmN0aW9uIChwcm9wcykge1xuXHRcdFx0cmV0dXJuIHVwZGF0ZV9pbnN0YW5jZShwcm9wcywgT2JqZWN0LmNyZWF0ZShpbnN0YW5jZV9wcm90bykpO1xuXHRcdH0sXG5cdFx0dXBkYXRlOiB1cGRhdGVfaW5zdGFuY2UsXG5cdFx0Y3JlYXRlX2V2ZW50OiBcImNyZWF0ZVwiLFxuXHRcdGluaXRfZXZlbnQ6IFwic3RhcnRlZFwiLFxuXHRcdGV4aXRfZXZlbnQ6IFwic3RvcHBlZFwiLFxuXHRcdHVwZGF0ZV9ldmVudDogXCJ1cGRhdGVkXCIsXG5cdFx0aWRfZmllbGQ6IGluc3RhbmNlSWRGdW5jdGlvbixcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdGFnbVJlYWR5OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHQvL2dldCB0aGUgZmlyc3QgQUdNXG5cdFx0XHRcdHZhciBzZXJ2ZXJfbmFtZSA9IE9iamVjdC5rZXlzKGUuQWdtU2VydmVycylbMF07XG5cdFx0XHRcdC8vQXR0YWNoIGl0IHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0dGhpcy5hZ20gPSBjb252ZXJ0X2FnbV9pbnN0YW5jZShlLkFnbVNlcnZlcnNbc2VydmVyX25hbWVdKTtcblx0XHRcdH0sXG5cdFx0XHRlcnJvcjogZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dGhpcy5lcnJvciA9IGU7XG5cdFx0XHR9LFxuXHRcdFx0d2luZG93QWRkZWQ6IGZ1bmN0aW9uICh3aW4pIHtcblx0XHRcdFx0dGhpcy5tYWluX3dpbmRvdyA9IHdpbjtcblx0XHRcdFx0dGhpcy53aW5kb3dzID0gdGhpcy53aW5kb3dzIHx8IFtdO1xuXHRcdFx0XHR0aGlzLndpbmRvd3MucHVzaCh3aW4pO1xuXHRcdFx0fSxcblx0XHRcdHdpbmRvd1JlbW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5tYWluX3dpbmRvdyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0dGhpcy53aW5kb3dzID0gW107XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW1vdmVPbkV4aXQ6IHRydWVcblx0fTtcblxuXHQvL2RlcHJlY2F0ZWRcblx0aW5zdGFuY2VUb0V2ZW50TWFuYWdlci5jYWxsYmFja3MuYWdtX3JlYWR5ID0gZGVwcmVjYXRlKGluc3RhbmNlVG9FdmVudE1hbmFnZXIuY2FsbGJhY2tzLmFnbVJlYWR5LCAnaW5zdGFuY2UuYWdtX3JlYWR5IGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGluc3RhbmNlLmFnbVJlYWR5KCkgaW5zdGVhZCcpO1xuXHRpbnN0YW5jZVRvRXZlbnRNYW5hZ2VyLmNhbGxiYWNrcy53aW5kb3dfYWRkZWQgPSBkZXByZWNhdGUoaW5zdGFuY2VUb0V2ZW50TWFuYWdlci5jYWxsYmFja3Mud2luZG93QWRkZWQsICdpbnN0YW5jZS53aW5kb3dfYWRkZWQgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgaW5zdGFuY2Uud2luZG93QWRkZWQoKSBpbnN0ZWFkJyk7XG5cdGluc3RhbmNlVG9FdmVudE1hbmFnZXIuY2FsbGJhY2tzLndpbmRvd19yZW1vdmVkID0gZGVwcmVjYXRlKGluc3RhbmNlVG9FdmVudE1hbmFnZXIuY2FsbGJhY2tzLndpbmRvd1JlbW92ZWQsICdpbnN0YW5jZS53aW5kb3dfcmVtb3ZlZCBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBpbnN0YW5jZS53aW5kb3dSZW1vdmVkKCkgaW5zdGVhZCcpO1xuXG5cdHJldHVybiBldmVudF9tYW5hZ2VyKGluc3RhbmNlVG9FdmVudE1hbmFnZXIpO1xufTtcblxuZnVuY3Rpb24gY29udmVydF9hZ21faW5zdGFuY2UoYWdtKSB7XG5cdHJldHVybiB7XG5cdFx0bWFjaGluZTogYWdtLm1hY2hpbmVOYW1lLFxuXHRcdHVzZXI6IGFnbS51c2VyTmFtZSxcblx0XHRlbnZpcm9ubWVudDogYWdtLmVudmlyb25tZW50LFxuXHRcdGFwcGxpY2F0aW9uOiBhZ20uYXBwbGljYXRpb25OYW1lXG5cdH07XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIFwidGljazQyLWFwcC1tYW5hZ2VyQF4yLjAuMFwiLFxuICAgICAgXCJDOlxcXFx3b3JrXFxcXHN0YXNoXFxcXEdMVUUtZGV2XFxcXGRldlxcXFxqcy1nbHVlXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJ0aWNrNDItYXBwLW1hbmFnZXJAPj0yLjAuMCA8My4wLjBcIixcbiAgXCJfaWRcIjogXCJ0aWNrNDItYXBwLW1hbmFnZXJAMi41LjFcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi90aWNrNDItYXBwLW1hbmFnZXJcIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCI2LjMuMFwiLFxuICBcIl9ucG1Vc2VyXCI6IHt9LFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMy44LjVcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcInRpY2s0Mi1hcHAtbWFuYWdlclwiLFxuICAgIFwicmF3XCI6IFwidGljazQyLWFwcC1tYW5hZ2VyQF4yLjAuMFwiLFxuICAgIFwicmF3U3BlY1wiOiBcIl4yLjAuMFwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcInNwZWNcIjogXCI+PTIuMC4wIDwzLjAuMFwiLFxuICAgIFwidHlwZVwiOiBcInJhbmdlXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvXCJcbiAgXSxcbiAgXCJfc2hhc3VtXCI6IFwiOWZmOTkxYjc5NzZjODBkZjcxZTc5NDc4NTIxNmZlZTFjNWE4MDI0ZlwiLFxuICBcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG4gIFwiX3NwZWNcIjogXCJ0aWNrNDItYXBwLW1hbmFnZXJAXjIuMC4wXCIsXG4gIFwiX3doZXJlXCI6IFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxkZXZcXFxcanMtZ2x1ZVwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiVGljazQyXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwOi8vd3d3LnRpY2s0Mi5jb21cIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJjdWlkXCI6IFwiXjEuMy44XCIsXG4gICAgXCJlczYtcHJvbWlzZVwiOiBcIl4zLjAuMlwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBcHAgTWFuYWdlciBBUEkgZm9yIEphdmFTY3JpcHRcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmxhbmtldFwiOiBcIl4xLjEuNlwiLFxuICAgIFwiYm9vdHN0cmFwXCI6IFwiXjMuMy40XCIsXG4gICAgXCJicm93c2VyaWZ5LXZlcnNpb25pZnlcIjogXCJeMS4wLjRcIixcbiAgICBcImdydW50XCI6IFwiXjAuNC41XCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwiXjMuMy4wXCIsXG4gICAgXCJncnVudC1jbGlcIjogXCJeMC4xLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItY2xlYW5cIjogXCJeMC42LjBcIixcbiAgICBcImdydW50LWNvbnRyaWItY29ubmVjdFwiOiBcIl4wLjkuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1qc2hpbnRcIjogXCJeMC4xMS4wXCIsXG4gICAgXCJncnVudC1jb250cmliLXF1bml0XCI6IFwiXjAuNS4yXCIsXG4gICAgXCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIl4wLjYuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi13YXRjaFwiOiBcIl4wLjYuMVwiLFxuICAgIFwiZ3J1bnQtZXhvcmNpc2VcIjogXCJeMS4wLjBcIixcbiAgICBcImh0dHAtc2VydmVyXCI6IFwiXjAuOC4wXCIsXG4gICAgXCJqcXVlcnlcIjogXCJeMi4xLjRcIixcbiAgICBcImxvZGFzaFwiOiBcIl4zLjkuM1wiLFxuICAgIFwicGhhbnRvbWpzXCI6IFwiXjEuOS4xMlwiLFxuICAgIFwicXVuaXRqc1wiOiBcIl4xLjE1LjBcIixcbiAgICBcInRpY2s0Mi1hZ21cIjogXCJeMS4zLjBcIixcbiAgICBcInVnbGlmeWlmeVwiOiBcIl4zLjAuMVwiXG4gIH0sXG4gIFwiZGlyZWN0b3JpZXNcIjoge1xuICAgIFwiZXhhbXBsZVwiOiBcImV4YW1wbGVzXCJcbiAgfSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcIjlmZjk5MWI3OTc2YzgwZGY3MWU3OTQ3ODUyMTZmZWUxYzVhODAyNGZcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi1hcHAtbWFuYWdlci8tL3RpY2s0Mi1hcHAtbWFuYWdlci0yLjUuMS50Z3pcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCJmN2MxODAwNGEwNjkyNWZiZGRiOWU1NDExZDQxMTQ1YjUyY2I3YTIzXCIsXG4gIFwibGljZW5zZVwiOiBcIklTQ1wiLFxuICBcIm1haW5cIjogXCJsaWJyYXJ5L2FwcF9tYW5hZ2VyLmpzXCIsXG4gIFwibmFtZVwiOiBcInRpY2s0Mi1hcHAtbWFuYWdlclwiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vc3Rhc2gudGljazQyLmNvbS9zY20vb2Zndy9qcy1hcHAtbWFuYWdlci5naXRcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwicHJlcHVibGlzaFwiOiBcImdydW50XCIsXG4gICAgXCJ0ZXN0XCI6IFwiZWNobyBcXFwiRXJyb3I6IG5vIHRlc3Qgc3BlY2lmaWVkXFxcIiAmJiBleGl0IDFcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIyLjUuMVwiXG59XG4iLCIvKipcbiAqIEBtb2R1bGUgYXBwY29uZmlnXG4gKi9cbnZhciBfID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG52YXIgZXZlbnRzID0ge1xuICAgIGNvbm5lY3Q6ICdjb25uZWN0JyxcbiAgICBkaXNjb25uZWN0OiAnZGlzY29ubmVjdCcsXG4gICAgdXBkYXRlOiAndXBkYXRlJyxcbiAgICBzdGF0dXM6ICdzdGF0dXMnXG59O1xuXG52YXIgRXZlbnRCdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBzdWJzY3JpcHRpb25zQnlUeXBlO1xuICAgIHZhciBvbiA9IGZ1bmN0aW9uICh0eXBlLCBvbmNlLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIG9uY2U6IG9uY2UsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBzY29wZTogc2NvcGVcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zQnlUeXBlW3R5cGVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBzdWJzY3JpcHRpb24uaWQgPSBzdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKSAtIDE7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcblxuICAgIHZhciBlbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHR5cGUgPSBhcmdzLnNwbGljZSgwLCAxKVswXTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zQnlUeXBlW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9uc0J5VHlwZVt0eXBlXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjay5hcHBseShzdWJzY3JpcHRpb24uc2NvcGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIF8ud2FybignRXhjZXB0aW9uIGR1cmluZyBleGVjdXRpb24gb2YgY2FsbGJhY2snLCBzdWJzY3JpcHRpb24sIGFyZ3MsIHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLm9uY2UpIHtcbiAgICAgICAgICAgICAgICBvZmYoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBvZmYgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9uc0J5VHlwZVtzdWJzY3JpcHRpb24udHlwZV07XG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdWJzY3JpcHRpb25zW3N1YnNjcmlwdGlvbi5pZF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc3VtZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24uaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gb24oc3Vic2NyaXB0aW9uLnR5cGUsIHN1YnNjcmlwdGlvbi5vbmNlLCBzdWJzY3JpcHRpb24uY2FsbGJhY2ssIHN1YnNjcmlwdGlvbi5zY29wZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbc3Vic2NyaXB0aW9uLnR5cGVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zQnlUeXBlW3N1YnNjcmlwdGlvbi50eXBlXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zW3N1YnNjcmlwdGlvbi5pZF0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb25zQnlUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3Vic2NyaXB0aW9uc0J5VHlwZSkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9uc0J5VHlwZVt0eXBlXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3Vic2NyaXB0aW9uLmlkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1YnNjcmlwdGlvbnNCeVR5cGUgPSB7fTtcbiAgICB9O1xuXG4gICAgcmVzZXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbjogb24sXG4gICAgICAgIGVtaXQ6IGVtaXQsXG4gICAgICAgIG9mZjogb2ZmLFxuICAgICAgICByZXN1bWU6IHJlc3VtZSxcbiAgICAgICAgcmVzZXQ6IHJlc2V0XG5cbiAgICB9O1xufTtcblxudmFyIEFwcENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRlZmF1bHRMaXN0ZW4gID0gdHJ1ZTtcbiAgICB2YXIgZ2F0ZXdheTtcbiAgICB2YXIgaW5pdEdhdGV3YXk7XG4gICAgdmFyIGJ1cyA9IG5ldyBFdmVudEJ1cygpO1xuICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbChidXMpO1xuXG4gICAgdmFyIHJvb3QgPSByZXF1aXJlKCcuL3Byb3BzJykobW9kZWwucm9vdCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGdhdGV3YXlDb25uZWN0aW9uO1xuICAgIHZhciBwb2xsaW5nSW50ZXJ2YWxJZDtcbiAgICB2YXIgY2xlYXJQb2xsaW5nSW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9sbGluZ0ludGVydmFsSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHBvbGxpbmdJbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBQdWJsaWMgQVBJXG4gICAgc2VsZi5pbml0ID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgICAgIHZhciBpc0lkZW50aXR5VmFsaWQgPSB0eXBlb2Ygc2V0dGluZ3MuaWRlbnRpdHkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgT2JqZWN0LmtleXMoc2V0dGluZ3MuaWRlbnRpdHkpLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpdHlWYWxpZCkge1xuICAgICAgICAgICAgc2VsZi5pZGVudGl0eSA9IHNldHRpbmdzLmlkZW50aXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdExpc3RlbiA9IHNldHRpbmdzLmRlZmF1bHRMaXN0ZW4gfHwgZGVmYXVsdExpc3RlbjtcbiAgICAgICAgaWYgKCFzZWxmLmlkZW50aXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZGVudGl0eSBtdXN0IGJlIG5vbiBlbXB0eSBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbC5zZXBhcmF0b3IgPSBzZXR0aW5ncy5kZWZhdWx0U2VwYXJhdG9yIHx8IG1vZGVsLnNlcGFyYXRvcjtcblxuICAgICAgICBzZWxmLnNjaGVtYSA9IHNldHRpbmdzLnNjaGVtYSB8fCBzZWxmLnNjaGVtYSB8fCAnQXBwbGljYXRpb25Db25maWd1cmF0aW9uJztcblxuICAgICAgICBpbml0R2F0ZXdheSA9IF8uaXNGdW5jdGlvbihzZXR0aW5ncy5nYXRld2F5KVxuICAgICAgICA/IHNldHRpbmdzLmdhdGV3YXlcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmdhdGV3YXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZ2F0ZXdheSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmdhdGV3YXkuaW5zdGFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZ2F0ZXdheS5pbnN0YW5jZSA9IF8udXVpZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi9nYXRld2F5Jykoc2V0dGluZ3MuZ2F0ZXdheSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHNlbGYuY29ubmVjdCA9IGZ1bmN0aW9uIChsaXN0ZW4sIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBjbGVhclBvbGxpbmdJbnRlcnZhbCgpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24obGlzdGVuKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbGlzdGVuO1xuICAgICAgICAgICAgICAgIHNjb3BlID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgbGlzdGVuID0gZGVmYXVsdExpc3RlbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gYnVzLm9uKGV2ZW50cy5jb25uZWN0LCB0cnVlLCBjYWxsYmFjaywgc2NvcGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICBpZiAoIXNlbGYuaWRlbnRpdHkpIHtcbiAgICAgICAgICAgIGVycm9yID0gJ2lkZW50aXR5IGlzIG5vdCBzcGVjaWZpZWQuIGRpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgaW5pdCgpPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWdhdGV3YXkpIHtcbiAgICAgICAgICAgICAgICBnYXRld2F5ID0gaW5pdEdhdGV3YXkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFsaXN0ZW4pIHtcbiAgICAgICAgICAgICAgICBnYXRld2F5Q29ubmVjdGlvbiA9XG4gICAgICAgICAgICAgICAgICBnYXRld2F5LmNvbm5lY3QoXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlkZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yLCBzbmFwc2hvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hcHBseVNuYXBzaG90KHNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYnVzLmVtaXQoZXZlbnRzLmNvbm5lY3QsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IsIHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVzLmVtaXQoZXZlbnRzLnN0YXR1cywgZXJyb3IsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdEVtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnYXRld2F5Q29ubmVjdGlvbiA9IGdhdGV3YXkuY29ubmVjdChcbiAgICAgICAgICAgICAgICAgIHNlbGYuc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgc2VsZi5pZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IsIHNuYXBzaG90LCB1cGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzbmFwc2hvdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXBwbHlTbmFwc2hvdChzbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5hcHBseVVwZGF0ZXModXBkYXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0RW1pdHRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0RW1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ1cy5lbWl0KGV2ZW50cy5jb25uZWN0LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yLCBzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgTElTVEVOX05PVF9TVVBQT1JURUQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gTElTVEVOX05PVF9TVVBQT1JURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9sbGluZ0ludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXRld2F5LmRpc2Nvbm5lY3QoZ2F0ZXdheUNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2F0ZXdheUNvbm5lY3Rpb24gPSBnYXRld2F5LmNvbm5lY3Qoc2VsZi5zY2hlbWEsIHNlbGYuaWRlbnRpdHksIGZhbHNlLCBmdW5jdGlvbiAoZXJyb3IsIHNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYXBwbHlTbmFwc2hvdChzbmFwc2hvdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGJ1cy5lbWl0LCAwLCBldmVudHMuY29ubmVjdCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG5cbiAgICB9O1xuXG4gICAgc2VsZi5wcm9wcyA9IGZ1bmN0aW9uIChzZWN0aW9uLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHJvb3QucHJvcHMoc2VjdGlvbiwgc2VwYXJhdG9yKTtcbiAgICB9O1xuXG4gICAgc2VsZi5tb2RpZnkgPSBmdW5jdGlvbiAobW9kaWZpY2F0aW9ucywgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kaWZpY2F0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG1vZGlmaWNhdGlvbnMgPSBbbW9kaWZpY2F0aW9uc107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gYnVzLm9uKGV2ZW50cy51cGRhdGUsIHRydWUsIGNhbGxiYWNrLCBzY29wZSk7XG5cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuXG4gICAgc2VsZi5vbkNvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBidXMub24oZXZlbnRzLmNvbm5lY3QsIGZhbHNlLCBjYWxsYmFjaywgc2NvcGUpO1xuXG4gICAgfTtcblxuICAgIHNlbGYub25EaXNjb25uZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICByZXR1cm4gYnVzLm9uKGV2ZW50cy5kaXNjb25uZWN0LCBmYWxzZSwgY2FsbGJhY2ssIHNjb3BlKTtcbiAgICB9O1xuXG4gICAgc2VsZi5vZmYgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGJ1cy5vZmYoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLm9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBidXMucmVzdW1lKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgYnVzLm9uKGV2ZW50cy5kaXNjb25uZWN0LCB0cnVlLCBjYWxsYmFjaywgc2NvcGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJQb2xsaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBnYXRld2F5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZ2F0ZXdheS5kaXNjb25uZWN0KGdhdGV3YXlDb25uZWN0aW9uLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBidXMuZW1pdChldmVudHMuZGlzY29ubmVjdCwgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGdhdGV3YXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidXMuZW1pdChldmVudHMuZGlzY29ubmVjdCwgJ25vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5BcHBDb25maWcucHJvdG90eXBlLmlkZW50aXR5RXF1YWwgPSBoZWxwZXJzLmlkZW50aXR5RXF1YWw7XG5BcHBDb25maWcucHJvdG90eXBlLmlkZW50aXR5VG9TdHJpbmcgPSBoZWxwZXJzLmlkZW50aXR5VG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gbmV3IEFwcENvbmZpZygpO1xufTtcbiIsInZhciBnYXRld2F5Q29ubmVjdGlvbiA9IHJlcXVpcmUoJ3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24nKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgaWRlbnRpdHlUb1N0cmluZyA9IGhlbHBlcnMuaWRlbnRpdHlUb1N0cmluZztcbnZhciBQUk9EVUNUID0gJ2FwcGNvbmZpZyc7XG5cbnZhciBHYXRld2F5VHJhbnNwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGNvbm5lY3Rpb247XG4gICAgdmFyIGRhdGFIYW5kbGVycyA9IHt9O1xuICAgIHZhciBzdGF0dXNIYW5kbGVycyA9IHt9O1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RhdHVzTWVzc2FnZShtc2cpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBzdGF0dXNIYW5kbGVyc1ttc2cuaW5zdGFuY2VdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihtc2cuZXJyb3IsIG1zZy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRGF0YU1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHZhciBzY2hlbWEgPSBtc2cuc2NoZW1hO1xuICAgICAgICB2YXIgc2NoZW1hSGFuZGxlcnMgPSBkYXRhSGFuZGxlcnNbc2NoZW1hXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFIYW5kbGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZGVudGl0eUtleSA9IGlkZW50aXR5VG9TdHJpbmcobXNnLmlkZW50aXR5LCB0cnVlKTtcbiAgICAgICAgdmFyIGlkZW50aXR5SGFuZGxlcnMgPSBzY2hlbWFIYW5kbGVyc1tpZGVudGl0eUtleV07XG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnRpdHlIYW5kbGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkZW50aXR5SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKG1zZy5lcnJvciwgbXNnLnNuYXBzaG90LCBtc2cudXBkYXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuc3VyZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbm5lY3Rpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IG9wdGlvbnMuY29ubmVjdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IGdhdGV3YXlDb25uZWN0aW9uKG9wdGlvbnMuc2V0dGluZ3MsIG9wdGlvbnMuY3VzdG9tX2Nvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRhdGFTdWJzY3JpcHRpb247XG4gICAgdmFyIHN0YXR1c1N1YnNjcmlwdGlvbjtcbiAgICB2YXIgY29ubmVjdCA9IGZ1bmN0aW9uIChzY2hlbWEsIGlkZW50aXR5LCBsaXN0ZW4sIGhhbmRsZXIsIHN0YXR1c0hhbmRsZXIpIHtcbiAgICAgICAgZW5zdXJlQ29ubmVjdGlvbigpO1xuICAgICAgICB2YXIgc2NoZW1hSGFuZGxlcnMgPSBkYXRhSGFuZGxlcnNbc2NoZW1hXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFIYW5kbGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNjaGVtYUhhbmRsZXJzID0gZGF0YUhhbmRsZXJzW3NjaGVtYV0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZGVudGl0eUtleSA9IGlkZW50aXR5VG9TdHJpbmcoaWRlbnRpdHksIHRydWUpO1xuICAgICAgICB2YXIgaWRlbnRpdHlIYW5kbGVycyA9IHNjaGVtYUhhbmRsZXJzW2lkZW50aXR5S2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZGVudGl0eUhhbmRsZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWRlbnRpdHlIYW5kbGVycyA9IHNjaGVtYUhhbmRsZXJzW2lkZW50aXR5S2V5XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJUb1JlZ2lzdGVyO1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGlmIChsaXN0ZW4pIHtcbiAgICAgICAgICAgIGhhbmRsZXJUb1JlZ2lzdGVyID0gaGFuZGxlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZXJUb1JlZ2lzdGVyID0gZnVuY3Rpb24gKGVycm9yLCBzbmFwc2hvdCwgdXBkYXRlcykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXJyb3IsIHNuYXBzaG90LCB1cGRhdGVzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaWRlbnRpdHlIYW5kbGVyc1tpbmRleF07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBpZGVudGl0eUhhbmRsZXJzLnB1c2goaGFuZGxlclRvUmVnaXN0ZXIpIC0gMTtcblxuICAgICAgICBpZiAodHlwZW9mIChkYXRhU3Vic2NyaXB0aW9uKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRhdGFTdWJzY3JpcHRpb24gPSBjb25uZWN0aW9uLm9uKFBST0RVQ1QsIEdhdGV3YXlUcmFuc3BvcnQuTWVzc2FnZVR5cGUuREFUQSwgZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICAgIGhhbmRsZURhdGFNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG9wdGlvbnMuaW5zdGFuY2U7XG4gICAgICAgIHN0YXR1c0hhbmRsZXJzW2luc3RhbmNlXSA9IHN0YXR1c0hhbmRsZXI7XG4gICAgICAgIGlmICh0eXBlb2YgKHN0YXR1c1N1YnNjcmlwdGlvbikgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzdGF0dXNTdWJzY3JpcHRpb24gPSBjb25uZWN0aW9uLm9uKFBST0RVQ1QsIEdhdGV3YXlUcmFuc3BvcnQuTWVzc2FnZVR5cGUuU1RBVFVTLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlU3RhdHVzTWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbXNnID0ge1xuICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICBpZGVudGl0eTogaWRlbnRpdHksXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBsaXN0ZW46IGxpc3RlblxuICAgICAgICB9O1xuICAgICAgICBjb25uZWN0aW9uLnNlbmQoUFJPRFVDVCwgR2F0ZXdheVRyYW5zcG9ydC5NZXNzYWdlVHlwZS5DT05ORUNULCBtc2cpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICBpZGVudGl0eTogaWRlbnRpdHksXG4gICAgICAgICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIG1vZGlmeSA9IGZ1bmN0aW9uIChzY2hlbWEsIGlkZW50aXR5LCBtb2RpZmljYXRpb25zKSB7XG4gICAgICAgIGVuc3VyZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgY29ubmVjdGlvbi5zZW5kKFBST0RVQ1QsIEdhdGV3YXlUcmFuc3BvcnQuTWVzc2FnZVR5cGUuTU9ESUZZLCBtb2RpZmljYXRpb25zKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICAgICAgICB2YXIgc2NoZW1hSGFuZGxlcnMgPSBkYXRhSGFuZGxlcnNbZGVzY3JpcHRvci5zY2hlbWFdO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUhhbmRsZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIGlkZW50aXR5S2V5ID0gaWRlbnRpdHlUb1N0cmluZyhkZXNjcmlwdG9yLmlkZW50aXR5LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBpZGVudGl0eUhhbmRsZXJzID0gc2NoZW1hSGFuZGxlcnNbaWRlbnRpdHlLZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZGVudGl0eUhhbmRsZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gaWRlbnRpdHlIYW5kbGVyc1tkZXNjcmlwdG9yLmluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IGRlc2NyaXB0b3Iuc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHk6IGRlc2NyaXB0b3IuaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogb3B0aW9ucy5pbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNlbmQoR2F0ZXdheVRyYW5zcG9ydC5NZXNzYWdlVHlwZS5ESVNDT05ORUNULCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaWRlbnRpdHlIYW5kbGVyc1tkZXNjcmlwdG9yLmluZGV4XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaWRlbnRpdHlIYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYUhhbmRsZXJzW2lkZW50aXR5S2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWFIYW5kbGVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFIYW5kbGVyc1tkZXNjcmlwdG9yLnNjaGVtYV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGF0YUhhbmRsZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGRhdGFTdWJzY3JpcHRpb24pICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ub2ZmKGRhdGFTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHN0YXR1c0hhbmRsZXJzW2Rlc2NyaXB0b3IuaW5zdGFuY2VdO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoc3RhdHVzSGFuZGxlcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0dXNTdWJzY3JpcHRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vZmYoc3RhdHVzU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb25uZWN0OiBjb25uZWN0LFxuICAgICAgICBtb2RpZnk6IG1vZGlmeSxcbiAgICAgICAgZGlzY29ubmVjdDogZGlzY29ubmVjdFxuICAgIH07XG59O1xuXG5HYXRld2F5VHJhbnNwb3J0Lk1lc3NhZ2VUeXBlID0ge1xuICAgIC8vIHsgc2NoZW1hOiAnQXBwbGljYXRpb25Db25maWd1cmF0aW9uJywgaWRlbnRpdHk6IHt9LCBsaXN0ZW46IHRydWUsIGluc3RhbmNlOiAnJyB9XG4gICAgQ09OTkVDVDogJ2Nvbm5lY3QnLFxuICAgIC8vIHsgc2NoZW1hOiAnQXBwbGljYXRpb25Db25maWd1cmF0aW9uJywgaWRlbnRpdHk6IHt9LCBpbnN0YW5jZTogJycgfVxuICAgIERJU0NPTk5FQ1Q6ICdkaXNjb25uZWN0JyxcbiAgICAvLyB7IHNjaGVtYTogJ0FwcGxpY2F0aW9uQ29uZmlndXJhdGlvbicsIGlkZW50aXR5OiB7fSwgdXBkYXRlczogW10sIGluc3RhbmNlOiAnJyB9XG4gICAgTU9ESUZZOiAnbW9kaWZ5JyxcbiAgICAvLyB7IHNjaGVtYTogJ0FwcGxpY2F0aW9uQ29uZmlndXJhdGlvbicsIGlkZW50aXR5OiB7fSwgZXJyb3I6ICcnLCBzbmFwc2hvdDoge2RlZmF1bHRLZXlWYWx1ZTogJycsIGtleXM6IFtdLCBwcm9wczoge319LCB1cGRhdGVzOiBbXSB9XG4gICAgREFUQTogJ2RhdGEnLFxuICAgIC8vIHsgc2NoZW1hOiAnQXBwbGljYXRpb25Db25maWd1cmF0aW9uJywgaWRlbnRpdHk6IHt9LCBpbnN0YW5jZTogJycsIHN0YXR1czogJycsIGVycm9yOiAnJyB9XG4gICAgU1RBVFVTOiAnc3RhdHVzJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHYXRld2F5VHJhbnNwb3J0O1xuIiwiZnVuY3Rpb24gZXNjYXBlSWRlbnRpdHlUZXh0KHRleHQpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bXFxcXF0vZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvWzpdL2csICdcXFxcOicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaWRlbnRpdHlUb1N0cmluZyhpZGVudGl0eSwgaW5jbHVkZUtleXMsIHNlcGFyYXRvciwgb3JkZXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHR5cGVvZiAoaWRlbnRpdHkpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJy8nO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHkpO1xuICAgIGlmICh0eXBlb2YgKG9yZGVyKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBrZXlzLnNvcnQob3JkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuc29ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBpbmNsdWRlS2V5cyA/IChlc2NhcGVJZGVudGl0eVRleHQoa2V5KSArICc6JyArIGVzY2FwZUlkZW50aXR5VGV4dChpZGVudGl0eVtrZXldKSkgOiBpZGVudGl0eVtrZXldO1xuICAgIH0pLmpvaW4oc2VwYXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHlFcXVhbChpZGVudGl0eTEsIGlkZW50aXR5Mikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gaWRlbnRpdHlUb1N0cmluZyhpZGVudGl0eTEsIHRydWUpID09PSBpZGVudGl0eVRvU3RyaW5nKGlkZW50aXR5MiwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4ocHJvcHMsIHNlcGFyYXRvciwgbmFtZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJy4nO1xuICAgIHZhciBwcmVmaXggPSBuYW1lID8gbmFtZSArIHNlcGFyYXRvciA6ICcnO1xuICAgIHZhciB2YWwgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aCA9IGtleS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSB2YWw7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0W3BhcnRzW2ldXSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwYXJ0c1tpXV0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W3BhcnRzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFtwYXJ0c1tpXV0gPSBwcm9wc1trZXldLnZhbHVlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gcHJvcEVxdWFsKGxocywgcmhzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmIChsaHMudmFsdWUgIT09IHJocy52YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaHMudW5kZXJseWluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGhzVW5kZXJseWluZyA9IGxocy51bmRlcmx5aW5nW2ldO1xuICAgICAgICB2YXIgcmhzVW5kZXJseWluZyA9IHJocy51bmRlcmx5aW5nW2ldIHx8IHt9O1xuICAgICAgICBpZiAobGhzVW5kZXJseWluZy52YWx1ZSAhPT0gcmhzVW5kZXJseWluZy52YWx1ZSB8fCAhaWRlbnRpdHlFcXVhbChsaHNVbmRlcmx5aW5nLnBhcmVudCwgcmhzVW5kZXJseWluZy5wYXJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZmxhdHRlbjogZmxhdHRlbixcbiAgICBwcm9wRXF1YWw6IHByb3BFcXVhbCxcbiAgICBpZGVudGl0eVRvU3RyaW5nOiBpZGVudGl0eVRvU3RyaW5nLFxuICAgIGlkZW50aXR5RXF1YWw6IGlkZW50aXR5RXF1YWxcbn07XG4iLCJ2YXIgcHJvcEVxdWFsID0gcmVxdWlyZSgnLi9oZWxwZXJzJykucHJvcEVxdWFsO1xuXG52YXIgVXBkYXRlVHlwZSA9IHtcbiAgICBBZGRlZDogJ0FkZGVkJyxcbiAgICBDaGFuZ2VkOiAnQ2hhbmdlZCcsXG4gICAgUmVtb3ZlZDogJ1JlbW92ZWQnXG59O1xuXG52YXIgTW9kZWwgPSBmdW5jdGlvbiAoYnVzLCBzZXBhcmF0b3IpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdGhpcy5idXMgPSBidXM7XG4gICAgdGhpcy5yb290ID0gbmV3IFZpZXdNb2RlbCh0aGlzLCAnJywgc2VwYXJhdG9yIHx8ICcuJyk7XG4gICAgdGhpcy52aWV3cyA9IHt9O1xufTtcblxudmFyIFZpZXdNb2RlbCA9IGZ1bmN0aW9uIChtb2RlbCwgcGF0aCwgc2VwYXJhdG9yKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLm1vZGVsID0gbW9kZWw7XG4gICAgc2VsZi5wcm9wcyA9IHt9O1xuICAgIHNlbGYuc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8IG1vZGVsLnNlcGFyYXRvcjtcbiAgICBzZWxmLnBhdGggPSBwYXRoO1xufTtcblxuVmlld01vZGVsLnByb3RvdHlwZS5nZXRWaWV3TW9kZWwgPSBmdW5jdGlvbiAobmFtZSwgc2VwYXJhdG9yKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoICsgbmFtZSArIChzZXBhcmF0b3IgPyBzZXBhcmF0b3IgOiAnLicpO1xuICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC5yb290O1xuICAgIH1cblxuICAgIGlmICghbW9kZWwudmlld3NbcGF0aF0pIHtcbiAgICAgICAgdmFyIGJlc3RQYXJlbnQgPSAnJztcbiAgICAgICAgLy8gZmlsbCBzdWJ2aWV3IHJlZmVyZW5jZXMgYW5kIGNob29zZSBiZXN0IHBhcmVudCBwcm9wcyB0byBjb3B5IGZyb20uXG4gICAgICAgIE9iamVjdC5rZXlzKG1vZGVsLnZpZXdzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2Yoa2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChiZXN0UGFyZW50Lmxlbmd0aCA8IGtleS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFBhcmVudCA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBzdWJ2aWV3cyBzb3J0ZWQuXG4gICAgICAgICAgICAgICAgdmFyIHN1YnZpZXdzID0gbW9kZWwudmlld3Nba2V5XS5zdWJ2aWV3cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJ2aWV3c1tpXS5pbmRleE9mKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ2aWV3cy5zcGxpY2UoaSwgMCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdWJ2aWV3cy5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdmlld01vZGVsID0gbmV3IFZpZXdNb2RlbChtb2RlbCwgcGF0aCwgc2VwYXJhdG9yKTtcblxuICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSBiZXN0UGFyZW50ID09PSAnJyA/IG1vZGVsLnJvb3QucHJvcHMgOiBtb2RlbC52aWV3c1tiZXN0UGFyZW50XS5tb2RlbC5wcm9wcztcbiAgICAgICAgT2JqZWN0LmtleXMocGFyZW50UHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwYXJlbnRQcm9wc1trZXldO1xuICAgICAgICAgICAgaWYgKHByb3AubmFtZS5pbmRleE9mKHBhdGgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWUuc3Vic3RyaW5nKHBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2aWV3TW9kZWwucHJvcHNbbmFtZV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtb2RlbC52aWV3c1twYXRoXSA9IHtcbiAgICAgICAgICAgIHN1YnZpZXdzOiBbXSxcbiAgICAgICAgICAgIG1vZGVsOiB2aWV3TW9kZWxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kZWwudmlld3NbcGF0aF0ubW9kZWw7XG59O1xuXG5WaWV3TW9kZWwucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5vbih0aGlzLnBhdGgsIGNhbGxiYWNrLCBzY29wZSk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAocGF0aCwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciB0eXBlID0gdXBkYXRlVHlwZUZvclBhdGgocGF0aCk7XG4gICAgcmV0dXJuIHRoaXMuYnVzLm9uKHR5cGUsIGZhbHNlLCBjYWxsYmFjaywgc2NvcGUpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLmFwcGx5U25hcHNob3QgPSBmdW5jdGlvbiAoc25hcHNob3QsIGlzU25hcHNob3QpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaXNTbmFwc2hvdCA9IHR5cGVvZiBpc1NuYXBzaG90ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBpc1NuYXBzaG90O1xuXG4gICAgdmFyIHVwZGF0ZXMgPSB0b1VwZGF0ZXMoaXNTbmFwc2hvdCA/IHt9IDogdGhpcy5yb290LnByb3BzLCBzbmFwc2hvdC5wcm9wcyk7XG4gICAgYXBwbHlVcGRhdGVzQW5kRW1pdEV2ZW50cyh0aGlzLCB1cGRhdGVzLCBpc1NuYXBzaG90KTtcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVR5cGVGb3JQYXRoKHBhdGgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHR5cGUgPSAndXBkYXRlJztcbiAgICBpZiAocGF0aCAhPT0gJycpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUgKyAnfCcgKyBwYXRoO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xufVxuXG4vLyBzaGFsbG93IGNvcHlcbmZ1bmN0aW9uIGNsb25lVXBkYXRlRm9yUGF0aCh1cGRhdGUsIHBhdGgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgICB0eXBlOiB1cGRhdGUudHlwZSxcbiAgICAgICAgbmFtZTogdXBkYXRlLm5hbWUuc3Vic3RyaW5nKHBhdGgubGVuZ3RoKVxuICAgIH07XG5cbiAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgVXBkYXRlVHlwZS5DaGFuZ2VkOlxuICAgICAgICAgICAgY2xvbmUub2xkVmFsdWUgPSB1cGRhdGUub2xkVmFsdWU7XG4gICAgICAgICAgICBjbG9uZS52YWx1ZSA9IHVwZGF0ZS52YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFVwZGF0ZVR5cGUuQWRkZWQ6XG4gICAgICAgICAgICBjbG9uZS52YWx1ZSA9IHVwZGF0ZS52YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFVwZGF0ZVR5cGUuUmVtb3ZlZDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gYXBwbHlVcGRhdGVzQW5kRW1pdEV2ZW50cyhtb2RlbCwgdXBkYXRlcywgaXNTbmFwc2hvdCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgdmlld3MgPSBPYmplY3Qua2V5cyhtb2RlbC52aWV3cyk7XG4gICAgdmFyIGVmZmVjdGl2ZVVwZGF0ZXMgPSB7ICcnOiB1cGRhdGVzIH07XG4gICAgaWYgKHZpZXdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gc29ydCB2aWV3cyBmb3IgcHJlZml4IHNlYXJjaFxuICAgICAgICBpZiAodmlld3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmlld3Muc29ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB2aWV3O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3cy5sZW5ndGg7IHZpZXdzKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlLm5hbWUuaW5kZXhPZih2aWV3c1tpXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldyA9IHZpZXdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVmZmVjdGl2ZVVwZGF0ZXNbdmlld10ucHVzaChjbG9uZVVwZGF0ZUZvclBhdGgodXBkYXRlLCB2aWV3KSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBhZmZlY3RlZFBhdGhzID0gT2JqZWN0LmtleXMoZWZmZWN0aXZlVXBkYXRlcyk7XG4gICAgaWYgKGFmZmVjdGVkUGF0aHMubGVuZ3RoID4gMSkge1xuICAgICAgICBhZmZlY3RlZFBhdGhzLnNvcnQoKTtcbiAgICB9XG5cbiAgICBhZmZlY3RlZFBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHZpZXdNb2RlbCA9IHBhdGggPT09ICcnID8gbW9kZWwucm9vdCA6IG1vZGVsLnZpZXdzW3BhdGhdLm1vZGVsO1xuICAgICAgICBpZiAoaXNTbmFwc2hvdCkge1xuICAgICAgICAgICAgdmlld01vZGVsLnByb3BzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBlZmZlY3RpdmVVcGRhdGVzW3BhdGhdLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgVXBkYXRlVHlwZS5BZGRlZDpcbiAgICAgICAgICAgICAgIC8vIGJyZWFrIG9taXR0ZWRcbiAgICAgICAgICAgICAgICBjYXNlIFVwZGF0ZVR5cGUuQ2hhbmdlZDpcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VkIHdvcmtzIGV2ZW4gZm9yIG1pc3NpbmcgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICB2aWV3TW9kZWwucHJvcHNbdXBkYXRlLm5hbWVdID0gdXBkYXRlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFVwZGF0ZVR5cGUuUmVtb3ZlZDpcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZpZXdNb2RlbC5wcm9wc1t1cGRhdGUubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBhZmZlY3RlZFBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB1cGRhdGVUeXBlRm9yUGF0aChwYXRoKTtcbiAgICAgICAgbW9kZWwuYnVzLmVtaXQodHlwZSwgaXNTbmFwc2hvdCwgdXBkYXRlcyk7XG4gICAgfSk7XG59XG5cbk1vZGVsLnByb3RvdHlwZS5hcHBseVVwZGF0ZXMgPSBmdW5jdGlvbiAodXBkYXRlcykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBhcHBseVVwZGF0ZXNBbmRFbWl0RXZlbnRzKHRoaXMsIHVwZGF0ZXMsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHRvVXBkYXRlcyhpbWFnZSwgc25hcHNob3QpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgc25hcHNob3QgPSBzbmFwc2hvdCB8fCB7fTtcbiAgICB2YXIgdXBkYXRlcyA9IFtdO1xuICAgIHZhciB0b0RlbGV0ZSA9IE9iamVjdC5rZXlzKGltYWdlKTtcbiAgICBPYmplY3Qua2V5cyhzbmFwc2hvdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB1cGRhdGUgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZVtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdXBkYXRlLnR5cGUgPSBVcGRhdGVUeXBlLkFkZGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFwcm9wRXF1YWwoaW1hZ2Vba2V5XSwgc25hcHNob3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUudHlwZSA9IFVwZGF0ZVR5cGUuQ2hhbmdlZDtcbiAgICAgICAgICAgICAgICB1cGRhdGUub2xkVmFsdWUgPSBpbWFnZVtrZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5kZXhUb0RlbGV0ZTtcbiAgICAgICAgICAgIGZvciAoaW5kZXhUb0RlbGV0ZSA9IDA7IGluZGV4VG9EZWxldGUgPCB0b0RlbGV0ZS5sZW5ndGg7IHRvRGVsZXRlKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodG9EZWxldGVbaW5kZXhUb0RlbGV0ZV0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9EZWxldGVbaW5kZXhUb0RlbGV0ZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdG9EZWxldGUuc3BsaWNlKGluZGV4VG9EZWxldGUsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgICAgICB1cGRhdGUudmFsdWUgPSBzbmFwc2hvdFtrZXldO1xuICAgICAgICAgICAgdXBkYXRlLm5hbWUgPSBrZXk7XG4gICAgICAgICAgICB1cGRhdGVzLnB1c2godXBkYXRlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdG9EZWxldGUuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBVcGRhdGVUeXBlLlJlbW92ZWQsXG4gICAgICAgICAgICBuYW1lOiBrZXlcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXBkYXRlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDtcbiIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuZmxhdHRlbjtcblxudmFyIFByb3BzID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBwcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLnByb3BzW25hbWVdO1xuICAgIH07XG5cbiAgICB2YXIgdmFsID0gZnVuY3Rpb24gdmFsKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgbW9kZWwucHJvcHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbihtb2RlbC5wcm9wcywgbW9kZWwuc2VwYXJhdG9yLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RlbC5wcm9wc1tuYW1lXS52YWx1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHByb3BzID0gZnVuY3Rpb24gKHNlY3Rpb24sIHNlcGFyYXRvcikge1xuICAgICAgICBzZWN0aW9uID0gc2VjdGlvbiB8fCAnJztcbiAgICAgICAgaWYgKHNlY3Rpb24gPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IHNlcGFyYXRvciBjaGFuZ2UgZm9yICcnIChzYW1lKSBzZWN0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgbW9kZWwuc2VwYXJhdG9yO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BzKG1vZGVsLmdldFZpZXdNb2RlbChzZWN0aW9uLCBzZXBhcmF0b3IpKTtcbiAgICB9O1xuXG4gICAgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG1vZGVsLnByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUsIG1vZGVsLnByb3BzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG9uVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBtb2RlbC5vbihjYWxsYmFjaywgc2NvcGUpO1xuICAgIH07XG5cbiAgICB2YXIgc2VsZiA9IHtcbiAgICAgICAgcHJvcDogcHJvcCxcbiAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaCxcbiAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlXG4gICAgfTtcbiAgICByZXR1cm4gc2VsZjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvcHM7XG4iLCJ2YXIgdXVpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xuICAgICAgICB2YXIgdiA9IGMgPT09ICd4JyA/IHIgOiAoKHIgJiAweDMpIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59O1xuXG52YXIgbGV2ZWxzID0ge1xuICAgIGRlYnVnOiAnZGVidWcnLFxuICAgIGluZm86ICdpbmZvJyxcbiAgICB3YXJuOiAnd2FybicsXG4gICAgZXJyb3I6ICdlcnJvcidcbn07XG52YXIgbG9nID0gZnVuY3Rpb24gKGxldmVsLCBhcmdzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmIChjb25zb2xlKSB7XG4gICAgICAgIHZhciBsb2dnZXIgPSBjb25zb2xlW2xldmVsXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24obG9nZ2VyKSkge1xuICAgICAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBbXS5zcGxpY2UuY2FsbChhcmdzLCAwLCAwLCBub3cuZ2V0SG91cnMoKSArICc6JyArIG5vdy5nZXRNaW51dGVzKCkgKyAnOicgKyBub3cuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIGxvZ2dlci5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBpbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBsb2cobGV2ZWxzLmluZm8sIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgd2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgbG9nKGxldmVscy53YXJuLCBhcmd1bWVudHMpO1xufTtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBsb2cobGV2ZWxzLmRlYnVnLCBhcmd1bWVudHMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdXVpZDogdXVpZCxcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBsb2c6IGxvZyxcbiAgICB3YXJuOiB3YXJuLFxuICAgIGluZm86IGluZm8sXG4gICAgZGVidWc6IGRlYnVnXG59O1xuIiwidmFyIGNhbGxiYWNrUmVnaXN0cnkgPSByZXF1aXJlKCdjYWxsYmFjay1yZWdpc3RyeScpO1xudmFyIHBhY2thZ2VKc29uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5cbi8qKlxuICogQSB0ZW1wbGF0ZSBmb3IgZ2F0ZXdheSBjb25uZWN0aW9ucyAtIHRoaXMgaXMgZXh0ZW5kZWQgZnJvbSBzcGVjaWZpYyBwcm90b2NvbHMgYW5kIHRyYW5zcG9ydHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFRoZSBtZXNzYWdlIGhhbmRsZXJzIHRoYXQgaGF2ZSB0byBiZSBleGVjdXRlZCBmb3IgZWFjaCByZWNlaXZlZCBtZXNzYWdlXG4gICAgdmFyIG1lc3NhZ2VIYW5kbGVycyA9IHt9O1xuICAgIHZhciBpZHMgPSAwO1xuICAgIHZhciByZWdpc3RyeSA9IGNhbGxiYWNrUmVnaXN0cnkoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIF9jb25uZWN0ZWQgOiBmYWxzZSxcblxuICAgICAgICAvLyBhc3NlbWJsZXMgYSBuZXcgbWVzc2FnZSB0byBiZSBzZW50IHRvIGdhdGV3YXksXG4gICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIHJlcGxhY2VkIGZyb20gY29uY3JldGUgZ2F0ZXdheSBjb25uZWN0aW9uXG4gICAgICAgIF9jcmVhdGVNZXNzYWdlOiBmdW5jdGlvbih0eXBlLCBtZXNzYWdlLCBpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgLSB5b3Ugc2hvdWxkIGV4dGVuZCB0aGUgY29ubmVjdGlvbiB3aXRoIHByb3RvY29sICcgKyB0eXBlICsgbWVzc2FnZSArIGlkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBwcm9jZXNzZXMgYSBuZXcgbWVzc2FnZSBjYWxsaW5nIHRoZSBkaXN0cmlidXRlIG1ldGhvZCxcbiAgICAgICAgLy8gdGhpcyBzaG91bGQgYmUgcmVwbGFjZWQgZnJvbSBjb25jcmV0ZSBpZiB0aGV5IGhhdmUgZGlmZmVyZW50IG1lc3NhZ2Ugc3RydWN0dXJlXG4gICAgICAgIF9wcm9jZXNzTWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgLSB5b3Ugc2hvdWxkIGV4dGVuZCB0aGUgY29ubmVjdGlvbiB3aXRoIHByb3RvY29sICcgKyBtZXNzYWdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFeGVjdXRlcyBhcHByb3ByaWF0ZSBtZXNzYWdlIGhhbmRsZXJzIGZvciB0aGUgbWVzc2FnZSB0eXBlLlxuICAgICAgICBfZGlzdHJpYnV0ZU1lc3NhZ2U6IGZ1bmN0aW9uIChtZXNzYWdlLCB0eXBlKSB7XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBoYW5kbGVycyBmb3IgdGhlIG1lc3NhZ2UgdHlwZVxuICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gbWVzc2FnZUhhbmRsZXJzW3R5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlbVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1toYW5kbGVySWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gdHJpZ2dlcnMgY29ubmVjdGlvbiBjaGFuZ2Ugbm90aWZ5aW5nIGFsbCB1c2Vyc1xuICAgICAgICBfdHJpZ2dlckNvbm5lY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbihjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGNvbm5lY3RlZDtcblxuICAgICAgICAgICAgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJlZ2lzdHJ5LmV4ZWN1dGUoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWdpc3RyeS5leGVjdXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBdHRhY2hlcyBhIGhhbmRsZXJcbiAgICAgICAgb246IGZ1bmN0aW9uIChwcm9kdWN0LCB0eXBlLCBtZXNzYWdlSGFuZGxlcikge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlSGFuZGxlcnNbdHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyc1t0eXBlXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaWQgPSBpZHMrKztcbiAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyc1t0eXBlXVtpZF0gPSBtZXNzYWdlSGFuZGxlcjtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBSZW1vdmUgYSBoYW5kbGVyXG4gICAgICAgIG9mZjogZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtZXNzYWdlSGFuZGxlcnNbaW5mby50eXBlLnRvTG93ZXJDYXNlKCldW2luZm8uaWRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbm5lY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soc2V0dGluZ3Mud3MgfHwgc2V0dGluZ3MuaHR0cCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZ2lzdHJ5LmFkZCgnY29ubmVjdGVkJywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc2Nvbm5lY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZWdpc3RyeS5hZGQoJ2Rpc2Nvbm5lY3RlZCcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsb2dpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBsb2dvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSW5pdCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHN1Y2Nlc3NmdWwgbG9naW5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcm90b2NvbFZlcnNpb24gOiBzZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gfHwgMSxcblxuICAgICAgICB2ZXJzaW9uOiBwYWNrYWdlSnNvbi52ZXJzaW9uXG4gICAgfVxufTtcblxuIiwidmFyIGJhc2VDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJyk7XG5cbi8qKlxuICogQ2hlY2sgcmVhZG1lLm1kIGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvblxuICovXG52YXIgY29ubmVjdGlvbiA9IGZ1bmN0aW9uIChzZXR0aW5ncywgY3VzdG9tQ29ubmVjdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgIHZhciBjb25uZWN0aW9uID0gYmFzZUNvbm5lY3Rpb24oc2V0dGluZ3MpO1xuXG4gICAgLy8gaWYgcnVubmluZyBpbiBIQyB3ZSB1c2UgZ3cxIHByb3RvY29sIGFuZCBoYyB0cmFuc3BvcnRcbiAgICBpZiAoZ2xvYmFsLmh0bWxDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25uZWN0aW9uID0gcmVxdWlyZSgnLi9wcm90b2NvbHMvZ3cxJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2hjJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIC8vIGlmIHJ1bm5pbmcgaW4gdGhlIGJyb3dzZXIgLSBsZXQncyBjaGVjayB3aGljaCBwcm90b2NvbCB2ZXJzaW9uIHVzZXIgd2FudHNcbiAgICBpZiAoc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSAzKSB7XG4gICAgICAgIGNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL3Byb3RvY29scy9ndzMnKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgY29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vcHJvdG9jb2xzL2d3MicpKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25uZWN0aW9uID0gcmVxdWlyZSgnLi9wcm90b2NvbHMvZ3cxJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy53cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3RyYW5zcG9ydHMvd3MnKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5odHRwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9odHRwJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgIH0gZWxzZSBpZiAoY3VzdG9tQ29ubmVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3RyYW5zcG9ydHMvbW9jaycpKGNvbm5lY3Rpb24sIGN1c3RvbUNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbm5lY3Rpb24uIE1ha2Ugc3VyZSB5b3UgYXJlIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uIGZyb20gVGljazQyIEh0bWxDb250YWluZXIgb3IgZmlsbCB0aGUgXFwnY29ubmVjdGlvbi53ZWJzb2NrZXRfdXJsXFwnIHByb3BlcnR5LicpO1xuICAgIH1cbn07XG5cbmlmIChnbG9iYWwudGljazQyID09PSB1bmRlZmluZWQpIHtcbiAgICBnbG9iYWwudGljazQyID0ge307XG59XG5cbmdsb2JhbC50aWNrNDIuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdGlvbjtcbiIsIi8vIENvbm5lY3Rpb24gdG8gZ2F0ZXdheSBWMSAtIHRoZSBvbmUgdGhhdCBydW5zIG9uIHRoZSBkZXNrdG9wIHdpdGhvdXQgYXV0aGVudGljYXRpb25cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBjb25uZWN0aW9uLl9wcm9jZXNzTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgICAgIGNvbm5lY3Rpb24uX2Rpc3RyaWJ1dGVNZXNzYWdlKG1lc3NhZ2UubWVzc2FnZSwgbWVzc2FnZS50eXBlKTtcbiAgICB9O1xuXG4gICAgY29ubmVjdGlvbi5fY3JlYXRlTWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIG1lc3NhZ2UsIGlkKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29ubmVjdGlvbi5sb2dpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufTtcbiIsIi8vIENvbm5lY3Rpb24gdG8gZ2F0ZXdheSBWMiAtIGd3MSArICBhdXRoZW50aWNhdGlvblxudmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBzZXNzaW9uQ29va2llO1xuICAgIGNvbm5lY3Rpb24uX3Byb2Nlc3NNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICAgICAgdmFyIGRhdGFUeXBlID0gbWVzc2FnZS50eXBlO1xuXG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ1NFTkQnKSAge1xuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX2Rpc3RyaWJ1dGVNZXNzYWdlKG1lc3NhZ2UubWVzc2FnZSwgbWVzc2FnZS50eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX2Rpc3RyaWJ1dGVNZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29ubmVjdGlvbi5fY3JlYXRlTWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIG1lc3NhZ2UsIGlkKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnTE9HSU4nKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ0xPR09VVCcpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICdMT0dPVVQnIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHR5cGU6ICdTRU5EJyxcbiAgICAgICAgICAgIHNlc3Npb25Db29raWU6IHNlc3Npb25Db29raWUsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29ubmVjdGlvbi5sb2dpbiA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3Q7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50b2tlbikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBtZXNzYWdlLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTE9HSU5fVE9LRU4nXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS51c2VybmFtZSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXI6IG1lc3NhZ2UudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBtZXNzYWdlLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTE9HSU4nXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGF1dGggbWVzc2FnZScgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsclN1YnMgPSBjb25uZWN0aW9uLm9uKCcnLCAnTE9HSU5fUkVTUE9OU0UnLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLm9mZihsclN1YnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmICFyZXNwb25zZS5lcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkNvb2tpZSA9IHJlc3BvbnNlLnNlc3Npb25Db29raWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZCgnJywgJ0xPR0lOJywgcmVxdWVzdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25uZWN0aW9uLmxvZ291dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25uZWN0aW9uLnNlbmQoJycsICdMT0dPVVQnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG4iLCJ2YXIgc2hvcnRpZCA9IHJlcXVpcmUoJ3Nob3J0aWQnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xudmFyIFVSTFNlYXJjaFBhcmFtcyA9IHJlcXVpcmUoJ3VybC1zZWFyY2gtcGFyYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgc2V0dGluZ3MpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRhdGVQcmVmaXggPSAnI1Q0Ml9EQVRFXyc7XG4gICAgdmFyIGRhdGVQcmVmaXhMZW4gPSBkYXRlUHJlZml4Lmxlbmd0aDtcbiAgICB2YXIgZGF0ZU1pbkxlbiA9IGRhdGVQcmVmaXhMZW4gKyAxOy8vIHByZWZpeCArIGF0IGxlYXN0IG9uZSBjaGFyICgxOTcwLzAxLzAxID0gMClcbiAgICB2YXIgZGF0ZVByZWZpeEZpcnN0Q2hhciA9IGRhdGVQcmVmaXhbMF07XG5cbiAgICBjb25uZWN0aW9uLmluc3RhbmNlID0gc2hvcnRpZC5nZW5lcmF0ZSgpO1xuXG4gICAgY29ubmVjdGlvbi5fcHJvY2Vzc01lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBKU09OLnBhcnNlKG1lc3NhZ2UsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlbMF0gIT09IGRhdGVQcmVmaXhGaXJzdENoYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDwgZGF0ZU1pbkxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoZGF0ZVByZWZpeExlbiwgdmFsdWUubGVuZ3RoKSwgMTApO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG1pbGxpc2Vjb25kcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobWlsbGlzZWNvbmRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbm5lY3Rpb24uX2Rpc3RyaWJ1dGVNZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2UudHlwZSk7XG4gICAgfTtcblxuICAgIGNvbm5lY3Rpb24uX2NyZWF0ZU1lc3NhZ2UgPSAgZnVuY3Rpb24odHlwZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWVzc2FnZSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBkYXRlcyBhcyAjVDQyX0RBVEUoPE1JTExJU0VDT05EU19GUk9NXzE5NzBfMDFfMDE+KVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvbWUgZHVjayB0eXBpbmdcbiAgICAgICAgICAgIGlmICghdmFsdWUuZ2V0VGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGVQcmVmaXggKyB2YWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25uZWN0aW9uLmxvZ2luID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgYXV0aGVudGljYXRpb24gPSB7fTtcbiAgICAgICAgICAgIHZhciBnd1Rva2VuID0gZ2V0R2F0ZXdheVRva2VuKCk7XG4gICAgICAgICAgICBpZiAoZ3dUb2tlbikge1xuICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uLm1ldGhvZCA9ICdnYXRld2F5LXRva2VuJztcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvbi50b2tlbiA9IGd3VG9rZW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudG9rZW4pIHtcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvbi5tZXRob2QgPSAnYWNjZXNzLXRva2VuJztcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvbi50b2tlbiA9IG1lc3NhZ2UudG9rZW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvbi5tZXRob2QgPSAnc2VjcmV0JztcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvbi51c2VyID0gbWVzc2FnZS51c2VybmFtZTtcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdGlvbi5zZWNyZXQgPSBtZXNzYWdlLnBhc3N3b3JkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXV0aCBtZXNzYWdlJyArIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlcXVlc3RJZCA9IHNob3J0aWQuZ2VuZXJhdGUoKTtcbiAgICAgICAgICAgIHZhciBoZWxsb01zZyA9IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X2lkOiByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlbGxvJyxcbiAgICAgICAgICAgICAgICBpZGVudGl0eTogeyBhcHBsaWNhdGlvbjogc2V0dGluZ3MuYXBwbGljYXRpb24sIGluc3RhbmNlOiBjb25uZWN0aW9uLmluc3RhbmNlIH0sXG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb246IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgd2VsY29tZVN1YiA9IGNvbm5lY3Rpb24ub24oJycsICd3ZWxjb21lJywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICAgIGlmIChtc2cucmVxdWVzdF9pZCAhPT0gcmVxdWVzdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLm9mZih3ZWxjb21lU3ViKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLm9mZihlcnJvclN1Yik7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5wZWVySWQgPSBtc2cucGVlcl9pZDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmd3VG9rZW4gPSBnd1Rva2VuO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobXNnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgZXJyb3JTdWIgPSBjb25uZWN0aW9uLm9uKCcnLCAnZXJyb3InLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1zZy5yZXF1ZXN0X2lkICE9PSByZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ub2ZmKGVycm9yU3ViKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLm9mZih3ZWxjb21lU3ViKTtcbiAgICAgICAgICAgICAgICByZWplY3QobXNnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25uZWN0aW9uLnNlbmQoJycsICdMT0dJTicsIGhlbGxvTXNnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbm5lY3Rpb24ubG9nb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZCgnJywgJ0xPR09VVCcpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRHYXRld2F5VG9rZW4oKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5nd1Rva2VuUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5nd1Rva2VuUHJvdmlkZXIuZ2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jYXRpb24gJiYgbG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaFBhcmFtcy5nZXQoJ3Q0Mmd3dG9rZW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuIiwiLyoqXG4gKiBDb25uZWN0aW9uIHRvIEh0bWxDb250YWluZXJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgY29ubmVjdGlvbklkID0gTWF0aC5mbG9vcigxZTEwICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKTtcbiAgICAvLyBSb3V0ZSBtZXNzYWdlcyB0byBmYWNhZGUocylcbiAgICBjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbiAocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAocHJvZHVjdCA9PT0gJ21ldHJpY3MnKSB7XG4gICAgICAgICAgICBnbG9iYWwuaHRtbENvbnRhaW5lci5tZXRyaWNzRmFjYWRlLnNlbmQodHlwZSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2R1Y3QgPT09ICdsb2cnKSB7XG4gICAgICAgICAgICBnbG9iYWwuaHRtbENvbnRhaW5lci5sb2dnaW5nRmFjYWRlLnNlbmQodHlwZSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2R1Y3QgPT09ICdhcHBjb25maWcnKSB7XG4gICAgICAgICAgICBnbG9iYWwuaHRtbENvbnRhaW5lci5hcHBDb25maWdGYWNhZGUuc2VuZCh0eXBlLCBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgY29ubmVjdGlvbklkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoZ2xvYmFsLmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2xvYmFsLmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlLmluaXRDb25uZWN0aW9uKFxuICAgICAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG1lc3NhZ2VBc0pzb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5faGFuZGxlX21lc3NhZ2UoSlNPTi5wYXJzZShtZXNzYWdlQXNKc29uKSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnbG9iYWwuY29ubmVjdGlvbnMgPSBnbG9iYWwuY29ubmVjdGlvbnMgfHwge307XG4gICAgLy8gRXhwb3NlIGZ1bmN0aW9uIGZvciBzZW5kaW5nIG1lc3NhZ2VzOlxuICAgIGdsb2JhbC5jb25uZWN0aW9uc1snY29ubmVjdGlvbicgKyBjb25uZWN0aW9uSWRdID0gY29ubmVjdGlvbi5faGFuZGxlX21lc3NhZ2U7XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBzZXR0aW5ncykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgdXJsID0gc2V0dGluZ3MuaHR0cDtcbiAgICAvLyBwb2xsaW5nIGludGVydmFsIGluIG1zLCBkZWZhdWx0IGlzIDEgc2Vjb25kXG4gICAgdmFyIGludGVydmFsID0gc2V0dGluZ3MuaHR0cF9pbnRlcnZhbF9tcztcbiAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICAgIGludGVydmFsID0gMTAwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2dEZWJ1ZyhtZXNzYWdlKSB7XG4gICAgICAgIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIChzZXR0aW5ncy5kZWJ1ZyA9PT0gdHJ1ZSB8fCBzZXR0aW5ncy50cmFjZSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9nVHJhY2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBzZXR0aW5ncy50cmFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2dEZWJ1ZygnQXR0ZW1waW5nIHRvIGNvbm5lY3QgdG8gR2F0ZXdheSB2aWEgSFRUUCB3aXRoIHVybCBcXCcnICsgdXJsICsgJ1xcJyBhbmQgcG9sbGluZyBpbnRlcnZhbCAnICsgaW50ZXJ2YWwgKyAnIG1zJyk7XG5cbiAgICBjb25uZWN0aW9uLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcG9sbCh1cmwsIGludGVydmFsLCAwLCBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpdGVtcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLl9wcm9jZXNzTWVzc2FnZShpdGVtc1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbiAocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSwgaWQpIHtcbiAgICAgICAgdmFyIG1zZyA9IGNvbm5lY3Rpb24uX2NyZWF0ZU1lc3NhZ2UodHlwZSwgbWVzc2FnZSwgaWQpO1xuICAgICAgICBodHRwUG9zdCh1cmwsIG1zZyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBvbGxzIGRhdGEgZnJvbSBhIGdpdmVuIHVybCBvbiBzb21lIGludGVydmFsXG4gICAgICogQHBhcmFtIHVybCAgICAgICBCYXNlIHNlcnZlciB1cmwuIEEgc2VxdWVuY2UgdXJsIHBhcmFtIG1heSBiZSBhZGRlZCBiYXNlZCBvbiB0aGUgc2VxIHBhcmFtXG4gICAgICogQHBhcmFtIGludGVydmFsICBJbnRlcnZhbCAoaW4gbXMpIGJldHdlZW4gcG9sbGluZyByZXF1ZXN0dHNcbiAgICAgKiBAcGFyYW0gc2VxICAgICAgIE5leHQgc2VxdWVuY2UgbnVtYmVyIHdlIHNob3VsZCBhc2sgZm9yIChpZiAwIHRoZSBzZXJ2ZXIgd2lsbCByZXR1cm4gdGhlIGxhc3Qga25vd24gbWVzc2FnZSlcbiAgICAgKiBAcGFyYW0gb25kYXRhICAgIERhdGEgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb2xsKHVybCwgaW50ZXJ2YWwsIHNlcSwgb25kYXRhKSB7XG4gICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgZ2V0IFVybCAtIGlmIHNlcSAhPSAwIGFkZCBhcyB1cmwgcGFyYW0gdG8gZ2V0XG4gICAgICAgIC8vIG9ubHkgbWVzc2FnZXMgYWZ0ZXIgdGhpcyBzZXF1ZW5jZVxuICAgICAgICB2YXIgZ2V0VXJsID0gdXJsO1xuXG4gICAgICAgIGlmIChzZXEgIT09IDApIHtcbiAgICAgICAgICAgIGdldFVybCA9IHVybCArICc/c2VxdWVuY2U9JyArIHNlcSArICcmbm8tY2FjaGU9JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcmVxdWVzdFxuICAgICAgICB2YXIgeG1saHR0cCA9IGNyZWF0ZUNPUlNSZXF1ZXN0KCdHRVQnLCBnZXRVcmwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZXEgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnQ29ubmVjdGVkIHRvIEdhdGV3YXkgb24gJyArIHVybCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvZ1RyYWNlKCdSZXNwb25zZSBmcm9tIFxcJycgKyBnZXRVcmwgKyAnXFwnIGlzICcgKyB4bWxodHRwLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoeG1saHR0cC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgLy8gdGhlIHNlcnZlciByZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIG5leHQgc2VxdWVuY2UgdGhhdCB3ZSBtdXN0IHF1ZXJ5IGZvclxuICAgICAgICAgICAgdmFyIG5leHRTZXEgPSBtZXNzYWdlLm5leHRTZXF1ZW5jZTtcbiAgICAgICAgICAgIC8vIGNhbGwgdXNlciBjYWxsYmFja2VcbiAgICAgICAgICAgIG9uZGF0YShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgLy8gcmUtc2NoZWR1bGVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBvbGwodXJsLCBpbnRlcnZhbCwgbmV4dFNlcSwgb25kYXRhKTtcbiAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgeG1saHR0cC5vbmVycm9yID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgcG9sbGluZyBkYXRhIGZyb20gaHR0cCBzZXJ2ZXIgXFwnJyArIGdldFVybCArICdcXCcgLSAnICsgZXYpO1xuICAgICAgICAgICAgLy8gcmUtc2NoZWR1bGVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBvbGwodXJsLCBpbnRlcnZhbCwgc2VxLCBvbmRhdGEpO1xuICAgICAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxvZ1RyYWNlKCdTZW5kaW5nIEdFVCB0byBcXCcnICsgZ2V0VXJsICsgJ1xcJycpO1xuICAgICAgICB4bWxodHRwLnNlbmQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQT1NUcyBhIG1lc3NhZ2UgdG8gYSBnaXZlbiB1cmxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBodHRwUG9zdCh1cmwsIG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgcmVxdWVzdFxuICAgICAgICB2YXIgeG1saHR0cCA9IGNyZWF0ZUNPUlNSZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgICAgICAgbG9nVHJhY2UoJ1NlbmRpbmcgUE9TVCB0byBcXCcnICsgdXJsICsgJ1xcJyA6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgeG1saHR0cC5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgQ09SUyByZXF1ZXN0IChjcm9zcyBkb21haW4gcmVxdWVzdHMpIGZvciBkaWZmZXJlbnQgYnJvd3NlcnMgLSBYTUxIdHRwUmVxdWVzdCB3aXRoQ3JlZGVudGlhbHNcbiAgICAgKiBmb3IgQ2hyb21lIGFuZCBGRiBhbmQgWERvbWFpblJlcXVlc3QgZm9yIElFXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ09SU1JlcXVlc3QobWV0aG9kLCB1cmwsIHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0IGhhcyBhIFwid2l0aENyZWRlbnRpYWxzXCIgcHJvcGVydHkuXG4gICAgICAgICAgICAvLyBcIndpdGhDcmVkZW50aWFsc1wiIG9ubHkgZXhpc3RzIG9uIFhNTEhUVFBSZXF1ZXN0MiBvYmplY3RzLlxuICAgICAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRDYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNoZWNrIGlmIFhEb21haW5SZXF1ZXN0LlxuICAgICAgICAgICAgLy8gWERvbWFpblJlcXVlc3Qgb25seSBleGlzdHMgaW4gSUUsIGFuZCBpcyBJRSdzIHdheSBvZiBtYWtpbmcgQ09SUyByZXF1ZXN0cy5cbiAgICAgICAgICAgIHhociA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRDYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB4aHIub25sb2FkID0gcmVzdWx0Q2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIENPUlMgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgIHhociA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geGhyO1xuICAgIH1cblxuICAgIHJldHVybiBjb25uZWN0aW9uO1xufTtcbiIsIi8qKlxuICogVXNlZCBmb3IgdGVzdHNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBjdXN0b21Db25uZWN0aW9uKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGNvbm5lY3Rpb24uc2VuZCA9IGZ1bmN0aW9uIChwcm9kdWN0LCB0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgIGN1c3RvbUNvbm5lY3Rpb24ucHVibGlzaCh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY3VzdG9tQ29ubmVjdGlvbi5zdWJzY3JpYmUoY29ubmVjdGlvbi5faGFuZGxlX21lc3NhZ2UpO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIHNldHRpbmdzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gTG9hZCB0aGUgJ3dzJyBsaWJyYXJ5LCBidXQgb25seSBpZiB3ZSBhcmUgcnVubmluZyB1bmRlciBub2RlIGpzXG4gICAgdmFyIFdlYlNvY2tldCA9IHJlcXVpcmUoJ2RldGVjdC1ub2RlJykgPyByZXF1aXJlKCd3cycpIDogZ2xvYmFsLldlYlNvY2tldDtcblxuICAgIGZ1bmN0aW9uIGluaXRpYXRlU29ja2V0KCkge1xuICAgICAgICB2YXIgd3MgPSBuZXcgV2ViU29ja2V0KHNldHRpbmdzLndzKTtcbiAgICAgICAgd3Mub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX3RyaWdnZXJDb25uZWN0aW9uQ2hhbmdlZChmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIExvZyBvbiBjb25uZWN0aW9uXG4gICAgICAgIHdzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX3RyaWdnZXJDb25uZWN0aW9uQ2hhbmdlZCh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXR0YWNoIGhhbmRsZXJcbiAgICAgICAgd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX3Byb2Nlc3NNZXNzYWdlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHdzO1xuICAgIH1cblxuICAgIC8vIEhvbGRzIGNhbGxiYWNrIGV4ZWN1dGlvbiB1bnRpbCBzb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZC5cbiAgICBmdW5jdGlvbiB3YWl0Rm9yU29ja2V0Q29ubmVjdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA+IDEpIHtcbiAgICAgICAgICAgIC8vID4gMSBtZWFucyBjbG9zaW5nIG9yIGNsb3NlZFxuICAgICAgICAgICAgc29ja2V0ID0gaW5pdGlhdGVTb2NrZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2FpdEZvclNvY2tldENvbm5lY3Rpb24oY2FsbGJhY2spO1xuICAgICAgICB9LCA1MCk7IC8vIHdhaXQgNSBtaWxsaXNlY29uZHMgZm9yIHRoZSBjb25uZWN0aW9uLi4uXG4gICAgfVxuXG4gICAgLy8gSW5pdGlhdGUgYSBuZXcgc29ja2V0ICh0aGlzIGdldHMgcmUtZXhlY3V0ZWQgb24gcmVjb25uZWN0KVxuICAgIHZhciBzb2NrZXQgPSBpbml0aWF0ZVNvY2tldCgpO1xuXG4gICAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gZm9yIHNlbmRpbmcgYSBtZXNzYWdlXG4gICAgY29ubmVjdGlvbi5zZW5kID0gZnVuY3Rpb24gKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2UsIGlkKSB7XG4gICAgICAgIHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IGNvbm5lY3Rpb24uX2NyZWF0ZU1lc3NhZ2UodHlwZSwgbWVzc2FnZSwgaWQpO1xuICAgICAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb2NrZXQuc2VuZChtc2cpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29ubmVjdGlvbi53ZWJzb2NrZXRfdXJsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgc2V0dGluZ3Mud2Vic29ja2V0X3VybCA9IGE7XG4gICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICBzb2NrZXQgPSBpbml0aWF0ZVNvY2tldCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvbkA+PTEuMy4yXCIsXG4gICAgICBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcZGV2XFxcXGpzLWdsdWVcXFxcbm9kZV9tb2R1bGVzXFxcXHRpY2s0Mi1hcHBjb25maWdcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25APj0xLjMuMlwiLFxuICBcIl9pZFwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25AMi4xLjRcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi90aWNrNDItYXBwY29uZmlnL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25cIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCI2LjMuMFwiLFxuICBcIl9ucG1Vc2VyXCI6IHt9LFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMy44LjVcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25cIixcbiAgICBcInJhd1wiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25APj0xLjMuMlwiLFxuICAgIFwicmF3U3BlY1wiOiBcIj49MS4zLjJcIixcbiAgICBcInNjb3BlXCI6IG51bGwsXG4gICAgXCJzcGVjXCI6IFwiPj0xLjMuMlwiLFxuICAgIFwidHlwZVwiOiBcInJhbmdlXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvdGljazQyLWFwcGNvbmZpZ1wiXG4gIF0sXG4gIFwiX3NoYXN1bVwiOiBcImNlY2Y1MmRhNzg1YjNkMGI1MjhkY2UxZTEwYzE5ZmFkNTE2ODA2NWZcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvbkA+PTEuMy4yXCIsXG4gIFwiX3doZXJlXCI6IFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxkZXZcXFxcanMtZ2x1ZVxcXFxub2RlX21vZHVsZXNcXFxcdGljazQyLWFwcGNvbmZpZ1wiLFxuICBcImJpblwiOiB7XG4gICAgXCJidWlsZFwiOiBcIi4vYmluL2J1aWxkLmpzXCIsXG4gICAgXCJjbGVhblwiOiBcIi4vYmluL2NsZWFuLmpzXCIsXG4gICAgXCJmaWxlLXZlcnNpb25pZnlcIjogXCIuL2Jpbi9maWxlLXZlcnNpb25pZnkuanNcIixcbiAgICBcIm1pbmlmeVwiOiBcIi4vYmluL21pbmlmeS5qc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXJpZnktdmVyc2lvbmlmeVwiOiBcIl4xLjAuNFwiLFxuICAgIFwiY2FsbGJhY2stcmVnaXN0cnlcIjogXCJeMS4wLjFcIixcbiAgICBcImRldGVjdC1ub2RlXCI6IFwiXjIuMC4zXCIsXG4gICAgXCJlczYtcHJvbWlzZVwiOiBcIl4zLjIuMVwiLFxuICAgIFwic2hvcnRpZFwiOiBcIl4yLjIuNlwiLFxuICAgIFwidXJsLXNlYXJjaC1wYXJhbXNcIjogXCJeMC41LjBcIixcbiAgICBcIndzXCI6IFwiXjAuNy4yXCJcbiAgfSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlRpY2s0MiBHYXRld2F5IENvbm5lY3Rpb24uXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJsYW5rZXRcIjogXCJeMS4xLjZcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTMuMC4wXCIsXG4gICAgXCJicm93c2VyaWZ5LXJlcGxhY2lmeVwiOiBcIl4wLjAuNFwiLFxuICAgIFwiYnJvd3NlcmlmeS12ZXJzaW9uaWZ5XCI6IFwiXjEuMC40XCIsXG4gICAgXCJlc2xpbnRcIjogXCJeMy4xLjFcIixcbiAgICBcImVzbGludC1jb25maWctc3RhbmRhcmRcIjogXCJeNS4zLjVcIixcbiAgICBcImVzbGludC1jb25maWctdGljazQyXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXByb21pc2VcIjogXCJeMi4wLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tc3RhbmRhcmRcIjogXCJeMi4wLjBcIixcbiAgICBcImZzXCI6IFwiMC4wLjJcIixcbiAgICBcImpzZG9tXCI6IFwiXjguMS4wXCIsXG4gICAgXCJtaW5pZnlpZnlcIjogXCJeNy4zLjJcIixcbiAgICBcIm9uY2hhbmdlXCI6IFwiXjIuMS4yXCIsXG4gICAgXCJwaGFudG9tanNcIjogXCJeMS45LjEyXCIsXG4gICAgXCJxdW5pdGpzXCI6IFwiXjEuMTUuMFwiLFxuICAgIFwic2hlbGxqc1wiOiBcIl4wLjYuMFwiXG4gIH0sXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCJjZWNmNTJkYTc4NWIzZDBiNTI4ZGNlMWUxMGMxOWZhZDUxNjgwNjVmXCIsXG4gICAgXCJ0YXJiYWxsXCI6IFwiaHR0cDovLzE5Mi4xNjguMC4yMzQ6NDg3My90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uLy0vdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi0yLjEuNC50Z3pcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCI0ZGRkMWRlODI2MjhkODJiM2Y5NjQ2NzY5MDkyNTYxMGZjMTU0N2FmXCIsXG4gIFwibWFpblwiOiBcImxpYnJhcnkvbWFpbi5qc1wiLFxuICBcIm5hbWVcIjogXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCIsXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuICBcInJlYWRtZUZpbGVuYW1lXCI6IFwicmVhZG1lLm1kXCIsXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJidWlsZFwiOiBcIm5wbSBydW4gZXNsaW50ICYmIG5vZGUgYmluL2NsZWFuLmpzICYmIG5vZGUgYmluL2J1aWxkLmpzICYmIG5vZGUgYmluL21pbmlmeSAmJiBub2RlIGJpbi9maWxlLXZlcnNpb25pZnlcIixcbiAgICBcImVzbGludFwiOiBcImVzbGludCBsaWJyYXJ5XCIsXG4gICAgXCJlc2xpbnQ6Zml4XCI6IFwiZXNsaW50IGxpYnJhcnkgLS1maXggXCIsXG4gICAgXCJwcmVwdWJsaXNoXCI6IFwibnBtIHVwZGF0ZSAmIG5wbSBydW4gYnVpbGRcIixcbiAgICBcInRlc3RcIjogXCJucG0gcnVuIGVzbGludCAmJiBtb2NoYSAtLXJlcXVpcmUgLi90ZXN0L3Rlc3RfaGVscGVyIFxcXCJ0ZXN0LyoqLyouanNcXFwiXCIsXG4gICAgXCJ3YXRjaFwiOiBcIm9uY2hhbmdlIFxcXCIuL2xpYnJhcnkvKi5qc1xcXCIgLWl2IC1lIFxcXCIuL2JpblxcXCIgLS0gbnBtIHJ1biBidWlsZFwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjIuMS40XCJcbn1cbiIsImZ1bmN0aW9uIGNyZWF0ZUJyaWRnZSgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICByZXR1cm4ge307XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQnJpZGdlO1xyXG4iLCJmdW5jdGlvbiBjcmVhdGVCcmlkZ2UoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgZmFjYWRlID0gaHRtbENvbnRhaW5lci5zaGFyZWRDb250ZXh0RmFjYWRlO1xyXG5cclxuICAgIGZ1bmN0aW9uIGFsbCgpIHtcclxuICAgICAgICB2YXIgYWxsT2JqID0gZmFjYWRlLmFsbCgpO1xyXG4gICAgICAgIGlmICghYWxsT2JqIHx8ICFhbGxPYmoua2V5cykge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbGxPYmoua2V5cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGUobmFtZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBmYWNhZGUudXBkYXRlKG5hbWUsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldChuYW1lLCBkYXRhKSB7XHJcbiAgICAgICAgZmFjYWRlLnNldChuYW1lLCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJzY3JpYmUobmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gZmFjYWRlLnN1YnNjcmliZShuYW1lLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdW5zdWJzY3JpYmUoa2V5KSB7XHJcbiAgICAgICAgZmFjYWRlLnVuc3Vic2NyaWJlKGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhbGw6IGFsbCxcclxuICAgICAgICB1cGRhdGU6IHVwZGF0ZSxcclxuICAgICAgICBzZXQ6IHNldCxcclxuICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcclxuICAgICAgICB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVcclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQnJpZGdlO1xyXG5cclxuXHJcbiIsInZhciBQYWNrYWdlSnNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xyXG52YXIgaGNCcmlkZ2UgPSByZXF1aXJlKCcuL2JyaWRnZXMvaGMuanMnKTtcclxudmFyIGd3QnJpZGdlID0gcmVxdWlyZSgnLi9icmlkZ2VzL2d3LmpzJyk7XHJcblxyXG5mdW5jdGlvbiBjb250ZXh0cyhjb25maWcpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciBicmlkZ2UgPSBnZXRCcmlkZ2UoY29uZmlnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRCcmlkZ2UoY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBodG1sQ29udGFpbmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZiAoIWh0bWxDb250YWluZXIuc2hhcmVkQ29udGV4dEZhY2FkZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdZb3VyIHZlcnNpb24gb2YgSHRtbENvbnRhaW5lciBkb2VzIG5vdCBzdXBwb3J0IGNvbnRleHRzLiBHZXQgdmVyc2lvbiAxLjQ2LjAuMCBvciBsYXRlciB0byBoYXZlIHRoYXQgZmVhdHVyZS4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoY0JyaWRnZShjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ3dCcmlkZ2UoY29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIGJyaWRnZS5hbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGUobmFtZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBicmlkZ2UudXBkYXRlKG5hbWUsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldChuYW1lLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIGJyaWRnZS5zZXQobmFtZSwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKG5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIGJyaWRnZS5zdWJzY3JpYmUobmFtZSwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleSkge1xyXG4gICAgICAgIGJyaWRnZS51bnN1YnNjcmliZShrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGJyaWRnZSBiZWluZyBhIHN0cmluZyBtZWFucyB0aGUgaW5pdGlhbGl6dGlvbiBmYWlsZWQgYW5kIHRoZXJlIGlzIHNvbWUgZXJyb3IgaW4gdGhhdCBzdHJpbmdcclxuICAgIGlmICh0eXBlb2YgYnJpZGdlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGVycm9yOiBicmlkZ2UsXHJcbiAgICAgICAgICAgIHZlcnNpb246IFBhY2thZ2VKc29uLnZlcnNpb25cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYWxsOiBhbGwsXHJcbiAgICAgICAgdXBkYXRlOiB1cGRhdGUsXHJcbiAgICAgICAgc2V0OiBzZXQsXHJcbiAgICAgICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXHJcbiAgICAgICAgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLFxyXG4gICAgICAgIHZlcnNpb246IFBhY2thZ2VKc29uLnZlcnNpb25cclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29udGV4dHM7XHJcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAgXCJ0aWNrNDItY29udGV4dHNAMC4wLjJcIixcbiAgICAgIFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxqcy1nbHVlXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJ0aWNrNDItY29udGV4dHNAMC4wLjJcIixcbiAgXCJfaWRcIjogXCJ0aWNrNDItY29udGV4dHNAMC4wLjJcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi90aWNrNDItY29udGV4dHNcIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCI1LjMuMFwiLFxuICBcIl9ucG1Vc2VyXCI6IHt9LFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMy4zLjEyXCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcIm5hbWVcIjogXCJ0aWNrNDItY29udGV4dHNcIixcbiAgICBcInJhd1wiOiBcInRpY2s0Mi1jb250ZXh0c0AwLjAuMlwiLFxuICAgIFwicmF3U3BlY1wiOiBcIjAuMC4yXCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcIjAuMC4yXCIsXG4gICAgXCJ0eXBlXCI6IFwidmVyc2lvblwiXG4gIH0sXG4gIFwiX3JlcXVpcmVkQnlcIjogW1xuICAgIFwiL1wiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cDovLzE5Mi4xNjguMC4yMzQ6NDg3My90aWNrNDItY29udGV4dHMvLS90aWNrNDItY29udGV4dHMtMC4wLjIudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcImFmMDM4YmI1OWVjNDMwOTEyOWYzOTJlNzYzYjRiNTUyNzRjZWVlNWVcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwidGljazQyLWNvbnRleHRzQDAuMC4yXCIsXG4gIFwiX3doZXJlXCI6IFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxqcy1nbHVlXCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJUaWNrNDJcIlxuICB9LFxuICBcImJpblwiOiB7XG4gICAgXCJidWlsZFwiOiBcIi4vYmluL2J1aWxkLmpzXCIsXG4gICAgXCJjbGVhblwiOiBcIi4vYmluL2NsZWFuLmpzXCIsXG4gICAgXCJmaWxlLXZlcnNpb25pZnlcIjogXCIuL2Jpbi9maWxlLXZlcnNpb25pZnkuanNcIixcbiAgICBcIm1pbmlmeVwiOiBcIi4vYmluL21pbmlmeS5qc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25cIjogXCI+PTEuMS45XCJcbiAgfSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgbGlicmFyeSBmb3Igc2hhcmVkIGNvbnRleHRzXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTMuMC4wXCIsXG4gICAgXCJicm93c2VyaWZ5LXJlcGxhY2lmeVwiOiBcIl4wLjAuNFwiLFxuICAgIFwiYnJvd3NlcmlmeS12ZXJzaW9uaWZ5XCI6IFwiXjEuMC40XCIsXG4gICAgXCJlc2xpbnRcIjogXCJeMy4xLjFcIixcbiAgICBcImVzbGludC1jb25maWctc3RhbmRhcmRcIjogXCJeNS4zLjVcIixcbiAgICBcImVzbGludC1jb25maWctdGljazQyXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXByb21pc2VcIjogXCJeMi4wLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tc3RhbmRhcmRcIjogXCJeMi4wLjBcIixcbiAgICBcIm1pbmlmeWlmeVwiOiBcIl43LjMuMlwiLFxuICAgIFwib25jaGFuZ2VcIjogXCJeMi4xLjJcIlxuICB9LFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiYWYwMzhiYjU5ZWM0MzA5MTI5ZjM5MmU3NjNiNGI1NTI3NGNlZWU1ZVwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHA6Ly8xOTIuMTY4LjAuMjM0OjQ4NzMvdGljazQyLWNvbnRleHRzLy0vdGljazQyLWNvbnRleHRzLTAuMC4yLnRnelwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcImFkMGZmNDE1NmIyMDljZGViMGI4NTUzZmYwYjNkYWEzMzU4NWY3NmRcIixcbiAgXCJsaWNlbnNlXCI6IFwiSVNDXCIsXG4gIFwibWFpblwiOiBcImxpYnJhcnkvbWFpbi5qc1wiLFxuICBcIm5hbWVcIjogXCJ0aWNrNDItY29udGV4dHNcIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2twb3BvdkBzdGFzaC50aWNrNDIuY29tL3NjbS90Zy9qcy1jb250ZXh0cy5naXRcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnVpbGRcIjogXCJucG0gcnVuIGVzbGludCAmJiBub2RlIGJpbi9jbGVhbi5qcyAmJiBub2RlIGJpbi9idWlsZC5qcyAmJiBub2RlIGJpbi9taW5pZnkgJiYgbm9kZSBiaW4vZmlsZS12ZXJzaW9uaWZ5XCIsXG4gICAgXCJlc2xpbnRcIjogXCJlc2xpbnQgbGlicmFyeVwiLFxuICAgIFwiZXNsaW50OmZpeFwiOiBcImVzbGludCBsaWJyYXJ5IC0tZml4XCIsXG4gICAgXCJwcmVwdWJsaXNoXCI6IFwibnBtIHVwZGF0ZSAmIG5wbSBydW4gYnVpbGRcIixcbiAgICBcIndhdGNoXCI6IFwib25jaGFuZ2UgXFxcIi4vbGlicmFyeS8qLmpzXFxcIiAtaXYgLWUgXFxcIi4vYmluXFxcIiAtLSBucG0gcnVuIGJ1aWxkXCJcbiAgfSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4wLjJcIlxufVxuIiwidmFyIFBhY2thZ2VKc29uID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKTtcbnZhciBjb25uZWN0aW9uID0gZnVuY3Rpb24gKHNldHRpbmdzLCBjdXN0b21fY29ubmVjdGlvbil7XG4gIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gIC8vVGhlIG1lc3NhZ2UgaGFuZGxlcnMgdGhhdCBoYXZlIHRvIGJlIGV4ZWN1dGVkIGZvciBlYWNoIHJlY2VpdmVkIG1lc3NhZ2VcbiAgdmFyIG1lc3NhZ2VfaGFuZGxlcnMgPSB7fTtcblxuICB2YXIgaWRzID0gMDtcblxuICB2YXIgY29ubmVjdGlvbiA9IHtcbiAgICAvL0V4ZWN1dGVzIGFwcHJvcHJpYXRlIG1lc3NhZ2UgaGFuZGxlcnMgZm9yIHRoZSBtZXNzYWdlIHR5cGUuXG4gICAgX2hhbmRsZV9tZXNzYWdlOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgLy9SZXRyaWV2ZSBoYW5kbGVycyBmb3IgdGhlIG1lc3NhZ2UgdHlwZVxuICAgICAgdmFyIGhhbmRsZXJzID0gbWVzc2FnZV9oYW5kbGVyc1ttZXNzYWdlLnR5cGVdO1xuICAgICAgaWYgKGhhbmRsZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy9FeGVjdXRlIHRoZW1cbiAgICAgICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXJfaWQpIHtcbiAgICAgICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2hhbmRsZXJfaWRdO1xuICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIobWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy9BdHRhY2hlcyBhIGhhbmRsZXJcbiAgICBvbjogZnVuY3Rpb24gKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2VfaGFuZGxlcikge1xuICAgICAgaWYgKG1lc3NhZ2VfaGFuZGxlcnNbdHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXNzYWdlX2hhbmRsZXJzW3R5cGVdID0ge307XG4gICAgICB9XG4gICAgICB2YXIgaWQgPSBpZHMrKztcbiAgICAgIG1lc3NhZ2VfaGFuZGxlcnNbdHlwZV1baWRdPSBtZXNzYWdlX2hhbmRsZXI7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6dHlwZSxcbiAgICAgICAgaWQ6aWRcbiAgICAgIH07XG4gICAgfSxcbiAgICAvL1JlbW92ZSBhIGhhbmRsZXJcbiAgICBvZmY6IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBkZWxldGUgbWVzc2FnZV9oYW5kbGVyc1tpbmZvLnR5cGVdW2luZm8uaWRdO1xuICAgIH0sXG4gICAgLy9EdW1teSBmdW5jdGlvbnMgZm9yIHRyYW5zcG9ydHMgdGhhdCBhcmUgYWx3YXlzIGNvbm5lY3RlZFxuICAgIGNvbm5lY3RlZDogZnVuY3Rpb24gKGEpIHthKCk7fSxcbiAgICBkaXNjb25uZWN0ZWQ6IGZ1bmN0aW9uICgpIHt9LFxuICAgIHZlcnNpb246IFBhY2thZ2VKc29uLnZlcnNpb25cbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2Nvbm5lY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICBjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbiAocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSkge1xuICAgICAgY3VzdG9tX2Nvbm5lY3Rpb24ucHVibGlzaCh7XG4gICAgICAgIHR5cGU6dHlwZSxcbiAgICAgICAgbWVzc2FnZTptZXNzYWdlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGN1c3RvbV9jb25uZWN0aW9uLnN1YnNjcmliZShjb25uZWN0aW9uLl9oYW5kbGVfbWVzc2FnZSk7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIH1cblxuICBpZiAoc2V0dGluZ3Mud2Vic29ja2V0X3VybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoXCIuL3dzXCIpKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgfSBlbHNlIGlmIChzZXR0aW5ncy5odHRwX3VybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoXCIuL2h0dHBcIikoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5maW4gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXF1aXJlKFwiLi9maW5cIikoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICB9IGVsc2UgaWYgKGN1c3RvbV9jb25uZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY3JlYXRlX2N1c3RvbV9jb25uZWN0aW9uKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICAvL0Nvbm5lY3QgdmlhIEhUTUwgQ29udGFpbmVyIGZhY2FkZVxuICB9IGVsc2UgaWYgKGdsb2JhbC5odG1sQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVxdWlyZShcIi4vY29udFwiKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgXCJObyBjb25uZWN0aW9uLiBNYWtlIHN1cmUgeW91IGFyZSBydW5uaW5nIHRoZSBhcHBsaWNhdGlvbiBmcm9tIE9wZW5GaW4sIG9yIFRpY2s0MiBIVE1MIENvbnRhaW5lciBvciBmaWxsIHRoZSAnY29ubmVjdGlvbi53ZWJzb2NrZXRfdXJsJyBwcm9wZXJ0eS5cIjtcbiAgfVxufTtcblxuaWYgKGdsb2JhbC50aWNrNDIgPT09IHVuZGVmaW5lZCkge1xuICBnbG9iYWwudGljazQyID0ge307XG59XG5nbG9iYWwudGljazQyLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3Rpb247XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XHJcbiAgdmFyIGNvbm5lY3Rpb25faWQgPSBNYXRoLmZsb29yKDFlMTAgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpO1xyXG4gIC8vUm91dGUgbWVzc2FnZXMgdG8gZmFjYWRlKHMpXHJcbiAgY29ubmVjdGlvbi5zZW5kID0gZnVuY3Rpb24gKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2UpIHtcclxuICAgIGlmIChwcm9kdWN0ID09PSBcIm1ldHJpY3NcIikge1xyXG4gICAgICBnbG9iYWwuaHRtbENvbnRhaW5lci5tZXRyaWNzRmFjYWRlLnNlbmQodHlwZSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xyXG4gICAgfSBlbHNlIGlmIChwcm9kdWN0ID09PSBcImxvZ1wiKSB7XHJcbiAgICAgIGdsb2JhbC5odG1sQ29udGFpbmVyLmxvZ2dpbmdGYWNhZGUuc2VuZCh0eXBlLCBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XHJcbiAgICB9IGVsc2UgaWYgKHByb2R1Y3QgPT09IFwiYXBwY29uZmlnXCIpIHtcclxuICAgICAgZ2xvYmFsLmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlLnNlbmQodHlwZSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIGNvbm5lY3Rpb25faWQpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgaWYgKGdsb2JhbC5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBnbG9iYWwuaHRtbENvbnRhaW5lci5hcHBDb25maWdGYWNhZGUuaW5pdENvbm5lY3Rpb24oXHJcbiAgICAgIGNvbm5lY3Rpb25faWQsXHJcbiAgICAgIGZ1bmN0aW9uIChtZXNzYWdlQXNKc29uKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlKEpTT04ucGFyc2UobWVzc2FnZUFzSnNvbikpO1xyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZ2xvYmFsLmNvbm5lY3Rpb25zID0gZ2xvYmFsLmNvbm5lY3Rpb25zIHx8IHt9O1xyXG4gIC8vRXhwb3NlIGZ1bmN0aW9uIGZvciBzZW5kaW5nIG1lc3NhZ2VzOlxyXG4gIGdsb2JhbC5jb25uZWN0aW9uc1snY29ubmVjdGlvbicrY29ubmVjdGlvbl9pZF0gPSBjb25uZWN0aW9uLl9oYW5kbGVfbWVzc2FnZTtcclxuXHJcbiAgcmV0dXJuIGNvbm5lY3Rpb247XHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIHNldHRpbmdzKSB7XHJcbiAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MuZGVidWcgPT09IHRydWUpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiQXR0ZW1waW5nIHRvIGNvbm5lY3QgdG8gR2F0ZXdheSB2aWEgT3BlbkZpbiBJbnRlciBBcHBsaWNhdGlvbiBCdXMuXCIpO1xyXG4gIH1cclxuXHJcbiAgLy9BIGZ1bmN0aW9uIGZvciBzZW5kaW5nIGEgbWVzc2FnZVxyXG4gIGNvbm5lY3Rpb24uc2VuZCA9IGZ1bmN0aW9uIChwcm9kdWN0LCB0eXBlLCBtZXNzYWdlKSB7XHJcbiAgICBmaW4uZGVza3RvcC5JbnRlckFwcGxpY2F0aW9uQnVzLnB1Ymxpc2goXCJBR01cIiwge3R5cGU6dHlwZSwgbWVzc2FnZTptZXNzYWdlfSk7XHJcbiAgfTtcclxuICAvL0EgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBtZXNzYWdlc1xyXG4gIGZpbi5kZXNrdG9wLkludGVyQXBwbGljYXRpb25CdXMuc3Vic2NyaWJlKCcqJywnQUdNJywgY29ubmVjdGlvbi5faGFuZGxlX21lc3NhZ2UpO1xyXG4gIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLmRlYnVnID09PSB0cnVlKXtcclxuICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdGVkIHRvIE9wZW5GaW4gdHJhbnNwb3J0LlwiKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjb25uZWN0aW9uO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBzZXR0aW5ncykge1xyXG4gIHZhciB1cmwgPSBzZXR0aW5ncy5odHRwX3VybDtcclxuICAvLyBwb2xsaW5nIGludGVydmFsIGluIG1zLCBkZWZhdWx0IGlzIDEgc2Vjb25kXHJcbiAgdmFyIGludGVydmFsID0gc2V0dGluZ3MuaHR0cF9pbnRlcnZhbF9tcztcclxuICBpZiAoIWludGVydmFsKSBpbnRlcnZhbCA9IDEwMDA7XHJcblxyXG4gIGZ1bmN0aW9uIGxvZ19kZWJ1ZyAobWVzc2FnZSkge1xyXG4gICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgKHNldHRpbmdzLmRlYnVnID09PSB0cnVlIHx8IHNldHRpbmdzLnRyYWNlID09PSB0cnVlKSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxvZ190cmFjZSAobWVzc2FnZSkge1xyXG4gICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MudHJhY2UgPT09IHRydWUpIHtcclxuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsb2dfZGVidWcoXCJBdHRlbXBpbmcgdG8gY29ubmVjdCB0byBHYXRld2F5IHZpYSBIVFRQIHdpdGggdXJsICdcIiArIHVybCArIFwiJyBhbmQgcG9sbGluZyBpbnRlcnZhbCBcIiArIGludGVydmFsICsgXCIgbXNcIik7XHJcblxyXG4gIHBvbGwodXJsLCBpbnRlcnZhbCwgMCwgZnVuY3Rpb24gKGl0ZW1zKSB7XHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaXRlbXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlKGl0ZW1zW2luZGV4XSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGNvbm5lY3Rpb24uc2VuZCA9IGZ1bmN0aW9uIChwcm9kdWN0LCB0eXBlLCBtZXNzYWdlLCBpZCkge1xyXG4gICAgdmFyIG1zZyA9IEpTT04uc3RyaW5naWZ5KHsgdHlwZTogdHlwZSwgbWVzc2FnZTogbWVzc2FnZSwgaWQ6IGlkIH0pO1xyXG4gICAgaHR0cF9wb3N0KHVybCwgbXNnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBQb2xscyBkYXRhIGZyb20gYSBnaXZlbiB1cmwgb24gc29tZSBpbnRlcnZhbFxyXG4gICAqIEBwYXJhbSB1cmwgICAgICAgQmFzZSBzZXJ2ZXIgdXJsLiBBIHNlcXVlbmNlIHVybCBwYXJhbSBtYXkgYmUgYWRkZWQgYmFzZWQgb24gdGhlIHNlcSBwYXJhbVxyXG4gICAqIEBwYXJhbSBpbnRlcnZhbCAgSW50ZXJ2YWwgKGluIG1zKSBiZXR3ZWVuIHBvbGxpbmcgcmVxdWVzdHRzXHJcbiAgICogQHBhcmFtIHNlcSAgICAgICBOZXh0IHNlcXVlbmNlIG51bWJlciB3ZSBzaG91bGQgYXNrIGZvciAoaWYgMCB0aGUgc2VydmVyIHdpbGwgcmV0dXJuIHRoZSBsYXN0IGtub3duIG1lc3NhZ2UpXHJcbiAgICogQHBhcmFtIG9uZGF0YSAgICBEYXRhIGNhbGxiYWNrXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcG9sbCAodXJsLCBpbnRlcnZhbCwgc2VxLCBvbmRhdGEpIHtcclxuICAgIC8vIGNvbnN0cnVjdCB0aGUgZ2V0IFVybCAtIGlmIHNlcSAhPSAwIGFkZCBhcyB1cmwgcGFyYW0gdG8gZ2V0XHJcbiAgICAvLyBvbmx5IG1lc3NhZ2VzIGFmdGVyIHRoaXMgc2VxdWVuY2VcclxuICAgIHZhciBnZXRVcmwgPSB1cmw7XHJcblxyXG4gICAgaWYgKHNlcSAhPT0gMCkge1xyXG4gICAgICBnZXRVcmwgPSB1cmwgKyBcIj9zZXF1ZW5jZT1cIiArIHNlcSArIFwiJm5vLWNhY2hlPVwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY3JlYXRlIGEgcmVxdWVzdFxyXG4gICAgdmFyIHhtbGh0dHAgPSBjcmVhdGVDT1JTUmVxdWVzdChcIkdFVFwiLCBnZXRVcmwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHNlcSA9PT0gMCkge1xyXG4gICAgICAgIGxvZ19kZWJ1ZyhcIkNvbm5lY3RlZCB0byBHYXRld2F5IG9uIFwiICsgdXJsKTtcclxuICAgICAgfVxyXG4gICAgICBsb2dfdHJhY2UoXCJSZXNwb25zZSBmcm9tICdcIiArIGdldFVybCArIFwiJyBpcyBcIiArIHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcclxuICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcclxuICAgICAgLy8gdGhlIHNlcnZlciByZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIG5leHQgc2VxdWVuY2UgdGhhdCB3ZSBtdXN0IHF1ZXJ5IGZvclxyXG4gICAgICB2YXIgbmV4dFNlcSA9IG1lc3NhZ2UubmV4dFNlcXVlbmNlO1xyXG4gICAgICAvLyBjYWxsIHVzZXIgY2FsbGJhY2tlXHJcbiAgICAgIG9uZGF0YShtZXNzYWdlLmRhdGEpO1xyXG4gICAgICAvLyByZS1zY2hlZHVsZVxyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwb2xsKHVybCwgaW50ZXJ2YWwsIG5leHRTZXEsIG9uZGF0YSk7XHJcbiAgICAgIH0sIGludGVydmFsKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHhtbGh0dHAub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIHBvbGxpbmcgZGF0YSBmcm9tIGh0dHAgc2VydmVyICdcIiArIGdldFVybCArIFwiJyAtIFwiICsgZXYpO1xyXG4gICAgICAvLyByZS1zY2hlZHVsZVxyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwb2xsKHVybCwgaW50ZXJ2YWwsIHNlcSwgb25kYXRhKTtcclxuICAgICAgfSwgaW50ZXJ2YWwpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsb2dfdHJhY2UoXCJTZW5kaW5nIEdFVCB0byAnXCIgKyBnZXRVcmwgKyBcIidcIik7XHJcbiAgICB4bWxodHRwLnNlbmQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBPU1RzIGEgbWVzc2FnZSB0byBhIGdpdmVuIHVybFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGh0dHBfcG9zdCAodXJsLCBtZXNzYWdlKSB7XHJcbiAgICAvLyBjcmVhdGUgYSByZXF1ZXN0XHJcbiAgICB2YXIgeG1saHR0cCA9IGNyZWF0ZUNPUlNSZXF1ZXN0KFwiUE9TVFwiLCB1cmwpO1xyXG4gICAgbG9nX3RyYWNlKFwiU2VuZGluZyBQT1NUIHRvICdcIiArIHVybCArIFwiJyA6IFwiICsgbWVzc2FnZSk7XHJcbiAgICB4bWxodHRwLnNlbmQobWVzc2FnZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIENPUlMgcmVxdWVzdCAoY3Jvc3MgZG9tYWluIHJlcXVlc3RzKSBmb3IgZGlmZmVyZW50IGJyb3dzZXJzIC0gWE1MSHR0cFJlcXVlc3Qgd2l0aENyZWRlbnRpYWxzXHJcbiAgICogZm9yIENocm9tZSBhbmQgRkYgYW5kIFhEb21haW5SZXF1ZXN0IGZvciBJRVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZUNPUlNSZXF1ZXN0IChtZXRob2QsIHVybCwgcmVzdWx0X2NhbGxiYWNrKSB7XHJcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG4gICAgaWYgKFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyKSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBYTUxIdHRwUmVxdWVzdCBvYmplY3QgaGFzIGEgXCJ3aXRoQ3JlZGVudGlhbHNcIiBwcm9wZXJ0eS5cclxuICAgICAgLy8gXCJ3aXRoQ3JlZGVudGlhbHNcIiBvbmx5IGV4aXN0cyBvbiBYTUxIVFRQUmVxdWVzdDIgb2JqZWN0cy5cclxuICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xyXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdF9jYWxsYmFjayAhPT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0ICYmIHhoci5zdGF0dXMgPT0gMjAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdF9jYWxsYmFjaygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBpZiBYRG9tYWluUmVxdWVzdC5cclxuICAgICAgLy8gWERvbWFpblJlcXVlc3Qgb25seSBleGlzdHMgaW4gSUUsIGFuZCBpcyBJRSdzIHdheSBvZiBtYWtpbmcgQ09SUyByZXF1ZXN0cy5cclxuICAgICAgeGhyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XHJcbiAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsKTtcclxuICAgICAgaWYgKHR5cGVvZiByZXN1bHRfY2FsbGJhY2sgIT09IFwidW5kZWZpbmVkXCIpe1xyXG4gICAgICAgIHhoci5vbmxvYWQgPSByZXN1bHRfY2FsbGJhY2s7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE90aGVyd2lzZSwgQ09SUyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLlxyXG4gICAgICB4aHIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHhocjtcclxuICB9XHJcblxyXG4gIHJldHVybiBjb25uZWN0aW9uO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBzZXR0aW5ncykge1xyXG4gIHZhciBjb25uZWN0ZWQgPSBmYWxzZTtcclxuXHJcbiAgLy9Mb2FkIHRoZSAnd3MnIGxpYnJhcnksIGJ1dCBvbmx5IGlmIHdlIGFyZSBydW5uaW5nIHVuZGVyIG5vZGUganNcclxuICB2YXIgV2ViU29ja2V0ID0gcmVxdWlyZShcImRldGVjdC1ub2RlXCIpID8gcmVxdWlyZShcIndzXCIpIDogZ2xvYmFsLldlYlNvY2tldDtcclxuXHJcbiAgZnVuY3Rpb24gaW5pdGlhdGVfc29ja2V0ICgpIHtcclxuICAgIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLmRlYnVnID09PSB0cnVlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiQXR0ZW1waW5nIHRvIGNvbm5lY3QgdG8gR2F0ZXdheSB2aWEgV2ViU29ja2V0LlwiKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgd3MgPSBuZXcgV2ViU29ja2V0KHNldHRpbmdzLndlYnNvY2tldF91cmwpO1xyXG4gICAgLy9BZGQgdXNlciBjYWxsYmFja3NcclxuICAgIHdzLm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5kaXNjb25uZWN0ZWQ9PT1cImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBzZXR0aW5ncy5kaXNjb25uZWN0ZWQoc2V0dGluZ3Mud2Vic29ja2V0X3VybCwgZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vTG9nIG9uIGNvbm5lY3Rpb25cclxuICAgIHdzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5jb25uZWN0ZWQ9PT1cImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBzZXR0aW5ncy5jb25uZWN0ZWQoc2V0dGluZ3Mud2Vic29ja2V0X3VybCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MuZGVidWcgPT09IHRydWUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3RlZCB0byBXUyBVUkwgXCIrc2V0dGluZ3Mud2Vic29ja2V0X3VybCk7XHJcbiAgICAgIH1cclxuICAgICAgY29ubmVjdGVkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvL0F0dGFjaCBoYW5kbGVyXHJcbiAgICB3cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICBjb25uZWN0aW9uLl9oYW5kbGVfbWVzc2FnZShKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB3cztcclxuICB9XHJcblxyXG4gIC8vSW5pdGlhdGUgYSBuZXcgc29ja2V0ICh0aGlzIGdldHMgcmUtZXhlY3V0ZWQgb24gcmVjb25uZWN0KVxyXG4gIHZhciBzb2NrZXQgPSBpbml0aWF0ZV9zb2NrZXQoKTtcclxuXHJcbiAgLy9DcmVhdGUgYSBmdW5jdGlvbiBmb3Igc2VuZGluZyBhIG1lc3NhZ2VcclxuICBjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbiAocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSwgaWQpIHtcclxuICAgIC8vSWYgd2UgYXJlIGNvbm5lY3RlZCBzZW5kIHRoZSBtZXNzYWdlXHJcbiAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcclxuICAgICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe3R5cGU6dHlwZSwgbWVzc2FnZTptZXNzYWdlLCBpZDppZH0pKTtcclxuICAgICAgLy9JZiB3ZSBhcmUgbm90IGNvbm5lY3RlZCBhbmQgd2UgYXJlIG5vdCBhdHRlbXB0aW5nIHRvIGNvbm5lY3QgcmlnaHQgbm93LCBhdHRlbXB0IHRvIGNvbm5lY3RcclxuICAgIH0gZWxzZSBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IDApIHtcclxuICAgICAgc29ja2V0ID0gaW5pdGlhdGVfc29ja2V0KCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29ubmVjdGlvbi53ZWJzb2NrZXRfdXJsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgIHNldHRpbmdzLndlYnNvY2tldF91cmwgPSBhO1xyXG4gICAgc29ja2V0LmNsb3NlKCk7XHJcbiAgICBzb2NrZXQgPSBpbml0aWF0ZV9zb2NrZXQoKTtcclxuICB9O1xyXG5cclxuICBjb25uZWN0aW9uLmNvbm5lY3RlZCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICBpZiAoY29ubmVjdGVkKSB7XHJcbiAgICAgIGEoc2V0dGluZ3Mud2Vic29ja2V0X3VybCk7XHJcbiAgICB9XHJcbiAgICBzZXR0aW5ncy5jb25uZWN0ZWQgPSBhO1xyXG4gIH07XHJcbiAgY29ubmVjdGlvbi5kaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgc2V0dGluZ3MuZGlzY29ubmVjdGVkID0gYTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gY29ubmVjdGlvbjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25AXjEuMS42XCIsXG4gICAgICBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcZGV2XFxcXGpzLWdsdWVcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25APj0xLjEuNiA8Mi4wLjBcIixcbiAgXCJfaWRcIjogXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uQDEuMy4yXCIsXG4gIFwiX2luQ2FjaGVcIjogdHJ1ZSxcbiAgXCJfaW5zdGFsbGFibGVcIjogdHJ1ZSxcbiAgXCJfbG9jYXRpb25cIjogXCIvdGljazQyLWdhdGV3YXktY29ubmVjdGlvblwiLFxuICBcIl9ub2RlVmVyc2lvblwiOiBcIjUuMy4wXCIsXG4gIFwiX25wbVVzZXJcIjoge30sXG4gIFwiX25wbVZlcnNpb25cIjogXCIzLjMuMTJcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25cIixcbiAgICBcInJhd1wiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25AXjEuMS42XCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiXjEuMS42XCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcIj49MS4xLjYgPDIuMC4wXCIsXG4gICAgXCJ0eXBlXCI6IFwicmFuZ2VcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9cIixcbiAgICBcIi90aWNrNDItYWdtXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vLS90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uLTEuMy4yLnRnelwiLFxuICBcIl9zaGFzdW1cIjogXCIyYTc1NWNiZWI3MmZkNDUyNGIwMTA3YWE0MzMzZDMzZWRjNzRkMTBmXCIsXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25AXjEuMS42XCIsXG4gIFwiX3doZXJlXCI6IFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxkZXZcXFxcanMtZ2x1ZVwiLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJicm93c2VyaWZ5LXZlcnNpb25pZnlcIjogXCJeMS4wLjRcIixcbiAgICBcImRldGVjdC1ub2RlXCI6IFwiXjIuMC4zXCIsXG4gICAgXCJ3c1wiOiBcIl4wLjcuMlwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUaWNrNDIgR2F0ZXdheSBDb25uZWN0aW9uLlwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJibGFua2V0XCI6IFwiXjEuMS42XCIsXG4gICAgXCJncnVudFwiOiBcIl4wLjQuNVwiLFxuICAgIFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIl4zLjMuMFwiLFxuICAgIFwiZ3J1bnQtY2xpXCI6IFwiXjAuMS4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWNsZWFuXCI6IFwiXjAuNi4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWNvbm5lY3RcIjogXCJeMC45LjBcIixcbiAgICBcImdydW50LWNvbnRyaWItanNoaW50XCI6IFwiXjAuMTEuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1xdW5pdFwiOiBcIl4wLjUuMlwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeMC42LjBcIixcbiAgICBcImdydW50LWNvbnRyaWItd2F0Y2hcIjogXCJeMC42LjFcIixcbiAgICBcImdydW50LWV4b3JjaXNlXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJwaGFudG9tanNcIjogXCJeMS45LjEyXCIsXG4gICAgXCJxdW5pdGpzXCI6IFwiXjEuMTUuMFwiLFxuICAgIFwidWdsaWZ5aWZ5XCI6IFwiXjMuMC4xXCJcbiAgfSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcIjJhNzU1Y2JlYjcyZmQ0NTI0YjAxMDdhYTQzMzNkMzNlZGM3NGQxMGZcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vLS90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uLTEuMy4yLnRnelwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcIjFiMGY0ZjczYThhYTk0MGFmZDEyNjNhNDA1MGU4ZTA0NTJhM2EwMmFcIixcbiAgXCJtYWluXCI6IFwibGlicmFyeS9jb25uZWN0aW9uLmpzXCIsXG4gIFwibmFtZVwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25cIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCIsXG4gIFwic2NyaXB0c1wiOiB7fSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4zLjJcIlxufVxuIiwidmFyIGFzY2lpVGFibGUgPSByZXF1aXJlKCdhc2NpaS10YWJsZScpO1xudmFyIHRpY2s0MkNvbm5lY3Rpb24gPSByZXF1aXJlKCd0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uJyk7XG52YXIgUGFja2FnZUpzb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcblxudmFyIGxldmVscyA9IFsndHJhY2UnLCAnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJywgJ29mZiddO1xuXG5mdW5jdGlvbiBzZXJpYWxpemVQYXRoKHBhdGgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID09PSAwID8gJycgOiBwYXRoLmpvaW4oJy4nKTtcbn1cblxudmFyIGlzQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGMuc2VuZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYy5vbiA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbmZ1bmN0aW9uIGdldExldmVsKGxvZ2dlciwgbGV2ZWwpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gUmV0cmlldmVzIHRoZSBjb25zb2xlIG9yIHB1Ymxpc2ggbGV2ZWwgb2YgYSBsb2dnZXJcbiAgICAvLyBsb2dnZXIgLSB0aGUgbG9nZ2VyIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGV2ZWxcbiAgICAvLyBsZXZlbCAtIGEgc3RyaW5nIHdoaWNoIGNhbiBlaXRoZXIgYmUgXCJwdWJsaXNoTGV2ZWxcIiBmb3IgcmV0cmlldmluZyB0aGUgcHVibGlzaCBsZXZlbCBvciBcImNfbGV2ZWxcIiBmb3IgcmV0cmlldmluZyB0aGUgY29uc29sZSBsZXZlbC5cbiAgICBpZiAobG9nZ2VyW2xldmVsXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXJbbGV2ZWxdO1xuICAgIH0gZWxzZSBpZiAobG9nZ2VyLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBnZXRMZXZlbChsb2dnZXIucGFyZW50LCBsZXZlbCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtZXNzYWdlVG9UYWJsZSh0aXRsZSwgcm93cykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBEaXNwbGF5IG1lc3NhZ2UgYXMgdGFibGUgaW4gZmlsZVxuICAgIHZhciBrZXlzID0gZ2V0QWxsS2V5cyhyb3dzKTtcbiAgICAvLyBmaWxsIHJvd3Mgd2l0aCBtZXNzYWdlIHByb3BlcnRpZXNcbiAgICB2YXIgdGFibGVSb3dzID0gcm93cy5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciB0YWJsZU1lc3NhZ2UgPSBhc2NpaVRhYmxlLmZhY3Rvcnkoe1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGhlYWRpbmc6IGtleXMsXG4gICAgICAgIHJvd3M6IHRhYmxlUm93c1xuICAgIH0pO1xuICAgIHJldHVybiB0YWJsZU1lc3NhZ2UudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxsS2V5cyhkYXRhKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIEFjY2VwdHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGtleXMgZnJvbSBhbGwgb2JqZWN0c1xuICAgIHZhciBhbGxLZXlzID0gW107XG5cbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGFsbEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGFsbEtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhbGxLZXlzO1xufVxuXG5mdW5jdGlvbiBsb2dnZXIoY29uZmlndXJhdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5jb25uZWN0aW9uID0ge307XG4gICAgfVxuXG4gICAgLy8gU2V0IGRlYnVnIGZvciB0aGUgY29ubmVjdGlvbiBtb2R1bGUgaWYgZ2xvYmFsIGRlYnVnIGlzIHNldFxuICAgIGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbi5kZWJ1ZyA9IGNvbmZpZ3VyYXRpb24uZGVidWc7XG5cbiAgICAvLyBJbml0IGNvbm5lY3Rpb25cbiAgICAvLyBEZXRlcm1pbmUgaWYgd2UgYXJlIGdpdmVuIGEgcmVhZHkgJ2Nvbm5lY3Rpb24nIG9iamVjdCBvciBhIGNvbmZpZ3VyYXRpb24uXG4gICAgdmFyIGNvbm5lY3Rpb24gPSBpc0Nvbm5lY3Rpb24oY29uZmlndXJhdGlvbi5jb25uZWN0aW9uKSA/IGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiA6IHRpY2s0MkNvbm5lY3Rpb24oY29uZmlndXJhdGlvbi5jb25uZWN0aW9uKTtcblxuICAgIHZhciBpZEtleXMgPSBbJ3N5c3RlbScsICdzZXJ2aWNlJywgJ2luc3RhbmNlJ107XG5cbiAgICAvLyBDb252ZXJ0IGluc3RhbmNlIHRvIHN0cmluZywgdGhyb3cgZXhjZXB0aW9ucyBpZiBpdCBpcyBub3QgZnVsbFxuICAgIHZhciBpbnN0YW5jZVN0ciA9IGlkS2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcHJvcCA9IGNvbmZpZ3VyYXRpb24uaWRlbnRpdHlba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc3BlY2lmeSBcIicgKyBrZXkgKyAnXCIgaW4geW91ciBpZGVudGl0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgfSkuam9pbignLycpO1xuXG4gICAgdmFyIGxvZ2dlclByb3RvID0ge1xuICAgICAgICBzdWJMb2dnZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3VibG9nZ2VyIGlzIGFscmVhZHkgY3JlYXRlZFxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nU3VibG9nZ2VyID0gdGhpcy5zdWJsb2dnZXJzLmZpbHRlcihmdW5jdGlvbiAoc3ViTG9nZ2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YkxvZ2dlci5uYW1lID09PSBuYW1lO1xuICAgICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICAgIGlmIChleGlzdGluZ1N1YmxvZ2dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nU3VibG9nZ2VyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbmFtZSBpc24ndCB0aGUgc2FtZSBhcyBvbmUgb2YgdGhlIHBhcmVudCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzdWIgbG9nZ2VyIG5hbWUgaXMgbm90IGFsbG93ZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbmFtZSBpc24ndCB0aGUgc2FtZSBhcyBvbmUgb2YgdGhlIHBhcmVudCBtZXRob2RzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhsb2dnZXJQcm90bykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgc3ViIGxvZ2dlciBuYW1lIGlzIG5vdCBhbGxvd2VkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aC5zbGljZSgwKTtcbiAgICAgICAgICAgIHBhdGgucHVzaCh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvZ2dlcihuYW1lLCBwYXRoLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwdWJsaXNoTGV2ZWw6IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgaWYgKGxldmVsICE9PSBudWxsICYmIGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdldExldmVsKHRoaXMsICdfcHVibGlzaExldmVsJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29uc29sZUxldmVsOiBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCAhPT0gbnVsbCAmJiBsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZUxldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZXRMZXZlbCh0aGlzLCAnX2NvbnNvbGVMZXZlbCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1ldHJpY3NMZXZlbDogZnVuY3Rpb24gKGxldmVsLCBtZXRyaWNzU3lzdGVtKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgIT09IG51bGwgJiYgbGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ldHJpY0xldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRyaWNzU3lzdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1ldHJpY3NTeXN0ZW0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBtZXRyaWNzU3lzdGVtLm9iamVjdE1ldHJpYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldHJpY1N5c3RlbSA9IG1ldHJpY3NTeXN0ZW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc3BlY2lmeSBtZXRyaWMgc3lzdGVtICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0YWJsZTogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIG1lc3NhZ2UgbXVzdCBiZSBpbiBhbiBhcnJheSwgdG8gYmUgZGlzcGxheWVkIGFzIHRhYmxlXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtZXNzYWdlIG11c3QgYmUgaW4gYW4gYXJyYXknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0cmlldmUgbG9nZ2VyIG5hbWUgYW5kIGxldmVsc1xuICAgICAgICAgICAgdmFyIGxvZ2dlck5hbWUgPSBnZXRMb2dnZXJOYW1lKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBQdWJsaXNoIGluIGNvbnNvbGVcbiAgICAgICAgICAgIGlmIChzaG91bGRQdWJsaXNoKGdldExldmVsKHRoaXMsICdfY29uc29sZUxldmVsJyksICdpbmZvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obG9nZ2VyTmFtZSArICc6Jyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS50YWJsZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggaW4gZmlsZVxuICAgICAgICAgICAgaWYgKHNob3VsZFB1Ymxpc2goZ2V0TGV2ZWwodGhpcywgJ19wdWJsaXNoTGV2ZWwnKSwgJ2luZm8nKSkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZCgnbG9nJywgJ0xvZ01lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVN0cixcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVscy5pbmRleE9mKCdpbmZvJyksXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcjogbG9nZ2VyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVRvVGFibGUobG9nZ2VyTmFtZSwgbWVzc2FnZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsb2c6IGZ1bmN0aW9uIChtZXNzYWdlLCBsZXZlbCkge1xuICAgICAgICAgICAgcHVibGlzaE1lc3NhZ2UodGhpcywgbGV2ZWwgfHwgJ2luZm8nLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2dnZXIobmFtZSwgcGF0aCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBsb2dnZXIgPSBPYmplY3QuY3JlYXRlKGxvZ2dlclByb3RvKTtcbiAgICAgICAgbG9nZ2VyLm5hbWUgPSBuYW1lO1xuICAgICAgICBsb2dnZXIucGF0aCA9IHBhdGg7XG4gICAgICAgIGxvZ2dlci5zdWJsb2dnZXJzID0gW107XG4gICAgICAgIGxvZ2dlci5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYWRkIHN1YmxvZ2dlciB0byBzdWJsb2dnZXJzIGFycmF5XG4gICAgICAgICAgICBwYXJlbnQuc3VibG9nZ2Vycy5wdXNoKGxvZ2dlcik7XG4gICAgICAgICAgICAvLyBhZGQgZWFzeSBhY2Nlc3MgdG8gc3VibG9nZ2VyXG4gICAgICAgICAgICBwYXJlbnRbbG9nZ2VyLm5hbWVdID0gbG9nZ2VyO1xuICAgICAgICAgICAgLy8gY3JlYXRlIG1ldHJpYyBzeXN0ZW1cbiAgICAgICAgICAgIGlmIChwYXJlbnQubWV0cmljU3lzdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubWV0cmljc0xldmVsKCd3YXJuJywgcGFyZW50Lm1ldHJpY1N5c3RlbS5zdWJTeXN0ZW0obG9nZ2VyLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgbG9nZ2VyW2xldmVsXSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcHVibGlzaE1lc3NhZ2UobG9nZ2VyLCBsZXZlbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBsb2dnZXIub2ZmID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgbG9nZ2VyLnZlcnNpb24gPSBQYWNrYWdlSnNvbi52ZXJzaW9uO1xuXG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaE1lc3NhZ2UobG9nZ2VyLCBsZXZlbCwgbWVzc2FnZSkge1xuICAgICAgICAvLyBSZXRyaWV2ZSBsb2dnZXIgbmFtZSBhbmQgbGV2ZWxzXG4gICAgICAgIHZhciBsb2dnZXJOYW1lID0gZ2V0TG9nZ2VyTmFtZShsb2dnZXIpO1xuXG4gICAgICAgIC8vIEFkZCBzdGFjayB0cmFjZSBpZiB0aGUgbWVzc2FnZSBpcyBhbiBlcnJvclxuICAgICAgICBpZiAobGV2ZWwgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBpZiAoZS5zdGFjaykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICsgJ1xcbicgKyAoZS5zdGFjay5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDMpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdWJsaXNoIGluIGNvbnNvbGVcbiAgICAgICAgaWYgKHNob3VsZFB1Ymxpc2goZ2V0TGV2ZWwobG9nZ2VyLCAnX2NvbnNvbGVMZXZlbCcpLCBsZXZlbCkpIHtcbiAgICAgICAgICAgIGlmICghY29uc29sZVtsZXZlbF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlW2xldmVsXShsb2dnZXJOYW1lICsgJzogJyArIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFB1Ymxpc2ggaW4gZmlsZVxuICAgICAgICBpZiAoc2hvdWxkUHVibGlzaChnZXRMZXZlbChsb2dnZXIsICdfcHVibGlzaExldmVsJyksIGxldmVsKSkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kKCdsb2cnLCAnTG9nTWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VTdHIsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVscy5pbmRleE9mKGxldmVsKSxcbiAgICAgICAgICAgICAgICBsb2dnZXI6IGxvZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdWJsaXNoIGluIG1ldHJpY3NcbiAgICAgICAgaWYgKHNob3VsZFB1Ymxpc2goZ2V0TGV2ZWwobG9nZ2VyLCAnX21ldHJpY0xldmVsJyksIGxldmVsKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlci5tZXRyaWNTeXN0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5tZXRyaWNTeXN0ZW0ub2JqZWN0TWV0cmljKCdMb2dNZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICBUaW1lOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBMb2dnZXI6IGxvZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgICAgIExldmVsOiBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5tZXRyaWNTeXN0ZW0uc2V0U3RhdGUoMTAwLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkUHVibGlzaCA9IGZ1bmN0aW9uIChwdWJsaXNoTGV2ZWwsIG1lc3NhZ2VMZXZlbCkge1xuICAgICAgICByZXR1cm4gKCFwdWJsaXNoTGV2ZWwgfHwgbGV2ZWxzLmluZGV4T2YocHVibGlzaExldmVsKSA8PSBsZXZlbHMuaW5kZXhPZihtZXNzYWdlTGV2ZWwpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldExvZ2dlck5hbWUgPSBmdW5jdGlvbiAobG9nZ2VyKSB7XG4gICAgICAgIHZhciBsb2dnZXJQYXRoQW5kTmFtZSA9IGxvZ2dlci5wYXRoLnNsaWNlKCk7XG4gICAgICAgIGxvZ2dlclBhdGhBbmROYW1lLnB1c2gobG9nZ2VyLm5hbWUpO1xuICAgICAgICByZXR1cm4gJ1snICsgc2VyaWFsaXplUGF0aChsb2dnZXJQYXRoQW5kTmFtZSkgKyAnXSc7XG4gICAgfTtcblxuICAgIHZhciBtYWluTG9nZ2VyID0gY3JlYXRlTG9nZ2VyKCdtYWluJywgW10sIHVuZGVmaW5lZCk7XG4gICAgbWFpbkxvZ2dlci5wdWJsaXNoTGV2ZWwoJ3dhcm4nKTtcbiAgICBtYWluTG9nZ2VyLmNvbnNvbGVMZXZlbCgnaW5mbycpO1xuICAgIG1haW5Mb2dnZXIubWV0cmljc0xldmVsKCd3YXJuJyk7XG5cbiAgICByZXR1cm4gbWFpbkxvZ2dlcjtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LnRpY2s0MiA9IHdpbmRvdy50aWNrNDIgfHwge307XG4gICAgd2luZG93LnRpY2s0Mi5sb2cgPSBsb2dnZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nZ2VyO1xuIiwidmFyIGJhc2VDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJyk7XG5cbi8qKlxuICogQ2hlY2sgcmVhZG1lLm1kIGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvblxuICovXG52YXIgY29ubmVjdGlvbiA9IGZ1bmN0aW9uIChzZXR0aW5ncywgY3VzdG9tQ29ubmVjdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgIHZhciBjb25uZWN0aW9uID0gYmFzZUNvbm5lY3Rpb24oc2V0dGluZ3MpO1xuXG4gICAgLy8gaWYgcnVubmluZyBpbiBIQyB3ZSB1c2UgZ3cxIHByb3RvY29sIGFuZCBoYyB0cmFuc3BvcnRcbiAgICBpZiAoZ2xvYmFsLmh0bWxDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25uZWN0aW9uID0gcmVxdWlyZSgnLi9wcm90b2NvbHMvZ3cxJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2hjJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIC8vIGlmIHJ1bm5pbmcgaW4gdGhlIGJyb3dzZXIgLSBsZXQncyBjaGVjayB3aGljaCBwcm90b2NvbCB2ZXJzaW9uIHVzZXIgd2FudHNcbiAgICBpZiAoc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSAzKSB7XG4gICAgICAgIGNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL3Byb3RvY29scy9ndzMnKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgY29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vcHJvdG9jb2xzL2d3MicpKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25uZWN0aW9uID0gcmVxdWlyZSgnLi9wcm90b2NvbHMvZ3cxJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy53cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3RyYW5zcG9ydHMvd3MnKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5odHRwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9odHRwJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgIH0gZWxzZSBpZiAoY3VzdG9tQ29ubmVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3RyYW5zcG9ydHMvbW9jaycpKGNvbm5lY3Rpb24sIGN1c3RvbUNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbm5lY3Rpb24uIE1ha2Ugc3VyZSB5b3UgYXJlIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uIGZyb20gVGljazQyIEh0bWxDb250YWluZXIgb3IgZmlsbCB0aGUgXFwnY29ubmVjdGlvbi53ZWJzb2NrZXRfdXJsXFwnIHByb3BlcnR5LicpO1xuICAgIH1cbn07XG5cbmlmIChnbG9iYWwudGljazQyID09PSB1bmRlZmluZWQpIHtcbiAgICBnbG9iYWwudGljazQyID0ge307XG59XG5cbmdsb2JhbC50aWNrNDIuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdGlvbjtcbiIsIi8qKlxuICogQ29ubmVjdGlvbiB0byBIdG1sQ29udGFpbmVyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGNvbm5lY3Rpb25JZCA9IE1hdGguZmxvb3IoMWUxMCAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKCk7XG4gICAgLy8gUm91dGUgbWVzc2FnZXMgdG8gZmFjYWRlKHMpXG4gICAgY29ubmVjdGlvbi5zZW5kID0gZnVuY3Rpb24gKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHByb2R1Y3QgPT09ICdtZXRyaWNzJykge1xuICAgICAgICAgICAgZ2xvYmFsLmh0bWxDb250YWluZXIubWV0cmljc0ZhY2FkZS5zZW5kKHR5cGUsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9kdWN0ID09PSAnbG9nJykge1xuICAgICAgICAgICAgZ2xvYmFsLmh0bWxDb250YWluZXIubG9nZ2luZ0ZhY2FkZS5zZW5kKHR5cGUsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9kdWN0ID09PSAnYXBwY29uZmlnJykge1xuICAgICAgICAgICAgZ2xvYmFsLmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlLnNlbmQodHlwZSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGdsb2JhbC5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdsb2JhbC5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZS5pbml0Q29ubmVjdGlvbihcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChtZXNzYWdlQXNKc29uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlKEpTT04ucGFyc2UobWVzc2FnZUFzSnNvbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2xvYmFsLmNvbm5lY3Rpb25zID0gZ2xvYmFsLmNvbm5lY3Rpb25zIHx8IHt9O1xuICAgIC8vIEV4cG9zZSBmdW5jdGlvbiBmb3Igc2VuZGluZyBtZXNzYWdlczpcbiAgICBnbG9iYWwuY29ubmVjdGlvbnNbJ2Nvbm5lY3Rpb24nICsgY29ubmVjdGlvbklkXSA9IGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlO1xuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29ubmVjdGlvbiwgc2V0dGluZ3MpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHVybCA9IHNldHRpbmdzLmh0dHA7XG4gICAgLy8gcG9sbGluZyBpbnRlcnZhbCBpbiBtcywgZGVmYXVsdCBpcyAxIHNlY29uZFxuICAgIHZhciBpbnRlcnZhbCA9IHNldHRpbmdzLmh0dHBfaW50ZXJ2YWxfbXM7XG4gICAgaWYgKCFpbnRlcnZhbCkge1xuICAgICAgICBpbnRlcnZhbCA9IDEwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9nRGVidWcobWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiAoc2V0dGluZ3MuZGVidWcgPT09IHRydWUgfHwgc2V0dGluZ3MudHJhY2UgPT09IHRydWUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvZ1RyYWNlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MudHJhY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9nRGVidWcoJ0F0dGVtcGluZyB0byBjb25uZWN0IHRvIEdhdGV3YXkgdmlhIEhUVFAgd2l0aCB1cmwgXFwnJyArIHVybCArICdcXCcgYW5kIHBvbGxpbmcgaW50ZXJ2YWwgJyArIGludGVydmFsICsgJyBtcycpO1xuXG4gICAgY29ubmVjdGlvbi5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHBvbGwodXJsLCBpbnRlcnZhbCwgMCwgZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaXRlbXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5fcHJvY2Vzc01lc3NhZ2UoaXRlbXNbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5zZW5kID0gZnVuY3Rpb24gKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2UsIGlkKSB7XG4gICAgICAgIHZhciBtc2cgPSBjb25uZWN0aW9uLl9jcmVhdGVNZXNzYWdlKHR5cGUsIG1lc3NhZ2UsIGlkKTtcbiAgICAgICAgaHR0cFBvc3QodXJsLCBtc2cpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb2xscyBkYXRhIGZyb20gYSBnaXZlbiB1cmwgb24gc29tZSBpbnRlcnZhbFxuICAgICAqIEBwYXJhbSB1cmwgICAgICAgQmFzZSBzZXJ2ZXIgdXJsLiBBIHNlcXVlbmNlIHVybCBwYXJhbSBtYXkgYmUgYWRkZWQgYmFzZWQgb24gdGhlIHNlcSBwYXJhbVxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAgSW50ZXJ2YWwgKGluIG1zKSBiZXR3ZWVuIHBvbGxpbmcgcmVxdWVzdHRzXG4gICAgICogQHBhcmFtIHNlcSAgICAgICBOZXh0IHNlcXVlbmNlIG51bWJlciB3ZSBzaG91bGQgYXNrIGZvciAoaWYgMCB0aGUgc2VydmVyIHdpbGwgcmV0dXJuIHRoZSBsYXN0IGtub3duIG1lc3NhZ2UpXG4gICAgICogQHBhcmFtIG9uZGF0YSAgICBEYXRhIGNhbGxiYWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gcG9sbCh1cmwsIGludGVydmFsLCBzZXEsIG9uZGF0YSkge1xuICAgICAgICAvLyBjb25zdHJ1Y3QgdGhlIGdldCBVcmwgLSBpZiBzZXEgIT0gMCBhZGQgYXMgdXJsIHBhcmFtIHRvIGdldFxuICAgICAgICAvLyBvbmx5IG1lc3NhZ2VzIGFmdGVyIHRoaXMgc2VxdWVuY2VcbiAgICAgICAgdmFyIGdldFVybCA9IHVybDtcblxuICAgICAgICBpZiAoc2VxICE9PSAwKSB7XG4gICAgICAgICAgICBnZXRVcmwgPSB1cmwgKyAnP3NlcXVlbmNlPScgKyBzZXEgKyAnJm5vLWNhY2hlPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHJlcXVlc3RcbiAgICAgICAgdmFyIHhtbGh0dHAgPSBjcmVhdGVDT1JTUmVxdWVzdCgnR0VUJywgZ2V0VXJsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0Nvbm5lY3RlZCB0byBHYXRld2F5IG9uICcgKyB1cmwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2dUcmFjZSgnUmVzcG9uc2UgZnJvbSBcXCcnICsgZ2V0VXJsICsgJ1xcJyBpcyAnICsgeG1saHR0cC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKHhtbGh0dHAucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRoZSBuZXh0IHNlcXVlbmNlIHRoYXQgd2UgbXVzdCBxdWVyeSBmb3JcbiAgICAgICAgICAgIHZhciBuZXh0U2VxID0gbWVzc2FnZS5uZXh0U2VxdWVuY2U7XG4gICAgICAgICAgICAvLyBjYWxsIHVzZXIgY2FsbGJhY2tlXG4gICAgICAgICAgICBvbmRhdGEobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgIC8vIHJlLXNjaGVkdWxlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwb2xsKHVybCwgaW50ZXJ2YWwsIG5leHRTZXEsIG9uZGF0YSk7XG4gICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHhtbGh0dHAub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIHBvbGxpbmcgZGF0YSBmcm9tIGh0dHAgc2VydmVyIFxcJycgKyBnZXRVcmwgKyAnXFwnIC0gJyArIGV2KTtcbiAgICAgICAgICAgIC8vIHJlLXNjaGVkdWxlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwb2xsKHVybCwgaW50ZXJ2YWwsIHNlcSwgb25kYXRhKTtcbiAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICBsb2dUcmFjZSgnU2VuZGluZyBHRVQgdG8gXFwnJyArIGdldFVybCArICdcXCcnKTtcbiAgICAgICAgeG1saHR0cC5zZW5kKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUE9TVHMgYSBtZXNzYWdlIHRvIGEgZ2l2ZW4gdXJsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaHR0cFBvc3QodXJsLCBtZXNzYWdlKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIHJlcXVlc3RcbiAgICAgICAgdmFyIHhtbGh0dHAgPSBjcmVhdGVDT1JTUmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gICAgICAgIGxvZ1RyYWNlKCdTZW5kaW5nIFBPU1QgdG8gXFwnJyArIHVybCArICdcXCcgOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIHhtbGh0dHAuc2VuZChtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIENPUlMgcmVxdWVzdCAoY3Jvc3MgZG9tYWluIHJlcXVlc3RzKSBmb3IgZGlmZmVyZW50IGJyb3dzZXJzIC0gWE1MSHR0cFJlcXVlc3Qgd2l0aENyZWRlbnRpYWxzXG4gICAgICogZm9yIENocm9tZSBhbmQgRkYgYW5kIFhEb21haW5SZXF1ZXN0IGZvciBJRVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNPUlNSZXF1ZXN0KG1ldGhvZCwgdXJsLCByZXN1bHRDYWxsYmFjaykge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIFhNTEh0dHBSZXF1ZXN0IG9iamVjdCBoYXMgYSBcIndpdGhDcmVkZW50aWFsc1wiIHByb3BlcnR5LlxuICAgICAgICAgICAgLy8gXCJ3aXRoQ3JlZGVudGlhbHNcIiBvbmx5IGV4aXN0cyBvbiBYTUxIVFRQUmVxdWVzdDIgb2JqZWN0cy5cbiAgICAgICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0Q2FsbGJhY2sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0ICYmIHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBpZiBYRG9tYWluUmVxdWVzdC5cbiAgICAgICAgICAgIC8vIFhEb21haW5SZXF1ZXN0IG9ubHkgZXhpc3RzIGluIElFLCBhbmQgaXMgSUUncyB3YXkgb2YgbWFraW5nIENPUlMgcmVxdWVzdHMuXG4gICAgICAgICAgICB4aHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0Q2FsbGJhY2sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgeGhyLm9ubG9hZCA9IHJlc3VsdENhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBDT1JTIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICB4aHIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHhocjtcbiAgICB9XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBzZXR0aW5ncykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIExvYWQgdGhlICd3cycgbGlicmFyeSwgYnV0IG9ubHkgaWYgd2UgYXJlIHJ1bm5pbmcgdW5kZXIgbm9kZSBqc1xuICAgIHZhciBXZWJTb2NrZXQgPSByZXF1aXJlKCdkZXRlY3Qtbm9kZScpID8gcmVxdWlyZSgnd3MnKSA6IGdsb2JhbC5XZWJTb2NrZXQ7XG5cbiAgICBmdW5jdGlvbiBpbml0aWF0ZVNvY2tldCgpIHtcbiAgICAgICAgdmFyIHdzID0gbmV3IFdlYlNvY2tldChzZXR0aW5ncy53cyk7XG4gICAgICAgIHdzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl90cmlnZ2VyQ29ubmVjdGlvbkNoYW5nZWQoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBMb2cgb24gY29ubmVjdGlvblxuICAgICAgICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl90cmlnZ2VyQ29ubmVjdGlvbkNoYW5nZWQodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEF0dGFjaCBoYW5kbGVyXG4gICAgICAgIHdzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl9wcm9jZXNzTWVzc2FnZShtZXNzYWdlLmRhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB3cztcbiAgICB9XG5cbiAgICAvLyBIb2xkcyBjYWxsYmFjayBleGVjdXRpb24gdW50aWwgc29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQuXG4gICAgZnVuY3Rpb24gd2FpdEZvclNvY2tldENvbm5lY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPiAxKSB7XG4gICAgICAgICAgICAvLyA+IDEgbWVhbnMgY2xvc2luZyBvciBjbG9zZWRcbiAgICAgICAgICAgIHNvY2tldCA9IGluaXRpYXRlU29ja2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKGNhbGxiYWNrKTtcbiAgICAgICAgfSwgNTApOyAvLyB3YWl0IDUgbWlsbGlzZWNvbmRzIGZvciB0aGUgY29ubmVjdGlvbi4uLlxuICAgIH1cblxuICAgIC8vIEluaXRpYXRlIGEgbmV3IHNvY2tldCAodGhpcyBnZXRzIHJlLWV4ZWN1dGVkIG9uIHJlY29ubmVjdClcbiAgICB2YXIgc29ja2V0ID0gaW5pdGlhdGVTb2NrZXQoKTtcblxuICAgIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZvciBzZW5kaW5nIGEgbWVzc2FnZVxuICAgIGNvbm5lY3Rpb24uc2VuZCA9IGZ1bmN0aW9uIChwcm9kdWN0LCB0eXBlLCBtZXNzYWdlLCBpZCkge1xuICAgICAgICB3YWl0Rm9yU29ja2V0Q29ubmVjdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBjb25uZWN0aW9uLl9jcmVhdGVNZXNzYWdlKHR5cGUsIG1lc3NhZ2UsIGlkKTtcbiAgICAgICAgICAgIGlmICghbXNnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0LnNlbmQobXNnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbm5lY3Rpb24ud2Vic29ja2V0X3VybCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHNldHRpbmdzLndlYnNvY2tldF91cmwgPSBhO1xuICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgc29ja2V0ID0gaW5pdGlhdGVTb2NrZXQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25APj0xLjMuMlwiLFxuICAgICAgXCJDOlxcXFx3b3JrXFxcXHN0YXNoXFxcXEdMVUUtZGV2XFxcXGRldlxcXFxqcy1nbHVlXFxcXG5vZGVfbW9kdWxlc1xcXFx0aWNrNDItYXBwY29uZmlnXCJcbiAgICBdLFxuICAgIFtcbiAgICAgIFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvbkA+PTEuMS45XCIsXG4gICAgICBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcZGV2XFxcXGpzLWdsdWVcXFxcbm9kZV9tb2R1bGVzXFxcXHRpY2s0Mi1sb2dnZXJcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25APj0xLjEuOVwiLFxuICBcIl9pZFwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25AMi4xLjRcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi90aWNrNDItbG9nZ2VyL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25cIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCI2LjMuMFwiLFxuICBcIl9ucG1Vc2VyXCI6IHt9LFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMy44LjVcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25cIixcbiAgICBcInJhd1wiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25APj0xLjEuOVwiLFxuICAgIFwicmF3U3BlY1wiOiBcIj49MS4xLjlcIixcbiAgICBcInNjb3BlXCI6IG51bGwsXG4gICAgXCJzcGVjXCI6IFwiPj0xLjEuOVwiLFxuICAgIFwidHlwZVwiOiBcInJhbmdlXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvdGljazQyLWxvZ2dlclwiXG4gIF0sXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25APj0xLjEuOVwiLFxuICBcIl93aGVyZVwiOiBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcZGV2XFxcXGpzLWdsdWVcXFxcbm9kZV9tb2R1bGVzXFxcXHRpY2s0Mi1sb2dnZXJcIixcbiAgXCJiaW5cIjoge1xuICAgIFwiYnVpbGRcIjogXCIuL2Jpbi9idWlsZC5qc1wiLFxuICAgIFwiY2xlYW5cIjogXCIuL2Jpbi9jbGVhbi5qc1wiLFxuICAgIFwiZmlsZS12ZXJzaW9uaWZ5XCI6IFwiLi9iaW4vZmlsZS12ZXJzaW9uaWZ5LmpzXCIsXG4gICAgXCJtaW5pZnlcIjogXCIuL2Jpbi9taW5pZnkuanNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJicm93c2VyaWZ5LXZlcnNpb25pZnlcIjogXCJeMS4wLjRcIixcbiAgICBcImNhbGxiYWNrLXJlZ2lzdHJ5XCI6IFwiXjEuMC4xXCIsXG4gICAgXCJkZXRlY3Qtbm9kZVwiOiBcIl4yLjAuM1wiLFxuICAgIFwiZXM2LXByb21pc2VcIjogXCJeMy4yLjFcIixcbiAgICBcInNob3J0aWRcIjogXCJeMi4yLjZcIixcbiAgICBcInVybC1zZWFyY2gtcGFyYW1zXCI6IFwiXjAuNS4wXCIsXG4gICAgXCJ3c1wiOiBcIl4wLjcuMlwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUaWNrNDIgR2F0ZXdheSBDb25uZWN0aW9uLlwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJibGFua2V0XCI6IFwiXjEuMS42XCIsXG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjEzLjAuMFwiLFxuICAgIFwiYnJvd3NlcmlmeS1yZXBsYWNpZnlcIjogXCJeMC4wLjRcIixcbiAgICBcImJyb3dzZXJpZnktdmVyc2lvbmlmeVwiOiBcIl4xLjAuNFwiLFxuICAgIFwiZXNsaW50XCI6IFwiXjMuMS4xXCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXN0YW5kYXJkXCI6IFwiXjUuMy41XCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXRpY2s0MlwiOiBcIl4xLjAuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1wcm9taXNlXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXN0YW5kYXJkXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJmc1wiOiBcIjAuMC4yXCIsXG4gICAgXCJqc2RvbVwiOiBcIl44LjEuMFwiLFxuICAgIFwibWluaWZ5aWZ5XCI6IFwiXjcuMy4yXCIsXG4gICAgXCJvbmNoYW5nZVwiOiBcIl4yLjEuMlwiLFxuICAgIFwicGhhbnRvbWpzXCI6IFwiXjEuOS4xMlwiLFxuICAgIFwicXVuaXRqc1wiOiBcIl4xLjE1LjBcIixcbiAgICBcInNoZWxsanNcIjogXCJeMC42LjBcIlxuICB9LFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiY2VjZjUyZGE3ODViM2QwYjUyOGRjZTFlMTBjMTlmYWQ1MTY4MDY1ZlwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHA6Ly8xOTIuMTY4LjAuMjM0OjQ4NzMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi8tL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24tMi4xLjQudGd6XCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiNGRkZDFkZTgyNjI4ZDgyYjNmOTY0Njc2OTA5MjU2MTBmYzE1NDdhZlwiLFxuICBcIm1haW5cIjogXCJsaWJyYXJ5L21haW4uanNcIixcbiAgXCJuYW1lXCI6IFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvblwiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcInJlYWRtZS5tZFwiLFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnVpbGRcIjogXCJucG0gcnVuIGVzbGludCAmJiBub2RlIGJpbi9jbGVhbi5qcyAmJiBub2RlIGJpbi9idWlsZC5qcyAmJiBub2RlIGJpbi9taW5pZnkgJiYgbm9kZSBiaW4vZmlsZS12ZXJzaW9uaWZ5XCIsXG4gICAgXCJlc2xpbnRcIjogXCJlc2xpbnQgbGlicmFyeVwiLFxuICAgIFwiZXNsaW50OmZpeFwiOiBcImVzbGludCBsaWJyYXJ5IC0tZml4IFwiLFxuICAgIFwicHJlcHVibGlzaFwiOiBcIm5wbSB1cGRhdGUgJiBucG0gcnVuIGJ1aWxkXCIsXG4gICAgXCJ0ZXN0XCI6IFwibnBtIHJ1biBlc2xpbnQgJiYgbW9jaGEgLS1yZXF1aXJlIC4vdGVzdC90ZXN0X2hlbHBlciBcXFwidGVzdC8qKi8qLmpzXFxcIlwiLFxuICAgIFwid2F0Y2hcIjogXCJvbmNoYW5nZSBcXFwiLi9saWJyYXJ5LyouanNcXFwiIC1pdiAtZSBcXFwiLi9iaW5cXFwiIC0tIG5wbSBydW4gYnVpbGRcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIyLjEuNFwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIFwidGljazQyLWxvZ2dlckAyLjAuNlwiLFxuICAgICAgXCJDOlxcXFx3b3JrXFxcXHN0YXNoXFxcXEdMVUUtZGV2XFxcXGpzLWdsdWVcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcInRpY2s0Mi1sb2dnZXJAMi4wLjZcIixcbiAgXCJfaWRcIjogXCJ0aWNrNDItbG9nZ2VyQDIuMC42XCIsXG4gIFwiX2luQ2FjaGVcIjogdHJ1ZSxcbiAgXCJfaW5zdGFsbGFibGVcIjogdHJ1ZSxcbiAgXCJfbG9jYXRpb25cIjogXCIvdGljazQyLWxvZ2dlclwiLFxuICBcIl9ub2RlVmVyc2lvblwiOiBcIjYuMy4wXCIsXG4gIFwiX25wbVVzZXJcIjoge30sXG4gIFwiX25wbVZlcnNpb25cIjogXCIzLjguNVwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwidGljazQyLWxvZ2dlclwiLFxuICAgIFwicmF3XCI6IFwidGljazQyLWxvZ2dlckAyLjAuNlwiLFxuICAgIFwicmF3U3BlY1wiOiBcIjIuMC42XCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcIjIuMC42XCIsXG4gICAgXCJ0eXBlXCI6IFwidmVyc2lvblwiXG4gIH0sXG4gIFwiX3JlcXVpcmVkQnlcIjogW1xuICAgIFwiL1wiXG4gIF0sXG4gIFwiX3NoYXN1bVwiOiBcIjA0MTI0NzYzYjMwZDJiYmUxOTllMzhhYWM3MTVlMzA4ZTQyNWMwMjNcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwidGljazQyLWxvZ2dlckAyLjAuNlwiLFxuICBcIl93aGVyZVwiOiBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcanMtZ2x1ZVwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiVGljazQyXCJcbiAgfSxcbiAgXCJiaW5cIjoge1xuICAgIFwiYnVpbGRcIjogXCIuL2Jpbi9idWlsZC5qc1wiLFxuICAgIFwiY2xlYW5cIjogXCIuL2Jpbi9jbGVhbi5qc1wiLFxuICAgIFwiZmlsZS12ZXJzaW9uaWZ5XCI6IFwiLi9iaW4vZmlsZS12ZXJzaW9uaWZ5LmpzXCIsXG4gICAgXCJtaW5pZnlcIjogXCIuL2Jpbi9taW5pZnkuanNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJhc2NpaS10YWJsZVwiOiBcIjAuMC44XCIsXG4gICAgXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCI6IFwiPj0xLjEuOVwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIGxpYnJhcnkgZm9yIGxvZ2dpbmdcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmxhbmtldFwiOiBcIl4xLjEuNlwiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIl4xMy4wLjBcIixcbiAgICBcImJyb3dzZXJpZnktcmVwbGFjaWZ5XCI6IFwiXjAuMC40XCIsXG4gICAgXCJicm93c2VyaWZ5LXZlcnNpb25pZnlcIjogXCJeMS4wLjRcIixcbiAgICBcImVzbGludFwiOiBcIl4zLjEuMVwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy1zdGFuZGFyZFwiOiBcIl41LjMuNVwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy10aWNrNDJcIjogXCJeMS4wLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tcHJvbWlzZVwiOiBcIl4yLjAuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1zdGFuZGFyZFwiOiBcIl4yLjAuMFwiLFxuICAgIFwiZnNcIjogXCIwLjAuMlwiLFxuICAgIFwianNkb21cIjogXCJeOC4xLjBcIixcbiAgICBcIm1pbmlmeWlmeVwiOiBcIl43LjMuMlwiLFxuICAgIFwib25jaGFuZ2VcIjogXCJeMi4xLjJcIixcbiAgICBcInBoYW50b21qc1wiOiBcIl4xLjkuMTJcIixcbiAgICBcInF1bml0anNcIjogXCJeMS4xNS4wXCIsXG4gICAgXCJzaGVsbGpzXCI6IFwiXjAuNi4wXCJcbiAgfSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcIjA0MTI0NzYzYjMwZDJiYmUxOTllMzhhYWM3MTVlMzA4ZTQyNWMwMjNcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi1sb2dnZXIvLS90aWNrNDItbG9nZ2VyLTIuMC42LnRnelwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcIjM0YmUzMDE5YjIzNzkxMTkzNzYzOGE2ZjRhYmYxZTgyMGY2ZDE4MjlcIixcbiAgXCJsaWNlbnNlXCI6IFwiSVNDXCIsXG4gIFwibWFpblwiOiBcImxpYnJhcnkvbG9nZ2VyXCIsXG4gIFwibmFtZVwiOiBcInRpY2s0Mi1sb2dnZXJcIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL3N0YXNoLnRpY2s0Mi5jb206ODQ0My9zY20vb2Zndy9qcy1sb2dnZXIuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwibnBtIHJ1biBlc2xpbnQgJiYgbm9kZSBiaW4vY2xlYW4uanMgJiYgbm9kZSBiaW4vYnVpbGQuanMgJiYgbm9kZSBiaW4vbWluaWZ5ICYmIG5vZGUgYmluL2ZpbGUtdmVyc2lvbmlmeVwiLFxuICAgIFwiZXNsaW50XCI6IFwiZXNsaW50IGxpYnJhcnlcIixcbiAgICBcImVzbGludDpmaXhcIjogXCJlc2xpbnQgbGlicmFyeSAtLWZpeFwiLFxuICAgIFwicHJlcHVibGlzaFwiOiBcIm5wbSB1cGRhdGUgJiBucG0gcnVuIGJ1aWxkXCIsXG4gICAgXCJ0ZXN0XCI6IFwibnBtIHJ1biBlc2xpbnQgJiYgbW9jaGEgLS1yZXF1aXJlIC4vdGVzdC90ZXN0X2hlbHBlciBcXFwidGVzdC8qKi8qLmpzXFxcIlwiLFxuICAgIFwid2F0Y2hcIjogXCJvbmNoYW5nZSBcXFwiLi9saWJyYXJ5LyouanNcXFwiIC1pdiAtZSBcXFwiLi9iaW5cXFwiIC0tIG5wbSBydW4gYnVpbGRcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIyLjAuNlwiXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIG9iamVjdE1ldHJpY18xID0gcmVxdWlyZShcIi4uL21ldHJpY3Mvb2JqZWN0TWV0cmljXCIpO1xyXG52YXIgc3RyaW5nTWV0cmljXzEgPSByZXF1aXJlKFwiLi4vbWV0cmljcy9zdHJpbmdNZXRyaWNcIik7XHJcbnZhciBudW1iZXJNZXRyaWNfMSA9IHJlcXVpcmUoXCIuLi9tZXRyaWNzL251bWJlck1ldHJpY1wiKTtcclxudmFyIHRpbWVzdGFtcE1ldHJpY18xID0gcmVxdWlyZShcIi4uL21ldHJpY3MvdGltZXN0YW1wTWV0cmljXCIpO1xyXG52YXIgTWV0cmljU2VyaWFsaXplciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZXRyaWNTZXJpYWxpemVyKCkge1xyXG4gICAgfVxyXG4gICAgTWV0cmljU2VyaWFsaXplci5tZXRyaWNUb01lc3NhZ2UgPSBmdW5jdGlvbiAobWV0cmljKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IE1ldHJpY1NlcmlhbGl6ZXIuX2dldE1ldHJpY0RlZmluaXRpb24obWV0cmljLm5hbWUsIG1ldHJpYy52YWx1ZSwgbWV0cmljLnBhdGgsIG1ldHJpYy50eXBlLCBtZXRyaWMuZGVzY3JpcHRpb24sIG1ldHJpYy5wZXJpb2QsIG1ldHJpYy5yZXNvbHV0aW9uKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogbWV0cmljLmlkLFxyXG4gICAgICAgICAgICBpbnN0YW5jZTogbWV0cmljLnJlcG8uaW5zdGFuY2UsXHJcbiAgICAgICAgICAgIGRlZmluaXRpb246IGRlZixcclxuICAgICAgICAgICAgdmFsdWU6IE1ldHJpY1NlcmlhbGl6ZXIuX3NlcmlhbGl6ZVZhbHVlKG1ldHJpYy52YWx1ZSwgbWV0cmljKSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIE1ldHJpY1NlcmlhbGl6ZXIuX2dldE1ldHJpY0RlZmluaXRpb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHBhdGgsIHR5cGUsIGRlc2NyaXB0aW9uLCByZXNvbHV0aW9uLCBwZXJpb2QpIHtcclxuICAgICAgICB2YXIgZGVmID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUgPyB0eXBlIDogTWV0cmljU2VyaWFsaXplci5fZ2V0VHlwZUZyb21WYWx1ZSh2YWx1ZSksXHJcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXHJcbiAgICAgICAgICAgIHBlcmlvZDogcGVyaW9kXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoZGVmLnR5cGUgPT09IG9iamVjdE1ldHJpY18xLk9iamVjdE1ldHJpYy50eXBlKSB7XHJcbiAgICAgICAgICAgIGRlZi5Db21wb3NpdGUgPSBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaChNZXRyaWNTZXJpYWxpemVyLl9nZXRNZXRyaWNEZWZpbml0aW9uKGtleSwgdmFsLCBwYXRoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWY7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljU2VyaWFsaXplci5fc2VyaWFsaXplVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIG1ldHJpYykge1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLl92YWx1ZVR5cGVzLmluZGV4T2YoXCJkYXRlXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS52YWx1ZU9mKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheTogZmFsc2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBDb21wb3NpdGVWYWx1ZTogT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gTWV0cmljU2VyaWFsaXplci5fc2VyaWFsaXplVmFsdWUodmFsdWVba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsLklubmVyTWV0cmljTmFtZSA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgICAgICAgICB9LCBbXSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSBtZXRyaWMgPyBtZXRyaWMuZ2V0VmFsdWVUeXBlKCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhbHVlVHlwZSA9IHZhbHVlVHlwZSB8IHRoaXMuX3ZhbHVlVHlwZXMuaW5kZXhPZih0eXBlb2YgdmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogeyB0eXBlOiB2YWx1ZVR5cGUsIHZhbHVlOiB2YWx1ZSwgaXNBcnJheTogZmFsc2UgfSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNZXRyaWNTZXJpYWxpemVyLl9nZXRUeXBlRnJvbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHR5cGVBc1N0cmluZyA9IHZhbHVlLmNvbnN0cnVjdG9yID09PSBEYXRlID8gJ3RpbWVzdGFtcCcgOiB0eXBlb2YgdmFsdWU7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlQXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdNZXRyaWNfMS5TdHJpbmdNZXRyaWMudHlwZTtcclxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXJNZXRyaWNfMS5OdW1iZXJNZXRyaWMudHlwZTtcclxuICAgICAgICAgICAgY2FzZSAndGltZXN0YW1wJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lc3RhbXBNZXRyaWNfMS5UaW1lc3RhbXBNZXRyaWMudHlwZTtcclxuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3RNZXRyaWNfMS5PYmplY3RNZXRyaWMudHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljU2VyaWFsaXplci5fdmFsdWVUeXBlcyA9IFtcclxuICAgICAgICBcImJvb2xlYW5cIixcclxuICAgICAgICBcImludFwiLFxyXG4gICAgICAgIFwibnVtYmVyXCIsXHJcbiAgICAgICAgXCJsb25nXCIsXHJcbiAgICAgICAgXCJzdHJpbmdcIixcclxuICAgICAgICBcImRhdGVcIixcclxuICAgICAgICBcIm9iamVjdFwiXTtcclxuICAgIHJldHVybiBNZXRyaWNTZXJpYWxpemVyO1xyXG59KCkpO1xyXG5leHBvcnRzLk1ldHJpY1NlcmlhbGl6ZXIgPSBNZXRyaWNTZXJpYWxpemVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWNTZXJpYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgbWV0cmljU2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vbWV0cmljU2VyaWFsaXplclwiKTtcclxudmFyIE1ldHJpY3NCcmlkZ2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWV0cmljc0JyaWRnZShyZXBvLCBjb25uZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9yZXBvID0gcmVwbztcclxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcclxuICAgICAgICBjb25uZWN0aW9uLm9uKCdtZXRyaWNzJywgXCJNZXRyaWNzU25hcHNob3RSZXF1ZXN0XCIsIGZ1bmN0aW9uIChpbnN0YW5jZUluZm8pIHtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlSW5mby5JbnN0YW5jZSAhPT0gcmVwby5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnNlbmRGdWxsKF90aGlzLl9yZXBvKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLnNlbmRGdWxsID0gZnVuY3Rpb24gKHJlcG8pIHtcclxuICAgICAgICB2YXIgcm9vdFN5c3RlbSA9IHJlcG8ucm9vdDtcclxuICAgICAgICBpZiAoIXJvb3RTeXN0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm9vdFN5c3RlbS5zdWJTeXN0ZW1zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW5kRnVsbFN5c3RlbShyb290U3lzdGVtKTtcclxuICAgIH07XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS5zZW5kRnVsbFN5c3RlbSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNyZWF0ZVN5c3RlbShzKTtcclxuICAgICAgICBzLnN1YlN5c3RlbXMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNlbmRGdWxsU3lzdGVtKChzdWIpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzLm1ldHJpY3MuZm9yRWFjaChmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICBfdGhpcy5jcmVhdGVNZXRyaWMobSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljc0JyaWRnZS5wcm90b3R5cGUuY3JlYXRlTWV0cmljID0gZnVuY3Rpb24gKG1ldHJpYykge1xyXG4gICAgICAgIHRoaXMuX3NlbmQoXCJDcmVhdGVNZXRyaWNcIiwgbWV0cmljU2VyaWFsaXplcl8xLk1ldHJpY1NlcmlhbGl6ZXIubWV0cmljVG9NZXNzYWdlKG1ldHJpYykpO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLnVwZGF0ZU1ldHJpYyA9IGZ1bmN0aW9uIChtZXRyaWMpIHtcclxuICAgICAgICB0aGlzLl9zZW5kKFwiVXBkYXRlTWV0cmljXCIsIG1ldHJpY1NlcmlhbGl6ZXJfMS5NZXRyaWNTZXJpYWxpemVyLm1ldHJpY1RvTWVzc2FnZShtZXRyaWMpKTtcclxuICAgIH07XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS5jcmVhdGVTeXN0ZW0gPSBmdW5jdGlvbiAoc3lzdGVtKSB7XHJcbiAgICAgICAgaWYgKHN5c3RlbS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZW5kKFwiQ3JlYXRlTWV0cmljU3lzdGVtXCIsIHtcclxuICAgICAgICAgICAgICAgIGlkOiBzeXN0ZW0uaWQsXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogc3lzdGVtLnJlcG8uaW5zdGFuY2UsXHJcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiB7IG5hbWU6IHN5c3RlbS5uYW1lLCBkZXNjcmlwdGlvbjogc3lzdGVtLmRlc2NyaXB0aW9uLCBwYXRoOiBzeXN0ZW0ucGF0aCB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS51cGRhdGVTeXN0ZW0gPSBmdW5jdGlvbiAoc3lzdGVtLCBzdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuX3NlbmQoXCJVcGRhdGVNZXRyaWNTeXN0ZW1cIiwge1xyXG4gICAgICAgICAgICBpZDogc3lzdGVtLmlkLFxyXG4gICAgICAgICAgICBpbnN0YW5jZTogc3lzdGVtLnJlcG8uaW5zdGFuY2UsXHJcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLmhlYXJ0YmVhdCA9IGZ1bmN0aW9uIChyZXBvLCBpbnRlcnZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NlbmQoXCJIZWFydGJlYXRNZXRyaWNzXCIsIHsgcHVibGlzaGluZ0ludGVydmFsOiBpbnRlcnZhbCwgaW5zdGFuY2U6IHJlcG8uaW5zdGFuY2UgfSk7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljc0JyaWRnZS5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZChcIm1ldHJpY3NcIiwgdHlwZSwgbWVzc2FnZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1ldHJpY3NCcmlkZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTWV0cmljc0JyaWRnZSA9IE1ldHJpY3NCcmlkZ2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9ydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgQWRkcmVzc01ldHJpYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWRkcmVzc01ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFkZHJlc3NNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCBBZGRyZXNzTWV0cmljLnR5cGUsIHZhbHVlIHx8ICcnKTtcclxuICAgIH1cclxuICAgIEFkZHJlc3NNZXRyaWMudHlwZSA9IDg7XHJcbiAgICByZXR1cm4gQWRkcmVzc01ldHJpYztcclxufShtZXRyaWNfMS5NZXRyaWMpKTtcclxuZXhwb3J0cy5BZGRyZXNzTWV0cmljID0gQWRkcmVzc01ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzc01ldHJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgQ291bnRNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvdW50TWV0cmljLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ291bnRNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCBDb3VudE1ldHJpYy50eXBlLCB2YWx1ZSB8fCAwKTtcclxuICAgIH1cclxuICAgIENvdW50TWV0cmljLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRCeSgxKTtcclxuICAgIH07XHJcbiAgICBDb3VudE1ldHJpYy5wcm90b3R5cGUuZGVjcmVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGVjcmVtZW50QnkoMSk7XHJcbiAgICB9O1xyXG4gICAgQ291bnRNZXRyaWMucHJvdG90eXBlLmluY3JlbWVudEJ5ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgodGhpcy52YWx1ZSB8fCAwKSArIG4pO1xyXG4gICAgfTtcclxuICAgIENvdW50TWV0cmljLnByb3RvdHlwZS5kZWNyZW1lbnRCeSA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKHRoaXMudmFsdWUgfHwgMCkgLSBuKTtcclxuICAgIH07XHJcbiAgICBDb3VudE1ldHJpYy5wcm90b3R5cGUuZ2V0VmFsdWVUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAzO1xyXG4gICAgfTtcclxuICAgIENvdW50TWV0cmljLnR5cGUgPSAzO1xyXG4gICAgcmV0dXJuIENvdW50TWV0cmljO1xyXG59KG1ldHJpY18xLk1ldHJpYykpO1xyXG5leHBvcnRzLkNvdW50TWV0cmljID0gQ291bnRNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvdW50TWV0cmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgTWV0cmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB0eXBlLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IGRlZi5uYW1lO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZWYuZGVzY3JpcHRpb247XHJcbiAgICAgICAgdGhpcy5wZXJpb2QgPSBkZWYucGVyaW9kO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IGRlZi5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMucmVwbyA9IHBhcmVudC5yZXBvO1xyXG4gICAgICAgIHRoaXMuaWQgPSBwYXJlbnQucGF0aCArIFwiL1wiICsgdGhpcy5uYW1lO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhcmVudC5wYXRoLnNsaWNlKDApO1xyXG4gICAgICAgIHRoaXMucGF0aC5wdXNoKHBhcmVudC5uYW1lKTtcclxuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmNyZWF0ZU1ldHJpYyh0aGlzKTtcclxuICAgIH1cclxuICAgIE1ldHJpYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC51cGRhdGVNZXRyaWModGhpcyk7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljLnByb3RvdHlwZS5nZXRWYWx1ZVR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBNZXRyaWMudHlwZSA9IDA7XHJcbiAgICByZXR1cm4gTWV0cmljO1xyXG59KCkpO1xyXG5leHBvcnRzLk1ldHJpYyA9IE1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0cmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBOdW1iZXJNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE51bWJlck1ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE51bWJlck1ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIE51bWJlck1ldHJpYy50eXBlLCB2YWx1ZSB8fCAwKTtcclxuICAgIH1cclxuICAgIE51bWJlck1ldHJpYy5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaW5jcmVtZW50QnkoMSk7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVyTWV0cmljLnByb3RvdHlwZS5kZWNyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kZWNyZW1lbnRCeSgxKTtcclxuICAgIH07XHJcbiAgICBOdW1iZXJNZXRyaWMucHJvdG90eXBlLmluY3JlbWVudEJ5ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgodGhpcy52YWx1ZSB8fCAwKSArIG4pO1xyXG4gICAgfTtcclxuICAgIE51bWJlck1ldHJpYy5wcm90b3R5cGUuZGVjcmVtZW50QnkgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCh0aGlzLnZhbHVlIHx8IDApIC0gbik7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVyTWV0cmljLnR5cGUgPSAyO1xyXG4gICAgcmV0dXJuIE51bWJlck1ldHJpYztcclxufShtZXRyaWNfMS5NZXRyaWMpKTtcclxuZXhwb3J0cy5OdW1iZXJNZXRyaWMgPSBOdW1iZXJNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlck1ldHJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgT2JqZWN0TWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhPYmplY3RNZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBPYmplY3RNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCBPYmplY3RNZXRyaWMudHlwZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0TWV0cmljLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBPYmplY3RNZXRyaWMudHlwZSA9IDExO1xyXG4gICAgcmV0dXJuIE9iamVjdE1ldHJpYztcclxufShtZXRyaWNfMS5NZXRyaWMpKTtcclxuZXhwb3J0cy5PYmplY3RNZXRyaWMgPSBPYmplY3RNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdE1ldHJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgUmF0ZU1ldHJpYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUmF0ZU1ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJhdGVNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCBSYXRlTWV0cmljLnR5cGUsIHZhbHVlIHx8IDApO1xyXG4gICAgfVxyXG4gICAgUmF0ZU1ldHJpYy50eXBlID0gNDtcclxuICAgIHJldHVybiBSYXRlTWV0cmljO1xyXG59KG1ldHJpY18xLk1ldHJpYykpO1xyXG5leHBvcnRzLlJhdGVNZXRyaWMgPSBSYXRlTWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRlTWV0cmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBTdGF0aXN0aWNzTWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdGF0aXN0aWNzTWV0cmljLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3RhdGlzdGljc01ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIFN0YXRpc3RpY3NNZXRyaWMudHlwZSwgdmFsdWUgfHwgMCk7XHJcbiAgICB9XHJcbiAgICBTdGF0aXN0aWNzTWV0cmljLnR5cGUgPSA2O1xyXG4gICAgcmV0dXJuIFN0YXRpc3RpY3NNZXRyaWM7XHJcbn0obWV0cmljXzEuTWV0cmljKSk7XHJcbmV4cG9ydHMuU3RhdGlzdGljc01ldHJpYyA9IFN0YXRpc3RpY3NNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRpc3RpY3NNZXRyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIFN0cmluZ01ldHJpYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU3RyaW5nTWV0cmljLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3RyaW5nTWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgU3RyaW5nTWV0cmljLnR5cGUsIHZhbHVlIHx8ICcnKTtcclxuICAgIH1cclxuICAgIFN0cmluZ01ldHJpYy50eXBlID0gMTtcclxuICAgIHJldHVybiBTdHJpbmdNZXRyaWM7XHJcbn0obWV0cmljXzEuTWV0cmljKSk7XHJcbmV4cG9ydHMuU3RyaW5nTWV0cmljID0gU3RyaW5nTWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdNZXRyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIFRpbWVzcGFuTWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUaW1lc3Bhbk1ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVzcGFuTWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgVGltZXNwYW5NZXRyaWMudHlwZSwgdmFsdWUgfHwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgVGltZXNwYW5NZXRyaWMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xyXG4gICAgfTtcclxuICAgIFRpbWVzcGFuTWV0cmljLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBUaW1lc3Bhbk1ldHJpYy50eXBlID0gMTA7XHJcbiAgICByZXR1cm4gVGltZXNwYW5NZXRyaWM7XHJcbn0obWV0cmljXzEuTWV0cmljKSk7XHJcbmV4cG9ydHMuVGltZXNwYW5NZXRyaWMgPSBUaW1lc3Bhbk1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXNwYW5NZXRyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIFRpbWVzdGFtcE1ldHJpYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVGltZXN0YW1wTWV0cmljLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGltZXN0YW1wTWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgVGltZXN0YW1wTWV0cmljLnR5cGUsIHZhbHVlIHx8IG5ldyBEYXRlKCkpO1xyXG4gICAgfVxyXG4gICAgVGltZXN0YW1wTWV0cmljLnByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUobmV3IERhdGUoKSk7XHJcbiAgICB9O1xyXG4gICAgVGltZXN0YW1wTWV0cmljLnR5cGUgPSA3O1xyXG4gICAgcmV0dXJuIFRpbWVzdGFtcE1ldHJpYztcclxufShtZXRyaWNfMS5NZXRyaWMpKTtcclxuZXhwb3J0cy5UaW1lc3RhbXBNZXRyaWMgPSBUaW1lc3RhbXBNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVzdGFtcE1ldHJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIHN5c3RlbV8xID0gcmVxdWlyZShcIi4vc3lzdGVtXCIpO1xyXG52YXIgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9icmlkZ2UvdHJhbnNwb3J0XCIpO1xyXG52YXIgUmVwb3NpdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZXBvc2l0b3J5KGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0XzEuTWV0cmljc0JyaWRnZSh0aGlzLCBjb25maWcuY29ubmVjdGlvbik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGNvbmZpZy5pZGVudGl0eS5zeXN0ZW0gKyAnLycgKyBjb25maWcuaWRlbnRpdHkuc2VydmljZSArICcvJyArIGNvbmZpZy5pZGVudGl0eS5pbnN0YW5jZTtcclxuICAgICAgICB0aGlzLmlkZW50aXR5ID0gY29uZmlnLmlkZW50aXR5O1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0SGVhcnRiZWF0aW5nKCk7XHJcbiAgICAgICAgdGhpcy5yb290ID0gbmV3IHN5c3RlbV8xLlN5c3RlbSgnJywgdGhpcywgdGhpcy5fdHJhbnNwb3J0KTtcclxuICAgICAgICB0aGlzLl9pbml0U3lzdGVtTWV0cmljcyh0aGlzLnJvb3QsIGNvbmZpZy5jbGlja1N0cmVhbSB8fCBjb25maWcuY2xpY2tTdHJlYW0gPT09IHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICBSZXBvc2l0b3J5LnByb3RvdHlwZS5fc3RhcnRIZWFydGJlYXRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl90cmFuc3BvcnQuaGVhcnRiZWF0KHRoaXMsIHRoaXMuX2NvbmZpZy5zZXR0aW5ncy5oZWFydGJlYXRJbnRlcnZhbCk7XHJcbiAgICAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fdHJhbnNwb3J0LmhlYXJ0YmVhdChfdGhpcywgX3RoaXMuX2NvbmZpZy5zZXR0aW5ncy5oZWFydGJlYXRJbnRlcnZhbCk7XHJcbiAgICAgICAgfSwgdGhpcy5fY29uZmlnLnNldHRpbmdzLmhlYXJ0YmVhdEludGVydmFsKTtcclxuICAgIH07XHJcbiAgICBSZXBvc2l0b3J5LnByb3RvdHlwZS5faW5pdFN5c3RlbU1ldHJpY3MgPSBmdW5jdGlvbiAocm9vdFN5c3RlbSwgdXNlQ2xpY2tTdHJlYW0pIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcm9vdFN5c3RlbS5zdHJpbmdNZXRyaWMoJ1VzZXJBZ2VudCcsIG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXNlQ2xpY2tTdHJlYW0gJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB2YXIgY2xpY2tTdHJlYW1fMSA9IHJvb3RTeXN0ZW0uc3ViU3lzdGVtKFwiQ2xpY2tTdHJlYW1cIik7XHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudENsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWUudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2xpY2tTdHJlYW1fMS5vYmplY3RNZXRyaWMoXCJMYXN0QnJvd3NlckV2ZW50XCIsIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNsaWNrXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGUudGFyZ2V0ID8gZS50YXJnZXQuY2xhc3NOYW1lIDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBlLnRhcmdldC5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJzwnICsgZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiBlLnRhcmdldC5ocmVmIHx8IFwiXCJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2xpY2tTdHJlYW1fMS5vYmplY3RNZXRyaWMoXCJQYWdlXCIsIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBkb2N1bWVudC50aXRsZSxcclxuICAgICAgICAgICAgICAgIHBhZ2U6IHdpbmRvdy5sb2NhdGlvbi5ocmVmXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBkb2N1bWVudENsaWNrSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgnb25jbGljaycsIGRvY3VtZW50Q2xpY2tIYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVwb3NpdG9yeTtcclxufSgpKTtcclxuZXhwb3J0cy5SZXBvc2l0b3J5ID0gUmVwb3NpdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwb3NpdG9yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIG51bWJlck1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljcy9udW1iZXJNZXRyaWNcIik7XHJcbnZhciB0aW1lc3Bhbk1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljcy90aW1lc3Bhbk1ldHJpY1wiKTtcclxudmFyIHN0cmluZ01ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljcy9zdHJpbmdNZXRyaWNcIik7XHJcbnZhciBhZGRyZXNzTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL2FkZHJlc3NNZXRyaWNcIik7XHJcbnZhciBvYmplY3RNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3Mvb2JqZWN0TWV0cmljXCIpO1xyXG52YXIgdGltZXN0YW1wTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL3RpbWVzdGFtcE1ldHJpY1wiKTtcclxudmFyIGNvdW50TWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL2NvdW50TWV0cmljXCIpO1xyXG52YXIgc3RhdGlzdGljc01ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljcy9zdGF0aXN0aWNzTWV0cmljXCIpO1xyXG52YXIgcmF0ZU1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljcy9yYXRlTWV0cmljXCIpO1xyXG52YXIgU3lzdGVtID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN5c3RlbShuYW1lLCByZXBvLCB0cmFuc3BvcnQsIHBhcmVudCwgZGVzY3JpcHRpb24pIHtcclxuICAgICAgICB0aGlzLm1ldHJpY3MgPSBbXTtcclxuICAgICAgICB0aGlzLnN1YlN5c3RlbXMgPSBbXTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiB8fCAnJztcclxuICAgICAgICB0aGlzLnJlcG8gPSByZXBvO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcclxuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLl9idWlsZFBhdGgodGhpcy5wYXJlbnQpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAodGhpcy5wYXRoLmxlbmd0aCA+IDAgPyB0aGlzLnBhdGguam9pbignLycpICsgJy8nIDogJycpICsgdGhpcy5uYW1lO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSByZXBvLmlkZW50aXR5O1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHJlcG8ucm9vdDtcclxuICAgICAgICB0aGlzLl90cmFuc3BvcnQuY3JlYXRlU3lzdGVtKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5zdWJTeXN0ZW0gPSBmdW5jdGlvbiAobmFtZSwgZGVzY3JpcHRpb24pIHtcclxuICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIGlzIHJlcXVpcmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtYXRjaGluZ1N5c3RlbXMgPSB0aGlzLnN1YlN5c3RlbXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLm5hbWUgPT09IG5hbWU7IH0pO1xyXG4gICAgICAgIGlmIChtYXRjaGluZ1N5c3RlbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdTeXN0ZW1zWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3lzdGVtID0gbmV3IFN5c3RlbShuYW1lLCB0aGlzLnJlcG8sIHRoaXMuX3RyYW5zcG9ydCwgdGhpcywgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgIHRoaXMuc3ViU3lzdGVtcy5wdXNoKHN5c3RlbSk7XHJcbiAgICAgICAgcmV0dXJuIHN5c3RlbTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC51cGRhdGVTeXN0ZW0odGhpcywgeyBzdGF0ZTogc3RhdGUsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnN0cmluZ01ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIHN0cmluZ01ldHJpY18xLlN0cmluZ01ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHN0cmluZ01ldHJpY18xLlN0cmluZ01ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5udW1iZXJNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCBudW1iZXJNZXRyaWNfMS5OdW1iZXJNZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBudW1iZXJNZXRyaWNfMS5OdW1iZXJNZXRyaWMobWV0cmljRGVmLCBfdGhpcywgX3RoaXMuX3RyYW5zcG9ydCwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuY291bnRNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCBjb3VudE1ldHJpY18xLkNvdW50TWV0cmljLnR5cGUsIHZhbHVlLCBmdW5jdGlvbiAobWV0cmljRGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgY291bnRNZXRyaWNfMS5Db3VudE1ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5hZGRyZXNzTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgYWRkcmVzc01ldHJpY18xLkFkZHJlc3NNZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBhZGRyZXNzTWV0cmljXzEuQWRkcmVzc01ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5vYmplY3RNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCBvYmplY3RNZXRyaWNfMS5PYmplY3RNZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBvYmplY3RNZXRyaWNfMS5PYmplY3RNZXRyaWMobWV0cmljRGVmLCBfdGhpcywgX3RoaXMuX3RyYW5zcG9ydCwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUudGltZXNwYW5NZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCB0aW1lc3Bhbk1ldHJpY18xLlRpbWVzcGFuTWV0cmljLnR5cGUsIHZhbHVlLCBmdW5jdGlvbiAobWV0cmljRGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGltZXNwYW5NZXRyaWNfMS5UaW1lc3Bhbk1ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS50aW1lc3RhbXBNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCB0aW1lc3RhbXBNZXRyaWNfMS5UaW1lc3RhbXBNZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aW1lc3RhbXBNZXRyaWNfMS5UaW1lc3RhbXBNZXRyaWMobWV0cmljRGVmLCBfdGhpcywgX3RoaXMuX3RyYW5zcG9ydCwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUucmF0ZU1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIHJhdGVNZXRyaWNfMS5SYXRlTWV0cmljLnR5cGUsIHZhbHVlLCBmdW5jdGlvbiAobWV0cmljRGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcmF0ZU1ldHJpY18xLlJhdGVNZXRyaWMobWV0cmljRGVmLCBfdGhpcywgX3RoaXMuX3RyYW5zcG9ydCwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuc3RhdGl0aWNzTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgc3RhdGlzdGljc01ldHJpY18xLlN0YXRpc3RpY3NNZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0aXN0aWNzTWV0cmljXzEuU3RhdGlzdGljc01ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5fdW5pb25Ub01ldHJpY0RlZiA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1ldHJpY0RlZjtcclxuICAgICAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG1ldHJpY0RlZiA9IHsgbmFtZTogZGVmaW5pdGlvbiB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWV0cmljRGVmID0gZGVmaW5pdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1ldHJpY0RlZi5uYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRyaWMgbmFtZSBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1ldHJpY0RlZjtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLl9nZXRPckNyZWF0ZU1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCBleHBlY3RlZFR5cGUsIHZhbHVlLCBjcmVhdGVGdW5jKSB7XHJcbiAgICAgICAgdmFyIG1ldHJpY0RlZiA9IHRoaXMuX3VuaW9uVG9NZXRyaWNEZWYoZGVmaW5pdGlvbik7XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nTWV0cmljcyA9IHRoaXMubWV0cmljcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ubmFtZSA9PT0gbWV0cmljRGVmLm5hbWU7IH0pO1xyXG4gICAgICAgIGlmIChtYXRjaGluZ01ldHJpY3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdNZXRyaWMgPSBtYXRjaGluZ01ldHJpY3NbMF07XHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ01ldHJpYy50eXBlICE9PSBleHBlY3RlZFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBtZXRyaWMgbmFtZWQgJyArIG1ldHJpY0RlZi5uYW1lICsgJyBpcyBhbHJlYWR5IGRlZmluZWQgd2l0aCBkaWZmZXJlbnQgdHlwZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdGluZ01ldHJpYy51cGRhdGUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ01ldHJpYztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5ld01ldHJpYyA9IGNyZWF0ZUZ1bmMobWV0cmljRGVmKTtcclxuICAgICAgICB0aGlzLm1ldHJpY3MucHVzaChuZXdNZXRyaWMpO1xyXG4gICAgICAgIHJldHVybiBuZXdNZXRyaWM7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5fYnVpbGRQYXRoID0gZnVuY3Rpb24gKHN5c3RlbSkge1xyXG4gICAgICAgIGlmICghc3lzdGVtIHx8ICFzeXN0ZW0ucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLl9idWlsZFBhdGgoc3lzdGVtLnBhcmVudCk7XHJcbiAgICAgICAgcGF0aC5wdXNoKHN5c3RlbS5uYW1lKTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3lzdGVtO1xyXG59KCkpO1xyXG5leHBvcnRzLlN5c3RlbSA9IFN5c3RlbTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3lzdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgcmVwb3NpdG9yeV8xID0gcmVxdWlyZShcIi4vY29yZS9yZXBvc2l0b3J5XCIpO1xyXG52YXIgdGljazQyX2dhdGV3YXlfY29ubmVjdGlvbl8xID0gcmVxdWlyZSgndGljazQyLWdhdGV3YXktY29ubmVjdGlvbicpO1xyXG52YXIgd2luZG93QXNBbnkgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IChuZXcgT2JqZWN0KCkpIDogd2luZG93O1xyXG53aW5kb3dBc0FueS50aWNrNDIgPSB3aW5kb3dBc0FueS50aWNrNDIgfHwge307XHJcbndpbmRvd0FzQW55LnRpY2s0Mi5tZXRyaWNzID0gd2luZG93QXNBbnkudGljazQyLm1ldHJpY3MgfHwgZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgaWYgKCFjb25maWcuaWRlbnRpdHkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lkZW50aXR5IG1pc3NpbmcgZnJvbSBtZXRyaWNzIGNvbmZpZ3VyYXRpb24nKTtcclxuICAgIH1cclxuICAgIGlmICghY29uZmlnLmlkZW50aXR5LnNlcnZpY2UgfHwgdHlwZW9mIGNvbmZpZy5pZGVudGl0eS5zZXJ2aWNlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmljZSBtaXNzaW5nIG9yIGludmFsaWQgaW4gbWV0cmljcyBpZGVudGl0eSBjb25maWd1cmF0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNvbmZpZy5pZGVudGl0eS5zeXN0ZW0gfHwgdHlwZW9mIGNvbmZpZy5pZGVudGl0eS5zeXN0ZW0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTeXN0ZW0gbWlzc2luZyBvciBpbnZhbGlkIGluIG1ldHJpY3MgaWRlbnRpdHkgY29uZmlndXJhdGlvbicpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjb25maWcuaWRlbnRpdHkuaW5zdGFuY2UgfHwgdHlwZW9mIGNvbmZpZy5pZGVudGl0eS5pbnN0YW5jZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RhbmNlbWlzc2luZyBvciBpbnZhbGlkIGluIG1ldHJpY3MgaWRlbnRpdHkgY29uZmlndXJhdGlvbicpO1xyXG4gICAgfVxyXG4gICAgY29uZmlnLnNldHRpbmdzID0gY29uZmlnLnNldHRpbmdzIHx8IHt9O1xyXG4gICAgY29uZmlnLnNldHRpbmdzLmhlYXJ0YmVhdEludGVydmFsID0gY29uZmlnLnNldHRpbmdzLmhlYXJ0YmVhdEludGVydmFsIHx8IDE1MDAwO1xyXG4gICAgaWYgKHR5cGVvZiBjb25maWcuY29ubmVjdGlvbiAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGNvbmZpZy5jb25uZWN0aW9uID0ge307XHJcbiAgICB9XHJcbiAgICBpZiAoISh0eXBlb2YgY29uZmlnLmNvbm5lY3Rpb24gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbmZpZy5jb25uZWN0aW9uLnNlbmQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY29uZmlnLmNvbm5lY3Rpb24ub24gPT09IFwiZnVuY3Rpb25cIikpIHtcclxuICAgICAgICBjb25maWcuY29ubmVjdGlvbiA9IHRpY2s0Ml9nYXRld2F5X2Nvbm5lY3Rpb25fMS5jb25uZWN0aW9uKGNvbmZpZy5jb25uZWN0aW9uKTtcclxuICAgIH1cclxuICAgIHZhciByZXBvID0gbmV3IHJlcG9zaXRvcnlfMS5SZXBvc2l0b3J5KGNvbmZpZyk7XHJcbiAgICByZXBvWyd2ZXJzaW9uJ10gPSByZXBvLnJvb3RbJ3ZlcnNpb24nXSA9ICcyLjAuMTUnO1xyXG4gICAgcmV0dXJuIHJlcG8ucm9vdDtcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dBc0FueS50aWNrNDIubWV0cmljcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0cmljc01vZHVsZS5qcy5tYXAiLCJ2YXIgYmFzZUNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKTtcblxuLyoqXG4gKiBDaGVjayByZWFkbWUubWQgZm9yIGRldGFpbGVkIGRlc2NyaXB0aW9uXG4gKi9cbnZhciBjb25uZWN0aW9uID0gZnVuY3Rpb24gKHNldHRpbmdzLCBjdXN0b21Db25uZWN0aW9uKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgdmFyIGNvbm5lY3Rpb24gPSBiYXNlQ29ubmVjdGlvbihzZXR0aW5ncyk7XG5cbiAgICAvLyBpZiBydW5uaW5nIGluIEhDIHdlIHVzZSBndzEgcHJvdG9jb2wgYW5kIGhjIHRyYW5zcG9ydFxuICAgIGlmIChnbG9iYWwuaHRtbENvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL3Byb3RvY29scy9ndzEnKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaGMnKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLy8gaWYgcnVubmluZyBpbiB0aGUgYnJvd3NlciAtIGxldCdzIGNoZWNrIHdoaWNoIHByb3RvY29sIHZlcnNpb24gdXNlciB3YW50c1xuICAgIGlmIChzZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDMpIHtcbiAgICAgICAgY29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vcHJvdG9jb2xzL2d3MycpKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gMikge1xuICAgICAgICBjb25uZWN0aW9uID0gcmVxdWlyZSgnLi9wcm90b2NvbHMvZ3cyJykoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL3Byb3RvY29scy9ndzEnKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLndzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4vdHJhbnNwb3J0cy93cycpKGNvbm5lY3Rpb24sIHNldHRpbmdzKTtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmh0dHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2h0dHAnKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XG4gICAgfSBlbHNlIGlmIChjdXN0b21Db25uZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9tb2NrJykoY29ubmVjdGlvbiwgY3VzdG9tQ29ubmVjdGlvbiwgc2V0dGluZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29ubmVjdGlvbi4gTWFrZSBzdXJlIHlvdSBhcmUgcnVubmluZyB0aGUgYXBwbGljYXRpb24gZnJvbSBUaWNrNDIgSHRtbENvbnRhaW5lciBvciBmaWxsIHRoZSBcXCdjb25uZWN0aW9uLndlYnNvY2tldF91cmxcXCcgcHJvcGVydHkuJyk7XG4gICAgfVxufTtcblxuaWYgKGdsb2JhbC50aWNrNDIgPT09IHVuZGVmaW5lZCkge1xuICAgIGdsb2JhbC50aWNrNDIgPSB7fTtcbn1cblxuZ2xvYmFsLnRpY2s0Mi5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0aW9uO1xuIiwiLyoqXG4gKiBDb25uZWN0aW9uIHRvIEh0bWxDb250YWluZXJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgY29ubmVjdGlvbklkID0gTWF0aC5mbG9vcigxZTEwICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKTtcbiAgICAvLyBSb3V0ZSBtZXNzYWdlcyB0byBmYWNhZGUocylcbiAgICBjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbiAocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAocHJvZHVjdCA9PT0gJ21ldHJpY3MnKSB7XG4gICAgICAgICAgICBnbG9iYWwuaHRtbENvbnRhaW5lci5tZXRyaWNzRmFjYWRlLnNlbmQodHlwZSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2R1Y3QgPT09ICdsb2cnKSB7XG4gICAgICAgICAgICBnbG9iYWwuaHRtbENvbnRhaW5lci5sb2dnaW5nRmFjYWRlLnNlbmQodHlwZSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2R1Y3QgPT09ICdhcHBjb25maWcnKSB7XG4gICAgICAgICAgICBnbG9iYWwuaHRtbENvbnRhaW5lci5hcHBDb25maWdGYWNhZGUuc2VuZCh0eXBlLCBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgY29ubmVjdGlvbklkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoZ2xvYmFsLmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2xvYmFsLmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlLmluaXRDb25uZWN0aW9uKFxuICAgICAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG1lc3NhZ2VBc0pzb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5faGFuZGxlX21lc3NhZ2UoSlNPTi5wYXJzZShtZXNzYWdlQXNKc29uKSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnbG9iYWwuY29ubmVjdGlvbnMgPSBnbG9iYWwuY29ubmVjdGlvbnMgfHwge307XG4gICAgLy8gRXhwb3NlIGZ1bmN0aW9uIGZvciBzZW5kaW5nIG1lc3NhZ2VzOlxuICAgIGdsb2JhbC5jb25uZWN0aW9uc1snY29ubmVjdGlvbicgKyBjb25uZWN0aW9uSWRdID0gY29ubmVjdGlvbi5faGFuZGxlX21lc3NhZ2U7XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBzZXR0aW5ncykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgdXJsID0gc2V0dGluZ3MuaHR0cDtcbiAgICAvLyBwb2xsaW5nIGludGVydmFsIGluIG1zLCBkZWZhdWx0IGlzIDEgc2Vjb25kXG4gICAgdmFyIGludGVydmFsID0gc2V0dGluZ3MuaHR0cF9pbnRlcnZhbF9tcztcbiAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICAgIGludGVydmFsID0gMTAwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2dEZWJ1ZyhtZXNzYWdlKSB7XG4gICAgICAgIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIChzZXR0aW5ncy5kZWJ1ZyA9PT0gdHJ1ZSB8fCBzZXR0aW5ncy50cmFjZSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9nVHJhY2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBzZXR0aW5ncy50cmFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2dEZWJ1ZygnQXR0ZW1waW5nIHRvIGNvbm5lY3QgdG8gR2F0ZXdheSB2aWEgSFRUUCB3aXRoIHVybCBcXCcnICsgdXJsICsgJ1xcJyBhbmQgcG9sbGluZyBpbnRlcnZhbCAnICsgaW50ZXJ2YWwgKyAnIG1zJyk7XG5cbiAgICBjb25uZWN0aW9uLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcG9sbCh1cmwsIGludGVydmFsLCAwLCBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpdGVtcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLl9wcm9jZXNzTWVzc2FnZShpdGVtc1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbiAocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSwgaWQpIHtcbiAgICAgICAgdmFyIG1zZyA9IGNvbm5lY3Rpb24uX2NyZWF0ZU1lc3NhZ2UodHlwZSwgbWVzc2FnZSwgaWQpO1xuICAgICAgICBodHRwUG9zdCh1cmwsIG1zZyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBvbGxzIGRhdGEgZnJvbSBhIGdpdmVuIHVybCBvbiBzb21lIGludGVydmFsXG4gICAgICogQHBhcmFtIHVybCAgICAgICBCYXNlIHNlcnZlciB1cmwuIEEgc2VxdWVuY2UgdXJsIHBhcmFtIG1heSBiZSBhZGRlZCBiYXNlZCBvbiB0aGUgc2VxIHBhcmFtXG4gICAgICogQHBhcmFtIGludGVydmFsICBJbnRlcnZhbCAoaW4gbXMpIGJldHdlZW4gcG9sbGluZyByZXF1ZXN0dHNcbiAgICAgKiBAcGFyYW0gc2VxICAgICAgIE5leHQgc2VxdWVuY2UgbnVtYmVyIHdlIHNob3VsZCBhc2sgZm9yIChpZiAwIHRoZSBzZXJ2ZXIgd2lsbCByZXR1cm4gdGhlIGxhc3Qga25vd24gbWVzc2FnZSlcbiAgICAgKiBAcGFyYW0gb25kYXRhICAgIERhdGEgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb2xsKHVybCwgaW50ZXJ2YWwsIHNlcSwgb25kYXRhKSB7XG4gICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgZ2V0IFVybCAtIGlmIHNlcSAhPSAwIGFkZCBhcyB1cmwgcGFyYW0gdG8gZ2V0XG4gICAgICAgIC8vIG9ubHkgbWVzc2FnZXMgYWZ0ZXIgdGhpcyBzZXF1ZW5jZVxuICAgICAgICB2YXIgZ2V0VXJsID0gdXJsO1xuXG4gICAgICAgIGlmIChzZXEgIT09IDApIHtcbiAgICAgICAgICAgIGdldFVybCA9IHVybCArICc/c2VxdWVuY2U9JyArIHNlcSArICcmbm8tY2FjaGU9JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcmVxdWVzdFxuICAgICAgICB2YXIgeG1saHR0cCA9IGNyZWF0ZUNPUlNSZXF1ZXN0KCdHRVQnLCBnZXRVcmwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZXEgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnQ29ubmVjdGVkIHRvIEdhdGV3YXkgb24gJyArIHVybCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvZ1RyYWNlKCdSZXNwb25zZSBmcm9tIFxcJycgKyBnZXRVcmwgKyAnXFwnIGlzICcgKyB4bWxodHRwLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoeG1saHR0cC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgLy8gdGhlIHNlcnZlciByZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIG5leHQgc2VxdWVuY2UgdGhhdCB3ZSBtdXN0IHF1ZXJ5IGZvclxuICAgICAgICAgICAgdmFyIG5leHRTZXEgPSBtZXNzYWdlLm5leHRTZXF1ZW5jZTtcbiAgICAgICAgICAgIC8vIGNhbGwgdXNlciBjYWxsYmFja2VcbiAgICAgICAgICAgIG9uZGF0YShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgLy8gcmUtc2NoZWR1bGVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBvbGwodXJsLCBpbnRlcnZhbCwgbmV4dFNlcSwgb25kYXRhKTtcbiAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgeG1saHR0cC5vbmVycm9yID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgcG9sbGluZyBkYXRhIGZyb20gaHR0cCBzZXJ2ZXIgXFwnJyArIGdldFVybCArICdcXCcgLSAnICsgZXYpO1xuICAgICAgICAgICAgLy8gcmUtc2NoZWR1bGVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBvbGwodXJsLCBpbnRlcnZhbCwgc2VxLCBvbmRhdGEpO1xuICAgICAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxvZ1RyYWNlKCdTZW5kaW5nIEdFVCB0byBcXCcnICsgZ2V0VXJsICsgJ1xcJycpO1xuICAgICAgICB4bWxodHRwLnNlbmQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQT1NUcyBhIG1lc3NhZ2UgdG8gYSBnaXZlbiB1cmxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBodHRwUG9zdCh1cmwsIG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgcmVxdWVzdFxuICAgICAgICB2YXIgeG1saHR0cCA9IGNyZWF0ZUNPUlNSZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgICAgICAgbG9nVHJhY2UoJ1NlbmRpbmcgUE9TVCB0byBcXCcnICsgdXJsICsgJ1xcJyA6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgeG1saHR0cC5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgQ09SUyByZXF1ZXN0IChjcm9zcyBkb21haW4gcmVxdWVzdHMpIGZvciBkaWZmZXJlbnQgYnJvd3NlcnMgLSBYTUxIdHRwUmVxdWVzdCB3aXRoQ3JlZGVudGlhbHNcbiAgICAgKiBmb3IgQ2hyb21lIGFuZCBGRiBhbmQgWERvbWFpblJlcXVlc3QgZm9yIElFXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ09SU1JlcXVlc3QobWV0aG9kLCB1cmwsIHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0IGhhcyBhIFwid2l0aENyZWRlbnRpYWxzXCIgcHJvcGVydHkuXG4gICAgICAgICAgICAvLyBcIndpdGhDcmVkZW50aWFsc1wiIG9ubHkgZXhpc3RzIG9uIFhNTEhUVFBSZXF1ZXN0MiBvYmplY3RzLlxuICAgICAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRDYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNoZWNrIGlmIFhEb21haW5SZXF1ZXN0LlxuICAgICAgICAgICAgLy8gWERvbWFpblJlcXVlc3Qgb25seSBleGlzdHMgaW4gSUUsIGFuZCBpcyBJRSdzIHdheSBvZiBtYWtpbmcgQ09SUyByZXF1ZXN0cy5cbiAgICAgICAgICAgIHhociA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRDYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB4aHIub25sb2FkID0gcmVzdWx0Q2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIENPUlMgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgIHhociA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geGhyO1xuICAgIH1cblxuICAgIHJldHVybiBjb25uZWN0aW9uO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIHNldHRpbmdzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gTG9hZCB0aGUgJ3dzJyBsaWJyYXJ5LCBidXQgb25seSBpZiB3ZSBhcmUgcnVubmluZyB1bmRlciBub2RlIGpzXG4gICAgdmFyIFdlYlNvY2tldCA9IHJlcXVpcmUoJ2RldGVjdC1ub2RlJykgPyByZXF1aXJlKCd3cycpIDogZ2xvYmFsLldlYlNvY2tldDtcblxuICAgIGZ1bmN0aW9uIGluaXRpYXRlU29ja2V0KCkge1xuICAgICAgICB2YXIgd3MgPSBuZXcgV2ViU29ja2V0KHNldHRpbmdzLndzKTtcbiAgICAgICAgd3Mub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX3RyaWdnZXJDb25uZWN0aW9uQ2hhbmdlZChmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIExvZyBvbiBjb25uZWN0aW9uXG4gICAgICAgIHdzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX3RyaWdnZXJDb25uZWN0aW9uQ2hhbmdlZCh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXR0YWNoIGhhbmRsZXJcbiAgICAgICAgd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX3Byb2Nlc3NNZXNzYWdlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHdzO1xuICAgIH1cblxuICAgIC8vIEhvbGRzIGNhbGxiYWNrIGV4ZWN1dGlvbiB1bnRpbCBzb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZC5cbiAgICBmdW5jdGlvbiB3YWl0Rm9yU29ja2V0Q29ubmVjdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA+IDEpIHtcbiAgICAgICAgICAgIC8vID4gMSBtZWFucyBjbG9zaW5nIG9yIGNsb3NlZFxuICAgICAgICAgICAgc29ja2V0ID0gaW5pdGlhdGVTb2NrZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2FpdEZvclNvY2tldENvbm5lY3Rpb24oY2FsbGJhY2spO1xuICAgICAgICB9LCA1MCk7IC8vIHdhaXQgNSBtaWxsaXNlY29uZHMgZm9yIHRoZSBjb25uZWN0aW9uLi4uXG4gICAgfVxuXG4gICAgLy8gSW5pdGlhdGUgYSBuZXcgc29ja2V0ICh0aGlzIGdldHMgcmUtZXhlY3V0ZWQgb24gcmVjb25uZWN0KVxuICAgIHZhciBzb2NrZXQgPSBpbml0aWF0ZVNvY2tldCgpO1xuXG4gICAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gZm9yIHNlbmRpbmcgYSBtZXNzYWdlXG4gICAgY29ubmVjdGlvbi5zZW5kID0gZnVuY3Rpb24gKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2UsIGlkKSB7XG4gICAgICAgIHdhaXRGb3JTb2NrZXRDb25uZWN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IGNvbm5lY3Rpb24uX2NyZWF0ZU1lc3NhZ2UodHlwZSwgbWVzc2FnZSwgaWQpO1xuICAgICAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb2NrZXQuc2VuZChtc2cpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29ubmVjdGlvbi53ZWJzb2NrZXRfdXJsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgc2V0dGluZ3Mud2Vic29ja2V0X3VybCA9IGE7XG4gICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICBzb2NrZXQgPSBpbml0aWF0ZVNvY2tldCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvbkA+PTEuMy4yXCIsXG4gICAgICBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcZGV2XFxcXGpzLWdsdWVcXFxcbm9kZV9tb2R1bGVzXFxcXHRpY2s0Mi1hcHBjb25maWdcIlxuICAgIF0sXG4gICAgW1xuICAgICAgXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uQD49MS4xLjJcIixcbiAgICAgIFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxkZXZcXFxcanMtZ2x1ZVxcXFxub2RlX21vZHVsZXNcXFxcdGljazQyLW1ldHJpY3NcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25APj0xLjEuMlwiLFxuICBcIl9pZFwiOiBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25AMi4xLjRcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi90aWNrNDItbWV0cmljcy90aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCIsXG4gIFwiX25vZGVWZXJzaW9uXCI6IFwiNi4zLjBcIixcbiAgXCJfbnBtVXNlclwiOiB7fSxcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjMuOC41XCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcIm5hbWVcIjogXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCIsXG4gICAgXCJyYXdcIjogXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uQD49MS4xLjJcIixcbiAgICBcInJhd1NwZWNcIjogXCI+PTEuMS4yXCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcIj49MS4xLjJcIixcbiAgICBcInR5cGVcIjogXCJyYW5nZVwiXG4gIH0sXG4gIFwiX3JlcXVpcmVkQnlcIjogW1xuICAgIFwiL3RpY2s0Mi1tZXRyaWNzXCJcbiAgXSxcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvbkA+PTEuMS4yXCIsXG4gIFwiX3doZXJlXCI6IFwiQzpcXFxcd29ya1xcXFxzdGFzaFxcXFxHTFVFLWRldlxcXFxkZXZcXFxcanMtZ2x1ZVxcXFxub2RlX21vZHVsZXNcXFxcdGljazQyLW1ldHJpY3NcIixcbiAgXCJiaW5cIjoge1xuICAgIFwiYnVpbGRcIjogXCIuL2Jpbi9idWlsZC5qc1wiLFxuICAgIFwiY2xlYW5cIjogXCIuL2Jpbi9jbGVhbi5qc1wiLFxuICAgIFwiZmlsZS12ZXJzaW9uaWZ5XCI6IFwiLi9iaW4vZmlsZS12ZXJzaW9uaWZ5LmpzXCIsXG4gICAgXCJtaW5pZnlcIjogXCIuL2Jpbi9taW5pZnkuanNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJicm93c2VyaWZ5LXZlcnNpb25pZnlcIjogXCJeMS4wLjRcIixcbiAgICBcImNhbGxiYWNrLXJlZ2lzdHJ5XCI6IFwiXjEuMC4xXCIsXG4gICAgXCJkZXRlY3Qtbm9kZVwiOiBcIl4yLjAuM1wiLFxuICAgIFwiZXM2LXByb21pc2VcIjogXCJeMy4yLjFcIixcbiAgICBcInNob3J0aWRcIjogXCJeMi4yLjZcIixcbiAgICBcInVybC1zZWFyY2gtcGFyYW1zXCI6IFwiXjAuNS4wXCIsXG4gICAgXCJ3c1wiOiBcIl4wLjcuMlwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUaWNrNDIgR2F0ZXdheSBDb25uZWN0aW9uLlwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJibGFua2V0XCI6IFwiXjEuMS42XCIsXG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjEzLjAuMFwiLFxuICAgIFwiYnJvd3NlcmlmeS1yZXBsYWNpZnlcIjogXCJeMC4wLjRcIixcbiAgICBcImJyb3dzZXJpZnktdmVyc2lvbmlmeVwiOiBcIl4xLjAuNFwiLFxuICAgIFwiZXNsaW50XCI6IFwiXjMuMS4xXCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXN0YW5kYXJkXCI6IFwiXjUuMy41XCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXRpY2s0MlwiOiBcIl4xLjAuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1wcm9taXNlXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXN0YW5kYXJkXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJmc1wiOiBcIjAuMC4yXCIsXG4gICAgXCJqc2RvbVwiOiBcIl44LjEuMFwiLFxuICAgIFwibWluaWZ5aWZ5XCI6IFwiXjcuMy4yXCIsXG4gICAgXCJvbmNoYW5nZVwiOiBcIl4yLjEuMlwiLFxuICAgIFwicGhhbnRvbWpzXCI6IFwiXjEuOS4xMlwiLFxuICAgIFwicXVuaXRqc1wiOiBcIl4xLjE1LjBcIixcbiAgICBcInNoZWxsanNcIjogXCJeMC42LjBcIlxuICB9LFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiY2VjZjUyZGE3ODViM2QwYjUyOGRjZTFlMTBjMTlmYWQ1MTY4MDY1ZlwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHA6Ly8xOTIuMTY4LjAuMjM0OjQ4NzMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi8tL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24tMi4xLjQudGd6XCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiNGRkZDFkZTgyNjI4ZDgyYjNmOTY0Njc2OTA5MjU2MTBmYzE1NDdhZlwiLFxuICBcIm1haW5cIjogXCJsaWJyYXJ5L21haW4uanNcIixcbiAgXCJuYW1lXCI6IFwidGljazQyLWdhdGV3YXktY29ubmVjdGlvblwiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcInJlYWRtZS5tZFwiLFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnVpbGRcIjogXCJucG0gcnVuIGVzbGludCAmJiBub2RlIGJpbi9jbGVhbi5qcyAmJiBub2RlIGJpbi9idWlsZC5qcyAmJiBub2RlIGJpbi9taW5pZnkgJiYgbm9kZSBiaW4vZmlsZS12ZXJzaW9uaWZ5XCIsXG4gICAgXCJlc2xpbnRcIjogXCJlc2xpbnQgbGlicmFyeVwiLFxuICAgIFwiZXNsaW50OmZpeFwiOiBcImVzbGludCBsaWJyYXJ5IC0tZml4IFwiLFxuICAgIFwicHJlcHVibGlzaFwiOiBcIm5wbSB1cGRhdGUgJiBucG0gcnVuIGJ1aWxkXCIsXG4gICAgXCJ0ZXN0XCI6IFwibnBtIHJ1biBlc2xpbnQgJiYgbW9jaGEgLS1yZXF1aXJlIC4vdGVzdC90ZXN0X2hlbHBlciBcXFwidGVzdC8qKi8qLmpzXFxcIlwiLFxuICAgIFwid2F0Y2hcIjogXCJvbmNoYW5nZSBcXFwiLi9saWJyYXJ5LyouanNcXFwiIC1pdiAtZSBcXFwiLi9iaW5cXFwiIC0tIG5wbSBydW4gYnVpbGRcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIyLjEuNFwiXG59XG4iLCIgIHZhciBoZWxwZXJzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuICBoZWxwZXJzLmludm9rZUFnbVN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGJhY2tBYXJndW1lbnQpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjayhjYWxsYmFja0Fhcmd1bWVudCk7XG4gICAgICB9XG4gIH1cblxuICBoZWxwZXJzLmludm9rZUFnbUVycm9yQ2FsbGJhY2sgPSAgZnVuY3Rpb24gKGNhbGxiYWNrLCBlcnJvcikge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICB9XG5cbiAgaGVscGVycy5leGVjQ2FsbGJhY2tzID0gIGZ1bmN0aW9uIChhcnIsIHZhbCkge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgaWYgKGFyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sodmFsKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgfVxuXG4gIGhlbHBlcnMudmFscyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKGZ1bmN0aW9uKGFyciwga2V5KSB7XG4gICAgICAgICAgYXJyLnB1c2gob2JqW2tleV0pO1xuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9LCBbXSk7XG4gIH07XG5cblxuICBoZWxwZXJzLmFzc2lnbiA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgLy8gV2UgbXVzdCBjaGVjayBhZ2FpbnN0IHRoZXNlIHNwZWNpZmljIGNhc2VzLlxuICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4iLCJ2YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzLmluaXQgPSBpbml0O1xubW9kdWxlLmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlV2luZG93O1xuXG52YXIgYWdtO1xuXG5mdW5jdGlvbiBzZXRXaW5kb3dTdHlsZUF0dHJpYnV0ZXMod2luZG93U3R5bGVzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIEFkZGluZyB3aW5kb3dTdHlsZUF0dHJpYnV0ZXNcbiAgICBpZiAod2luZG93U3R5bGVzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHdpbmRvd1N0eWxlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uod2luZG93U3R5bGVzKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvd1N0eWxlcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB3aW5kb3dTdHlsZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3dTdHlsZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdChhKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGFnbSA9IGE7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlV2luZG93KGlkLCBpbnRlcm5hbElkLCBuYW1lLCBjb250YWluZXJPYmosIHVybCwgdGl0bGUsIHdpbmRvd1N0eWxlcykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICghY29udGFpbmVyT2JqKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udGFpbmVyT2JqIGNhbiBub3QgYmUgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdFdpbmRvdztcblxuICAgIGZ1bmN0aW9uIGFkZENhbGxiYWNrKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9iaiA9IHJlc3VsdFdpbmRvdy5fY2FsbGJhY2tzO1xuICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGdW5jdGlvbnMgZm9yIG9wZW5pbmcsIGNsb3NpbmcsIHJlc2l6aW5nIHdpbmRvd3NcbiAgICBmdW5jdGlvbiBvcGVuKGRpbWVuc2lvbnMsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cbiAgICAgICAgLy8gQSB3cmFwcGVyIGZvciB0aGUgc3RhbmRhcmQgQUdNIFwib3BlblwiIGZ1bmN0aW9uXG4gICAgICAgIHZhciB0aGVXaW5kb3cgPSB0aGlzO1xuXG4gICAgICAgIC8vIEluaXQgc3R5bGUgb2JqZWN0cyBpZiB0aGV5IGFyZSBudWxsXG4gICAgICAgIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgdGFyZ2V0ID0gY29udGFpbmVyT2JqLmdldEFnbVRhcmdldCgpO1xuXG4gICAgICAgIHZhciBhcmdzID0ge1xuICAgICAgICAgICAgLy8gV2luZG93IG5hbWUgYW5kIHVybFxuICAgICAgICAgICAgd2luZG93TmFtZTogdGhlV2luZG93Lm5hbWUsXG4gICAgICAgICAgICB1cmw6IHRoZVdpbmRvdy51cmwsXG5cbiAgICAgICAgICAgIC8vIGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRvcDogZGltZW5zaW9ucy50b3AsXG4gICAgICAgICAgICBsZWZ0OiBkaW1lbnNpb25zLmxlZnQsXG4gICAgICAgICAgICB3aWR0aDogZGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZGltZW5zaW9ucy5oZWlnaHQsXG5cbiAgICAgICAgICAgIC8vIFN0eWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIHdpbmRvd1N0eWxlQXR0cmlidXRlczogSlNPTi5zdHJpbmdpZnkob3B0aW9ucylcbiAgICAgICAgfTtcblxuICAgICAgICBhcmdzID0gaGVscGVycy5hc3NpZ24oYXJncywgb3B0aW9ucyk7XG5cbiAgICAgICAgYWdtLmludm9rZSgnVDQyLkh0bWwuQ3JlYXRlV2luZG93JyxcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIG9wZW5lZCxcbiAgICAgICAgICAgIGNhbm5vdE9wZW4pO1xuXG4gICAgICAgIGZ1bmN0aW9uIG9wZW5lZChtZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBBZGQgaWQgdG8gdGhlIGN1cnJlbnQgd2luZG93cyBiZWNhdXNlIHRoZSBjdXJyZW50IEhUTUwgQ29udGFpbmVyXG4gICAgICAgICAgICAvLyBkb2Vzbid0IHN1cHBvcnQgdHJhY2tpbmcgdGhlIHVwZGF0ZXMgb2YgdGhlIHdpbmRvd1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmV0dXJuZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoZVdpbmRvdy5pZCA9IG1lc3NhZ2UucmV0dXJuZWQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWxwZXJzLmludm9rZUFnbVN1Y2Nlc3NDYWxsYmFjayhzdWNjZXNzLCB0aGVXaW5kb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2Fubm90T3BlbihlKSB7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBlcnJvciBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJ5IHRvIGJpbmQgdGhlIHJldHVybmVkIG9iamVjdCBpbiBjYXNlLi4uXG4gICAgICAgICAgICAvLyBiaW5kV2luZG93KHRoZVdpbmRvdyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhlV2luZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gYWdtQWN0aW9uKCdUNDIuV25kLlNldFdpbmRvd1N0eWxlJywgc3VjY2VzcywgZXJyb3IsIHsgd2luZG93U3R5bGVBdHRyaWJ1dGVzOiBKU09OLnN0cmluZ2lmeShzdHlsZSkgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3BlbmVkKCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0V2luZG93LmlkICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlV2luZG93Q2xvc2UoKSB7XG4gICAgICAgIGlmIChyZXN1bHRXaW5kb3cuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGVscGVycy5leGVjQ2FsbGJhY2tzKHJlc3VsdFdpbmRvdy5fY2FsbGJhY2tzLm9uQ2xvc2UpO1xuICAgICAgICAgICAgcmVzdWx0V2luZG93LmlkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzdWx0V2luZG93Ll9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gYWdtQWN0aW9uKCdUNDIuV25kLkNsb3NlJywgZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnXCInICsgd2luLm5hbWUgKyAgJ1wiIHdpbmRvdyB3YXMgY2xvc2VkLicpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnXCInICsgcmVzdWx0V2luZG93Lm5hbWUgKyAgJ1wiIHdpbmRvdyB3YXMgTk9UIGNsb3NlZCBkdWUgZm9sbG93aW5nIGVycm9yOiAnLCBlcnIpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlKHVybCwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGFnbUFjdGlvbignVDQyLkh0bWwuT3BlblVybCcsIHN1Y2Nlc3MsIGVycm9yLCB7IHVybDogdXJsIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRpdGxlKHRpdGxlLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gYWdtQWN0aW9uKCdUNDIuV25kLlNldFdpbmRvd1RpdGxlJywgc3VjY2VzcywgZXJyb3IsIHsgdGl0bGU6IHRpdGxlIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERldGFpbHMoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHdpbmRvd0lkID0gcmVzdWx0V2luZG93LmlkO1xuICAgICAgICBhZ20uaW52b2tlKCdUNDIuV25kLkZpbmRCeUlkJywgeyB3aW5kb3dJZDogcmVzdWx0V2luZG93LmlkIH0sIGNvbnRhaW5lck9iai5nZXRBZ21UYXJnZXQoKSwge30sIHJldHVybmVkRGltZW5zaW9ucywgY2Fubm90UmV0dXJuRGltZW5zaW9ucyk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmV0dXJuZWREaW1lbnNpb25zKHZhbHVlKSB7XG4gICAgICAgICAgICBoZWxwZXJzLmludm9rZUFnbVN1Y2Nlc3NDYWxsYmFjayhzdWNjZXNzLCB2YWx1ZS5yZXR1cm5lZFt3aW5kb3dJZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2Fubm90UmV0dXJuRGltZW5zaW9ucyhlKSB7XG4gICAgICAgICAgICBoZWxwZXJzLmludm9rZUFnbUVycm9yQ2FsbGJhY2soZXJyb3IsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZVJlc2l6ZShkaW1lbnNpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gYWdtQWN0aW9uKCdUNDIuV25kLlJlc2l6ZUFuZE1vdmUnLCBzdWNjZXNzLCBlcnJvciwgZGltZW5zaW9ucylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUYWJCdXR0b24oYnV0dG9uSW5mbywgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgYWRkRnJhbWVCdXR0b24oYnV0dG9uSW5mbywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEZyYW1lQnV0dG9uKGJ1dHRvbkluZm8sIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYnV0dG9uSW5mbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yKCdObyBidXR0b24gaW5mbycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1dHRvbkluZm8uYnV0dG9uSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ05vIGJ1dHRvbklkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnV0dG9uSW5mby5pbWFnZUJhc2U2NCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvcignTm8gaW1hZ2VCYXNlNjQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludm9rZSB0aGUgQUdNIG1ldGhvZFxuICAgICAgICBhZ20uaW52b2tlKCdUNDIuV25kLkFkZEJ1dHRvbicsIHtcbiAgICAgICAgICAgIHdpbmRvd0lkOiByZXN1bHRXaW5kb3cuaWQsXG4gICAgICAgICAgICBidXR0b25JbmZvOiBidXR0b25JbmZvXG4gICAgICAgIH0sIGNvbnRhaW5lck9iai5nZXRBZ21UYXJnZXQoKSwge30sIGJ1dHRvbklzQWRkZWQuYmluZCh0aGlzKSwgYnV0dG9uQ2Fubm90QmVBZGRlZC5iaW5kKHRoaXMpKTtcblxuICAgICAgICBmdW5jdGlvbiBidXR0b25Jc0FkZGVkKCkge1xuICAgICAgICAgICAgdmFyIF9idXR0b25JZCA9IGJ1dHRvbkluZm8uYnV0dG9uSWQ7XG4gICAgICAgICAgICByZXN1bHRXaW5kb3cuYnV0dG9uc1tfYnV0dG9uSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBfYnV0dG9uSWQsXG4gICAgICAgICAgICAgICAgaW5mbzogYnV0dG9uSW5mb1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlbHBlcnMuaW52b2tlQWdtU3VjY2Vzc0NhbGxiYWNrKHN1Y2Nlc3MsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYnV0dG9uQ2Fubm90QmVBZGRlZChlKSB7XG4gICAgICAgICAgICBoZWxwZXJzLmludm9rZUFnbUVycm9yQ2FsbGJhY2soZXJyb3IsIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25UaXRsZUNoYW5nZWQoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0V2luZG93LnRpdGxlKTtcbiAgICAgICAgYWRkQ2FsbGJhY2soJ29uVGl0bGVDaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQXZhaWxhYmxlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChyZXN1bHRXaW5kb3cub3BlbmVkKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRDYWxsYmFjaygnb25BdmFpbGFibGUnLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbG9zZShjYWxsYmFjaykge1xuICAgICAgICBhZGRDYWxsYmFjaygnb25DbG9zZScsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblVybENoYW5nZWQoY2FsbGJhY2spIHtcbiAgICAgICAgYWRkQ2FsbGJhY2soJ29uVXJsQ2hhbmdlZCcsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRhYkJ1dHRvbihjYWxsYmFjaykge1xuICAgICAgICBvbkZyYW1lQnV0dG9uKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkZyYW1lQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZENhbGxiYWNrKCdvbkZyYW1lQnV0dG9uJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFjdGl2YXRlKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBhZ21BY3Rpb24oJ1Q0Mi5XbmQuQWN0aXZhdGUnLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4aW1pemVSZXN0b3JlKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBhZ21BY3Rpb24oJ1Q0Mi5XbmQuTWF4aW1pemVPclJlc3RvcmVEb3duJywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heGltaXplKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBhZ21BY3Rpb24oJ1Q0Mi5XbmQuTWF4aW1pemUnLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdG9yZShzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gYWdtQWN0aW9uKCdUNDIuV25kLlJlc3RvcmUnLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWluaW1pemUoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGFnbUFjdGlvbignVDQyLlduZC5NaW5pbWl6ZScsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsYXBzZShzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gYWdtQWN0aW9uKCdUNDIuV25kLkNvbGxhcHNlJywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRpdGxlQ2hhbmdlZCh0aXRsZSkge1xuICAgICAgICByZXN1bHRXaW5kb3cudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgaGVscGVycy5leGVjQ2FsbGJhY2tzKHJlc3VsdFdpbmRvdy5fY2FsbGJhY2tzLm9uVGl0bGVDaGFuZ2VkLCB0aXRsZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXJsQ2hhbmdlZCh1cmwpIHtcbiAgICAgICAgcmVzdWx0V2luZG93LnVybCA9IHVybDtcbiAgICAgICAgaGVscGVycy5leGVjQ2FsbGJhY2tzKHJlc3VsdFdpbmRvdy5fY2FsbGJhY2tzLm9uVXJsQ2hhbmdlZCwgdXJsKTtcbiAgICB9XG5cbiAgICAvLyBBZGRzIGFuIGFsaWFzIG9mIGFuIEFHTSBtZXRob2QgaW4gdGhlIFdpbmRvdyBwcm90b3R5cGVcbiAgICBmdW5jdGlvbiBhZ21BY3Rpb24oYWN0aW9uLCBzdWNjZXNzLCBlcnJvciwgYXJncykge1xuICAgICAgICAvLyBTdG9wIGlmIHRoZSB3aW5kb3cgaXMgY2xvc2VkXG4gICAgICAgIGlmIChyZXN1bHRXaW5kb3cudXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IGV4ZWN1dGUgYSBjb21tYW5kIG9uIGEgY2xvc2VkIHdpbmRvdy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgd2luZG93IElEIHRvIHRoZSBhcmd1bWVudHNcbiAgICAgICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgICAgIGFyZ3Mud2luZG93SWQgPSByZXN1bHRXaW5kb3cuaWQ7XG5cbiAgICAgICAgLy8gSW52b2tlIHRoZSBBR00gbWV0aG9kXG4gICAgICAgIGFnbS5pbnZva2UoYWN0aW9uLCBhcmdzLCBjb250YWluZXJPYmouZ2V0QWdtVGFyZ2V0KCksIHt9LCBmdWxmaWxsZWQsIGVycm9yKTtcblxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQoKSB7XG4gICAgICAgICAgICBoZWxwZXJzLmludm9rZUFnbVN1Y2Nlc3NDYWxsYmFjayhzdWNjZXNzLCByZXN1bHRXaW5kb3cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0V2luZG93ID0ge1xuICAgICAgICBfaW50ZXJuYWxJZDogaW50ZXJuYWxJZCxcbiAgICAgICAgX2NhbGxiYWNrczoge30sXG5cbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXJPYmoubmFtZSxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgYXBwbGljYXRpb246IGNvbnRhaW5lck9iai5uYW1lICsgJy4nICsgbmFtZSxcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBidXR0b25zOiB7fSxcbiAgICAgICAgd2luZG93U3R5bGVBdHRyaWJ1dGVzOiBzZXRXaW5kb3dTdHlsZUF0dHJpYnV0ZXMod2luZG93U3R5bGVzKSxcblxuICAgICAgICBvbkF2YWlsYWJsZTogb25BdmFpbGFibGUsXG4gICAgICAgIG9uQ2xvc2U6IG9uQ2xvc2UsXG4gICAgICAgIG9uVXJsQ2hhbmdlZDogb25VcmxDaGFuZ2VkLFxuICAgICAgICBvblRpdGxlQ2hhbmdlZDogb25UaXRsZUNoYW5nZWQsXG4gICAgICAgIG9uVGFiQnV0dG9uOiBvblRhYkJ1dHRvbixcbiAgICAgICAgb25GcmFtZUJ1dHRvbjogb25GcmFtZUJ1dHRvbixcblxuICAgICAgICBtYXhpbWl6ZTogbWF4aW1pemUsXG4gICAgICAgIHJlc3RvcmU6IHJlc3RvcmUsXG4gICAgICAgIG1pbmltaXplOiBtaW5pbWl6ZSxcbiAgICAgICAgbWF4aW1pemVSZXN0b3JlOiBtYXhpbWl6ZVJlc3RvcmUsXG4gICAgICAgIGNvbGxhcHNlOiBjb2xsYXBzZSxcbiAgICAgICAgZm9jdXM6IGFjdGl2YXRlLFxuICAgICAgICBvcGVuOiBvcGVuLFxuICAgICAgICBvcGVuZWQ6IG9wZW5lZCxcbiAgICAgICAgZ2V0RGV0YWlsczogZ2V0RGV0YWlscyxcbiAgICAgICAgbW92ZVJlc2l6ZTogbW92ZVJlc2l6ZSxcbiAgICAgICAgc2V0VGl0bGU6IHNldFRpdGxlLFxuICAgICAgICBzZXRTdHlsZTogc2V0U3R5bGUsXG4gICAgICAgIG5hdmlnYXRlOiBuYXZpZ2F0ZSxcbiAgICAgICAgYWRkVGFiQnV0dG9uOiBhZGRUYWJCdXR0b24sXG4gICAgICAgIGFkZEZyYW1lQnV0dG9uIDogYWRkRnJhbWVCdXR0b24sXG4gICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgaGFuZGxlV2luZG93Q2xvc2U6IGhhbmRsZVdpbmRvd0Nsb3NlLFxuICAgICAgICB0aXRsZUNoYW5nZWQ6IHRpdGxlQ2hhbmdlZCxcbiAgICAgICAgdXJsQ2hhbmdlZDogdXJsQ2hhbmdlZCxcblxuICAgICAgICAvLyBkZXByZWNhdGVzXG4gICAgICAgIHNldF9zdHlsZTogZGVwcmVjYXRlKHNldFN0eWxlLCAnd2luZG93LnNldF9zdHlsZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIHdpbmRvdy5zZXRTdHlsZSgpIGluc3RlYWQnKSxcbiAgICAgICAgb25fYXZhaWxhYmxlOiBkZXByZWNhdGUob25BdmFpbGFibGUsICd3aW5kb3cub25fYXZhaWxhYmxlKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93Lm9uQXZhaWxhYmxlKCkgaW5zdGVhZCcpLFxuICAgICAgICBvbl9jbG9zZTogZGVwcmVjYXRlKG9uQ2xvc2UsICd3aW5kb3cub25fY2xvc2UoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cub25DbG9zZSgpIGluc3RlYWQnKSxcbiAgICAgICAgb25fdXJsX2NoYW5nZWQ6IGRlcHJlY2F0ZShvblVybENoYW5nZWQsICd3aW5kb3cub25fdXJsX2NoYW5nZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cub25VcmxDaGFuZ2VkKCkgaW5zdGVhZCcpLFxuICAgICAgICBzZXRfdGl0bGU6IGRlcHJlY2F0ZShzZXRUaXRsZSwgJ3dpbmRvdy5zZXRfdGl0bGUoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cuc2V0VGl0bGUoKSBpbnN0ZWFkJyksXG4gICAgICAgIGdldF9kZXRhaWxzOiBkZXByZWNhdGUoZ2V0RGV0YWlscywgJ3dpbmRvdy5nZXRfZGV0YWlscygpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIHdpbmRvdy5nZXREZXRhaWxzKCkgaW5zdGVhZCcpLFxuICAgICAgICBtb3ZlX3Jlc2l6ZTogZGVwcmVjYXRlKG1vdmVSZXNpemUsICd3aW5kb3cubW92ZV9yZXNpemUoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cubW92ZVJlc2l6ZSgpIGluc3RlYWQnKSxcbiAgICAgICAgbWF4aW1pemVfcmVzdG9yZTogZGVwcmVjYXRlKG1heGltaXplUmVzdG9yZSwgJ3dpbmRvdy5tYXhpbWl6ZV9yZXN0b3JlKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93Lm1heGltaXplUmVzdG9yZSgpIGluc3RlYWQnKVxuXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0V2luZG93O1xufVxuIiwidmFyIFBhY2thZ2VKc29uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG52YXIgZGVwcmVjYXRlID0gcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKTtcbnZhciB3aW5kb3dGYWN0b3J5ID0gcmVxdWlyZSgnLi93aW5kb3cnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbnZhciB3aW5kb3dzID0gZnVuY3Rpb24gKGFnbSkge1xuICAgICd1c2Ugc3RyaWN0J1xuXG4gICAgd2luZG93RmFjdG9yeS5pbml0KGFnbSk7XG5cbiAgICBpZiAoZ2xvYmFsLmh0bWxDb250YWluZXIgJiYgYWdtLnN1YnNjcmliZSkge1xuICAgICAgICAvLyBPbmx5IGNvbnRhaW5lci5cbiAgICAgICAgYWdtLnNlcnZlck1ldGhvZEFkZGVkKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgICAgICBpZiAoKHJlc3Auc2VydmVyLmFwcGxpY2F0aW9uLmluZGV4T2YoJ0h0bWxDb250YWluZXIuJykgIT09IC0xICYmIHJlc3Auc2VydmVyLmFwcGxpY2F0aW9uLmluZGV4T2YoJy5JbnRlcm5hbCcpICE9PSAtMSkgJiYgcmVzcC5tZXRob2QubmFtZS5pbmRleE9mKCdUNDIuV25kLldpbmRvd1N0YXRlQ2hhbmdlZCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFnbS5zdWJzY3JpYmUoJ1Q0Mi5XbmQuV2luZG93U3RhdGVDaGFuZ2VkJywgeyB0YXJnZXQ6ICdhbGwnIH0pLnRoZW4oZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25EYXRhKGZ1bmN0aW9uIChzdHJlYW1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVXaW5kb3coc3RyZWFtRGF0YS5kYXRhLCBtYXRjaENvbnRhaW5lcihzdHJlYW1EYXRhLnNlcnZlci5hcHBsaWNhdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0YWNoIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHJlYW0ub24oXCJlbmRcIiwgaGFuZGxlU3RyZWFtQ2xvc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyZWFtLm9uKFwiY2xvc2VcIiwgaGFuZGxlU3RyZWFtQ2xvc2VkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWdtLnNlcnZlckFkZGVkKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXIuYXBwbGljYXRpb24uaW5kZXhPZignSHRtbENvbnRhaW5lci4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gY29uc3RydWN0Q29udGFpbmVyT2JqZWN0KHNlcnZlci5hcHBsaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgYWRkQ29udGFpbmVyKGNvbnRhaW5lcnMsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgZ2V0QWxsV2luZG93c09uQWRkZWRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgd2luZG93cyB0aGF0IGFyZSB0cmFja2VkIGJ5IElEIGFuZCByZWNlaXZlIHVwZGF0ZXNcbiAgICB2YXIgd2luZG93cyA9IHt9O1xuICAgIHZhciBjb250YWluZXJzID0gW107XG5cbiAgICBpZiAoZ2xvYmFsLmh0bWxDb250YWluZXIpIHtcbiAgICAgICAgdmFyIG15Q29udGFpbmVyID0gY29uc3RydWN0Q29udGFpbmVyT2JqZWN0KGh0bWxDb250YWluZXIuY29udGFpbmVyTmFtZSk7XG4gICAgICAgIGFkZENvbnRhaW5lcihjb250YWluZXJzLCBteUNvbnRhaW5lcik7XG4gICAgICAgIGNyZWF0ZVdpbmRvdyhodG1sQ29udGFpbmVyLmJyb3dzZXJXaW5kb3dOYW1lLCBteUNvbnRhaW5lciwgd2luZG93LmxvY2F0aW9uLmhyZWYsIGh0bWxDb250YWluZXIud2luZG93SWQsIGh0bWxDb250YWluZXIud2luZG93U3R5bGVBdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbnN1cmVDb250YWluZXJBdmFpbGlhYmxlKGNvbnRhaW5lciwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb250YWluZXJGb3VuZCA9IG1hdGNoQ29udGFpbmVyKGNvbnRhaW5lcilcbiAgICAgICAgaWYgKGNvbnRhaW5lckZvdW5kKSB7XG4gICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soY29udGFpbmVyRm91bmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRm91bmQgPSBtYXRjaENvbnRhaW5lcihjb250YWluZXIpXG4gICAgICAgICAgICBpZiAoY29udGFpbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soY29udGFpbmVyRm91bmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoQ29udGFpbmVyKGNvbnRhaW5lcklkZW50aWZpZXIpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXJJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGFpbmVycy5maWx0ZXIoZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5zaG9ydE5hbWUgPT09IGNvbnRhaW5lcklkZW50aWZpZXIgfHxcbiAgICAgICAgICAgICAgICBjb250YWluZXIubmFtZSA9PT0gY29udGFpbmVySWRlbnRpZmllciB8fFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hZ21BcHBsaWNhdGlvbiA9PT0gY29udGFpbmVySWRlbnRpZmllcjtcbiAgICAgICAgfSlbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3RydWN0Q29udGFpbmVyT2JqZWN0KGNvbnRhaW5lcklkZW50aXR5KSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGNvbnRhaW5lcklkZW50aXR5LnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZSgwLCAwLCAnSHRtbENvbnRhaW5lcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFnbUFwcGxpY2F0aW9uID0gcGFydHNbMF0gKyAnLicgKyBwYXJ0c1sxXSArICcuJyArIHBhcnRzWzJdO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaG9ydE5hbWU6IHBhcnRzWzJdLFxuICAgICAgICAgICAgbmFtZTogcGFydHNbMV0gKyAnLicgKyBwYXJ0c1syXSxcbiAgICAgICAgICAgIGFnbUFwcGxpY2F0aW9uOiBhZ21BcHBsaWNhdGlvbixcbiAgICAgICAgICAgIGdldEFnbVRhcmdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGFwcGxpY2F0aW9uOiBhZ21BcHBsaWNhdGlvbiB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ29udGFpbmVyKGNvbnRhaW5lcnMsIGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoY29udGFpbmVycy5maWx0ZXIoZnVuY3Rpb24oY29udCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnQuc2hvcnROYW1lID09PSBjb250YWluZXIuc2hvcnROYW1lICYmXG4gICAgICAgICAgICBjb250Lm5hbWUgPT09IGNvbnRhaW5lci5uYW1lICYmXG4gICAgICAgICAgICBjb250LmFnbUFwcGxpY2F0aW9uID09PSBjb250YWluZXIuYWdtQXBwbGljYXRpb25cbiAgICAgICAgfSkubGVuZ3RoICA9PT0gMCkge1xuICAgICAgICAgICAgY29udGFpbmVycy5wdXNoKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250YWluZXJOYW1lKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3MuY29udGFpbmVyc0NhbGxiYWNrc1tjb250YWluZXJOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tzLmFsbENvbnRhaW5lcnNDYWxsYmFja3MuY29uY2F0KGNhbGxiYWNrcy5jb250YWluZXJzQ2FsbGJhY2tzW2NvbnRhaW5lck5hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFja3MuYWxsQ29udGFpbmVyc0NhbGxiYWNrcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1dENhbGxiYWNrcyhnbG9iYWxDYWxsYmFja3MsIGNhbGxiYWNrLCBjb250YWluZXIpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbG9iYWxDYWxsYmFja3MuYWxsQ29udGFpbmVyc0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWxDYWxsYmFja3MuY29udGFpbmVyc0NhbGxiYWNrc1tjb250YWluZXJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxDYWxsYmFja3MuY29udGFpbmVyc0NhbGxiYWNrc1tjb250YWluZXJdID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsQ2FsbGJhY2tzLmNvbnRhaW5lcnNDYWxsYmFja3NbY29udGFpbmVyXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpbmRvdyh3aW5kb3dJbmZvLCBjb250YWluZXJOYW1lKSB7XG4gICAgICAgIHZhciB0aGVXaW5kb3cgPSBnZXRXaW5kb3cod2luZG93SW5mby53aW5kb3dOYW1lLCBjb250YWluZXJOYW1lLCB3aW5kb3dJbmZvLnVybCwgd2luZG93SW5mby53aW5kb3dJZCwgd2luZG93SW5mby53aW5kb3dTdHlsZUF0dHJpYnV0ZXMsIHdpbmRvd0luZm8ud2luZG93VGl0bGUpO1xuXG4gICAgICAgIGlmICh0aGVXaW5kb3cuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhlV2luZG93LmlkID0gd2luZG93SW5mby53aW5kb3dJZDtcbiAgICAgICAgICAgIGhlbHBlcnMuZXhlY0NhbGxiYWNrcyh0aGVXaW5kb3cuX2NhbGxiYWNrcy5vbkF2YWlsYWJsZSwgdGhlV2luZG93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3dJbmZvLnN0YXRlID09PSAnVGl0bGVDaGFuZ2VkJykge1xuICAgICAgICAgICAgdGhlV2luZG93LnRpdGxlQ2hhbmdlZCh3aW5kb3dJbmZvLndpbmRvd1RpdGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3dJbmZvLnN0YXRlID09PSAnVXJsQ2hhbmdlZCcpIHtcbiAgICAgICAgICAgIHRoZVdpbmRvdy51cmxDaGFuZ2VkKHdpbmRvd0luZm8udXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3dJbmZvLnN0YXRlID09PSAnQ3JlYXRlZCcpIHtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgZ2xvYmFsIFwid2luZG93X2FkZGVkXCIgY2FsbGJhY2tzXG4gICAgICAgICAgICBoZWxwZXJzLmV4ZWNDYWxsYmFja3MoZ2V0Q2FsbGJhY2tzKHdpbmRvd0FkZGVkQ2FsbGJhY2tzLCBjb250YWluZXJOYW1lKSwgdGhlV2luZG93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFyIHRoZSB3aW5kb3cgb24gY2xvc2UgZXZlbnRcbiAgICAgICAgaWYgKHdpbmRvd0luZm8uc3RhdGUgPT09ICdDbG9zZWQnKSB7XG4gICAgICAgICAgICAvLyBFeGVjdXRlIGdsb2JhbCBcIndpbmRvd19yZW1vdmVkXCIgY2FsbGJhY2tzXG4gICAgICAgICAgICBoZWxwZXJzLmV4ZWNDYWxsYmFja3MoZ2V0Q2FsbGJhY2tzKHdpbmRvd1JlbW92ZWRDYWxsYmFja3MsIGNvbnRhaW5lck5hbWUpLCB0aGVXaW5kb3cpO1xuXG4gICAgICAgICAgICBkZWxldGUgd2luZG93c1t0aGVXaW5kb3cuX2ludGVybmFsSWRdO1xuXG4gICAgICAgICAgICB0aGVXaW5kb3cuaGFuZGxlV2luZG93Q2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1dHRvbkNsaWNrZWRcbiAgICAgICAgaWYgKHdpbmRvd0luZm8uc3RhdGUgPT09ICdCdXR0b25DbGlja2VkJykge1xuICAgICAgICAgICAgLy8gRXhlY3V0ZSBnbG9iYWwgXCJ3aW5kb3dfYWRkZWRcIiBjYWxsYmFja3NcbiAgICAgICAgICAgIGlmICh0aGVXaW5kb3cuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKHRoZVdpbmRvdy5idXR0b25zKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhlV2luZG93Ll9jYWxsYmFja3Mub25GcmFtZUJ1dHRvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGVscGVycy5leGVjQ2FsbGJhY2tzKHRoZVdpbmRvdy5fY2FsbGJhY2tzLm9uRnJhbWVCdXR0b24sIHdpbmRvd0luZm8uYnV0dG9uSWQsIHRoZVdpbmRvdy5idXR0b25zW3dpbmRvd0luZm8uYnV0dG9uSWRdLmluZm8pO1xuXG4gICAgICAgICAgICAgICAgdGhlV2luZG93Ll9jYWxsYmFja3Mub25GcmFtZUJ1dHRvbi5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh3aW5kb3dJbmZvLmJ1dHRvbklkLCB0aGVXaW5kb3cuYnV0dG9uc1t3aW5kb3dJbmZvLmJ1dHRvbklkXS5pbmZvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGRpY3Rpb25hcnkgdG8gc3RvcmUgdGhlIGNhbGxiYWNrcyBmb3IgdGhlIG1ldGhvZCBcIndpbmRvd19hZGRlZFwiLlxuICAgIHZhciB3aW5kb3dBZGRlZENhbGxiYWNrcyA9IHtcbiAgICAgICAgY29udGFpbmVyc0NhbGxiYWNrczoge30sXG4gICAgICAgIGFsbENvbnRhaW5lcnNDYWxsYmFja3M6IFtdXG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBhIGRpY3Rpb25hcnkgdG8gc3RvcmUgdGhlIGNhbGxiYWNrcyBmb3IgdGhlIG1ldGhvZCBcIndpbmRvd19yZW1vdmVkXCIuXG4gICAgdmFyIHdpbmRvd1JlbW92ZWRDYWxsYmFja3MgPSB7XG4gICAgICAgIGNvbnRhaW5lcnNDYWxsYmFja3M6IHt9LFxuICAgICAgICBhbGxDb250YWluZXJzQ2FsbGJhY2tzOiBbXVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVXaW5kb3dJZChuYW1lLCBjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5hZ21BcHBsaWNhdGlvbiArICcuJyArIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlV2luZG93KG5hbWUsIGNvbnRhaW5lciwgdXJsLCBpZCwgd2luZG93U3R5bGVzLCB0aXRsZSkge1xuICAgICAgICB2YXIgd2luZG93SWQgPSBjcmVhdGVXaW5kb3dJZChuYW1lLCBjb250YWluZXIpO1xuXG4gICAgICAgIHZhciB3aW5kb3dPYmogPSB3aW5kb3dGYWN0b3J5LmNyZWF0ZShpZCwgd2luZG93SWQsIG5hbWUsIGNvbnRhaW5lciwgdXJsLCB0aXRsZSwgd2luZG93U3R5bGVzKTtcblxuICAgICAgICB3aW5kb3dzW3dpbmRvd0lkXSA9IHdpbmRvd09iajtcblxuICAgICAgICByZXR1cm4gd2luZG93T2JqO1xuICAgIH1cblxuICAgIC8vIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRvIHJldHVybiB0aGUgd2luZG93IHdpdGggdGhlIHNhbWUgVVJMIGFuZCBJRFxuICAgIGZ1bmN0aW9uIGdldFdpbmRvdyhuYW1lLCBjb250YWluZXIsIHVybCwgaWQsIHdpbmRvd1N0eWxlcywgdGl0bGUpIHtcblxuICAgICAgICB2YXIgd2luZG93SWQgPSBjcmVhdGVXaW5kb3dJZChuYW1lLCBjb250YWluZXIpO1xuXG4gICAgICAgIHZhciBleGlzdGluZ1dpbmRvdyA9IHdpbmRvd3Nbd2luZG93SWRdO1xuXG4gICAgICAgIGlmIChleGlzdGluZ1dpbmRvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdXaW5kb3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbml0IG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVdpbmRvdyhuYW1lLCBjb250YWluZXIsIHVybCwgaWQsIHdpbmRvd1N0eWxlcywgdGl0bGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXkoKSB7XG4gICAgICAgIHZhciBoO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGggPSB3aW5kb3cuaHRtbENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgY3VycmVudCB3aW5kb3cgKHRoZSBvbncgaW4gd2hpY2ggeW91ciBhcHBsaWNhdGlvbiBjdXJyZW50bHkgcmVzaWRlcykuXG4gICAgICAgIGlmIChoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0V2luZG93KGguYnJvd3NlcldpbmRvd05hbWUsIG1hdGNoQ29udGFpbmVyKGguY29udGFpbmVyTmFtZSksIHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBoLndpbmRvd0lkLCBoLndpbmRvd1N0eWxlQXR0cmlidXRlcywgZG9jdW1lbnQudGl0bGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3BlbihuYW1lLCB1cmwsIGNvbnRhaW5lciwgZGltZW5zaW9ucywgc3R5bGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCAnSW50ZXJuYWwnO1xuICAgICAgICBlbnN1cmVDb250YWluZXJBdmFpbGlhYmxlKGNvbnRhaW5lciwgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvdyhuYW1lLCBjb250YWluZXIsIHVybCwgdW5kZWZpbmVkLCBzdHlsZSlcbiAgICAgICAgICAgICAgICAgICAgLm9wZW4oZGltZW5zaW9ucywgc3R5bGUsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXJyb3IoJ2NhbiBub3QgZmluZCBjb250YWluZXInKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kIChuYW1lLCBjb250YWluZXIsIHN1Y2Nlc3MpIHtcblxuICAgICAgICBjb250YWluZXIgPSBtYXRjaENvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgICAgIHZhciB3aW5kb3dzRm9yTGlzdGluZyA9IE9iamVjdC5rZXlzKHdpbmRvd3MpLnJlZHVjZShmdW5jdGlvbiAobWVtbywgd2luSWQpIHtcbiAgICAgICAgICAgIHZhciB3aW5kb3cgPSB3aW5kb3dzW3dpbklkXTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29udGFpbmVyID09PSBjb250YWluZXIubmFtZSAmJiB3aW5kb3cubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIG1lbW8ucHVzaCh3aW5kb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3dzRm9yTGlzdGluZ1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1Y2Nlc3Mod2luZG93c0Zvckxpc3RpbmdbMF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3QgKGNvbnRhaW5lciwgc3VjY2Vzcykge1xuXG4gICAgICAgIGNvbnRhaW5lciA9IG1hdGNoQ29udGFpbmVyKGNvbnRhaW5lcik7XG5cbiAgICAgICAgdmFyIHdpbmRvd3NGb3JMaXN0aW5nID0gT2JqZWN0LmtleXMod2luZG93cykucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCB3aW5JZCkge1xuICAgICAgICAgICAgdmFyIHdpbmRvdyA9IHdpbmRvd3Nbd2luSWRdO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb250YWluZXIgPT09IGNvbnRhaW5lci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgbWVtby5wdXNoKHdpbmRvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICByZXR1cm4gd2luZG93c0Zvckxpc3Rpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBzdWNjZXNzKHdpbmRvd3NGb3JMaXN0aW5nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kb3dBZGRlZChjYWxsYmFjaywgY29udGFpbmVyKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgY3VycmVudCBjYWxsYmFjayB0byB0aGUgY2FsbGJhY2sgZGljdGlvbmFyeS5cbiAgICAgICAgcHV0Q2FsbGJhY2tzKHdpbmRvd0FkZGVkQ2FsbGJhY2tzLCBjYWxsYmFjaywgY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kb3dSZW1vdmVkKGNhbGxiYWNrLCBjb250YWluZXIpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBjdXJyZW50IGNhbGxiYWNrIHRvIHRoZSBjYWxsYmFjayBkaWN0aW9uYXJ5LlxuICAgICAgICBwdXRDYWxsYmFja3Mod2luZG93UmVtb3ZlZENhbGxiYWNrcywgY2FsbGJhY2ssIGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbmVyQWRkZWQoY2FsbGJhY2spIHtcbiAgICAgICAgYWdtLnNlcnZlckFkZGVkKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXIuYXBwbGljYXRpb24uaW5kZXhPZignSHRtbENvbnRhaW5lci4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXJzLmludm9rZUFnbVN1Y2Nlc3NDYWxsYmFjayhjYWxsYmFjaywgc2VydmVyLmFwcGxpY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbmVyUmVtb3ZlZChjYWxsYmFjaykge1xuICAgICAgICBhZ20uc2VydmVyUmVtb3ZlZChmdW5jdGlvbiAoc2VydmVyKSB7XG4gICAgICAgICAgICBpZiAoc2VydmVyLmFwcGxpY2F0aW9uLmluZGV4T2YoJ0h0bWxDb250YWluZXIuJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaGVscGVycy5pbnZva2VBZ21TdWNjZXNzQ2FsbGJhY2soY2FsbGJhY2ssIHNlcnZlci5hcHBsaWNhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEFsbFdpbmRvd3NPbkFkZGVkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBhZ20uaW52b2tlKCdUNDIuV25kLkxpc3RXaW5kb3dzJywge30sICdiZXN0Jywge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobGlzdE9mV2luZG93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGxpc3RPZldpbmRvd3MucmV0dXJuZWQpLmZvckVhY2goZnVuY3Rpb24gKGV4aXN0aW5nV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aW5kb3dJbmZvID0gbGlzdE9mV2luZG93cy5yZXR1cm5lZFtleGlzdGluZ1dpbmRvd107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JpbmcgYWxsIHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlV2luZG93ID0gZ2V0V2luZG93KHdpbmRvd0luZm8ud2luZG93TmFtZSwgY29udGFpbmVyLCB3aW5kb3dJbmZvLnVybCwgd2luZG93SW5mby53aW5kb3dJZCwgd2luZG93SW5mby53aW5kb3dTdHlsZUF0dHJpYnV0ZXMsIHdpbmRvd0luZm8ud2luZG93VGl0bGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcnMuZXhlY0NhbGxiYWNrcyhnZXRDYWxsYmFja3Mod2luZG93QWRkZWRDYWxsYmFja3MsIGNvbnRhaW5lci5uYW1lKSwgdGhlV2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciBjYWxsYmFjayBpZiB0aGUgd2luZG93cyBjYW5ub3QgYmUgbGlzdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5hYmxlIHRvIGxvYWQgZXhpc3Rpbmcgd2luZG93cy4gJyArIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIFRoZSBBUEkgaXRzZWxmXG4gICAgdmFyIGFwaSA9IHtcbiAgICAgICAgbXk6IG15LFxuICAgICAgICBvcGVuOiBvcGVuLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBsaXN0OiBsaXN0LFxuICAgICAgICB3aW5kb3dBZGRlZDogd2luZG93QWRkZWQsXG4gICAgICAgIHdpbmRvd1JlbW92ZWQ6IHdpbmRvd1JlbW92ZWQsXG4gICAgICAgIGNvbnRhaW5lckFkZGVkOiBjb250YWluZXJBZGRlZCxcbiAgICAgICAgY29udGFpbmVyUmVtb3ZlZDogY29udGFpbmVyUmVtb3ZlZCxcblxuICAgICAgICBfZnJvbV9ldmVudDogZnVuY3Rpb24obmFtZSwgY29udGFpbmVyLCB1cmwsIGlkLCB3aW5kb3dTdHlsZXMsIHRpdGxlKSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSBtYXRjaENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvdyhuYW1lLCBjb250YWluZXIsIHVybCwgaWQsIHdpbmRvd1N0eWxlcywgdGl0bGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGRlcHJlY2F0ZXNcbiAgICBhcGkud2luZG93X2FkZGVkID0gZGVwcmVjYXRlKGFwaS53aW5kb3dBZGRlZCwgJ3dpbmRvdy53aW5kb3dfYWRkZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cud2luZG93QWRkZWQoKSBpbnN0ZWFkJyk7XG4gICAgYXBpLndpbmRvd19yZW1vdmVkID0gZGVwcmVjYXRlKGFwaS53aW5kb3dSZW1vdmVkLCAnd2luZG93LndpbmRvd19yZW1vdmVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93LndpbmRvd1JlbW92ZWQoKSBpbnN0ZWFkJyk7XG4gICAgYXBpLmNvbnRhaW5lcl9hZGRlZCA9IGRlcHJlY2F0ZShhcGkuY29udGFpbmVyQWRkZWQsICd3aW5kb3cuY29udGFpbmVyX2FkZGVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93LmNvbnRhaW5lckFkZGVkKCkgaW5zdGVhZCcpO1xuICAgIGFwaS5jb250YWluZXJfcmVtb3ZlZCA9IGRlcHJlY2F0ZShhcGkuY29udGFpbmVyUmVtb3ZlZCwgJ3dpbmRvdy5jb250YWluZXJfcmVtb3ZlZCgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIHdpbmRvdy5jb250YWluZXJSZW1vdmVkKCkgaW5zdGVhZCcpO1xuXG4gICAgYXBpLnZlcnNpb24gPSBQYWNrYWdlSnNvbi52ZXJzaW9uO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy50aWNrNDIgPSB3aW5kb3cudGljazQyIHx8IHt9O1xuICAgIHdpbmRvdy50aWNrNDIud2luZG93cyA9IHdpbmRvd3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luZG93cztcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAgXCJ0aWNrNDItd2luZG93c0AyLjIuOFwiLFxuICAgICAgXCJDOlxcXFx3b3JrXFxcXHN0YXNoXFxcXEdMVUUtZGV2XFxcXGRldlxcXFxqcy1nbHVlXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJ0aWNrNDItd2luZG93c0AyLjIuOFwiLFxuICBcIl9pZFwiOiBcInRpY2s0Mi13aW5kb3dzQDIuMi44XCIsXG4gIFwiX2luQ2FjaGVcIjogdHJ1ZSxcbiAgXCJfaW5zdGFsbGFibGVcIjogdHJ1ZSxcbiAgXCJfbG9jYXRpb25cIjogXCIvdGljazQyLXdpbmRvd3NcIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCI2LjMuMFwiLFxuICBcIl9ucG1Vc2VyXCI6IHt9LFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMy44LjVcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcInRpY2s0Mi13aW5kb3dzXCIsXG4gICAgXCJyYXdcIjogXCJ0aWNrNDItd2luZG93c0AyLjIuOFwiLFxuICAgIFwicmF3U3BlY1wiOiBcIjIuMi44XCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcIjIuMi44XCIsXG4gICAgXCJ0eXBlXCI6IFwidmVyc2lvblwiXG4gIH0sXG4gIFwiX3JlcXVpcmVkQnlcIjogW1xuICAgIFwiL1wiXG4gIF0sXG4gIFwiX3NoYXN1bVwiOiBcImI1NGYwYzAzZWFlMjEyZDg4YmVkYmMzMmM3OGYxMjAyOGZiZTlhODNcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwidGljazQyLXdpbmRvd3NAMi4yLjhcIixcbiAgXCJfd2hlcmVcIjogXCJDOlxcXFx3b3JrXFxcXHN0YXNoXFxcXEdMVUUtZGV2XFxcXGRldlxcXFxqcy1nbHVlXCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJUaWNrNDJcIlxuICB9LFxuICBcImJpblwiOiB7XG4gICAgXCJidWlsZFwiOiBcIi4vYmluL2J1aWxkLmpzXCIsXG4gICAgXCJjbGVhblwiOiBcIi4vYmluL2NsZWFuLmpzXCIsXG4gICAgXCJmaWxlLXZlcnNpb25pZnlcIjogXCIuL2Jpbi9maWxlLXZlcnNpb25pZnkuanNcIixcbiAgICBcIm1pbmlmeVwiOiBcIi4vYmluL21pbmlmeS5qc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImVzNi1wcm9taXNlXCI6IFwiXjMuMC4yXCIsXG4gICAgXCJ1dGlsLWRlcHJlY2F0ZVwiOiBcIl4xLjAuMlwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIHdpbmRvd2luZyBBUEkgZm9yIHRoZSBUaWNrNDIgSFRNTCBDb250YWluZXJcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmxhbmtldFwiOiBcIl4xLjEuNlwiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIl4xMy4wLjBcIixcbiAgICBcImJyb3dzZXJpZnktcmVwbGFjaWZ5XCI6IFwiXjAuMC40XCIsXG4gICAgXCJicm93c2VyaWZ5LXZlcnNpb25pZnlcIjogXCJeMS4wLjRcIixcbiAgICBcImVzbGludFwiOiBcIl4zLjEuMVwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy1zdGFuZGFyZFwiOiBcIl41LjMuNVwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy10aWNrNDJcIjogXCJeMS4wLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tcHJvbWlzZVwiOiBcIl4yLjAuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1zdGFuZGFyZFwiOiBcIl4yLjAuMFwiLFxuICAgIFwiZnNcIjogXCIwLjAuMlwiLFxuICAgIFwianNjc1wiOiBcIl4zLjAuN1wiLFxuICAgIFwianNkb21cIjogXCJeOC4xLjBcIixcbiAgICBcImpzaGludFwiOiBcIl4yLjkuMVwiLFxuICAgIFwibWluaWZ5aWZ5XCI6IFwiXjcuMy4yXCIsXG4gICAgXCJvbmNoYW5nZVwiOiBcIl4yLjEuMlwiLFxuICAgIFwicGhhbnRvbWpzXCI6IFwiXjEuOS4xMlwiLFxuICAgIFwicXVuaXRqc1wiOiBcIl4xLjE1LjBcIixcbiAgICBcInNoZWxsanNcIjogXCJeMC42LjBcIlxuICB9LFxuICBcImRpcmVjdG9yaWVzXCI6IHtcbiAgICBcInRlc3RcIjogXCJ0ZXN0c1wiXG4gIH0sXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCJiNTRmMGMwM2VhZTIxMmQ4OGJlZGJjMzJjNzhmMTIwMjhmYmU5YTgzXCIsXG4gICAgXCJ0YXJiYWxsXCI6IFwiaHR0cDovLzE5Mi4xNjguMC4yMzQ6NDg3My90aWNrNDItd2luZG93cy8tL3RpY2s0Mi13aW5kb3dzLTIuMi44LnRnelwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcIjQ5NWU5OTE3N2NlMmU4NjA2NzYyNzE0Mjc2MzQ1Y2FmMzliNzIxZmRcIixcbiAgXCJsaWNlbnNlXCI6IFwiSVNDXCIsXG4gIFwibWFpblwiOiBcImxpYnJhcnkvd2luZG93cy5qc1wiLFxuICBcIm5hbWVcIjogXCJ0aWNrNDItd2luZG93c1wiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vc3Rhc2gudGljazQyLmNvbTo4NDQzL3NjbS9vZmd3L2pzLXdpbmRvd3MuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwibnBtIHJ1biBlc2xpbnQgJiYgbm9kZSBiaW4vY2xlYW4uanMgJiYgbm9kZSBiaW4vYnVpbGQuanMgJiYgbm9kZSBiaW4vbWluaWZ5ICYmIG5vZGUgYmluL2ZpbGUtdmVyc2lvbmlmeVwiLFxuICAgIFwiZXNsaW50XCI6IFwiZXNsaW50IGxpYnJhcnlcIixcbiAgICBcImVzbGludDpmaXhcIjogXCJlc2xpbnQgbGlicmFyeSAtLWZpeFwiLFxuICAgIFwicHJlcHVibGlzaFwiOiBcIm5wbSB1cGRhdGUgJiBucG0gcnVuIGJ1aWxkXCIsXG4gICAgXCJ0ZXN0XCI6IFwibnBtIHJ1biBlc2xpbnQgJiYgbW9jaGEgLS1yZXF1aXJlIC4vdGVzdC90ZXN0X2hlbHBlciBcXFwidGVzdC8qKi8qLmpzXFxcIlwiLFxuICAgIFwid2F0Y2hcIjogXCJvbmNoYW5nZSBcXFwiLi9saWJyYXJ5LyouanNcXFwiIC1pdiAtZSBcXFwiLi9iaW5cXFwiIC0tIG5wbSBydW4gYnVpbGRcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIyLjIuOFwiXG59XG4iLCIvKiFcbkNvcHlyaWdodCAoQykgMjAxNSBieSBXZWJSZWZsZWN0aW9uXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZShmaW5kLCByZXBsYWNlcik7XG59XG5cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZShwbHVzLCAnICcpKTtcbn1cblxuZnVuY3Rpb24gVVJMU2VhcmNoUGFyYW1zKHF1ZXJ5KSB7XG4gIHRoaXNbc2VjcmV0XSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghcXVlcnkpIHJldHVybjtcbiAgZm9yICh2YXJcbiAgICBpbmRleCwgdmFsdWUsXG4gICAgcGFpcnMgPSAocXVlcnkgfHwgJycpLnNwbGl0KCcmJyksXG4gICAgaSA9IDAsXG4gICAgbGVuZ3RoID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKytcbiAgKSB7XG4gICAgdmFsdWUgPSBwYWlyc1tpXTtcbiAgICBpbmRleCA9IHZhbHVlLmluZGV4T2YoJz0nKTtcbiAgICBpZiAoLTEgPCBpbmRleCkge1xuICAgICAgdGhpcy5hcHBlbmQoXG4gICAgICAgIGRlY29kZSh2YWx1ZS5zbGljZSgwLCBpbmRleCkpLFxuICAgICAgICBkZWNvZGUodmFsdWUuc2xpY2UoaW5kZXggKyAxKSlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhclxuICBVUkxTZWFyY2hQYXJhbXNQcm90byA9IFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUsXG4gIGZpbmQgPSAvWyEnXFwoXFwpfl18JTIwfCUwMC9nLFxuICBwbHVzID0gL1xcKy9nLFxuICByZXBsYWNlID0ge1xuICAgICchJzogJyUyMScsXG4gICAgXCInXCI6ICclMjcnLFxuICAgICcoJzogJyUyOCcsXG4gICAgJyknOiAnJTI5JyxcbiAgICAnfic6ICclN0UnLFxuICAgICclMjAnOiAnKycsXG4gICAgJyUwMCc6ICdcXHgwMCdcbiAgfSxcbiAgcmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gcmVwbGFjZVttYXRjaF07XG4gIH0sXG4gIGl0ZXJhYmxlID0gaXNJdGVyYWJsZSgpLFxuICBzZWNyZXQgPSAnX19VUkxTZWFyY2hQYXJhbXNfXzonICsgTWF0aC5yYW5kb20oKVxuO1xuXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKCkge1xuICB0cnkge1xuICAgIHJldHVybiAhIVN5bWJvbC5pdGVyYXRvcjtcbiAgfSBjYXRjaChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5VUkxTZWFyY2hQYXJhbXNQcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGRpY3QgPSB0aGlzW3NlY3JldF07XG4gIGlmIChuYW1lIGluIGRpY3QpIHtcbiAgICBkaWN0W25hbWVdLnB1c2goJycgKyB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGljdFtuYW1lXSA9IFsnJyArIHZhbHVlXTtcbiAgfVxufTtcblxuVVJMU2VhcmNoUGFyYW1zUHJvdG8uZGVsZXRlID0gZnVuY3Rpb24gZGVsKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXNbc2VjcmV0XVtuYW1lXTtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gIHZhciBkaWN0ID0gdGhpc1tzZWNyZXRdO1xuICByZXR1cm4gbmFtZSBpbiBkaWN0ID8gZGljdFtuYW1lXVswXSA6IG51bGw7XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNQcm90by5nZXRBbGwgPSBmdW5jdGlvbiBnZXRBbGwobmFtZSkge1xuICB2YXIgZGljdCA9IHRoaXNbc2VjcmV0XTtcbiAgcmV0dXJuIG5hbWUgaW4gZGljdCA/IGRpY3RbbmFtZV0uc2xpY2UoMCkgOiBbXTtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLmhhcyA9IGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gIHJldHVybiBuYW1lIGluIHRoaXNbc2VjcmV0XTtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICB0aGlzW3NlY3JldF1bbmFtZV0gPSBbJycgKyB2YWx1ZV07XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNQcm90by5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICB2YXIgZGljdCA9IHRoaXNbc2VjcmV0XTtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGljdCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgZGljdFtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcbiAgfSwgdGhpcyk7XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNQcm90by5rZXlzID0gZnVuY3Rpb24ga2V5cygpIHtcbiAgdmFyIGl0ZW1zID0gW107XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKG5hbWUpOyB9KTtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5VUkxTZWFyY2hQYXJhbXNQcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gIHZhciBpdGVtcyA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHsgaXRlbXMucHVzaCh2YWx1ZSk7IH0pO1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9O1xuICAgIH1cbiAgfTtcblxuICBpZiAoaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7IH0pO1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9O1xuICAgIH1cbiAgfTtcblxuICBpZiAoaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbmlmIChpdGVyYWJsZSkge1xuICBVUkxTZWFyY2hQYXJhbXNQcm90b1tTeW1ib2wuaXRlcmF0b3JdID0gVVJMU2VhcmNoUGFyYW1zUHJvdG8uZW50cmllcztcbn1cblxuLypcblVSTFNlYXJjaFBhcmFtc1Byb3RvLnRvQm9keSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEJsb2IoXG4gICAgW3RoaXMudG9TdHJpbmcoKV0sXG4gICAge3R5cGU6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnfVxuICApO1xufTtcbiovXG5cblVSTFNlYXJjaFBhcmFtc1Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgcmV0dXJuIHt9O1xufTtcblxuVVJMU2VhcmNoUGFyYW1zUHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgdmFyIGRpY3QgPSB0aGlzW3NlY3JldF0sIHF1ZXJ5ID0gW10sIGksIGtleSwgbmFtZSwgdmFsdWU7XG4gIGZvciAoa2V5IGluIGRpY3QpIHtcbiAgICBuYW1lID0gZW5jb2RlKGtleSk7XG4gICAgZm9yIChcbiAgICAgIGkgPSAwLFxuICAgICAgdmFsdWUgPSBkaWN0W2tleV07XG4gICAgICBpIDwgdmFsdWUubGVuZ3RoOyBpKytcbiAgICApIHtcbiAgICAgIHF1ZXJ5LnB1c2gobmFtZSArICc9JyArIGVuY29kZSh2YWx1ZVtpXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcXVlcnkuam9pbignJicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuVVJMU2VhcmNoUGFyYW1zIHx8IFVSTFNlYXJjaFBhcmFtczsiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcblxuLyoqXG4gKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldCA/IHdzIDogbnVsbDtcblxuLyoqXG4gKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogVGhlIHRoaXJkIGBvcHRzYCBvcHRpb25zIG9iamVjdCBnZXRzIGlnbm9yZWQgaW4gd2ViIGJyb3dzZXJzLCBzaW5jZSBpdCdzXG4gKiBub24tc3RhbmRhcmQsIGFuZCB0aHJvd3MgYSBUeXBlRXJyb3IgaWYgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2VpbmFyb3Mvd3MvaXNzdWVzLzIyN1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3RvY29scyAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge09iamVjdCkgb3B0cyAob3B0aW9uYWwpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHdzKHVyaSwgcHJvdG9jb2xzLCBvcHRzKSB7XG4gIHZhciBpbnN0YW5jZTtcbiAgaWYgKHByb3RvY29scykge1xuICAgIGluc3RhbmNlID0gbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scyk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgV2ViU29ja2V0KHVyaSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5pZiAoV2ViU29ja2V0KSB3cy5wcm90b3R5cGUgPSBXZWJTb2NrZXQucHJvdG90eXBlO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJ0aWNrNDItZ2x1ZVwiLFxuICBcInZlcnNpb25cIjogXCIyLjEzLjBcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgSmF2YVNjcmlwdCBsaWJyYXJ5IHdoaWNoIHByb3ZpZGVzIHN1cHBvcnQgZm9yIFRpY2s0MiBHTFVFLlwiLFxuICBcIm1haW5cIjogXCJsaWJyYXJ5L2dsdWUuanNcIixcbiAgXCJiaW5cIjoge1xuICAgIFwiaW5pdC1kZXYtbW9kZVwiOiBcImJpbi9pbml0LWRldi1tb2RlLmpzXCIsXG4gICAgXCJyZW1vdmUtaW5zdGFsbGVkLWRlcGVuZGVuY2llc1wiOiBcImJpbi9yZW1vdmUtaW5zdGFsbGVkLWRlcGVuZGVuY2llcy5qc1wiLFxuICAgIFwicmVtb3ZlLWRldmVsb3BtZW50LWRlcGVuZGVuY2llc1wiOiBcImJpbi9yZW1vdmUtZGV2ZWxvcG1lbnQtZGVwZW5kZW5jaWVzLmpzXCIsXG4gICAgXCJidWlsZFwiOiBcIi4vYmluL2J1aWxkLmpzXCIsXG4gICAgXCJjbGVhblwiOiBcIi4vYmluL2NsZWFuLmpzXCIsXG4gICAgXCJmaWxlLXZlcnNpb25pZnlcIjogXCJiaW4vZmlsZS12ZXJzaW9uaWZ5LmpzXCIsXG4gICAgXCJtaW5pZnlcIjogXCIuL2Jpbi9taW5pZnkuanNcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiZXNsaW50XCI6IFwiZXNsaW50IGxpYnJhcnlcIixcbiAgICBcImVzbGludDpmaXhcIjogXCJlc2xpbnQgbGlicmFyeSAtLWZpeFwiLFxuICAgIFwidGVzdFwiOiBcIm5wbSBydW4gZXNsaW50ICYmIG1vY2hhIC0tcmVxdWlyZSAuL3Rlc3QvdGVzdF9oZWxwZXIgXFxcInRlc3QvKiovKi5qc1xcXCJcIixcbiAgICBcImJ1aWxkXCI6IFwibm9kZSBiaW4vY2xlYW4uanMgJiYgbm9kZSBiaW4vYnVpbGQuanMgJiYgbm9kZSBiaW4vbWluaWZ5ICYmIG5vZGUgYmluL2ZpbGUtdmVyc2lvbmlmeVwiLFxuICAgIFwiYnVpbGQ6ZGV2XCI6IFwibnBtIHJ1biBlc2xpbnQgJiYgbm9kZSBiaW4vY2xlYW4gJiBub2RlIGJpbi9idWlsZFwiLFxuICAgIFwicHJlcHVibGlzaFwiOiBcIm5wbSB1cGRhdGUgJiYgbnBtIHJ1biBidWlsZFwiLFxuICAgIFwiaW5pdDpkZXZlbG9wXCI6IFwibm9kZSBiaW4vaW5pdC1kZXYtbW9kZVwiLFxuICAgIFwiY2xlYXI6ZGV2ZWxvcFwiOiBcIm5vZGUgYmluL3JlbW92ZS1kZXZlbG9wbWVudC1kZXBlbmRlbmNpZXNcIixcbiAgICBcIndhdGNoXCI6IFwib25jaGFuZ2UgXFxcIi4vbGlicmFyeS8qLmpzXFxcIiBcXFwiLi9ub2RlX21vZHVsZXMvdGljazQyLSovbGlicmFyeS8qLmpzXFxcIiAgXFxcIi4vbm9kZV9tb2R1bGVzL3RpY2s0Mi0qL2xpYnJhcnlfanMvKi5qc1xcXCIgXFxcIi4uL25vZGVfbW9kdWxlcy90aWNrNDItKi9saWJyYXJ5LyouanNcXFwiICBcXFwiLi4vbm9kZV9tb2R1bGVzL3RpY2s0Mi0qL2xpYnJhcnlfanMvKi5qc1xcXCIgLWl2IC1lIFxcXCIuL2JpblxcXCIgLS0gbnBtIHJ1biBidWlsZDpkZXZcIixcbiAgICBcIndhdGNoOmRldmVsb3BcIjogXCJub2RlIGJpbi9yZW1vdmUtaW5zdGFsbGVkLWRlcGVuZGVuY2llcyAmJiBucG0gcnVuIHdhdGNoXCIsXG4gICAgXCJ3YXRjaDpwcm9kXCI6IFwibnBtIGluc3RhbGwgJiYgbnBtIHJ1biB3YXRjaFwiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL3N0YXNoLnRpY2s0Mi5jb206ODQ0My9zY20vb2Zndy9qcy1nbHVlLmdpdFwiXG4gIH0sXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJUaWNrNDJcIixcbiAgICBcInVybFwiOiBcImh0dHA6Ly93d3cudGljazQyLmNvbVwiXG4gIH0sXG4gIFwibGljZW5zZVwiOiBcIklTQ1wiLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJjdWlkXCI6IFwiXjEuMy44XCIsXG4gICAgXCJlc2xpbnRcIjogXCJeMy4xLjFcIixcbiAgICBcImVzbGludC1jb25maWctc3RhbmRhcmRcIjogXCJeNS4zLjVcIixcbiAgICBcImVzbGludC1wbHVnaW4tcHJvbWlzZVwiOiBcIl4yLjAuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1zdGFuZGFyZFwiOiBcIl4yLjAuMFwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy10aWNrNDJcIjogXCJeMS4wLjBcIixcbiAgICBcImRldGVjdC1ub2RlXCI6IFwiXjIuMC4zXCIsXG4gICAgXCJlczUtc2hpbVwiOiBcIl40LjEuMTRcIixcbiAgICBcInRpY2s0Mi1hY3Rpdml0eVwiOiBcIl4yLjAuMFwiLFxuICAgIFwidGljazQyLWFnbVwiOiBcIl4yLjMuNVwiLFxuICAgIFwidGljazQyLWFwcC1tYW5hZ2VyXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJ0aWNrNDItYXBwY29uZmlnXCI6IFwiXjAuMS4wXCIsXG4gICAgXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCI6IFwiXjEuMS42XCIsXG4gICAgXCJ0aWNrNDItbG9nZ2VyXCI6IFwiXjIuMC4zXCIsXG4gICAgXCJ0aWNrNDItbWV0cmljc1wiOiBcIl4yLjAuMTNcIixcbiAgICBcInRpY2s0Mi13aW5kb3dzXCI6IFwiXjIuMC4yXCIsXG4gICAgXCJ0aWNrNDItY29udGV4dHNcIjogXCIqXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnJvd3NlcmlmeVwiOiBcIl4xMy4wLjBcIixcbiAgICBcImJyb3dzZXJpZnktcmVwbGFjaWZ5XCI6IFwiXjAuMC40XCIsXG4gICAgXCJicm93c2VyaWZ5LXZlcnNpb25pZnlcIjogXCJeMS4wLjRcIixcbiAgICBcImNoYWlcIjogXCJeMy41LjBcIixcbiAgICBcImZzXCI6IFwiMC4wLjJcIixcbiAgICBcImpzZG9tXCI6IFwiXjguMS4wXCIsXG4gICAgXCJqc2hpbnRcIjogXCJeMi45LjFcIixcbiAgICBcIm1pbmlmeWlmeVwiOiBcIl43LjMuMlwiLFxuICAgIFwibW9jaGFcIjogXCJeMi40LjVcIixcbiAgICBcIm9uY2hhbmdlXCI6IFwiXjIuMS4yXCIsXG4gICAgXCJzaGVsbGpzXCI6IFwiXjAuNi4wXCJcbiAgfVxufVxuIl19
