(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function() {
	//Do not do anything if there is no support of ECMAScript 5
	if (typeof [].forEach !== 'function') {
		require("es5-shim");
		require("es5-shim/es5-sham");
	}

	var metrics = require("tick42-metrics");
	var agm = require("tick42-agm");
	var gatewayConnection = require("tick42-gateway-connection");
	var logger = require("tick42-logger");
	var appconfig = require("tick42-appconfig/src/js/appconfig");
	var windows = require("tick42-windows");
	var appManager = require("tick42-app-manager");
	var activity = require("tick42-activity");
	var pjson = require("../package.json");
	var cuid = require('cuid');

	//Do not do anything if the user turned off the auto initialization
	//
	if (typeof window !== 'undefined' && window.glue_auto_initialize === false) {
		return;
	}

	//Init the GLUE namespace
	var glue = {};
	glue.version = pjson.version;
	//Base configurations. Later they are updated depending on the runtime.
	var loggerConfiguration = {identity: {system: "Tick42"}};
	var metricsConfiguration = {identity: {system: "Tick42"}};
	var agmConfiguration = {instance: {}, server: {presence_interval: 3000}};

	//Here we will store a reference to the connection with the Service Provider
	glue.connection = undefined;
	var app_name;

	//If we are running in an HTML Container, use the HTML Container environment variables
	if (typeof window !== 'undefined' && window.htmlContainer !== undefined) {
		//Generate AGM app name
		app_name = window.agm_application || window.htmlContainer.containerName + "." + window.htmlContainer.browserWindowName;

		//Fill logger configurations with custom properties
		agmConfiguration.instance.application = app_name;
		loggerConfiguration.identity.system = "HtmlContainer." + window.htmlContainer.containerName;
		loggerConfiguration.identity.service = "JS." + window.htmlContainer.browserWindowName;
		loggerConfiguration.identity.instance = "~" + window.htmlContainer.machineName;

		if (window.htmlContainer.appConfigFacade !== undefined && window.htmlContainer.appConfigFacade.config !== undefined) {
			// Initialize AppConfig
			glue.appconfig = appconfig();
			glue.appconfig.init(function () {
				function supplant(template) {
					return template.replace(/\{([^{}]*)\}/g, function (match, key) {
						var value = this;
						key.split('.').forEach(function (part) {
							if (value) {
								value = value[part];
							}
						});
						return typeof value === 'string' || typeof value === 'number' ? value : match;
					});
				}

				var settings = window.htmlContainer.appConfigFacade.config;
				var identity = {};
				Object.keys(settings.identity).forEach(function (key) {
					var value = supplant(settings.identity[key]);
					identity[key] = value;
				});
				settings.identity = identity;
				return settings;
			}());
		}

		//Init the Connection
		glue.connection = gatewayConnection();

		//If we are running in normal browser, connect via Websocket
	} else {
		var connection_config = {};
		var uid_prefix;
		if (require("detect-node") || ('WebSocket' in window && window.WebSocket.CLOSING === 2)) {
			uid_prefix = "WS";
			//Websocket URL (this is the default that is used in the demo WS server) Defaults to insecure.
			var default_ws_url = 'ws://localhost:22037';
			if (window && window.location && window.location.protocol === 'https') {
				default_ws_url = 'wss://localhost:22037'
			}
			connection_config.websocket_url = window && window.glue_ws_url || default_ws_url;
		} else {
			// if no support for WebSocket use HTTP
			uid_prefix = "HTTP";
			// don't make insecure requests from secure env
			var default_http_url = window.location.protocol === 'http:' ? "http://localhost:22037" : "https://localhost:22037";
			connection_config.http_url = window.glue_http_url || default_http_url;
		}

		//Generate application UID to allow for the same application to be called multiple times.
		var uid = uid_prefix + cuid();

		//Generate AGM app name
		if (typeof document !== 'undefined' && document.title) {
			app_name =  document.title + uid
		} else if (window && window.agm_application) {
			app_name = window.agm_application;
		} else {
			app_name = uid;
		}

		//Fill configurations with custom properties
		agmConfiguration.instance.application = app_name;
		loggerConfiguration.identity.system = "Browser";
		loggerConfiguration.identity.service = typeof document !== 'undefined' ? document.title || 'unknown' : 'unknown';
		loggerConfiguration.identity.instance = "~" + uid;

		// Init the Connection and specify the URL of the Web Socket server that we are connecting to.
		glue.connection = gatewayConnection(connection_config);
	}

	//Place the Connection, as part of the components' configuration
	loggerConfiguration.connection = glue.connection;
	metricsConfiguration.connection = glue.connection;
	agmConfiguration.connection = glue.connection;

	//Override some props with environment variables, if provided
	loggerConfiguration.identity.system = window && window.glue_metric_system || loggerConfiguration.identity.system;
	loggerConfiguration.identity.service = window && window.glue_metric_service || loggerConfiguration.identity.service;
	loggerConfiguration.identity.instance = window && window.glue_metric_instance || loggerConfiguration.identity.instance;

	//Initialize Logger (uses the same configuration as Metrics)
	glue.logger = logger(loggerConfiguration);

	//Fill metrics configuration with the same properties as metrics configurations
	metricsConfiguration.identity = loggerConfiguration.identity;
	metricsConfiguration.logger = glue.logger.subLogger("metrics");

	//Initialize Metrics and save into the 'glue' global variable
	var rootMetrics = metrics(metricsConfiguration);
	glue.metrics = rootMetrics.subSystem("App");

	//Initialize the metrics system in the logger's "metrics_level" method
	glue.logger.metricsLevel("warn", glue.metrics.parent.subSystem("LogEvents"));

	agmConfiguration.instance.application = window && window.glue_agm_application || agmConfiguration.instance.application;

	//Include the metric repo in the AGM configuration (so that AGM can broadcast metrics)
	agmConfiguration.metrics = rootMetrics.subSystem("AGM");

	//Initialize AGM save into the 'glue' global variable
	glue.agm = agm(agmConfiguration);

	// Add activity in the container only
	var activitiesFacade = window && window.htmlContainer ? window.htmlContainer.activityFacade : undefined;
	if (typeof activitiesFacade !== "undefined") {
		var activityLogger = glue.logger.subLogger("activity");
		activityLogger.publishLevel("debug");
		activityLogger.consoleLevel("info");
		activityLogger.metricsLevel("off");
		glue.activities = activity({agm: glue.agm, logger: activityLogger});
	}

	glue.windows = windows(glue.agm);

	// camel case for App Manager
	glue.appManager = appManager(glue.agm, glue.windows);

	glue.info = {
		glueVersion: pjson.version,
		activities: glue.activities ? glue.activities.version : 'unknown',
		metrics: glue.metrics.repo.version,
		agm: glue.agm.version,
		windows: glue.windows.version,
		logger: glue.logger.version,
		appManager: glue.appManager.version,
		connection: glue.connection.version
	};

	// no conflict function
	var originalGlue = window && window.glue;
	glue.noConflict = function() {
		window.glue = originalGlue;
		return glue;
	};

	// feedback option
	glue.feedback = function() {
		if (!glue.agm){
			return;
		}

		glue.agm.invoke("T42.ACS.Feedback", {}, "best");
	};

	//Export GLUE
	if (window) {
		window.glue = glue;
	}
	module.exports = glue;
}());

},{"../package.json":80,"cuid":4,"detect-node":5,"es5-shim":7,"es5-shim/es5-sham":6,"tick42-activity":14,"tick42-agm":32,"tick42-app-manager":44,"tick42-appconfig/src/js/appconfig":49,"tick42-gateway-connection":55,"tick42-logger":60,"tick42-metrics":75,"tick42-windows":76}],2:[function(require,module,exports){
/**
 * (c) 2013 Beau Sorensen
 * MIT Licensed
 * For all details and documentation:
 * https://github.com/sorensen/ascii-table
 */

;(function() {
'use strict';

/*!
 * Module dependencies
 */

var slice = Array.prototype.slice
  , toString = Object.prototype.toString

/**
 * AsciiTable constructor
 *
 * @param {String|Object} title or JSON table
 * @param {Object} table options
 *  - `prefix` - string prefix added to each line on render
 * @constructor
 * @api public
 */

function AsciiTable(name, options) {
  this.options = options || {}
  this.reset(name)
}

/*!
 * Current library version, should match `package.json`
 */

AsciiTable.VERSION = '0.0.8'

/*!
 * Alignment constants
 */

AsciiTable.LEFT = 0
AsciiTable.CENTER = 1
AsciiTable.RIGHT = 2

/*!
 * Static methods
 */

/**
 * Create a new table instance
 *
 * @param {String|Object} title or JSON table
 * @param {Object} table options
 * @api public
 */

AsciiTable.factory = function(name, options) {
  return new AsciiTable(name, options)
}

/**
 * Align the a string at the given length
 *
 * @param {Number} direction
 * @param {String} string input
 * @param {Number} string length
 * @param {Number} padding character
 * @api public
 */

AsciiTable.align = function(dir, str, len, pad) {
  if (dir === AsciiTable.LEFT) return AsciiTable.alignLeft(str, len, pad)
  if (dir === AsciiTable.RIGHT) return AsciiTable.alignRight(str, len, pad)
  if (dir === AsciiTable.CENTER) return AsciiTable.alignCenter(str, len, pad)
  return AsciiTable.alignAuto(str, len, pad)
}

/**
 * Left align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignLeft = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var alen = len + 1 - str.length
  if (alen <= 0) return str
  return str + Array(len + 1 - str.length).join(pad)
}

/**
 * Center align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignCenter = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var nLen = str.length
    , half = Math.floor(len / 2 - nLen / 2)
    , odds = Math.abs((nLen % 2) - (len % 2))
    , len = str.length

  return AsciiTable.alignRight('', half, pad) 
    + str
    + AsciiTable.alignLeft('', half + odds, pad)
}

/**
 * Right align a string by padding it at a given length
 *
 * @param {String} str
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignRight = function(str, len, pad) {
  if (!len || len < 0) return ''
  if (str === undefined || str === null) str = ''
  if (typeof pad === 'undefined') pad = ' '
  if (typeof str !== 'string') str = str.toString()
  var alen = len + 1 - str.length
  if (alen <= 0) return str
  return Array(len + 1 - str.length).join(pad) + str
}

/**
 * Auto align string value based on object type
 *
 * @param {Any} object to string
 * @param {Number} string length
 * @param {String} padding character (optional, default '')
 * @api public
 */

AsciiTable.alignAuto = function(str, len, pad) {
  if (str === undefined || str === null) str = ''
  var type = toString.call(str)
  pad || (pad = ' ')
  len = +len
  if (type !== '[object String]') {
    str = str.toString()
  }
  if (str.length < len) {
    switch(type) {
      case '[object Number]': return AsciiTable.alignRight(str, len, pad)
      default: return AsciiTable.alignLeft(str, len, pad)
    }
  }
  return str
}

/**
 * Fill an array at a given size with the given value
 *
 * @param {Number} array size
 * @param {Any} fill value
 * @return {Array} filled array
 * @api public
 */

AsciiTable.arrayFill = function(len, fill) {
  var arr = new Array(len)
  for (var i = 0; i !== len; i++) {
    arr[i] = fill;
  }
  return arr
}

/*!
 * Instance methods
 */

/**
 * Reset the table state back to defaults
 *
 * @param {String|Object} title or JSON table
 * @api public
 */

AsciiTable.prototype.reset = 
AsciiTable.prototype.clear = function(name) {
  this.__name = ''
  this.__nameAlign = AsciiTable.CENTER
  this.__rows = []
  this.__maxCells = 0
  this.__aligns = []
  this.__colMaxes = []
  this.__spacing = 1
  this.__heading = null
  this.__headingAlign = AsciiTable.CENTER
  this.setBorder()

  if (toString.call(name) === '[object String]') {
    this.__name = name
  } else if (toString.call(name) === '[object Object]') {
    this.fromJSON(name)
  }
  return this
}

/**
 * Set the table border
 *
 * @param {String} horizontal edges (optional, default `|`)
 * @param {String} vertical edges (optional, default `-`)
 * @param {String} top corners (optional, default `.`)
 * @param {String} bottom corners (optional, default `'`)
 * @api public
 */

AsciiTable.prototype.setBorder = function(edge, fill, top, bottom) {
  this.__border = true
  if (arguments.length === 1) {
    fill = top = bottom = edge
  }
  this.__edge = edge || '|'
  this.__fill = fill || '-'
  this.__top = top || '.'
  this.__bottom = bottom || "'"
  return this
}

/**
 * Remove all table borders
 *
 * @api public
 */

AsciiTable.prototype.removeBorder = function() {
  this.__border = false
  this.__edge = ' '
  this.__fill = ' '
  return this
}

/**
 * Set the column alignment at a given index
 *
 * @param {Number} column index
 * @param {Number} alignment direction
 * @api public
 */

AsciiTable.prototype.setAlign = function(idx, dir) {
  this.__aligns[idx] = dir
  return this
}

/**
 * Set the title of the table
 *
 * @param {String} title
 * @api public
 */

AsciiTable.prototype.setTitle = function(name) {
  this.__name = name
  return this
}

/**
 * Get the title of the table
 *
 * @return {String} title
 * @api public
 */

AsciiTable.prototype.getTitle = function() {
  return this.__name
}

/**
 * Set table title alignment
 *
 * @param {Number} direction
 * @api public
 */

AsciiTable.prototype.setTitleAlign = function(dir) {
  this.__nameAlign = dir
  return this
}

/**
 * AsciiTable sorting shortcut to sort rows
 *
 * @param {Function} sorting method
 * @api public
 */

AsciiTable.prototype.sort = function(method) {
  this.__rows.sort(method)
  return this
}

/**
 * Sort rows based on sort method for given column
 *
 * @param {Number} column index
 * @param {Function} sorting method
 * @api public
 */

AsciiTable.prototype.sortColumn = function(idx, method) {
  this.__rows.sort(function(a, b) {
    return method(a[idx], b[idx])
  })
  return this
}

/**
 * Set table heading for columns
 *
 * @api public
 */

AsciiTable.prototype.setHeading = function(row) {
  if (arguments.length > 1 || toString.call(row) !== '[object Array]') {
    row = slice.call(arguments)
  }
  this.__heading = row
  return this
}

/**
 * Get table heading for columns
 *
 * @return {Array} copy of headings
 * @api public
 */

AsciiTable.prototype.getHeading = function() {
  return this.__heading.slice()
}

/**
 * Set heading alignment
 *
 * @param {Number} direction
 * @api public
 */

AsciiTable.prototype.setHeadingAlign = function(dir) {
  this.__headingAlign = dir
  return this
}

/**
 * Add a row of information to the table
 * 
 * @param {...|Array} argument values in order of columns
 * @api public
 */

AsciiTable.prototype.addRow = function(row) {
  if (arguments.length > 1 || toString.call(row) !== '[object Array]') {
    row = slice.call(arguments)
  }
  this.__maxCells = Math.max(this.__maxCells, row.length)
  this.__rows.push(row)
  return this
}

/**
 * Get a copy of all rows of the table
 *
 * @return {Array} copy of rows
 * @api public
 */

AsciiTable.prototype.getRows = function() {
  return this.__rows.slice().map(function(row) {
    return row.slice()
  })
}

/**
 * Add rows in the format of a row matrix
 *
 * @param {Array} row matrix
 * @api public
 */

AsciiTable.prototype.addRowMatrix = function(rows) {
  for (var i = 0; i < rows.length; i++) {
    this.addRow(rows[i])
  }
  return this
}

/**
 * Add rows from the given data array, processed by the callback function rowCallback.
 *
 * @param {Array} data
 * @param (Function) rowCallback
 * @param (Boolean) asMatrix - controls if the row created by rowCallback should be assigned as row matrix
 * @api public
 */

AsciiTable.prototype.addData = function(data, rowCallback, asMatrix) {
  if (toString.call(data) !== '[object Array]') {
    return this;
  }
  for (var index = 0, limit = data.length; index < limit; index++) {
    var row = rowCallback(data[index]);
    if(asMatrix) {
      this.addRowMatrix(row);
    } else {
      this.addRow(row);
    }
  }
  return this
}

  /**
 * Reset the current row state
 *
 * @api public
 */

AsciiTable.prototype.clearRows = function() {
  this.__rows = []
  this.__maxCells = 0
  this.__colMaxes = []
  return this
}

/**
 * Apply an even spaced column justification
 *
 * @param {Boolean} on / off
 * @api public
 */

AsciiTable.prototype.setJustify = function(val) {
  arguments.length === 0 && (val = true)
  this.__justify = !!val
  return this
}

/**
 * Convert the current instance to a JSON structure
 *
 * @return {Object} json representation
 * @api public
 */

AsciiTable.prototype.toJSON = function() {
  return {
    title: this.getTitle()
  , heading: this.getHeading()
  , rows: this.getRows()
  }
}

/**
 * Populate the table from a JSON object
 *
 * @param {Object} json representation
 * @api public
 */

AsciiTable.prototype.parse = 
AsciiTable.prototype.fromJSON = function(obj) {
  return this
    .clear()
    .setTitle(obj.title)
    .setHeading(obj.heading)
    .addRowMatrix(obj.rows)
}

/**
 * Render the table with the current information
 *
 * @return {String} formatted table
 * @api public
 */

AsciiTable.prototype.render =
AsciiTable.prototype.valueOf =
AsciiTable.prototype.toString = function() {
  var self = this
    , body = []
    , mLen = this.__maxCells
    , max = AsciiTable.arrayFill(mLen, 0)
    , total = mLen * 3
    , rows = this.__rows
    , justify
    , border = this.__border
    , all = this.__heading 
        ? [this.__heading].concat(rows)
        : rows

  // Calculate max table cell lengths across all rows
  for (var i = 0; i < all.length; i++) {
    var row = all[i]
    for (var k = 0; k < mLen; k++) {
      var cell = row[k]
      max[k] = Math.max(max[k], cell ? cell.toString().length : 0)
    }
  }
  this.__colMaxes = max
  justify = this.__justify ? Math.max.apply(null, max) : 0

  // Get 
  max.forEach(function(x) {
    total += justify ? justify : x + self.__spacing
  })
  justify && (total += max.length)
  total -= this.__spacing

  // Heading
  border && body.push(this._seperator(total - mLen + 1, this.__top))
  if (this.__name) {
    body.push(this._renderTitle(total - mLen + 1))
    border && body.push(this._seperator(total - mLen + 1))
  }
  if (this.__heading) {
    body.push(this._renderRow(this.__heading, ' ', this.__headingAlign))
    body.push(this._rowSeperator(mLen, this.__fill))
  }
  for (var i = 0; i < this.__rows.length; i++) {
    body.push(this._renderRow(this.__rows[i], ' '))
  }
  border && body.push(this._seperator(total - mLen + 1, this.__bottom))

  var prefix = this.options.prefix || ''
  return prefix + body.join('\n' + prefix)
}

/**
 * Create a line seperator
 *
 * @param {Number} string size
 * @param {String} side values (default '|')
 * @api private
 */

AsciiTable.prototype._seperator = function(len, sep) {
  sep || (sep = this.__edge)
  return sep + AsciiTable.alignRight(sep, len, this.__fill)
}

/**
 * Create a row seperator
 *
 * @return {String} seperator
 * @api private
 */

AsciiTable.prototype._rowSeperator = function() {
  var blanks = AsciiTable.arrayFill(this.__maxCells, this.__fill)
  return this._renderRow(blanks, this.__fill)
}

/**
 * Render the table title in a centered box
 *
 * @param {Number} string size
 * @return {String} formatted title
 * @api private
 */

AsciiTable.prototype._renderTitle = function(len) {
  var name = ' ' + this.__name + ' '
    , str = AsciiTable.align(this.__nameAlign, name, len - 1, ' ')
  return this.__edge + str + this.__edge
}

/**
 * Render an invdividual row
 *
 * @param {Array} row
 * @param {String} column seperator
 * @param {Number} total row alignment (optional, default `auto`)
 * @return {String} formatted row
 * @api private
 */

AsciiTable.prototype._renderRow = function(row, str, align) {
  var tmp = ['']
    , max = this.__colMaxes

  for (var k = 0; k < this.__maxCells; k++) {
    var cell = row[k]
      , just = this.__justify ? Math.max.apply(null, max) : max[k]
      // , pad = k === this.__maxCells - 1 ? just : just + this.__spacing
      , pad = just
      , cAlign = this.__aligns[k]
      , use = align
      , method = 'alignAuto'
  
    if (typeof align === 'undefined') use = cAlign

    if (use === AsciiTable.LEFT) method = 'alignLeft'
    if (use === AsciiTable.CENTER) method = 'alignCenter'
    if (use === AsciiTable.RIGHT) method = 'alignRight'

    tmp.push(AsciiTable[method](cell, pad, str))
  }
  var front = tmp.join(str + this.__edge + str)
  front = front.substr(1, front.length)
  return front + str + this.__edge
}

/*!
 * Aliases
 */

// Create method shortcuts to all alignment methods for each direction
;['Left', 'Right', 'Center'].forEach(function(dir) {
  var constant = AsciiTable[dir.toUpperCase()]

  ;['setAlign', 'setTitleAlign', 'setHeadingAlign'].forEach(function(method) {
    // Call the base method with the direction constant as the last argument
    AsciiTable.prototype[method + dir] = function() {
      var args = slice.call(arguments).concat(constant)
      return this[method].apply(this, args)
    }
  })
})

/*!
 * Module exports.
 */

if (typeof exports !== 'undefined') {
  module.exports = AsciiTable
} else {
  this.AsciiTable = AsciiTable
}

}).call(this);

},{}],3:[function(require,module,exports){
module.exports = require('./ascii-table')
},{"./ascii-table":2}],4:[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 *
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

/*global window, navigator, document, require, process, module */
(function (app) {
  'use strict';
  var namespace = 'cuid',
    c = 0,
    blockSize = 4,
    base = 36,
    discreteValues = Math.pow(base, blockSize),

    pad = function pad(num, size) {
      var s = "000000000" + num;
      return s.substr(s.length-size);
    },

    randomBlock = function randomBlock() {
      return pad((Math.random() *
            discreteValues << 0)
            .toString(base), blockSize);
    },

    safeCounter = function () {
      c = (c < discreteValues) ? c : 0;
      c++; // this is not subliminal
      return c - 1;
    },

    api = function cuid() {
      // Starting with a lowercase letter makes
      // it HTML element ID friendly.
      var letter = 'c', // hard-coded allows for sequential access

        // timestamp
        // warning: this exposes the exact date and time
        // that the uid was created.
        timestamp = (new Date().getTime()).toString(base),

        // Prevent same-machine collisions.
        counter,

        // A few chars to generate distinct ids for different
        // clients (so different computers are far less
        // likely to generate the same id)
        fingerprint = api.fingerprint(),

        // Grab some more chars from Math.random()
        random = randomBlock() + randomBlock();

        counter = pad(safeCounter().toString(base), blockSize);

      return  (letter + timestamp + counter + fingerprint + random);
    };

  api.slug = function slug() {
    var date = new Date().getTime().toString(36),
      counter,
      print = api.fingerprint().slice(0,1) +
        api.fingerprint().slice(-1),
      random = randomBlock().slice(-2);

      counter = safeCounter().toString(36).slice(-4);

    return date.slice(-2) +
      counter + print + random;
  };

  api.globalCount = function globalCount() {
    // We want to cache the results of this
    var cache = (function calc() {
        var i,
          count = 0;

        for (i in window) {
          count++;
        }

        return count;
      }());

    api.globalCount = function () { return cache; };
    return cache;
  };

  api.fingerprint = function browserPrint() {
    return pad((navigator.mimeTypes.length +
      navigator.userAgent.length).toString(36) +
      api.globalCount().toString(36), 4);
  };

  // don't change anything from here down.
  if (app.register) {
    app.register(namespace, api);
  } else if (typeof module !== 'undefined') {
    module.exports = api;
  } else {
    app[namespace] = api;
  }

}(this.applitude || this));

},{}],5:[function(require,module,exports){
(function (global){
module.exports = false;

// Only Node.JS has a process variable that is of [[Class]] process
try {
 module.exports = Object.prototype.toString.call(global.process) === '[object process]' 
} catch(e) {}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],6:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
    }
}(this, function () {

    var call = Function.call;
    var prototypeOfObject = Object.prototype;
    var owns = call.bind(prototypeOfObject.hasOwnProperty);
    var isEnumerable = call.bind(prototypeOfObject.propertyIsEnumerable);
    var toStr = call.bind(prototypeOfObject.toString);

    // If JS engine supports accessors creating shortcuts.
    var defineGetter;
    var defineSetter;
    var lookupGetter;
    var lookupSetter;
    var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
    if (supportsAccessors) {
        /* eslint-disable no-underscore-dangle */
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
        /* eslint-enable no-underscore-dangle */
    }

    var isPrimitive = function isPrimitive(o) {
        return o == null || (typeof o !== 'object' && typeof o !== 'function');
    };

    // ES5 15.2.3.2
    // http://es5.github.com/#x15.2.3.2
    if (!Object.getPrototypeOf) {
        // https://github.com/es-shims/es5-shim/issues#issue/2
        // http://ejohn.org/blog/objectgetprototypeof/
        // recommended by fschaefer on github
        //
        // sure, and webreflection says ^_^
        // ... this will nerever possibly return null
        // ... Opera Mini breaks here with infinite loops
        Object.getPrototypeOf = function getPrototypeOf(object) {
            /* eslint-disable no-proto */
            var proto = object.__proto__;
            /* eslint-enable no-proto */
            if (proto || proto === null) {
                return proto;
            } else if (toStr(object.constructor) === '[object Function]') {
                return object.constructor.prototype;
            } else if (object instanceof Object) {
                return prototypeOfObject;
            } else {
                // Correctly return null for Objects created with `Object.create(null)`
                // (shammed or native) or `{ __proto__: null}`.  Also returns null for
                // cross-realm objects on browsers that lack `__proto__` support (like
                // IE <11), but that's the best we can do.
                return null;
            }
        };
    }

    // ES5 15.2.3.3
    // http://es5.github.com/#x15.2.3.3

    var doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork(object) {
        try {
            object.sentinel = 0;
            return Object.getOwnPropertyDescriptor(object, 'sentinel').value === 0;
        } catch (exception) {
            return false;
        }
    };

    // check whether getOwnPropertyDescriptor works if it's given. Otherwise, shim partially.
    if (Object.defineProperty) {
        var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
        var getOwnPropertyDescriptorWorksOnDom = typeof document === 'undefined' ||
        doesGetOwnPropertyDescriptorWork(document.createElement('div'));
        if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
            var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
        }
    }

    if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
        var ERR_NON_OBJECT = 'Object.getOwnPropertyDescriptor called on a non-object: ';

        /* eslint-disable no-proto */
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
            if (isPrimitive(object)) {
                throw new TypeError(ERR_NON_OBJECT + object);
            }

            // make a valiant attempt to use the real getOwnPropertyDescriptor
            // for I8's DOM elements.
            if (getOwnPropertyDescriptorFallback) {
                try {
                    return getOwnPropertyDescriptorFallback.call(Object, object, property);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            var descriptor;

            // If object does not owns property return undefined immediately.
            if (!owns(object, property)) {
                return descriptor;
            }

            // If object has a property then it's for sure `configurable`, and
            // probably `enumerable`. Detect enumerability though.
            descriptor = {
                enumerable: isEnumerable(object, property),
                configurable: true
            };

            // If JS engine supports accessor properties then property may be a
            // getter or setter.
            if (supportsAccessors) {
                // Unfortunately `__lookupGetter__` will return a getter even
                // if object has own non getter property along with a same named
                // inherited getter. To avoid misbehavior we temporary remove
                // `__proto__` so that `__lookupGetter__` will return getter only
                // if it's owned by an object.
                var prototype = object.__proto__;
                var notPrototypeOfObject = object !== prototypeOfObject;
                // avoid recursion problem, breaking in Opera Mini when
                // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
                // or any other Object.prototype accessor
                if (notPrototypeOfObject) {
                    object.__proto__ = prototypeOfObject;
                }

                var getter = lookupGetter(object, property);
                var setter = lookupSetter(object, property);

                if (notPrototypeOfObject) {
                    // Once we have getter and setter we can put values back.
                    object.__proto__ = prototype;
                }

                if (getter || setter) {
                    if (getter) {
                        descriptor.get = getter;
                    }
                    if (setter) {
                        descriptor.set = setter;
                    }
                    // If it was accessor property we're done and return here
                    // in order to avoid adding `value` to the descriptor.
                    return descriptor;
                }
            }

            // If we got this far we know that object has an own property that is
            // not an accessor so we set it as a value and return descriptor.
            descriptor.value = object[property];
            descriptor.writable = true;
            return descriptor;
        };
        /* eslint-enable no-proto */
    }

    // ES5 15.2.3.4
    // http://es5.github.com/#x15.2.3.4
    if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
            return Object.keys(object);
        };
    }

    // ES5 15.2.3.5
    // http://es5.github.com/#x15.2.3.5
    if (!Object.create) {

        // Contributed by Brandon Benvie, October, 2012
        var createEmpty;
        var supportsProto = !({ __proto__: null } instanceof Object);
                            // the following produces false positives
                            // in Opera Mini => not a reliable check
                            // Object.prototype.__proto__ === null

        // Check for document.domain and active x support
        // No need to use active x approach when document.domain is not set
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        /* global ActiveXObject */
        var shouldUseActiveX = function shouldUseActiveX() {
            // return early if document.domain not set
            if (!document.domain) {
                return false;
            }

            try {
                return !!new ActiveXObject('htmlfile');
            } catch (exception) {
                return false;
            }
        };

        // This supports IE8 when document.domain is used
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        var getEmptyViaActiveX = function getEmptyViaActiveX() {
            var empty;
            var xDoc;

            xDoc = new ActiveXObject('htmlfile');

            var script = 'script';
            xDoc.write('<' + script + '></' + script + '>');
            xDoc.close();

            empty = xDoc.parentWindow.Object.prototype;
            xDoc = null;

            return empty;
        };

        // The original implementation using an iframe
        // before the activex approach was added
        // see https://github.com/es-shims/es5-shim/issues/150
        var getEmptyViaIFrame = function getEmptyViaIFrame() {
            var iframe = document.createElement('iframe');
            var parent = document.body || document.documentElement;
            var empty;

            iframe.style.display = 'none';
            parent.appendChild(iframe);
            /* eslint-disable no-script-url */
            iframe.src = 'javascript:';
            /* eslint-enable no-script-url */

            empty = iframe.contentWindow.Object.prototype;
            parent.removeChild(iframe);
            iframe = null;

            return empty;
        };

        /* global document */
        if (supportsProto || typeof document === 'undefined') {
            createEmpty = function () {
                return { __proto__: null };
            };
        } else {
            // In old IE __proto__ can't be used to manually set `null`, nor does
            // any other method exist to make an object that inherits from nothing,
            // aside from Object.prototype itself. Instead, create a new global
            // object and *steal* its Object.prototype and strip it bare. This is
            // used as the prototype to create nullary objects.
            createEmpty = function () {
                // Determine which approach to use
                // see https://github.com/es-shims/es5-shim/issues/150
                var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();

                delete empty.constructor;
                delete empty.hasOwnProperty;
                delete empty.propertyIsEnumerable;
                delete empty.isPrototypeOf;
                delete empty.toLocaleString;
                delete empty.toString;
                delete empty.valueOf;

                var Empty = function Empty() {};
                Empty.prototype = empty;
                // short-circuit future calls
                createEmpty = function () {
                    return new Empty();
                };
                return new Empty();
            };
        }

        Object.create = function create(prototype, properties) {

            var object;
            var Type = function Type() {}; // An empty constructor.

            if (prototype === null) {
                object = createEmpty();
            } else {
                if (prototype !== null && isPrimitive(prototype)) {
                    // In the native implementation `parent` can be `null`
                    // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)
                    // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`
                    // like they are in modern browsers. Using `Object.create` on DOM elements
                    // is...err...probably inappropriate, but the native version allows for it.
                    throw new TypeError('Object prototype may only be an Object or null'); // same msg as Chrome
                }
                Type.prototype = prototype;
                object = new Type();
                // IE has no built-in implementation of `Object.getPrototypeOf`
                // neither `__proto__`, but this manually setting `__proto__` will
                // guarantee that `Object.getPrototypeOf` will work as expected with
                // objects created using `Object.create`
                /* eslint-disable no-proto */
                object.__proto__ = prototype;
                /* eslint-enable no-proto */
            }

            if (properties !== void 0) {
                Object.defineProperties(object, properties);
            }

            return object;
        };
    }

    // ES5 15.2.3.6
    // http://es5.github.com/#x15.2.3.6

    // Patch for WebKit and IE8 standard mode
    // Designed by hax <hax.github.com>
    // related issue: https://github.com/es-shims/es5-shim/issues#issue/5
    // IE8 Reference:
    //     http://msdn.microsoft.com/en-us/library/dd282900.aspx
    //     http://msdn.microsoft.com/en-us/library/dd229916.aspx
    // WebKit Bugs:
    //     https://bugs.webkit.org/show_bug.cgi?id=36423

    var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
        try {
            Object.defineProperty(object, 'sentinel', {});
            return 'sentinel' in object;
        } catch (exception) {
            return false;
        }
    };

    // check whether defineProperty works if it's given. Otherwise,
    // shim partially.
    if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document === 'undefined' ||
            doesDefinePropertyWork(document.createElement('div'));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
            var definePropertyFallback = Object.defineProperty,
                definePropertiesFallback = Object.defineProperties;
        }
    }

    if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
        var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
        var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';

        Object.defineProperty = function defineProperty(object, property, descriptor) {
            if (isPrimitive(object)) {
                throw new TypeError(ERR_NON_OBJECT_TARGET + object);
            }
            if (isPrimitive(descriptor)) {
                throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
            }
            // make a valiant attempt to use the real defineProperty
            // for I8's DOM elements.
            if (definePropertyFallback) {
                try {
                    return definePropertyFallback.call(Object, object, property, descriptor);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            // If it's a data property.
            if ('value' in descriptor) {
                // fail silently if 'writable', 'enumerable', or 'configurable'
                // are requested but not supported
                /*
                // alternate approach:
                if ( // can't implement these features; allow false but not true
                    ('writable' in descriptor && !descriptor.writable) ||
                    ('enumerable' in descriptor && !descriptor.enumerable) ||
                    ('configurable' in descriptor && !descriptor.configurable)
                ))
                    throw new RangeError(
                        'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
                    );
                */

                if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
                    // As accessors are supported only on engines implementing
                    // `__proto__` we can safely override `__proto__` while defining
                    // a property to make sure that we don't hit an inherited
                    // accessor.
                    /* eslint-disable no-proto */
                    var prototype = object.__proto__;
                    object.__proto__ = prototypeOfObject;
                    // Deleting a property anyway since getter / setter may be
                    // defined on object itself.
                    delete object[property];
                    object[property] = descriptor.value;
                    // Setting original `__proto__` back now.
                    object.__proto__ = prototype;
                    /* eslint-enable no-proto */
                } else {
                    object[property] = descriptor.value;
                }
            } else {
                var hasGetter = 'get' in descriptor;
                var hasSetter = 'set' in descriptor;
                if (!supportsAccessors && (hasGetter || hasSetter)) {
                     return;
                }
                // If we got that far then getters and setters can be defined !!
                if (hasGetter) {
                    defineGetter(object, property, descriptor.get);
                }
                if (hasSetter) {
                    defineSetter(object, property, descriptor.set);
                }
            }
            return object;
        };
    }

    // ES5 15.2.3.7
    // http://es5.github.com/#x15.2.3.7
    if (!Object.defineProperties || definePropertiesFallback) {
        Object.defineProperties = function defineProperties(object, properties) {
            // make a valiant attempt to use the real defineProperties
            if (definePropertiesFallback) {
                try {
                    return definePropertiesFallback.call(Object, object, properties);
                } catch (exception) {
                    // try the shim if the real one doesn't work
                }
            }

            Object.keys(properties).forEach(function (property) {
                if (property !== '__proto__') {
                    Object.defineProperty(object, property, properties[property]);
                }
            });
            return object;
        };
    }

    // ES5 15.2.3.8
    // http://es5.github.com/#x15.2.3.8
    if (!Object.seal) {
        Object.seal = function seal(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.seal can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // ES5 15.2.3.9
    // http://es5.github.com/#x15.2.3.9
    if (!Object.freeze) {
        Object.freeze = function freeze(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.freeze can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // detect a Rhino bug and patch it
    try {
        Object.freeze(function () {});
    } catch (exception) {
        Object.freeze = (function (freezeObject) {
            return function freeze(object) {
                if (typeof object === 'function') {
                    return object;
                } else {
                    return freezeObject(object);
                }
            };
        }(Object.freeze));
    }

    // ES5 15.2.3.10
    // http://es5.github.com/#x15.2.3.10
    if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.preventExtensions can only be called on Objects.');
            }
            // this is misleading and breaks feature-detection, but
            // allows "securable" code to "gracefully" degrade to working
            // but insecure code.
            return object;
        };
    }

    // ES5 15.2.3.11
    // http://es5.github.com/#x15.2.3.11
    if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.isSealed can only be called on Objects.');
            }
            return false;
        };
    }

    // ES5 15.2.3.12
    // http://es5.github.com/#x15.2.3.12
    if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
            if (Object(object) !== object) {
                throw new TypeError('Object.isFrozen can only be called on Objects.');
            }
            return false;
        };
    }

    // ES5 15.2.3.13
    // http://es5.github.com/#x15.2.3.13
    if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
            // 1. If Type(O) is not Object throw a TypeError exception.
            if (Object(object) !== object) {
                throw new TypeError('Object.isExtensible can only be called on Objects.');
            }
            // 2. Return the Boolean value of the [[Extensible]] internal property of O.
            var name = '';
            while (owns(object, name)) {
                name += '?';
            }
            object[name] = true;
            var returnValue = owns(object, name);
            delete object[name];
            return returnValue;
        };
    }

}));

},{}],7:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
    }
}(this, function () {
    /**
     * Brings an environment as close to ECMAScript 5 compliance
     * as is possible with the facilities of erstwhile engines.
     *
     * Annotated ES5: http://es5.github.com/ (specific links below)
     * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
     * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
     */

    // Shortcut to an often accessed properties, in order to avoid multiple
    // dereference that costs universally. This also holds a reference to known-good
    // functions.
    var $Array = Array;
    var ArrayPrototype = $Array.prototype;
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    var $Function = Function;
    var FunctionPrototype = $Function.prototype;
    var $String = String;
    var StringPrototype = $String.prototype;
    var $Number = Number;
    var NumberPrototype = $Number.prototype;
    var array_slice = ArrayPrototype.slice;
    var array_splice = ArrayPrototype.splice;
    var array_push = ArrayPrototype.push;
    var array_unshift = ArrayPrototype.unshift;
    var array_concat = ArrayPrototype.concat;
    var array_join = ArrayPrototype.join;
    var call = FunctionPrototype.call;
    var apply = FunctionPrototype.apply;
    var max = Math.max;
    var min = Math.min;

    // Having a toString local variable name breaks in Opera so use to_string.
    var to_string = ObjectPrototype.toString;

    /* global Symbol */
    /* eslint-disable one-var-declaration-per-line, no-redeclare, max-statements-per-line */
    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn(value) { try { var fnStr = fnToStr.call(value); var singleStripped = fnStr.replace(/\/\/.*\n/g, ''); var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, ''); var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' '); return constructorRegex.test(spaceStripped); } catch (e) { return false; /* not a function */ } }, tryFunctionObject = function tryFunctionObject(value) { try { if (isES6ClassFn(value)) { return false; } fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', isCallable = function isCallable(value) { if (!value) { return false; } if (typeof value !== 'function' && typeof value !== 'object') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } if (isES6ClassFn(value)) { return false; } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };

    var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
    var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
    /* eslint-enable one-var-declaration-per-line, no-redeclare, max-statements-per-line */

    /* inlined from http://npmjs.com/define-properties */
    var supportsDescriptors = $Object.defineProperty && (function () {
        try {
            var obj = {};
            $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
            for (var _ in obj) { // jscs:ignore disallowUnusedVariables
                return false;
            }
            return obj.x === obj;
        } catch (e) { /* this is ES3 */
            return false;
        }
    }());
    var defineProperties = (function (has) {
        // Define configurable, writable, and non-enumerable props
        // if they don't exist.
        var defineProperty;
        if (supportsDescriptors) {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                $Object.defineProperty(object, name, {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: method
                });
            };
        } else {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                object[name] = method;
            };
        }
        return function defineProperties(object, map, forceAssign) {
            for (var name in map) {
                if (has.call(map, name)) {
                    defineProperty(object, name, map[name], forceAssign);
                }
            }
        };
    }(ObjectPrototype.hasOwnProperty));

    //
    // Util
    // ======
    //

    /* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
    var isPrimitive = function isPrimitive(input) {
        var type = typeof input;
        return input === null || (type !== 'object' && type !== 'function');
    };

    var isActualNaN = $Number.isNaN || function isActualNaN(x) {
        return x !== x;
    };

    var ES = {
        // ES5 9.4
        // http://es5.github.com/#x9.4
        // http://jsperf.com/to-integer
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
        ToInteger: function ToInteger(num) {
            var n = +num;
            if (isActualNaN(n)) {
                n = 0;
            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
            return n;
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
        ToPrimitive: function ToPrimitive(input) {
            var val, valueOf, toStr;
            if (isPrimitive(input)) {
                return input;
            }
            valueOf = input.valueOf;
            if (isCallable(valueOf)) {
                val = valueOf.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            toStr = input.toString;
            if (isCallable(toStr)) {
                val = toStr.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            throw new TypeError();
        },

        // ES5 9.9
        // http://es5.github.com/#x9.9
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
        ToObject: function (o) {
            if (o == null) { // this matches both null and undefined
                throw new TypeError("can't convert " + o + ' to object');
            }
            return $Object(o);
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
        ToUint32: function ToUint32(x) {
            return x >>> 0;
        }
    };

    //
    // Function
    // ========
    //

    // ES-5 15.3.4.5
    // http://es5.github.com/#x15.3.4.5

    var Empty = function Empty() {};

    defineProperties(FunctionPrototype, {
        bind: function bind(that) { // .length is 1
            // 1. Let Target be the this value.
            var target = this;
            // 2. If IsCallable(Target) is false, throw a TypeError exception.
            if (!isCallable(target)) {
                throw new TypeError('Function.prototype.bind called on incompatible ' + target);
            }
            // 3. Let A be a new (possibly empty) internal list of all of the
            //   argument values provided after thisArg (arg1, arg2 etc), in order.
            // XXX slicedArgs will stand in for "A" if used
            var args = array_slice.call(arguments, 1); // for normal call
            // 4. Let F be a new native ECMAScript object.
            // 11. Set the [[Prototype]] internal property of F to the standard
            //   built-in Function prototype object as specified in 15.3.3.1.
            // 12. Set the [[Call]] internal property of F as described in
            //   15.3.4.5.1.
            // 13. Set the [[Construct]] internal property of F as described in
            //   15.3.4.5.2.
            // 14. Set the [[HasInstance]] internal property of F as described in
            //   15.3.4.5.3.
            var bound;
            var binder = function () {

                if (this instanceof bound) {
                    // 15.3.4.5.2 [[Construct]]
                    // When the [[Construct]] internal method of a function object,
                    // F that was created using the bind function is called with a
                    // list of arguments ExtraArgs, the following steps are taken:
                    // 1. Let target be the value of F's [[TargetFunction]]
                    //   internal property.
                    // 2. If target has no [[Construct]] internal method, a
                    //   TypeError exception is thrown.
                    // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Construct]] internal
                    //   method of target providing args as the arguments.

                    var result = apply.call(
                        target,
                        this,
                        array_concat.call(args, array_slice.call(arguments))
                    );
                    if ($Object(result) === result) {
                        return result;
                    }
                    return this;

                } else {
                    // 15.3.4.5.1 [[Call]]
                    // When the [[Call]] internal method of a function object, F,
                    // which was created using the bind function is called with a
                    // this value and a list of arguments ExtraArgs, the following
                    // steps are taken:
                    // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 2. Let boundThis be the value of F's [[BoundThis]] internal
                    //   property.
                    // 3. Let target be the value of F's [[TargetFunction]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Call]] internal method
                    //   of target providing boundThis as the this value and
                    //   providing args as the arguments.

                    // equiv: target.call(this, ...boundArgs, ...args)
                    return apply.call(
                        target,
                        that,
                        array_concat.call(args, array_slice.call(arguments))
                    );

                }

            };

            // 15. If the [[Class]] internal property of Target is "Function", then
            //     a. Let L be the length property of Target minus the length of A.
            //     b. Set the length own property of F to either 0 or L, whichever is
            //       larger.
            // 16. Else set the length own property of F to 0.

            var boundLength = max(0, target.length - args.length);

            // 17. Set the attributes of the length own property of F to the values
            //   specified in 15.3.5.1.
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                array_push.call(boundArgs, '$' + i);
            }

            // XXX Build a dynamic function with desired amount of arguments is the only
            // way to set the length property of a function.
            // In environments where Content Security Policies enabled (Chrome extensions,
            // for ex.) all use of eval or Function costructor throws an exception.
            // However in all of these environments Function.prototype.bind exists
            // and so this code will never be executed.
            bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                // Clean up dangling references.
                Empty.prototype = null;
            }

            // TODO
            // 18. Set the [[Extensible]] internal property of F to true.

            // TODO
            // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
            // 20. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
            //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
            //   false.
            // 21. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
            //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
            //   and false.

            // TODO
            // NOTE Function objects created using Function.prototype.bind do not
            // have a prototype property or the [[Code]], [[FormalParameters]], and
            // [[Scope]] internal properties.
            // XXX can't delete prototype in pure-js.

            // 22. Return F.
            return bound;
        }
    });

    // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
    // use it in defining shortcuts.
    var owns = call.bind(ObjectPrototype.hasOwnProperty);
    var toStr = call.bind(ObjectPrototype.toString);
    var arraySlice = call.bind(array_slice);
    var arraySliceApply = apply.bind(array_slice);
    var strSlice = call.bind(StringPrototype.slice);
    var strSplit = call.bind(StringPrototype.split);
    var strIndexOf = call.bind(StringPrototype.indexOf);
    var pushCall = call.bind(array_push);
    var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
    var arraySort = call.bind(ArrayPrototype.sort);

    //
    // Array
    // =====
    //

    var isArray = $Array.isArray || function isArray(obj) {
        return toStr(obj) === '[object Array]';
    };

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.13
    // Return len+argCount.
    // [bugfix, ielt8]
    // IE < 8 bug: [].unshift(0) === undefined but should be "1"
    var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
    defineProperties(ArrayPrototype, {
        unshift: function () {
            array_unshift.apply(this, arguments);
            return this.length;
        }
    }, hasUnshiftReturnValueBug);

    // ES5 15.4.3.2
    // http://es5.github.com/#x15.4.3.2
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
    defineProperties($Array, { isArray: isArray });

    // The IsCallable() check in the Array functions
    // has been replaced with a strict check on the
    // internal class of the object to trap cases where
    // the provided function was actually a regular
    // expression literal, which in V8 and
    // JavaScriptCore is a typeof "function".  Only in
    // V8 are regular expression literals permitted as
    // reduce parameters, so it is desirable in the
    // general case for the shim to match the more
    // strict and common behavior of rejecting regular
    // expressions.

    // ES5 15.4.4.18
    // http://es5.github.com/#x15.4.4.18
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

    // Check failure of by-index access of string characters (IE < 9)
    // and failure of `0 in boxedString` (Rhino)
    var boxedString = $Object('a');
    var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

    var properlyBoxesContext = function properlyBoxed(method) {
        // Check node 0.6.21 bug where third parameter is not boxed
        var properlyBoxesNonStrict = true;
        var properlyBoxesStrict = true;
        var threwException = false;
        if (method) {
            try {
                method.call('foo', function (_, __, context) {
                    if (typeof context !== 'object') {
                        properlyBoxesNonStrict = false;
                    }
                });

                method.call([1], function () {
                    'use strict';

                    properlyBoxesStrict = typeof this === 'string';
                }, 'x');
            } catch (e) {
                threwException = true;
            }
        }
        return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
    };

    defineProperties(ArrayPrototype, {
        forEach: function forEach(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var i = -1;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.forEach callback must be a function');
            }

            while (++i < length) {
                if (i in self) {
                    // Invoke the callback function with call, passing arguments:
                    // context, property value, property key, thisArg object
                    if (typeof T === 'undefined') {
                        callbackfn(self[i], i, object);
                    } else {
                        callbackfn.call(T, self[i], i, object);
                    }
                }
            }
        }
    }, !properlyBoxesContext(ArrayPrototype.forEach));

    // ES5 15.4.4.19
    // http://es5.github.com/#x15.4.4.19
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
    defineProperties(ArrayPrototype, {
        map: function map(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = $Array(length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.map callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    if (typeof T === 'undefined') {
                        result[i] = callbackfn(self[i], i, object);
                    } else {
                        result[i] = callbackfn.call(T, self[i], i, object);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.map));

    // ES5 15.4.4.20
    // http://es5.github.com/#x15.4.4.20
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
    defineProperties(ArrayPrototype, {
        filter: function filter(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = [];
            var value;
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.filter callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    value = self[i];
                    if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
                        pushCall(result, value);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.filter));

    // ES5 15.4.4.16
    // http://es5.github.com/#x15.4.4.16
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
    defineProperties(ArrayPrototype, {
        every: function every(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.every callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return false;
                }
            }
            return true;
        }
    }, !properlyBoxesContext(ArrayPrototype.every));

    // ES5 15.4.4.17
    // http://es5.github.com/#x15.4.4.17
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
    defineProperties(ArrayPrototype, {
        some: function some(callbackfn/*, thisArg */) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.some callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return true;
                }
            }
            return false;
        }
    }, !properlyBoxesContext(ArrayPrototype.some));

    // ES5 15.4.4.21
    // http://es5.github.com/#x15.4.4.21
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
    var reduceCoercesToObject = false;
    if (ArrayPrototype.reduce) {
        reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduce: function reduce(callbackfn/*, initialValue*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduce callback must be a function');
            }

            // no value to return if no initial value and an empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduce of empty array with no initial value');
            }

            var i = 0;
            var result;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i++];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (++i >= length) {
                        throw new TypeError('reduce of empty array with no initial value');
                    }
                } while (true);
            }

            for (; i < length; i++) {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            }

            return result;
        }
    }, !reduceCoercesToObject);

    // ES5 15.4.4.22
    // http://es5.github.com/#x15.4.4.22
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
    var reduceRightCoercesToObject = false;
    if (ArrayPrototype.reduceRight) {
        reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduceRight: function reduceRight(callbackfn/*, initial*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduceRight callback must be a function');
            }

            // no value to return if no initial value, empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduceRight of empty array with no initial value');
            }

            var result;
            var i = length - 1;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i--];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (--i < 0) {
                        throw new TypeError('reduceRight of empty array with no initial value');
                    }
                } while (true);
            }

            if (i < 0) {
                return result;
            }

            do {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            } while (i--);

            return result;
        }
    }, !reduceRightCoercesToObject);

    // ES5 15.4.4.14
    // http://es5.github.com/#x15.4.4.14
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
    var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
    defineProperties(ArrayPrototype, {
        indexOf: function indexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }

            var i = 0;
            if (arguments.length > 1) {
                i = ES.ToInteger(arguments[1]);
            }

            // handle negative indices
            i = i >= 0 ? i : max(0, length + i);
            for (; i < length; i++) {
                if (i in self && self[i] === searchElement) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2IndexOfBug);

    // ES5 15.4.4.15
    // http://es5.github.com/#x15.4.4.15
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
    var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
    defineProperties(ArrayPrototype, {
        lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }
            var i = length - 1;
            if (arguments.length > 1) {
                i = min(i, ES.ToInteger(arguments[1]));
            }
            // handle negative indices
            i = i >= 0 ? i : length - Math.abs(i);
            for (; i >= 0; i--) {
                if (i in self && searchElement === self[i]) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2LastIndexOfBug);

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.12
    var spliceNoopReturnsEmptyArray = (function () {
        var a = [1, 2];
        var result = a.splice();
        return a.length === 2 && isArray(result) && result.length === 0;
    }());
    defineProperties(ArrayPrototype, {
        // Safari 5.0 bug where .splice() returns undefined
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            } else {
                return array_splice.apply(this, arguments);
            }
        }
    }, !spliceNoopReturnsEmptyArray);

    var spliceWorksWithEmptyObject = (function () {
        var obj = {};
        ArrayPrototype.splice.call(obj, 0, 0, 1);
        return obj.length === 1;
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            }
            var args = arguments;
            this.length = max(ES.ToInteger(this.length), 0);
            if (arguments.length > 0 && typeof deleteCount !== 'number') {
                args = arraySlice(arguments);
                if (args.length < 2) {
                    pushCall(args, this.length - start);
                } else {
                    args[1] = ES.ToInteger(deleteCount);
                }
            }
            return array_splice.apply(this, args);
        }
    }, !spliceWorksWithEmptyObject);
    var spliceWorksWithLargeSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
        var arr = new $Array(1e5);
        // note: the index MUST be 8 or larger or the test will false pass
        arr[8] = 'x';
        arr.splice(1, 1);
        // note: this test must be defined *after* the indexOf shim
        // per https://github.com/es-shims/es5-shim/issues/313
        return arr.indexOf('x') === 7;
    }());
    var spliceWorksWithSmallSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Opera 12.15 breaks on this, no idea why.
        var n = 256;
        var arr = [];
        arr[n] = 'a';
        arr.splice(n + 1, 0, 'b');
        return arr[n] === 'a';
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            var O = ES.ToObject(this);
            var A = [];
            var len = ES.ToUint32(O.length);
            var relativeStart = ES.ToInteger(start);
            var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
            var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

            var k = 0;
            var from;
            while (k < actualDeleteCount) {
                from = $String(actualStart + k);
                if (owns(O, from)) {
                    A[k] = O[from];
                }
                k += 1;
            }

            var items = arraySlice(arguments, 2);
            var itemCount = items.length;
            var to;
            if (itemCount < actualDeleteCount) {
                k = actualStart;
                var maxK = len - actualDeleteCount;
                while (k < maxK) {
                    from = $String(k + actualDeleteCount);
                    to = $String(k + itemCount);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k += 1;
                }
                k = len;
                var minK = len - actualDeleteCount + itemCount;
                while (k > minK) {
                    delete O[k - 1];
                    k -= 1;
                }
            } else if (itemCount > actualDeleteCount) {
                k = len - actualDeleteCount;
                while (k > actualStart) {
                    from = $String(k + actualDeleteCount - 1);
                    to = $String(k + itemCount - 1);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k -= 1;
                }
            }
            k = actualStart;
            for (var i = 0; i < items.length; ++i) {
                O[k] = items[i];
                k += 1;
            }
            O.length = len - actualDeleteCount + itemCount;

            return A;
        }
    }, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

    var originalJoin = ArrayPrototype.join;
    var hasStringJoinBug;
    try {
        hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
    } catch (e) {
        hasStringJoinBug = true;
    }
    if (hasStringJoinBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
            }
        }, hasStringJoinBug);
    }

    var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
    if (hasJoinUndefinedBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(this, sep);
            }
        }, hasJoinUndefinedBug);
    }

    var pushShim = function push(item) {
        var O = ES.ToObject(this);
        var n = ES.ToUint32(O.length);
        var i = 0;
        while (i < arguments.length) {
            O[n + i] = arguments[i];
            i += 1;
        }
        O.length = n + i;
        return n + i;
    };

    var pushIsNotGeneric = (function () {
        var obj = {};
        var result = Array.prototype.push.call(obj, undefined);
        return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
    }());
    defineProperties(ArrayPrototype, {
        push: function push(item) {
            if (isArray(this)) {
                return array_push.apply(this, arguments);
            }
            return pushShim.apply(this, arguments);
        }
    }, pushIsNotGeneric);

    // This fixes a very weird bug in Opera 10.6 when pushing `undefined
    var pushUndefinedIsWeird = (function () {
        var arr = [];
        var result = arr.push(undefined);
        return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
    }());
    defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);

    // ES5 15.2.3.14
    // http://es5.github.io/#x15.4.4.10
    // Fix boxed string bug
    defineProperties(ArrayPrototype, {
        slice: function (start, end) {
            var arr = isString(this) ? strSplit(this, '') : this;
            return arraySliceApply(arr, arguments);
        }
    }, splitString);

    var sortIgnoresNonFunctions = (function () {
        try {
            [1, 2].sort(null);
            [1, 2].sort({});
            return true;
        } catch (e) {}
        return false;
    }());
    var sortThrowsOnRegex = (function () {
        // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
        try {
            [1, 2].sort(/a/);
            return false;
        } catch (e) {}
        return true;
    }());
    var sortIgnoresUndefined = (function () {
        // applies in IE 8, for one.
        try {
            [1, 2].sort(undefined);
            return true;
        } catch (e) {}
        return false;
    }());
    defineProperties(ArrayPrototype, {
        sort: function sort(compareFn) {
            if (typeof compareFn === 'undefined') {
                return arraySort(this);
            }
            if (!isCallable(compareFn)) {
                throw new TypeError('Array.prototype.sort callback must be a function');
            }
            return arraySort(this, compareFn);
        }
    }, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);

    //
    // Object
    // ======
    //

    // ES5 15.2.3.14
    // http://es5.github.com/#x15.2.3.14

    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = !isEnum({ 'toString': null }, 'toString');
    var hasProtoEnumBug = isEnum(function () {}, 'prototype');
    var hasStringEnumBug = !owns('x', '0');
    var equalsConstructorPrototype = function (o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var blacklistedKeys = {
        $window: true,
        $console: true,
        $parent: true,
        $self: true,
        $frame: true,
        $frames: true,
        $frameElement: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $external: true
    };
    var hasAutomationEqualityBug = (function () {
        /* globals window */
        if (typeof window === 'undefined') {
            return false;
        }
        for (var k in window) {
            try {
                if (!blacklistedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
                    equalsConstructorPrototype(window[k]);
                }
            } catch (e) {
                return true;
            }
        }
        return false;
    }());
    var equalsConstructorPrototypeIfNotBuggy = function (object) {
        if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(object);
        }
        try {
            return equalsConstructorPrototype(object);
        } catch (e) {
            return false;
        }
    };
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var dontEnumsLength = dontEnums.length;

    // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
    // can be replaced with require('is-arguments') if we ever use a build process instead
    var isStandardArguments = function isArguments(value) {
        return toStr(value) === '[object Arguments]';
    };
    var isLegacyArguments = function isArguments(value) {
        return value !== null &&
            typeof value === 'object' &&
            typeof value.length === 'number' &&
            value.length >= 0 &&
            !isArray(value) &&
            isCallable(value.callee);
    };
    var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

    defineProperties($Object, {
        keys: function keys(object) {
            var isFn = isCallable(object);
            var isArgs = isArguments(object);
            var isObject = object !== null && typeof object === 'object';
            var isStr = isObject && isString(object);

            if (!isObject && !isFn && !isArgs) {
                throw new TypeError('Object.keys called on a non-object');
            }

            var theKeys = [];
            var skipProto = hasProtoEnumBug && isFn;
            if ((isStr && hasStringEnumBug) || isArgs) {
                for (var i = 0; i < object.length; ++i) {
                    pushCall(theKeys, $String(i));
                }
            }

            if (!isArgs) {
                for (var name in object) {
                    if (!(skipProto && name === 'prototype') && owns(object, name)) {
                        pushCall(theKeys, $String(name));
                    }
                }
            }

            if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                for (var j = 0; j < dontEnumsLength; j++) {
                    var dontEnum = dontEnums[j];
                    if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
                        pushCall(theKeys, dontEnum);
                    }
                }
            }
            return theKeys;
        }
    });

    var keysWorksWithArguments = $Object.keys && (function () {
        // Safari 5.0 bug
        return $Object.keys(arguments).length === 2;
    }(1, 2));
    var keysHasArgumentsLengthBug = $Object.keys && (function () {
        var argKeys = $Object.keys(arguments);
        return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
    }(1));
    var originalKeys = $Object.keys;
    defineProperties($Object, {
        keys: function keys(object) {
            if (isArguments(object)) {
                return originalKeys(arraySlice(object));
            } else {
                return originalKeys(object);
            }
        }
    }, !keysWorksWithArguments || keysHasArgumentsLengthBug);

    //
    // Date
    // ====
    //

    var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
    var aNegativeTestDate = new Date(-1509842289600292);
    var aPositiveTestDate = new Date(1449662400000);
    var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
    var hasToDateStringFormatBug;
    var hasToStringFormatBug;
    var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
    if (timeZoneOffset < -720) {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
        hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
    } else {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
        hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
    }

    var originalGetFullYear = call.bind(Date.prototype.getFullYear);
    var originalGetMonth = call.bind(Date.prototype.getMonth);
    var originalGetDate = call.bind(Date.prototype.getDate);
    var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
    var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
    var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
    var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
    var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
    var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
    var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
    var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
    var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var daysInMonth = function daysInMonth(month, year) {
        return originalGetDate(new Date(year, month, 0));
    };

    defineProperties(Date.prototype, {
        getFullYear: function getFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            if (year < 0 && originalGetMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getMonth: function getMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getDate: function getDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            var date = originalGetDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        },
        getUTCFullYear: function getUTCFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            if (year < 0 && originalGetUTCMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getUTCMonth: function getUTCMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getUTCDate: function getUTCDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            var date = originalGetUTCDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        }
    }, hasNegativeMonthYearBug);

    defineProperties(Date.prototype, {
        toUTCString: function toUTCString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = originalGetUTCDay(this);
            var date = originalGetUTCDate(this);
            var month = originalGetUTCMonth(this);
            var year = originalGetUTCFullYear(this);
            var hour = originalGetUTCHours(this);
            var minute = originalGetUTCMinutes(this);
            var second = originalGetUTCSeconds(this);
            return dayName[day] + ', ' +
                (date < 10 ? '0' + date : date) + ' ' +
                monthName[month] + ' ' +
                year + ' ' +
                (hour < 10 ? '0' + hour : hour) + ':' +
                (minute < 10 ? '0' + minute : minute) + ':' +
                (second < 10 ? '0' + second : second) + ' GMT';
        }
    }, hasNegativeMonthYearBug || hasToUTCStringFormatBug);

    // Opera 12 has `,`
    defineProperties(Date.prototype, {
        toDateString: function toDateString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            return dayName[day] + ' ' +
                monthName[month] + ' ' +
                (date < 10 ? '0' + date : date) + ' ' +
                year;
        }
    }, hasNegativeMonthYearBug || hasToDateStringFormatBug);

    // can't use defineProperties here because of toString enumeration issue in IE <= 8
    if (hasNegativeMonthYearBug || hasToStringFormatBug) {
        Date.prototype.toString = function toString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            var hour = this.getHours();
            var minute = this.getMinutes();
            var second = this.getSeconds();
            var timezoneOffset = this.getTimezoneOffset();
            var hoursOffset = Math.floor(Math.abs(timezoneOffset) / 60);
            var minutesOffset = Math.floor(Math.abs(timezoneOffset) % 60);
            return dayName[day] + ' ' +
                monthName[month] + ' ' +
                (date < 10 ? '0' + date : date) + ' ' +
                year + ' ' +
                (hour < 10 ? '0' + hour : hour) + ':' +
                (minute < 10 ? '0' + minute : minute) + ':' +
                (second < 10 ? '0' + second : second) + ' GMT' +
                (timezoneOffset > 0 ? '-' : '+') +
                (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset) +
                (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
        };
        if (supportsDescriptors) {
            $Object.defineProperty(Date.prototype, 'toString', {
                configurable: true,
                enumerable: false,
                writable: true
            });
        }
    }

    // ES5 15.9.5.43
    // http://es5.github.com/#x15.9.5.43
    // This function returns a String value represent the instance in time
    // represented by this Date object. The format of the String is the Date Time
    // string format defined in 15.9.1.15. All fields are present in the String.
    // The time zone is always UTC, denoted by the suffix Z. If the time value of
    // this object is not a finite Number a RangeError exception is thrown.
    var negativeDate = -62198755200000;
    var negativeYearString = '-000001';
    var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
    var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

    var getTime = call.bind(Date.prototype.getTime);

    defineProperties(Date.prototype, {
        toISOString: function toISOString() {
            if (!isFinite(this) || !isFinite(getTime(this))) {
                // Adope Photoshop requires the second check.
                throw new RangeError('Date.prototype.toISOString called on non-finite value.');
            }

            var year = originalGetUTCFullYear(this);

            var month = originalGetUTCMonth(this);
            // see https://github.com/es-shims/es5-shim/issues/111
            year += Math.floor(month / 12);
            month = (month % 12 + 12) % 12;

            // the date time string format is specified in 15.9.1.15.
            var result = [month + 1, originalGetUTCDate(this), originalGetUTCHours(this), originalGetUTCMinutes(this), originalGetUTCSeconds(this)];
            year = (
                (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
                strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
            );

            for (var i = 0; i < result.length; ++i) {
                // pad months, days, hours, minutes, and seconds to have two digits.
                result[i] = strSlice('00' + result[i], -2);
            }
            // pad milliseconds to have three digits.
            return (
                year + '-' + arraySlice(result, 0, 2).join('-') +
                'T' + arraySlice(result, 2).join(':') + '.' +
                strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
            );
        }
    }, hasNegativeDateBug || hasSafari51DateBug);

    // ES5 15.9.5.44
    // http://es5.github.com/#x15.9.5.44
    // This function provides a String representation of a Date object for use by
    // JSON.stringify (15.12.3).
    var dateToJSONIsSupported = (function () {
        try {
            return Date.prototype.toJSON &&
                new Date(NaN).toJSON() === null &&
                new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
                Date.prototype.toJSON.call({ // generic
                    toISOString: function () { return true; }
                });
        } catch (e) {
            return false;
        }
    }());
    if (!dateToJSONIsSupported) {
        Date.prototype.toJSON = function toJSON(key) {
            // When the toJSON method is called with argument key, the following
            // steps are taken:

            // 1.  Let O be the result of calling ToObject, giving it the this
            // value as its argument.
            // 2. Let tv be ES.ToPrimitive(O, hint Number).
            var O = $Object(this);
            var tv = ES.ToPrimitive(O);
            // 3. If tv is a Number and is not finite, return null.
            if (typeof tv === 'number' && !isFinite(tv)) {
                return null;
            }
            // 4. Let toISO be the result of calling the [[Get]] internal method of
            // O with argument "toISOString".
            var toISO = O.toISOString;
            // 5. If IsCallable(toISO) is false, throw a TypeError exception.
            if (!isCallable(toISO)) {
                throw new TypeError('toISOString property is not callable');
            }
            // 6. Return the result of calling the [[Call]] internal method of
            //  toISO with O as the this value and an empty argument list.
            return toISO.call(O);

            // NOTE 1 The argument is ignored.

            // NOTE 2 The toJSON function is intentionally generic; it does not
            // require that its this value be a Date object. Therefore, it can be
            // transferred to other kinds of objects for use as a method. However,
            // it does require that any such object have a toISOString method. An
            // object is free to use the argument key to filter its
            // stringification.
        };
    }

    // ES5 15.9.4.2
    // http://es5.github.com/#x15.9.4.2
    // based on work shared by Daniel Friesen (dantman)
    // http://gist.github.com/303249
    var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
    var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
    var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
    if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
        // XXX global assignment won't work in embeddings that use
        // an alternate object for the context.
        /* global Date: true */
        /* eslint-disable no-undef */
        var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
        var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
        /* eslint-disable no-implicit-globals */
        Date = (function (NativeDate) {
        /* eslint-enable no-implicit-globals */
        /* eslint-enable no-undef */
            // Date.length === 7
            var DateShim = function Date(Y, M, D, h, m, s, ms) {
                var length = arguments.length;
                var date;
                if (this instanceof NativeDate) {
                    var seconds = s;
                    var millis = ms;
                    if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
                        // work around a Safari 8/9 bug where it treats the seconds as signed
                        var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                        var sToShift = Math.floor(msToShift / 1e3);
                        seconds += sToShift;
                        millis -= sToShift * 1e3;
                    }
                    date = length === 1 && $String(Y) === Y ? // isString(Y)
                        // We explicitly pass it through parse:
                        new NativeDate(DateShim.parse(Y)) :
                        // We have to manually make calls depending on argument
                        // length here
                        length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) :
                        length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) :
                        length >= 5 ? new NativeDate(Y, M, D, h, m) :
                        length >= 4 ? new NativeDate(Y, M, D, h) :
                        length >= 3 ? new NativeDate(Y, M, D) :
                        length >= 2 ? new NativeDate(Y, M) :
                        length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y) :
                                      new NativeDate();
                } else {
                    date = NativeDate.apply(this, arguments);
                }
                if (!isPrimitive(date)) {
                    // Prevent mixups with unfixed Date object
                    defineProperties(date, { constructor: DateShim }, true);
                }
                return date;
            };

            // 15.9.1.15 Date Time String Format.
            var isoDateExpression = new RegExp('^' +
                '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
                                          // 6-digit extended year
                '(?:-(\\d{2})' + // optional month capture
                '(?:-(\\d{2})' + // optional day capture
                '(?:' + // capture hours:minutes:seconds.milliseconds
                    'T(\\d{2})' + // hours capture
                    ':(\\d{2})' + // minutes capture
                    '(?:' + // optional :seconds.milliseconds
                        ':(\\d{2})' + // seconds capture
                        '(?:(\\.\\d{1,}))?' + // milliseconds capture
                    ')?' +
                '(' + // capture UTC offset component
                    'Z|' + // UTC capture
                    '(?:' + // offset specifier +/-hours:minutes
                        '([-+])' + // sign capture
                        '(\\d{2})' + // hours offset capture
                        ':(\\d{2})' + // minutes offset capture
                    ')' +
                ')?)?)?)?' +
            '$');

            var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

            var dayFromMonth = function dayFromMonth(year, month) {
                var t = month > 1 ? 1 : 0;
                return (
                    months[month] +
                    Math.floor((year - 1969 + t) / 4) -
                    Math.floor((year - 1901 + t) / 100) +
                    Math.floor((year - 1601 + t) / 400) +
                    365 * (year - 1970)
                );
            };

            var toUTC = function toUTC(t) {
                var s = 0;
                var ms = t;
                if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
                    // work around a Safari 8/9 bug where it treats the seconds as signed
                    var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                    var sToShift = Math.floor(msToShift / 1e3);
                    s += sToShift;
                    ms -= sToShift * 1e3;
                }
                return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
            };

            // Copy any custom methods a 3rd party library may have added
            for (var key in NativeDate) {
                if (owns(NativeDate, key)) {
                    DateShim[key] = NativeDate[key];
                }
            }

            // Copy "native" methods explicitly; they may be non-enumerable
            defineProperties(DateShim, {
                now: NativeDate.now,
                UTC: NativeDate.UTC
            }, true);
            DateShim.prototype = NativeDate.prototype;
            defineProperties(DateShim.prototype, {
                constructor: DateShim
            }, true);

            // Upgrade Date.parse to handle simplified ISO 8601 strings
            var parseShim = function parse(string) {
                var match = isoDateExpression.exec(string);
                if (match) {
                    // parse months, days, hours, minutes, seconds, and milliseconds
                    // provide default values if necessary
                    // parse the UTC offset component
                    var year = $Number(match[1]),
                        month = $Number(match[2] || 1) - 1,
                        day = $Number(match[3] || 1) - 1,
                        hour = $Number(match[4] || 0),
                        minute = $Number(match[5] || 0),
                        second = $Number(match[6] || 0),
                        millisecond = Math.floor($Number(match[7] || 0) * 1000),
                        // When time zone is missed, local offset should be used
                        // (ES 5.1 bug)
                        // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                        isLocalTime = Boolean(match[4] && !match[8]),
                        signOffset = match[9] === '-' ? 1 : -1,
                        hourOffset = $Number(match[10] || 0),
                        minuteOffset = $Number(match[11] || 0),
                        result;
                    var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
                    if (
                        hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
                        minute < 60 && second < 60 && millisecond < 1000 &&
                        month > -1 && month < 12 && hourOffset < 24 &&
                        minuteOffset < 60 && // detect invalid offsets
                        day > -1 &&
                        day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
                    ) {
                        result = (
                            (dayFromMonth(year, month) + day) * 24 +
                            hour +
                            hourOffset * signOffset
                        ) * 60;
                        result = (
                            (result + minute + minuteOffset * signOffset) * 60 +
                            second
                        ) * 1000 + millisecond;
                        if (isLocalTime) {
                            result = toUTC(result);
                        }
                        if (-8.64e15 <= result && result <= 8.64e15) {
                            return result;
                        }
                    }
                    return NaN;
                }
                return NativeDate.parse.apply(this, arguments);
            };
            defineProperties(DateShim, { parse: parseShim });

            return DateShim;
        }(Date));
        /* global Date: false */
    }

    // ES5 15.9.4.4
    // http://es5.github.com/#x15.9.4.4
    if (!Date.now) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }

    //
    // Number
    // ======
    //

    // ES5.1 15.7.4.5
    // http://es5.github.com/#x15.7.4.5
    var hasToFixedBugs = NumberPrototype.toFixed && (
      (0.00008).toFixed(3) !== '0.000' ||
      (0.9).toFixed(0) !== '1' ||
      (1.255).toFixed(2) !== '1.25' ||
      (1000000000000000128).toFixed(0) !== '1000000000000000128'
    );

    var toFixedHelpers = {
        base: 1e7,
        size: 6,
        data: [0, 0, 0, 0, 0, 0],
        multiply: function multiply(n, c) {
            var i = -1;
            var c2 = c;
            while (++i < toFixedHelpers.size) {
                c2 += n * toFixedHelpers.data[i];
                toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
                c2 = Math.floor(c2 / toFixedHelpers.base);
            }
        },
        divide: function divide(n) {
            var i = toFixedHelpers.size;
            var c = 0;
            while (--i >= 0) {
                c += toFixedHelpers.data[i];
                toFixedHelpers.data[i] = Math.floor(c / n);
                c = (c % n) * toFixedHelpers.base;
            }
        },
        numToString: function numToString() {
            var i = toFixedHelpers.size;
            var s = '';
            while (--i >= 0) {
                if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
                    var t = $String(toFixedHelpers.data[i]);
                    if (s === '') {
                        s = t;
                    } else {
                        s += strSlice('0000000', 0, 7 - t.length) + t;
                    }
                }
            }
            return s;
        },
        pow: function pow(x, n, acc) {
            return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
        },
        log: function log(x) {
            var n = 0;
            var x2 = x;
            while (x2 >= 4096) {
                n += 12;
                x2 /= 4096;
            }
            while (x2 >= 2) {
                n += 1;
                x2 /= 2;
            }
            return n;
        }
    };

    var toFixedShim = function toFixed(fractionDigits) {
        var f, x, s, m, e, z, j, k;

        // Test for NaN and round fractionDigits down
        f = $Number(fractionDigits);
        f = isActualNaN(f) ? 0 : Math.floor(f);

        if (f < 0 || f > 20) {
            throw new RangeError('Number.toFixed called with invalid number of decimals');
        }

        x = $Number(this);

        if (isActualNaN(x)) {
            return 'NaN';
        }

        // If it is too big or small, return the string value of the number
        if (x <= -1e21 || x >= 1e21) {
            return $String(x);
        }

        s = '';

        if (x < 0) {
            s = '-';
            x = -x;
        }

        m = '0';

        if (x > 1e-21) {
            // 1e-21 < x < 1e21
            // -70 < log2(x) < 70
            e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
            z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
            z *= 0x10000000000000; // Math.pow(2, 52);
            e = 52 - e;

            // -18 < e < 122
            // x = z / 2 ^ e
            if (e > 0) {
                toFixedHelpers.multiply(0, z);
                j = f;

                while (j >= 7) {
                    toFixedHelpers.multiply(1e7, 0);
                    j -= 7;
                }

                toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
                j = e - 1;

                while (j >= 23) {
                    toFixedHelpers.divide(1 << 23);
                    j -= 23;
                }

                toFixedHelpers.divide(1 << j);
                toFixedHelpers.multiply(1, 1);
                toFixedHelpers.divide(2);
                m = toFixedHelpers.numToString();
            } else {
                toFixedHelpers.multiply(0, z);
                toFixedHelpers.multiply(1 << (-e), 0);
                m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
            }
        }

        if (f > 0) {
            k = m.length;

            if (k <= f) {
                m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
            } else {
                m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
            }
        } else {
            m = s + m;
        }

        return m;
    };
    defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

    var hasToPrecisionUndefinedBug = (function () {
        try {
            return 1.0.toPrecision(undefined) === '1';
        } catch (e) {
            return true;
        }
    }());
    var originalToPrecision = NumberPrototype.toPrecision;
    defineProperties(NumberPrototype, {
        toPrecision: function toPrecision(precision) {
            return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
        }
    }, hasToPrecisionUndefinedBug);

    //
    // String
    // ======
    //

    // ES5 15.5.4.14
    // http://es5.github.com/#x15.5.4.14

    // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
    // Many browsers do not split properly with regular expressions or they
    // do not perform the split correctly under obscure conditions.
    // See http://blog.stevenlevithan.com/archives/cross-browser-split
    // I've tested in many browsers and this seems to cover the deviant ones:
    //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
    //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
    //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
    //       [undefined, "t", undefined, "e", ...]
    //    ''.split(/.?/) should be [], not [""]
    //    '.'.split(/()()/) should be ["."], not ["", "", "."]

    if (
        'ab'.split(/(?:ab)*/).length !== 2 ||
        '.'.split(/(.?)(.?)/).length !== 4 ||
        'tesst'.split(/(s)*/)[1] === 't' ||
        'test'.split(/(?:)/, -1).length !== 4 ||
        ''.split(/.?/).length ||
        '.'.split(/()()/).length > 1
    ) {
        (function () {
            var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
            var maxSafe32BitInt = Math.pow(2, 32) - 1;

            StringPrototype.split = function (separator, limit) {
                var string = String(this);
                if (typeof separator === 'undefined' && limit === 0) {
                    return [];
                }

                // If `separator` is not a regex, use native split
                if (!isRegex(separator)) {
                    return strSplit(this, separator, limit);
                }

                var output = [];
                var flags = (separator.ignoreCase ? 'i' : '') +
                            (separator.multiline ? 'm' : '') +
                            (separator.unicode ? 'u' : '') + // in ES6
                            (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
                    lastLastIndex = 0,
                    // Make `global` and avoid `lastIndex` issues by working with a copy
                    separator2, match, lastIndex, lastLength;
                var separatorCopy = new RegExp(separator.source, flags + 'g');
                if (!compliantExecNpcg) {
                    // Doesn't need flags gy, but they don't hurt
                    separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
                }
                /* Values for `limit`, per the spec:
                 * If undefined: 4294967295 // maxSafe32BitInt
                 * If 0, Infinity, or NaN: 0
                 * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
                 * If negative number: 4294967296 - Math.floor(Math.abs(limit))
                 * If other: Type-convert, then use the above rules
                 */
                var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
                match = separatorCopy.exec(string);
                while (match) {
                    // `separatorCopy.lastIndex` is not reliable cross-browser
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        pushCall(output, strSlice(string, lastLastIndex, match.index));
                        // Fix browsers whose `exec` methods don't consistently return `undefined` for
                        // nonparticipating capturing groups
                        if (!compliantExecNpcg && match.length > 1) {
                            /* eslint-disable no-loop-func */
                            match[0].replace(separator2, function () {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (typeof arguments[i] === 'undefined') {
                                        match[i] = void 0;
                                    }
                                }
                            });
                            /* eslint-enable no-loop-func */
                        }
                        if (match.length > 1 && match.index < string.length) {
                            array_push.apply(output, arraySlice(match, 1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= splitLimit) {
                            break;
                        }
                    }
                    if (separatorCopy.lastIndex === match.index) {
                        separatorCopy.lastIndex++; // Avoid an infinite loop
                    }
                    match = separatorCopy.exec(string);
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separatorCopy.test('')) {
                        pushCall(output, '');
                    }
                } else {
                    pushCall(output, strSlice(string, lastLastIndex));
                }
                return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
            };
        }());

    // [bugfix, chrome]
    // If separator is undefined, then the result array contains just one String,
    // which is the this value (converted to a String). If limit is not undefined,
    // then the output array is truncated so that it contains no more than limit
    // elements.
    // "0".split(undefined, 0) -> []
    } else if ('0'.split(void 0, 0).length) {
        StringPrototype.split = function split(separator, limit) {
            if (typeof separator === 'undefined' && limit === 0) {
                return [];
            }
            return strSplit(this, separator, limit);
        };
    }

    var str_replace = StringPrototype.replace;
    var replaceReportsGroupsCorrectly = (function () {
        var groups = [];
        'x'.replace(/x(.)?/g, function (match, group) {
            pushCall(groups, group);
        });
        return groups.length === 1 && typeof groups[0] === 'undefined';
    }());

    if (!replaceReportsGroupsCorrectly) {
        StringPrototype.replace = function replace(searchValue, replaceValue) {
            var isFn = isCallable(replaceValue);
            var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
            if (!isFn || !hasCapturingGroups) {
                return str_replace.call(this, searchValue, replaceValue);
            } else {
                var wrappedReplaceValue = function (match) {
                    var length = arguments.length;
                    var originalLastIndex = searchValue.lastIndex;
                    searchValue.lastIndex = 0;
                    var args = searchValue.exec(match) || [];
                    searchValue.lastIndex = originalLastIndex;
                    pushCall(args, arguments[length - 2], arguments[length - 1]);
                    return replaceValue.apply(this, args);
                };
                return str_replace.call(this, searchValue, wrappedReplaceValue);
            }
        };
    }

    // ECMA-262, 3rd B.2.3
    // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
    // non-normative section suggesting uniform semantics and it should be
    // normalized across all browsers
    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
    var string_substr = StringPrototype.substr;
    var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
    defineProperties(StringPrototype, {
        substr: function substr(start, length) {
            var normalizedStart = start;
            if (start < 0) {
                normalizedStart = max(this.length + start, 0);
            }
            return string_substr.call(this, normalizedStart, length);
        }
    }, hasNegativeSubstrBug);

    // ES5 15.5.4.20
    // whitespace from: http://es5.github.io/#x15.5.4.20
    var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
        '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
        '\u2029\uFEFF';
    var zeroWidth = '\u200b';
    var wsRegexChars = '[' + ws + ']';
    var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
    var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
    var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
    defineProperties(StringPrototype, {
        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
        // http://perfectionkills.com/whitespace-deviations/
        trim: function trim() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
        }
    }, hasTrimWhitespaceBug);
    var trim = call.bind(String.prototype.trim);

    var hasLastIndexBug = StringPrototype.lastIndexOf && 'abcあい'.lastIndexOf('あい', 2) !== -1;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var S = $String(this);
            var searchStr = $String(searchString);
            var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
            var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
            var start = min(max(pos, 0), S.length);
            var searchLen = searchStr.length;
            var k = start + searchLen;
            while (k > 0) {
                k = max(0, k - searchLen);
                var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
                if (index !== -1) {
                    return k + index;
                }
            }
            return -1;
        }
    }, hasLastIndexBug);

    var originalLastIndexOf = StringPrototype.lastIndexOf;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            return originalLastIndexOf.apply(this, arguments);
        }
    }, StringPrototype.lastIndexOf.length !== 1);

    // ES-5 15.1.2.2
    /* eslint-disable radix */
    if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
    /* eslint-enable radix */
        /* global parseInt: true */
        parseInt = (function (origParseInt) {
            var hexRegex = /^[\-+]?0[xX]/;
            return function parseInt(str, radix) {
                var string = trim(String(str));
                var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
                return origParseInt(string, defaultedRadix);
            };
        }(parseInt));
    }

    // https://es5.github.io/#x15.1.2.3
    if (1 / parseFloat('-0') !== -Infinity) {
        /* global parseFloat: true */
        parseFloat = (function (origParseFloat) {
            return function parseFloat(string) {
                var inputString = trim(String(string));
                var result = origParseFloat(inputString);
                return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
            };
        }(parseFloat));
    }

    if (String(new RangeError('test')) !== 'RangeError: test') {
        var errorToStringShim = function toString() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var name = this.name;
            if (typeof name === 'undefined') {
                name = 'Error';
            } else if (typeof name !== 'string') {
                name = $String(name);
            }
            var msg = this.message;
            if (typeof msg === 'undefined') {
                msg = '';
            } else if (typeof msg !== 'string') {
                msg = $String(msg);
            }
            if (!name) {
                return msg;
            }
            if (!msg) {
                return name;
            }
            return name + ': ' + msg;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        Error.prototype.toString = errorToStringShim;
    }

    if (supportsDescriptors) {
        var ensureNonEnumerable = function (obj, prop) {
            if (isEnum(obj, prop)) {
                var desc = Object.getOwnPropertyDescriptor(obj, prop);
                if (desc.configurable) {
                    desc.enumerable = false;
                    Object.defineProperty(obj, prop, desc);
                }
            }
        };
        ensureNonEnumerable(Error.prototype, 'message');
        if (Error.prototype.message !== '') {
            Error.prototype.message = '';
        }
        ensureNonEnumerable(Error.prototype, 'name');
    }

    if (String(/a/mig) !== '/a/gim') {
        var regexToString = function toString() {
            var str = '/' + this.source + '/';
            if (this.global) {
                str += 'g';
            }
            if (this.ignoreCase) {
                str += 'i';
            }
            if (this.multiline) {
                str += 'm';
            }
            return str;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        RegExp.prototype.toString = regexToString;
    }
}));

},{}],8:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.2.1
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }
    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
      var parent = this;

      var child = new this.constructor(lib$es6$promise$$internal$$noop);

      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
        lib$es6$promise$$internal$$makePromise(child);
      }

      var state = parent._state;

      if (state) {
        var callback = arguments[state - 1];
        lib$es6$promise$asap$$asap(function(){
          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
        });
      } else {
        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
      }

      return child;
    }
    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
      if (maybeThenable.constructor === promise.constructor &&
          then === lib$es6$promise$then$$default &&
          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    var lib$es6$promise$$internal$$id = 0;
    function lib$es6$promise$$internal$$nextId() {
      return lib$es6$promise$$internal$$id++;
    }

    function lib$es6$promise$$internal$$makePromise(promise) {
      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
      promise._state = undefined;
      promise._result = undefined;
      promise._subscribers = [];
    }

    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      if (!lib$es6$promise$utils$$isArray(entries)) {
        return new Constructor(function(resolve, reject) {
          reject(new TypeError('You must pass an array to race.'));
        });
      } else {
        return new Constructor(function(resolve, reject) {
          var length = entries.length;
          for (var i = 0; i < length; i++) {
            Constructor.resolve(entries[i]).then(resolve, reject);
          }
        });
      }
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;


    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
      this._result = this._state = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      })['catch'](function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: lib$es6$promise$then$$default,

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor()['catch'](function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
        lib$es6$promise$$internal$$makePromise(this.promise);
      }

      if (lib$es6$promise$utils$$isArray(input)) {
        this._input     = input;
        this.length     = input.length;
        this._remaining = input.length;

        this._result = new Array(this.length);

        if (this.length === 0) {
          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate();
          if (this._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
      }
    }

    function lib$es6$promise$enumerator$$validationError() {
      return new Error('Array Methods must be provided an Array');
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var length  = this.length;
      var input   = this._input;

      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        this._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var c = this._instanceConstructor;
      var resolve = c.resolve;

      if (resolve === lib$es6$promise$promise$resolve$$default) {
        var then = lib$es6$promise$$internal$$getThen(entry);

        if (then === lib$es6$promise$then$$default &&
            entry._state !== lib$es6$promise$$internal$$PENDING) {
          this._settledAt(entry._state, i, entry._result);
        } else if (typeof then !== 'function') {
          this._remaining--;
          this._result[i] = entry;
        } else if (c === lib$es6$promise$promise$$default) {
          var promise = new c(lib$es6$promise$$internal$$noop);
          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
          this._willSettleAt(promise, i);
        } else {
          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
        }
      } else {
        this._willSettleAt(resolve(entry), i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var promise = this.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        this._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          this._result[i] = value;
        }
      }

      if (this._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, this._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":9}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],10:[function(require,module,exports){
"use strict";
var promiseExtensions_1 = require("./../helpers/promiseExtensions");
var activityManagementAPI_1 = require("./activityManagementAPI");
var activityAGM_1 = require("../core/activityAGM");
var ActivityAPI = (function () {
    function ActivityAPI(manager, my) {
        this.version = "2.1.7";
        this._manager = manager;
        this._my = my;
        this.all = new activityManagementAPI_1.ActivityManagementAPI(manager, my);
    }
    ActivityAPI.prototype.ready = function (callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this._manager.ready()
                .then(function () {
                resolve(_this);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    Object.defineProperty(ActivityAPI.prototype, "my", {
        get: function () {
            return this._my;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "aware", {
        get: function () {
            return this._my.window !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "inActivity", {
        get: function () {
            return this.aware && this._my.activity !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityAPI.prototype, "agm", {
        get: function () {
            if (!this.aware) {
                return undefined;
            }
            if (!this.inActivity) {
                return new activityAGM_1.ActivityAGM(null);
            }
            return this._my.activity.agm;
        },
        enumerable: true,
        configurable: true
    });
    return ActivityAPI;
}());
exports.ActivityAPI = ActivityAPI;

},{"../core/activityAGM":18,"./../helpers/promiseExtensions":29,"./activityManagementAPI":11}],11:[function(require,module,exports){
"use strict";
var util = require("./../helpers/util");
var ActivityManagementAPI = (function () {
    function ActivityManagementAPI(manager, my) {
        this._manager = manager;
        this._my = my;
        this.activityTypes = {
            get: this._getActivityTypesWrapper.bind(this),
            register: this._manager.registerActivityType.bind(this._manager),
            unregister: this._manager.unregisterActivityType.bind(this._manager),
            subscribe: this._manager.subscribeActivityTypeEvents.bind(this._manager),
            unsubscribe: undefined,
            initiate: this._manager.initiate.bind(this._manager)
        };
        this.windowTypes = {
            get: this._getWindowTypesWrapper.bind(this),
            registerFactory: this._manager.registerWindowFactory.bind(this._manager),
            unregisterFactory: this._manager.unregisterWindowFactory.bind(this._manager),
            subscribe: this._manager.subscribeWindowTypeEvents.bind(this._manager),
            unsubscribe: undefined
        };
        this.windows = {
            get: this._manager.getWindows.bind(this._manager),
            subscribe: this._manager.subscribeWindowEvents.bind(this._manager),
            announce: this._manager.announceWindow.bind(this._manager),
            unsubscribe: undefined,
            create: this._manager.createWindow.bind(this._manager)
        };
        this.instances = {
            get: this._manager.getActivities.bind(this._manager),
            subscribe: this._manager.subscribeActivityEvents.bind(this._manager),
            unsubscribe: undefined
        };
    }
    ActivityManagementAPI.prototype._getActivityTypesWrapper = function (name) {
        if (util.isUndefined(name)) {
            return this._manager.getActivityTypes();
        }
        return this._manager.getActivityType(name);
    };
    ActivityManagementAPI.prototype._getWindowTypesWrapper = function (name) {
        if (util.isUndefined(name)) {
            return this._manager.getWindowTypes();
        }
        return this._manager.getWindowType(name);
    };
    return ActivityManagementAPI;
}());
exports.ActivityManagementAPI = ActivityManagementAPI;

},{"./../helpers/util":31}],12:[function(require,module,exports){
"use strict";
var logger_1 = require("./../helpers/logger");
var util = require("./../helpers/util");
var ActivityMy = (function () {
    function ActivityMy(manager) {
        var _this = this;
        this._myActivityJoinedCallbacks = [];
        this._myActivityRemovedCallbacks = [];
        this._myContextUpdateCallbacks = [];
        this._logger = logger_1.Logger.Get(this);
        this._manager = manager;
        manager.ready()
            .then(function (am) {
            am.subscribeActivityContextChanged(_this._subscribeMyContextChanged.bind(_this));
            am.subscribeWindowEvents(_this._subscribeMyWindowEvent.bind(_this));
        });
    }
    Object.defineProperty(ActivityMy.prototype, "window", {
        get: function () {
            if (util.isUndefinedOrNull(this._window)) {
                var announcedWindows = this._manager.announcedWindows;
                if (announcedWindows.length > 0) {
                    this._window = announcedWindows[0];
                }
            }
            return this._window;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityMy.prototype, "activity", {
        get: function () {
            var myWin = this.window;
            if (util.isUndefinedOrNull(myWin)) {
                return undefined;
            }
            return myWin.activity;
        },
        enumerable: true,
        configurable: true
    });
    ActivityMy.prototype.createWindow = function (windowType) {
        return this._manager.createWindow(this.activity, windowType);
    };
    Object.defineProperty(ActivityMy.prototype, "context", {
        get: function () {
            var activity = this.activity;
            if (util.isUndefined(activity)) {
                return {};
            }
            return activity.context;
        },
        enumerable: true,
        configurable: true
    });
    ActivityMy.prototype.onActivityJoined = function (callback) {
        this._myActivityJoinedCallbacks.push(callback);
        var myWin = this.window;
        if (!util.isUndefinedOrNull(myWin) && !util.isUndefinedOrNull(myWin.activity)) {
            callback(myWin.activity);
        }
    };
    ActivityMy.prototype.onActivityLeft = function (callback) {
        this._myActivityRemovedCallbacks.push(callback);
    };
    ActivityMy.prototype.onContextChanged = function (callback) {
        this._myContextUpdateCallbacks.push(callback);
        var myWin = this.window;
        if (util.isUndefinedOrNull(myWin)) {
            return;
        }
        var activity = myWin.activity;
        if (util.isUndefinedOrNull(activity)) {
            return;
        }
        callback(activity.context, activity.context, [], activity);
    };
    ActivityMy.prototype._subscribeMyContextChanged = function (activity, context, delta, removed) {
        var myWin = this.window;
        if (util.isUndefinedOrNull(myWin)) {
            return;
        }
        var myActivity = myWin.activity;
        if (util.isUndefinedOrNull(myActivity)) {
            return;
        }
        if (activity.id !== myActivity.id) {
            return;
        }
        this._notifyMyContextChanged(activity, context, delta, removed);
    };
    ActivityMy.prototype._subscribeMyWindowEvent = function (activity, window, event) {
        if (util.isUndefinedOrNull(this.window)) {
            return;
        }
        if (this.window.id !== window.id) {
            return;
        }
        if (event === "joined") {
            this._notifyOnJoined(activity);
        }
        else {
            this._notifyMyWindowEvent(activity, this._myActivityRemovedCallbacks);
        }
    };
    ActivityMy.prototype._notifyMyWindowEvent = function (activity, callbackStore) {
        for (var index = 0; index < callbackStore.length; index++) {
            var element = callbackStore[index];
            try {
                element(activity, event);
            }
            catch (e) {
                this._logger.warn('error in user callback ' + e);
            }
        }
    };
    ActivityMy.prototype._notifyMyContextChanged = function (activity, context, delta, removed) {
        delta = delta || {};
        removed = removed || [];
        for (var index = 0; index < this._myContextUpdateCallbacks.length; index++) {
            var element = this._myContextUpdateCallbacks[index];
            try {
                element(context, delta, removed, activity);
            }
            catch (e) {
                this._logger.warn('error in user callback ' + e);
            }
        }
    };
    ActivityMy.prototype._notifyOnJoined = function (activity) {
        this._notifyMyWindowEvent(activity, this._myActivityJoinedCallbacks);
        this._notifyMyContextChanged(activity, activity.context);
    };
    return ActivityMy;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityMy;

},{"./../helpers/logger":28,"./../helpers/util":31}],13:[function(require,module,exports){
"use strict";
var ActivityConfig = (function () {
    function ActivityConfig() {
    }
    return ActivityConfig;
}());
exports.ActivityConfig = ActivityConfig;

},{}],14:[function(require,module,exports){
"use strict";
require("es6-promise");
var hcBridge_1 = require("./bridges/hcBridge");
var activityManager_1 = require("./core/activityManager");
var activityMyAPI_1 = require("./API/activityMyAPI");
var logger_1 = require("./helpers/logger");
var util = require("./helpers/util");
var activityConfig_1 = require("./activityConfig");
var activityAPI_1 = require("./API/activityAPI");
var activityAGM_1 = require("./core/activityAGM");
var activity = function (config) {
    config = config || new activityConfig_1.ActivityConfig;
    if (!util.isUndefined(config.logLevel)) {
        logger_1.Logger.Level = config.logLevel;
    }
    if (!util.isUndefinedOrNull(config.logger)) {
        logger_1.Logger.GlueLogger = config.logger;
    }
    var bridge;
    if (!util.isUndefined(window.htmlContainer)) {
        bridge = new hcBridge_1['default']();
    }
    else {
        throw new Error("Activity not supported in in browser");
    }
    if (!bridge) {
        throw new Error("A bridge to native activity is needed to create activity lib.");
    }
    activityAGM_1.ActivityAGM.AGM = config.agm;
    var activityManager = new activityManager_1['default'](bridge, !config.disableAutoAnnounce);
    var my = new activityMyAPI_1['default'](activityManager);
    return new activityAPI_1.ActivityAPI(activityManager, my);
};
module.exports = activity;

},{"./API/activityAPI":10,"./API/activityMyAPI":12,"./activityConfig":13,"./bridges/hcBridge":15,"./core/activityAGM":18,"./core/activityManager":19,"./helpers/logger":28,"./helpers/util":31,"es6-promise":8}],15:[function(require,module,exports){
"use strict";
var entityEvent_1 = require("../contracts/entityEvent");
var activityStatus_1 = require("../contracts/activityStatus");
var activityType_1 = require("../entities/activityType");
var windowType_1 = require("../entities/windowType");
var activity_1 = require("../entities/activity");
var activityWindow_1 = require("../entities/activityWindow");
var proxyWindowFactory_1 = require("../core/proxyWindowFactory");
var logger_1 = require("../helpers/logger");
var entityEvent_2 = require("../contracts/entityEvent");
var readyMarker_1 = require("../helpers/readyMarker");
var util = require("../helpers/util");
var entityEvent_3 = require("../contracts/entityEvent");
var HCBridge = (function () {
    function HCBridge(agm) {
        this._activityTypeEntityName = "activityType";
        this._windowTypeEntityName = "windowType";
        this._activityEntityName = "activity";
        this._windowEntityName = "activityWindow";
        this._logger = logger_1.Logger.Get(this);
        this._lastSeq = 0;
        this._eventQueue = [];
        this._activityTypeCallbacks = [];
        this._windowTypeCallbacks = [];
        this._activityCallbacks = [];
        this._windowCallbacks = [];
        this._agm = agm;
    }
    HCBridge.prototype.init = function () {
        var _this = this;
        this._readyMarker = new readyMarker_1.ReadyMarker("HC Bridge", 1);
        this._htmlContainer = window.htmlContainer.activityFacade;
        this._htmlContainer.init(this._agm ? this._agm.instance : undefined, this._hcEventHandler.bind(this), function () {
            _this._readyMarker.signal("Init done from HC");
        }, function (error) {
            _this._readyMarker.error(error);
        });
    };
    HCBridge.prototype.ready = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._readyMarker.setCallback(function (err) {
                if (!err) {
                    resolve(_this);
                }
                else {
                    _this._logger.error("Error initializing HC bridge - " + err);
                    reject(_this._readyMarker.getError());
                }
            });
        });
    };
    HCBridge.prototype._hcEventHandler = function (eventJson) {
        this._logger.trace(eventJson);
        var event = JSON.parse(eventJson);
        this._processEventBySeq(event);
    };
    HCBridge.prototype._processEventBySeq = function (event) {
        var seq = event.sequence;
        if (seq === this._lastSeq + 1) {
            this._processEvent(event);
            this._lastSeq++;
            var nextEvent = this._eventQueue[seq + 1];
            if (!util.isUndefined(nextEvent)) {
                this._logger.debug("replaying message number " + seq);
                this._processEventBySeq(nextEvent);
                delete this._eventQueue[seq + 1];
            }
        }
        else {
            this._eventQueue[seq] = event;
            this._logger.debug("Got out of order event with number " + seq + ". Will wait for previous event(s) before replaying.");
        }
    };
    HCBridge.prototype._processEvent = function (event) {
        var entityType = event.entityType;
        var eventContext = this._convertContext(event.context);
        var entity;
        switch (entityType) {
            case this._activityTypeEntityName:
                entity = HCBridge._hcToJsActivityType(event.entity);
                this._publishActivityTypeStatusChange(entity, eventContext);
                break;
            case this._windowTypeEntityName:
                entity = this._hcToJsWindowType(event.entity);
                this._publishWindowTypeStatusChange(entity, eventContext);
                break;
            case this._activityEntityName:
                entity = this._hcToJsActivity(event.entity);
                this._publishActivityStatusChange(entity, eventContext);
                break;
            case this._windowEntityName:
                entity = HCBridge._hcToJsWindow(event.entity);
                this._publishActivityWindowEvent(entity, eventContext);
                break;
        }
    };
    HCBridge.prototype._convertContext = function (hcContext) {
        if (hcContext.type === entityEvent_1.EntityEventType.StatusChange) {
            var oldStatus = new activityStatus_1.ActivityStatus(hcContext.oldStatus.state, hcContext.oldStatus.statusMessage, hcContext.oldStatus.statusTime);
            var newStatus = new activityStatus_1.ActivityStatus(hcContext.newStatus.state, hcContext.newStatus.statusMessage, hcContext.newStatus.statusTime);
            return new entityEvent_1.EntityStatusChangeEventContext(newStatus, oldStatus);
        }
        else if (hcContext.type === entityEvent_1.EntityEventType.ActivityWindowEvent) {
            var act = this._hcToJsActivity(hcContext.activity);
            return new entityEvent_1.EntityActivityWindowEventContext(act, hcContext.event);
        }
        else if (hcContext.type === entityEvent_1.EntityEventType.ActivityContextChange) {
            return new entityEvent_3.ActivityContextChangedContext(hcContext.newContext, hcContext.updated, hcContext.removed);
        }
        return new entityEvent_1.EntityEventContext(hcContext.type);
    };
    HCBridge._hcToJsWindow = function (hcWindow) {
        return new activityWindow_1['default'](hcWindow.id, hcWindow.name, hcWindow.type, hcWindow.activityId, hcWindow.instance, hcWindow.isIndependent);
    };
    HCBridge.prototype._hcToJsActivity = function (hcAct) {
        var window = hcAct.owner ? HCBridge._hcToJsWindow(hcAct.owner) : null;
        var status = new activityStatus_1.ActivityStatus(hcAct.status.state, hcAct.status.statusMessage, hcAct.status.statusTime);
        var helperWindows = hcAct.windows ? hcAct.windows.map(function (w) { return HCBridge._hcToJsWindow(w); }) : [];
        var context = JSON.parse(hcAct.context);
        return new activity_1['default'](hcAct.id, hcAct.type.name, status, context, window, helperWindows);
    };
    HCBridge._hcToJsActivityType = function (hcActType) {
        return new activityType_1['default'](hcActType.name, hcActType.ownerWindowType, hcActType.helperWindowTypes, hcActType.description);
    };
    HCBridge.prototype._hcToJsWindowType = function (hcWinType) {
        if (util.isUndefined(hcWinType.factories)) {
            hcWinType.factories = [];
        }
        var factories = hcWinType.factories.map(function (f) {
            return HCBridge._hcToJsWindowTypeFactory(f);
        });
        return new windowType_1['default'](hcWinType.name, factories);
    };
    HCBridge._hcToJsWindowTypeFactory = function (hcWinTypeFactory) {
        return new proxyWindowFactory_1.ProxyWindowFactory(hcWinTypeFactory.description);
    };
    HCBridge._getURLParameter = function (name) {
        return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.search) || [, ""])[1].replace(/\+/g, '%20')) || null;
    };
    HCBridge.prototype.getActivityTypes = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getActivityTypes(function (infos) {
                var result = [];
                for (var index = 0; index < infos.length; index++) {
                    var info = infos[index];
                    var newActivityType = HCBridge._hcToJsActivityType(info);
                    result.push(newActivityType);
                }
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.registerActivityType = function (activityTypeName, ownerWindow, helperWindows, layoutConfig, description) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (helperWindows === undefined) {
                helperWindows = [];
            }
            var config = {
                name: activityTypeName,
                ownerWindowType: ownerWindow,
                helperWindowTypes: helperWindows,
                description: description,
                layoutConfig: JSON.stringify(layoutConfig)
            };
            _this._htmlContainer.registerActivityType(JSON.stringify(config), function (info) {
                var newActivityType = HCBridge._hcToJsActivityType(info);
                resolve(newActivityType);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.unregisterActivityType = function (activityTypeName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.unregisterActivityType(activityTypeName, function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.getWindowTypes = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindowTypes(function (infos) {
                var result = [];
                for (var index = 0; index < infos.length; index++) {
                    var info = infos[index];
                    var newWindowType = _this._hcToJsWindowType(info);
                    result.push(newWindowType);
                }
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.registerWindowFactory = function (windowTypeName, factory) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowTypeName)) {
                reject("windowTypeName should be provided");
                return;
            }
            _this._htmlContainer.registerWindowFactory(windowTypeName, factory.create.bind(factory), function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.initiateActivity = function (activityType, context, callback) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activityType)) {
                reject("windowTypeName should be provided");
                return;
            }
            if (util.isUndefinedOrNull(context)) {
                context = {};
            }
            _this._htmlContainer.initiate(activityType, JSON.stringify(context), function (activityId) {
                resolve(activityId);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.getAnnouncementInfo = function () {
        var hc = window.htmlContainer;
        var context = hc.getContext();
        var result = { activityWindowId: "", activityWindowType: "", activityWindowIndependent: false, activityWindowName: "" };
        result.activityWindowType = context.activityWindowType;
        if (util.isUndefined(result.activityWindowType)) {
            result.activityWindowType = HCBridge._getURLParameter("activityWindowType");
        }
        result.activityWindowId = context.activityWindowId;
        if (util.isUndefined(result.activityWindowId)) {
            result.activityWindowId = HCBridge._getURLParameter("activityWindowId");
        }
        result.activityWindowIndependent = context.activityWindowIndependent;
        if (util.isUndefined(result.activityWindowIndependent)) {
        }
        result.activityWindowName = context.activityWindowName;
        if (util.isUndefined(result.activityWindowName)) {
            result.activityWindowName = HCBridge._getURLParameter("activityWindowName");
        }
        return result;
    };
    HCBridge.prototype.announceWindow = function (windowType, activityWindowId) {
        var _this = this;
        if (util.isUndefined(windowType)) {
            throw new Error("can not determine window type");
        }
        if (util.isUndefined(windowType)) {
            throw new Error("can not determine window activityWindowId");
        }
        this._htmlContainer.announceWindow(windowType, activityWindowId, function (error) {
            _this._logger.error("Error announcing activity window with id '" + activityWindowId + "'. " + error);
        });
    };
    HCBridge.prototype.getActivities = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._logger.trace("Executing getActivities()");
            _this._htmlContainer.getActivities(function (activitiesStr) {
                _this._logger.trace("Got getActivities() :" + activitiesStr);
                var activities = JSON.parse(activitiesStr);
                var result = activities.map(function (act) { return _this._hcToJsActivity(act); });
                resolve(result);
            }, function (error) {
                _this._logger.trace("Error in getActivities() :" + error);
                reject(error);
            });
        });
    };
    HCBridge.prototype.updateActivityContext = function (activity, context, fullReplace, removedKeys) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (util.isUndefined(removedKeys)) {
                removedKeys = [];
            }
            var options = {
                fullReplace: fullReplace,
                removedKeys: removedKeys
            };
            _this._htmlContainer.setActivityContext(activity.id, JSON.stringify(context), JSON.stringify(options), function (newContextString) {
                var newContext = JSON.parse(newContextString);
                resolve(newContext);
            }, function (error) { return reject(error); });
        });
    };
    HCBridge.prototype.getActivityWindows = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindows(function (windows) {
                var result = windows.map(function (wind) { return HCBridge._hcToJsWindow(wind); });
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.stopActivity = function (activity) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.stopActivity(activity.id, function (result) {
                resolve(result);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.unregisterWindowFactory = function (windowTypeName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.registerWindowFactory(windowTypeName, function (info) {
                resolve(true);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.createWindow = function (id, windowDefinition) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.createWindow(id, JSON.stringify(windowDefinition), function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.onActivityTypeStatusChange = function (callback) {
        this._activityTypeCallbacks.push(callback);
    };
    HCBridge.prototype.onWindowTypeStatusChange = function (callback) {
        this._windowTypeCallbacks.push(callback);
    };
    HCBridge.prototype.onActivityStatusChange = function (callback) {
        this._activityCallbacks.push(callback);
    };
    HCBridge.prototype.onActivityWindowChange = function (callback) {
        this._windowCallbacks.push(callback);
    };
    HCBridge.prototype.getWindowBounds = function (id) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.getWindowBounds(id, function (bounds) {
                resolve(bounds);
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.setWindowBounds = function (id, bounds) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.setWindowBounds(id, JSON.stringify(bounds), function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype.registerWindow = function (type, name, independent) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.registerWindow(type, name, independent, function (id) {
                resolve(id);
            }, function (error) {
                reject(error);
            });
        });
    };
    HCBridge.prototype.closeWindow = function (id) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._htmlContainer.closeWindow(id, function () {
                resolve();
            }, function (err) {
                reject(err);
            });
        });
    };
    HCBridge.prototype._publishStatusChange = function (entity, context, callbacks) {
        var entityEvent = new entityEvent_2.EntityEvent(entity, context);
        callbacks.forEach(function (callback) {
            callback(entityEvent);
        });
    };
    HCBridge.prototype._publishActivityTypeStatusChange = function (at, context) {
        this._publishStatusChange(at, context, this._activityTypeCallbacks);
    };
    HCBridge.prototype._publishWindowTypeStatusChange = function (wt, context) {
        this._publishStatusChange(wt, context, this._windowTypeCallbacks);
    };
    HCBridge.prototype._publishActivityStatusChange = function (act, context) {
        this._publishStatusChange(act, context, this._activityCallbacks);
    };
    HCBridge.prototype._publishActivityWindowEvent = function (w, context) {
        this._publishStatusChange(w, context, this._windowCallbacks);
    };
    return HCBridge;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= HCBridge;

},{"../contracts/activityStatus":16,"../contracts/entityEvent":17,"../core/proxyWindowFactory":21,"../entities/activity":22,"../entities/activityType":24,"../entities/activityWindow":25,"../entities/windowType":26,"../helpers/logger":28,"../helpers/readyMarker":30,"../helpers/util":31}],16:[function(require,module,exports){
"use strict";
var ActivityStatus = (function () {
    function ActivityStatus(state, message, time) {
        this.state = state;
        this.message = message;
        this.time = time;
    }
    ActivityStatus.prototype.getState = function () {
        return this.state;
    };
    ActivityStatus.prototype.getMessage = function () {
        return this.message;
    };
    ActivityStatus.prototype.getTime = function () {
        return this.time;
    };
    return ActivityStatus;
}());
exports.ActivityStatus = ActivityStatus;

},{}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var EntityEvent = (function () {
    function EntityEvent(entitiy, context) {
        this.entity = entitiy;
        this.context = context;
    }
    return EntityEvent;
}());
exports.EntityEvent = EntityEvent;
var EntityEventContext = (function () {
    function EntityEventContext(eventType) {
        this.type = eventType;
    }
    return EntityEventContext;
}());
exports.EntityEventContext = EntityEventContext;
var EntityStatusChangeEventContext = (function (_super) {
    __extends(EntityStatusChangeEventContext, _super);
    function EntityStatusChangeEventContext(newStatus, oldStatus) {
        _super.call(this, EntityEventType.StatusChange);
        this.newStatus = newStatus;
        this.oldStatus = oldStatus;
    }
    return EntityStatusChangeEventContext;
}(EntityEventContext));
exports.EntityStatusChangeEventContext = EntityStatusChangeEventContext;
var EntityActivityWindowEventContext = (function (_super) {
    __extends(EntityActivityWindowEventContext, _super);
    function EntityActivityWindowEventContext(activity, event) {
        _super.call(this, EntityEventType.ActivityWindowEvent);
        this.activity = activity;
        this.event = event;
    }
    return EntityActivityWindowEventContext;
}(EntityEventContext));
exports.EntityActivityWindowEventContext = EntityActivityWindowEventContext;
var ActivityContextChangedContext = (function (_super) {
    __extends(ActivityContextChangedContext, _super);
    function ActivityContextChangedContext(context, updated, removed) {
        _super.call(this, EntityEventType.ActivityContextChange);
        this.updated = updated;
        this.removed = removed;
        this.context = JSON.parse(context);
    }
    return ActivityContextChangedContext;
}(EntityEventContext));
exports.ActivityContextChangedContext = ActivityContextChangedContext;
var EntityEventType = (function () {
    function EntityEventType() {
    }
    EntityEventType.Added = "added";
    EntityEventType.Removed = "removed";
    EntityEventType.Updated = "updated";
    EntityEventType.FactoryRegistered = "factoryRegistered";
    EntityEventType.FactoryUnregistered = "factoryUnregistered";
    EntityEventType.StatusChange = "statusChange";
    EntityEventType.ActivityContextChange = "activityContextUpdate";
    EntityEventType.ActivityWindowEvent = "activityWindowEvent";
    return EntityEventType;
}());
exports.EntityEventType = EntityEventType;

},{}],18:[function(require,module,exports){
"use strict";
var util = require("../helpers/util");
var ActivityAGM = (function () {
    function ActivityAGM(activity) {
        this._activity = activity;
    }
    ActivityAGM.prototype.register = function (definition, handler) {
        this._ensureHasAgm();
        ActivityAGM.AGM.register(definition, handler);
    };
    ActivityAGM.prototype.servers = function () {
        this._ensureHasAgm();
        if (util.isUndefinedOrNull(this._activity)) {
            return [];
        }
        return this._activity.windows.map(function (w) {
            return w.instance;
        });
    };
    ActivityAGM.prototype.methods = function () {
        this._ensureHasAgm();
        if (util.isUndefinedOrNull(this._activity)) {
            return [];
        }
        var windows = this._activity.windows;
        var methodNames = [];
        var methods = [];
        for (var index = 0; index < windows.length; index++) {
            var window_1 = windows[index];
            var windowMethods = this.methodsForWindow(window_1);
            for (var methodIndex = 0; methodIndex < windowMethods.length; methodIndex++) {
                var currentWindowMethod = windowMethods[methodIndex];
                if (methodNames.indexOf(currentWindowMethod.name) === -1) {
                    methodNames.push(currentWindowMethod.name);
                    methods.push(currentWindowMethod);
                }
            }
        }
        return methods;
    };
    ActivityAGM.prototype.methodsForWindow = function (window) {
        this._ensureHasAgm();
        if (!window.instance) {
            return [];
        }
        return ActivityAGM.AGM.methodsForInstance(window.instance);
    };
    ActivityAGM.prototype.invoke = function (methodName, arg, target, options, success, error) {
        this._ensureHasAgm();
        var activityServers = this.servers();
        var serversToInvokeAgainst = [];
        if (util.isUndefinedOrNull(target)) {
            target = "activity.all";
        }
        if (util.isString(target)) {
            if (target === "activity.all") {
                serversToInvokeAgainst = activityServers;
            }
            else if (target === "activity.best") {
                var potentialTargets = activityServers.filter(function (server) {
                    var methods = ActivityAGM.AGM.methodsForInstance(server);
                    return methods.filter(function (m) {
                        return m.name === methodName;
                    }).length > 0;
                });
                if (potentialTargets.length > 0) {
                    serversToInvokeAgainst = [potentialTargets[0]];
                }
            }
            else if (target === "all" || target === "best") {
                return ActivityAGM.AGM.invoke(methodName, arg, target, options, success, error);
            }
            else {
                throw new Error("Invalid invoke target " + target);
            }
        }
        else if (util.isArray(target)) {
            if (target.length >= 0) {
                var firstElem = target[0];
                if (this._isAgmInstance(firstElem)) {
                    serversToInvokeAgainst = target.map(function (instance) { return instance; });
                }
                else if (this._isActivityWindow(firstElem)) {
                    serversToInvokeAgainst = target.map(function (win) { return win.instance; });
                }
                else {
                    throw new Error("Unknown target object");
                }
            }
        }
        else {
            if (this._isAgmInstance(target)) {
                serversToInvokeAgainst = [target];
            }
            else if (this._isActivityWindow(target)) {
                serversToInvokeAgainst = [target.instance];
            }
            else {
                throw new Error("Unknown target object");
            }
        }
        return ActivityAGM.AGM.invoke(methodName, arg, serversToInvokeAgainst, options, success, error);
    };
    ActivityAGM.prototype.unregister = function (definition) {
        this._ensureHasAgm();
        return ActivityAGM.AGM.unregister(definition);
    };
    ActivityAGM.prototype.createStream = function (methodDefinition, subscriberAddedHandler, subscriberRemovedFunction) {
        this._ensureHasAgm();
        ActivityAGM.AGM.createStream(methodDefinition, subscriberAddedHandler, subscriberRemovedFunction);
    };
    ActivityAGM.prototype.subscribe = function (methodDefinition, parameters, target) {
        this._ensureHasAgm();
        var servers = this.servers();
        return ActivityAGM.AGM.subscribe(methodDefinition, parameters, servers);
    };
    ActivityAGM.prototype._ensureHasAgm = function () {
        if (util.isUndefinedOrNull(ActivityAGM.AGM)) {
            throw new Error("Agm should be configured to be used in activity");
        }
    };
    ActivityAGM.prototype._isAgmInstance = function (obj) {
        return obj.application != undefined;
    };
    ActivityAGM.prototype._isActivityWindow = function (obj) {
        return obj.instance !== undefined;
    };
    return ActivityAGM;
}());
exports.ActivityAGM = ActivityAGM;

},{"../helpers/util":31}],19:[function(require,module,exports){
"use strict";
var entityEvent_1 = require("../contracts/entityEvent");
var activityType_1 = require("../entities/activityType");
var promiseExtensions_1 = require("../helpers/promiseExtensions");
var readyMarker_1 = require("../helpers/readyMarker");
var entityObservableCollection_1 = require("../helpers/entityObservableCollection");
var logger_1 = require("../helpers/logger");
var util = require("../helpers/util");
var localWindowFactory_1 = require("./localWindowFactory");
var ActivityManager = (function () {
    function ActivityManager(bridge, autoAnnounce) {
        var _this = this;
        this._logger = logger_1.Logger.Get(this);
        this._announcedWindows = [];
        this._bridge = bridge;
        this._activityTypes = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._windowTypes = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._activities = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._windows = new entityObservableCollection_1.EntityObservableCollection(function (e) { return _this._grabEntity(e); });
        this._dataReadyMarker = new readyMarker_1.ReadyMarker("Activity Manager Data", ["GetActivityTypes", "GetWindowTypes", "GetActivities", "GetWindows"].length);
        if (autoAnnounce) {
            var announceMaker = new readyMarker_1.ReadyMarker("Activity Manager Announce", ["Announcement"].length);
            this._readyMarker = announceMaker;
            this._dataReadyMarker.setCallback(function (err) {
                if (err) {
                    _this._readyMarker.error(err);
                }
                _this._logger.debug("Auto announcing window");
                _this.announceWindow()
                    .then(function (w) {
                    _this._announcedWindows.push(w);
                    _this._readyMarker.signal("Successfully announced window with id '" + w.id + "'");
                })['catch'](function (err) {
                    _this._logger.debug("Will not announce window - " + err);
                    _this._readyMarker.signal();
                });
            });
        }
        else {
            this._readyMarker = this._dataReadyMarker;
        }
        this._bridge.init();
        this._bridge
            .ready()
            .then(function (aw) {
            _this._subscribeForData();
        })['catch'](function (error) {
            console.log(error);
        });
    }
    Object.defineProperty(ActivityManager.prototype, "announcedWindows", {
        get: function () {
            return this._announcedWindows;
        },
        set: function (v) {
            throw new Error("not allowed");
        },
        enumerable: true,
        configurable: true
    });
    ActivityManager.prototype.ready = function (callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this._readyMarker.setCallback(function (err) {
                if (!err) {
                    resolve(_this);
                }
                else {
                    reject(_this._readyMarker.getError());
                }
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getActivityTypes = function () {
        return this._activityTypes.get();
    };
    ActivityManager.prototype.getActivityType = function (name) {
        return this._activityTypes.getByName(name);
    };
    ActivityManager.prototype.registerActivityType = function (activityTypeName, ownerWindowType, helperWindowTypes, layoutConfig, description, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activityTypeName)) {
                reject("activityTypeName argument can not be undefined");
            }
            if (!util.isString(activityTypeName)) {
                reject("activityTypeName should be string");
            }
            var actType = _this.getActivityType(activityTypeName);
            if (!util.isUndefinedOrNull(actType)) {
                reject("Activity type '" + activityTypeName + "' already exists");
            }
            var ownerDefinition;
            if (util.isUndefined(ownerWindowType)) {
                reject("Owner window type can not be undefined");
            }
            if (util.isString(ownerWindowType)) {
                ownerDefinition = { type: ownerWindowType, name: "", isIndependent: false, arguments: {} };
            }
            else {
                ownerDefinition = ownerWindowType;
            }
            var helperDefinitions = [];
            if (!util.isUndefined(helperWindowTypes) && util.isArray(helperWindowTypes)) {
                for (var index in helperWindowTypes) {
                    var item = helperWindowTypes[index];
                    if (util.isString(item)) {
                        var definition = {
                            type: item,
                            name: "",
                            isIndependent: false,
                            arguments: {},
                            relativeTo: "",
                            relativeDirection: "",
                            windowStyleAttributes: {}
                        };
                        helperDefinitions.push(definition);
                    }
                    else {
                        helperDefinitions.push(item);
                    }
                }
            }
            _this._bridge
                .registerActivityType(activityTypeName, ownerDefinition, helperDefinitions, layoutConfig, description)
                .then(function (activityType) {
                _this._grabEntity(activityType);
                resolve(activityType);
            })['catch'](function (error) {
                reject(error);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.unregisterActivityType = function (type, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var actType = _this.getActivityType(type);
            if (util.isUndefined(actType)) {
                reject("Activity type '" + type + "' does not exists");
            }
            return _this._bridge.unregisterActivityType(type);
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.initiate = function (activityType, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var actType = _this.getActivityType(activityType);
            if (util.isUndefined(actType)) {
                reject("Activity type '" + activityType + "' does not exists");
            }
            _this._bridge
                .initiateActivity(activityType, context)
                .then(function (actId) {
                _this._activities
                    .getOrWait(actId)
                    .then(function (act) {
                    resolve(act);
                })['catch'](function (err) { return reject(err); });
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.subscribeActivityTypeEvents = function (handler) {
        this._activityTypes.subscribe(function (at, context) {
            handler(at, context.type);
        });
    };
    ActivityManager.prototype.getWindowTypes = function () {
        return this._windowTypes.get();
    };
    ActivityManager.prototype.getWindowType = function (name) {
        return this._windowTypes.getByName(name);
    };
    ActivityManager.prototype.registerWindowFactory = function (windowType, factoryMethod, description, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowType)) {
                reject("no windowType specified");
                return;
            }
            if (util.isObject(windowType)) {
                windowType = windowType.getName();
            }
            else if (!util.isString(windowType)) {
                reject("windowType should be string or object that has getName method");
                return;
            }
            var factory = new localWindowFactory_1.LocalWindowFactory(factoryMethod, description);
            _this._bridge
                .registerWindowFactory(windowType, factory)
                .then(function (v) {
                resolve(v);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.unregisterWindowFactory = function (windowType, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(windowType)) {
                reject("no windowType specified");
                return;
            }
            if (!util.isString(windowType)) {
                reject("windowType should be a string");
                return;
            }
            _this._bridge
                .unregisterWindowFactory(windowType)
                .then(function (v) {
                resolve(v);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getActivities = function (activityType) {
        var act = this._activities.get();
        if (!activityType) {
            return act;
        }
        var types = activityType;
        if (util.isString(activityType)) {
            types = [activityType];
        }
        else if (activityType instanceof activityType_1['default']) {
            types = [activityType.name];
        }
        else if (activityType instanceof Array) {
        }
        else {
            throw new Error("Invalid input argument 'activityType' = " + activityType);
        }
        return act.filter(function (act) {
            var type = act.type;
            return util.some(types, function (t) {
                return type.id == t.id;
            });
        });
    };
    ActivityManager.prototype.getActivityById = function (id) {
        return this._activities.getByName(id);
    };
    ActivityManager.prototype.announceWindow = function (activityWindowId, windowType) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var announcementInfo = _this._bridge.getAnnouncementInfo();
            if (util.isUndefined(activityWindowId)) {
                activityWindowId = announcementInfo.activityWindowId;
            }
            if (util.isUndefined(windowType)) {
                windowType = announcementInfo.activityWindowType;
            }
            if (util.isUndefinedOrNull(windowType)) {
                throw new Error("Can not announce - unknown windowType");
            }
            if (util.isUndefinedOrNull(activityWindowId)) {
                _this._logger.debug("Registering window with type:'" + windowType + "', name:'" + announcementInfo.activityWindowName + "', ind.:'" + announcementInfo.activityWindowIndependent + "'");
                _this._bridge.registerWindow(windowType, announcementInfo.activityWindowName, announcementInfo.activityWindowIndependent)
                    .then(_this._windows.getOrWait.bind(_this._windows))
                    .then(function (w) {
                    resolve(w);
                })['catch'](function (err) {
                    _this._logger.error(err);
                });
            }
            else {
                _this._logger.debug("Announcing window with id '" + activityWindowId + "' and type '" + windowType + "'");
                var currentWindow = _this._windows.getByName(activityWindowId);
                if (!util.isUndefinedOrNull(currentWindow)) {
                    _this._logger.debug("Window with id '" + activityWindowId + "' already announced - reusing the window");
                    resolve(currentWindow);
                    return;
                }
                var windowEventHandler = function (a, w, e) {
                    if (activityWindowId === w.id) {
                        if (e === "joined") {
                            var activity = w.activity;
                            if (util.isUndefined(activity)) {
                                reject("UNDEFINED ACTIVITY");
                            }
                            _this._logger.trace("Got joined event for id '" + activityWindowId + "'");
                            resolve(w);
                            _this.unsubscribeWindowEvents(windowEventHandler);
                        }
                    }
                };
                _this.subscribeWindowEvents(windowEventHandler);
                _this._logger.trace("Waiting for joined event for id '" + activityWindowId + "'");
                _this._bridge.announceWindow(windowType, activityWindowId);
            }
        });
        return promise;
    };
    ActivityManager.prototype.subscribeWindowTypeEvents = function (handler) {
        this._windowTypes.subscribe(function (wt, context) {
            handler(wt, context.type);
        });
    };
    ActivityManager.prototype.subscribeActivityEvents = function (handler) {
        this._activities.subscribe(function (act, context) {
            if (context.type === entityEvent_1.EntityEventType.StatusChange) {
                var p = context;
                handler(act, p.newStatus, p.oldStatus);
            }
        });
    };
    ActivityManager.prototype.subscribeWindowEvents = function (handler) {
        this._windows.subscribe(function (window, context) {
            if (context.type === entityEvent_1.EntityEventType.ActivityWindowEvent) {
                var p = context;
                handler(window.activity, window, p.event);
            }
        });
    };
    ActivityManager.prototype.unsubscribeWindowEvents = function (handler) {
    };
    ActivityManager.prototype.createWindow = function (activity, windowType, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity is undefined");
            }
            if (util.isUndefinedOrNull(windowType)) {
                reject("windowType is undefined");
            }
            var windowDefinition;
            if (util.isString(windowType)) {
                windowDefinition = { type: windowType, name: "", isIndependent: false, arguments: {} };
            }
            else {
                windowDefinition = windowType;
            }
            var relativeToWindow;
            if (!util.isUndefinedOrNull(windowDefinition.relativeTo)) {
                relativeToWindow = windowDefinition.relativeTo;
                if (util.isString(relativeToWindow)) {
                    var windows = _this.getWindows({ type: relativeToWindow });
                    if (!util.isUndefinedOrNull(windows) && windows.length > 0) {
                        windowDefinition.relativeTo = windows[0].id;
                    }
                }
                else if (!util.isUndefinedOrNull(relativeToWindow.type)) {
                    var windows = _this.getWindows({ type: relativeToWindow.type });
                    if (!util.isUndefinedOrNull(windows) && windows.length > 0) {
                        windowDefinition.relativeTo = windows[0].id;
                    }
                }
                else if (!util.isUndefinedOrNull(relativeToWindow.windowId)) {
                    windowDefinition.relativeTo = relativeToWindow.windowId;
                }
            }
            _this._bridge.createWindow(activity.id, windowDefinition)
                .then(function (wid) {
                _this._logger.debug("Window created, waiting for window entity with id " + wid);
                var handler = function (window, context) {
                    if (window.id === wid && window.activity) {
                        this._logger.debug("Got entity window with id " + wid);
                        resolve(window);
                        this._windows.unsubscribe(handler);
                    }
                }.bind(_this);
                _this._windows.subscribe(handler);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.joinWindowToActivity = function (activity, window, callback) {
        return undefined;
    };
    ActivityManager.prototype.leaveWindowFromActivity = function (activity, window, callback) {
        return undefined;
    };
    ActivityManager.prototype.setActivityContext = function (activity, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity can not be null");
            }
            _this._bridge
                .updateActivityContext(activity, context, true)
                .then(function (obj) {
                resolve(obj);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.updateActivityContext = function (activity, context, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (util.isUndefinedOrNull(activity)) {
                reject("activity can not be null");
            }
            var removedKeys = [];
            for (var key in context) {
                if (context.hasOwnProperty(key) && context[key] === null) {
                    removedKeys.push(key);
                }
            }
            _this._bridge
                .updateActivityContext(activity, context, false, removedKeys)
                .then(function (obj) {
                resolve(obj);
            })['catch'](function (err) {
                reject(err);
            });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.subscribeActivityContextChanged = function (handler) {
        this._activities.subscribe(function (act, context) {
            if (context.type === entityEvent_1.EntityEventType.ActivityContextChange) {
                var updateContext = context;
                handler(act, updateContext.context, updateContext.updated, updateContext.removed);
            }
        });
    };
    ActivityManager.prototype.stopActivity = function (activity, callback) {
        var promise = this._bridge.stopActivity(activity);
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.getWindows = function (filter) {
        if (util.isUndefined(filter)) {
            return this._windows.get();
        }
        if (!util.isUndefined(filter.id)) {
            return [this._windows.getByName(filter.id)];
        }
        var allWindows = this._windows.get();
        return allWindows.filter(function (w) {
            if (!util.isUndefined(filter.type) && w.type.id !== filter.type) {
                return false;
            }
            if (!util.isUndefined(filter.name) && w.name !== filter.name) {
                return false;
            }
            if (!util.isUndefined(filter.activityId)) {
                if (util.isUndefinedOrNull(w.activity)) {
                    return false;
                }
                if (w.activity.id !== filter.activityId) {
                    return false;
                }
            }
            return true;
        });
    };
    ActivityManager.prototype._grabEntity = function (entity) {
        entity.manager = this;
    };
    ActivityManager.prototype._subscribeForData = function () {
        var _this = this;
        this._logger.debug("Start getting initial data...");
        this._bridge.onActivityTypeStatusChange(function (event) {
            _this._activityTypes.process(event);
        });
        this._bridge.getActivityTypes()
            .then(function (at) {
            _this._activityTypes.add(at);
            _this._dataReadyMarker.signal("Got act types");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity types -" + error);
        });
        this._bridge.onWindowTypeStatusChange(function (event) {
            _this._windowTypes.process(event);
        });
        this._bridge.getWindowTypes()
            .then(function (wt) {
            _this._windowTypes.add(wt);
            _this._dataReadyMarker.signal("Got window types");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting window types  " + error);
        });
        this._bridge.onActivityStatusChange(function (event) {
            _this._activities.process(event);
        });
        this._bridge.getActivities()
            .then(function (ac) {
            _this._activities.add(ac);
            _this._dataReadyMarker.signal("Got activities");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity instances -" + error);
        });
        this._bridge.onActivityWindowChange(function (event) {
            _this._windows.process(event);
        });
        this._bridge.getActivityWindows()
            .then(function (aw) {
            _this._windows.add(aw);
            _this._dataReadyMarker.signal("Got windows");
        })['catch'](function (error) {
            _this._logger.error(error);
            _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity windows -" + error);
        });
    };
    ActivityManager.prototype.getWindowBounds = function (id) {
        return this._bridge.getWindowBounds(id);
    };
    ActivityManager.prototype.setWindowBounds = function (id, bounds, callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            _this._bridge.setWindowBounds(id, bounds)
                .then(function () { return resolve(); })['catch'](function (err) { return reject(err); });
        });
        return promiseExtensions_1.nodeify(promise, callback);
    };
    ActivityManager.prototype.closeWindow = function (id) {
        return this._bridge.closeWindow(id);
    };
    return ActivityManager;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityManager;

},{"../contracts/entityEvent":17,"../entities/activityType":24,"../helpers/entityObservableCollection":27,"../helpers/logger":28,"../helpers/promiseExtensions":29,"../helpers/readyMarker":30,"../helpers/util":31,"./localWindowFactory":20}],20:[function(require,module,exports){
"use strict";
var LocalWindowFactory = (function () {
    function LocalWindowFactory(createFunction, description) {
        this._createFunction = createFunction;
        this._description = description;
    }
    LocalWindowFactory.prototype.create = function (activityWindowId, context, layout) {
        return this._createFunction(activityWindowId, context, layout);
    };
    LocalWindowFactory.prototype.description = function () {
        return this._description;
    };
    return LocalWindowFactory;
}());
exports.LocalWindowFactory = LocalWindowFactory;

},{}],21:[function(require,module,exports){
"use strict";
var ProxyWindowFactory = (function () {
    function ProxyWindowFactory(description) {
        this._description = description;
    }
    ProxyWindowFactory.prototype.create = function (activityWindowId, context) {
        return undefined;
    };
    ProxyWindowFactory.prototype.description = function () {
        return this._description;
    };
    return ProxyWindowFactory;
}());
exports.ProxyWindowFactory = ProxyWindowFactory;

},{}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var activityAGM_1 = require("../core/activityAGM");
var Activity = (function (_super) {
    __extends(Activity, _super);
    function Activity(id, actType, status, context, owner, helperWindows) {
        _super.call(this, id);
        this._id = id;
        this._actType = actType;
        this._status = status;
        this._context = context;
        this._owner = owner;
        this._helperWindows = helperWindows;
        this._agm = new activityAGM_1.ActivityAGM(this);
    }
    Object.defineProperty(Activity.prototype, "type", {
        get: function () {
            if (this.manager) {
                return this.manager.getActivityType(this._actType);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "context", {
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "status", {
        get: function () {
            return this._status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "owner", {
        get: function () {
            return this._owner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "windows", {
        get: function () {
            return this.manager.getWindows({ activityId: this._id });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Activity.prototype, "agm", {
        get: function () {
            return this._agm;
        },
        enumerable: true,
        configurable: true
    });
    Activity.prototype.join = function (window, callback) {
        return this.manager.joinWindowToActivity(this, window, callback);
    };
    Activity.prototype.createWindow = function (windowType, callback) {
        return this.manager.createWindow(this, windowType, callback);
    };
    Activity.prototype.leave = function (window, callback) {
        return this.manager.leaveWindowFromActivity(this, window, callback);
    };
    Activity.prototype.getWindowsByType = function (windowType) {
        var filter = { activityId: this._id, type: windowType };
        return this.manager.getWindows(filter);
    };
    Activity.prototype.setContext = function (context, callback) {
        return this.manager.setActivityContext(this, context, callback);
    };
    Activity.prototype.updateContext = function (context, callback) {
        return this.manager.updateActivityContext(this, context, callback);
    };
    Activity.prototype.onStatusChange = function (handler) {
        var _this = this;
        this.manager.subscribeActivityEvents(function (a, ns, os) {
            if (a.id === _this.id) {
                handler(a, ns, os);
            }
        });
    };
    Activity.prototype.onWindowEvent = function (handler) {
        var _this = this;
        this.manager.subscribeWindowEvents(function (a, w, e) {
            if (a.id === _this.id) {
                handler(a, w, e);
            }
        });
    };
    Activity.prototype.onContextChanged = function (handler) {
        var _this = this;
        this.manager.subscribeActivityContextChanged(function (act, context, delta, removed) {
            if (act.id === _this.id) {
                handler(context, delta, removed, act);
            }
        });
        try {
            handler(this.context, this.context, [], this);
        }
        catch (e) { }
    };
    Activity.prototype.stop = function () {
        this.manager.stopActivity(this);
    };
    Activity.prototype.updateCore = function (activity) {
        _super.prototype.updateCore.call(this, activity);
        this._actType = activity._actType;
        this._context = activity._context;
        this._status = activity._status;
        this._helperWindows = activity._helperWindows;
        this._owner = activity._owner;
    };
    return Activity;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= Activity;

},{"../core/activityAGM":18,"./activityEntity":23}],23:[function(require,module,exports){
"use strict";
var ActivityEntity = (function () {
    function ActivityEntity(id) {
        this.listeners = [];
        this._id = id;
    }
    Object.defineProperty(ActivityEntity.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    ActivityEntity.prototype.onUpdated = function (handler) {
        this.listeners.push(handler);
    };
    ActivityEntity.prototype.update = function (other) {
        if (other._id != this._id) {
            throw Error("Can not update from entity with different id.");
        }
        this.updateCore(other);
        this.notify();
    };
    ActivityEntity.prototype.updateCore = function (other) {
    };
    ActivityEntity.prototype.notify = function () {
        for (var index = 0; index < this.listeners.length; index++) {
            var listener = this.listeners[index];
            listener(this);
        }
    };
    return ActivityEntity;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityEntity;

},{}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var ActivityType = (function (_super) {
    __extends(ActivityType, _super);
    function ActivityType(name, ownerWindow, helperWindows, description) {
        _super.call(this, name);
        this._name = name;
        this._description = description;
        this._ownerWindow = ownerWindow;
        this._helperWindows = helperWindows || [];
    }
    Object.defineProperty(ActivityType.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "description", {
        get: function () {
            return this._description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "helperWindows", {
        get: function () {
            return this._helperWindows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityType.prototype, "ownerWindow", {
        get: function () {
            return this._ownerWindow;
        },
        enumerable: true,
        configurable: true
    });
    ActivityType.prototype.subscribeActivityStatusChange = function (handler) {
        return undefined;
    };
    ActivityType.prototype.initiate = function (context, callback) {
        return this.manager.initiate(this._name, context, callback);
    };
    ActivityType.prototype.updateCore = function (type) {
        _super.prototype.updateCore.call(this, type);
        this._description = type._description;
        this._ownerWindow = type._ownerWindow;
        this._helperWindows = type._helperWindows;
    };
    return ActivityType;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityType;

},{"./activityEntity":23}],25:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var logger_1 = require("../helpers/logger");
var util = require("../helpers/util");
var ActivityWindow = (function (_super) {
    __extends(ActivityWindow, _super);
    function ActivityWindow(id, name, type, activityId, instance, isIndependent) {
        _super.call(this, id);
        this._logger = logger_1.Logger.Get(this);
        this._type = type;
        this._activityId = activityId;
        this._name = name;
        this._instance = instance;
        this._isIndependent = isIndependent;
    }
    ActivityWindow.prototype.getBounds = function () {
        return this.manager.getWindowBounds(this.id);
    };
    Object.defineProperty(ActivityWindow.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "isIndependent", {
        get: function () {
            return this._isIndependent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "type", {
        get: function () {
            if (this.manager) {
                return this.manager.getWindowType(this._type);
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "activity", {
        get: function () {
            if (util.isUndefined(this._activityId)) {
                return undefined;
            }
            return this.manager.getActivityById(this._activityId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivityWindow.prototype, "isOwner", {
        get: function () {
            var act = this.activity;
            if (util.isUndefined(act)) {
                return false;
            }
            return act.owner.id === this.id;
        },
        enumerable: true,
        configurable: true
    });
    ActivityWindow.prototype.setVisible = function (isVisible, callback) {
        return undefined;
    };
    ActivityWindow.prototype.setTitle = function (title, callback) {
        return undefined;
    };
    ActivityWindow.prototype.setBounds = function (bounds, callback) {
        return this.manager.setWindowBounds(this.id, bounds, callback);
    };
    ActivityWindow.prototype.setState = function (state, callback) {
        return undefined;
    };
    ActivityWindow.prototype.close = function () {
        return this.manager.closeWindow(this.id);
    };
    Object.defineProperty(ActivityWindow.prototype, "instance", {
        get: function () {
            return this._instance;
        },
        enumerable: true,
        configurable: true
    });
    ActivityWindow.prototype.onActivityJoined = function (callback) {
        this._subscribeForActivityWindowEvent("joined", callback);
    };
    ActivityWindow.prototype.onActivityRemoved = function (callback) {
        this._subscribeForActivityWindowEvent("removed", callback);
    };
    ActivityWindow.prototype.updateCore = function (other) {
        this._activityId = other._activityId;
        this._isIndependent = other._isIndependent;
        if (!util.isUndefinedOrNull(other._instance)) {
            this._instance = other._instance;
        }
    };
    ActivityWindow.prototype._subscribeForActivityWindowEvent = function (eventName, callback) {
        var _this = this;
        this.manager.subscribeWindowEvents(function (activity, window, event) {
            if (window.id !== _this.id) {
                return;
            }
            if (event === eventName) {
                callback(activity);
            }
        });
    };
    return ActivityWindow;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= ActivityWindow;

},{"../helpers/logger":28,"../helpers/util":31,"./activityEntity":23}],26:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var activityEntity_1 = require("./activityEntity");
var WindowType = (function (_super) {
    __extends(WindowType, _super);
    function WindowType(name, factories) {
        _super.call(this, name);
        this._name = name;
        this._factories = factories;
    }
    Object.defineProperty(WindowType.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowType.prototype, "factories", {
        get: function () {
            return this._factories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowType.prototype, "windows", {
        get: function () {
            return this.manager.getWindows({ type: this._name });
        },
        enumerable: true,
        configurable: true
    });
    WindowType.prototype.registerFactory = function (factory, factoryMethod, description, callback) {
        return this.manager.registerWindowFactory(this, factoryMethod, description);
    };
    return WindowType;
}(activityEntity_1['default']));
Object.defineProperty(exports, "__esModule", { value: true });
exports['default']= WindowType;

},{"./activityEntity":23}],27:[function(require,module,exports){
"use strict";
var entityEvent_1 = require("../contracts/entityEvent");
var EntityObservableCollection = (function () {
    function EntityObservableCollection(processNew) {
        this._items = {};
        this._listeners = [];
        this._processNew = processNew;
    }
    EntityObservableCollection.prototype.addOne = function (item) {
        this.add([item]);
    };
    EntityObservableCollection.prototype.add = function (items) {
        for (var index = 0; index < items.length; index++) {
            var element = items[index];
            this.process(new entityEvent_1.EntityEvent(element, new entityEvent_1.EntityEventContext(entityEvent_1.EntityEventType.Added)));
        }
    };
    EntityObservableCollection.prototype.process = function (event) {
        var context = event.context;
        var type = context.type;
        var entity = event.entity;
        var internalEntity = this._updateInternalCollections(entity, type);
        this._notifyListeners(internalEntity, context);
    };
    EntityObservableCollection.prototype.get = function () {
        var result = [];
        for (var key in this._items) {
            if (this._items.hasOwnProperty(key)) {
                var element = this._items[key];
                result.push(element);
            }
        }
        return result;
    };
    EntityObservableCollection.prototype.getByName = function (name) {
        for (var key in this._items) {
            if (key === name) {
                return this._items[key];
            }
        }
        return undefined;
    };
    EntityObservableCollection.prototype.getOrWait = function (name) {
        var _this = this;
        return new Promise(function (resolve) {
            var entityAddedHandler = function (entity) {
                if (entity.id !== name) {
                    return;
                }
                resolve(entity);
                _this.unsubscribe(entityAddedHandler);
            };
            _this.subscribe(entityAddedHandler);
            var window = _this.getByName(name);
            if (window) {
                resolve(window);
                return;
            }
        });
    };
    EntityObservableCollection.prototype.subscribe = function (handler) {
        this._listeners.push(handler);
        for (var key in this._items) {
            var element = this._items[key];
            handler(element, new entityEvent_1.EntityEventContext(entityEvent_1.EntityEventType.Added.toString()));
        }
    };
    EntityObservableCollection.prototype.unsubscribe = function (handler) {
        var index = this._listeners.indexOf(handler);
        if (index != -1) {
            this._listeners.splice(index, 1);
        }
    };
    EntityObservableCollection.prototype._notifyListeners = function (entity, context) {
        for (var index = 0; index < this._listeners.length; index++) {
            var listener = this._listeners[index];
            try {
                listener(entity, context);
            }
            catch (e) { }
        }
    };
    EntityObservableCollection.prototype._updateInternalCollections = function (entity, type) {
        if (type === entityEvent_1.EntityEventType.Removed) {
            delete this._items[entity.id];
            return entity;
        }
        else {
            var key = entity.id;
            if (!this._items.hasOwnProperty(key)) {
                this._processNew(entity);
                this._items[entity.id] = entity;
            }
            else {
                this._items[entity.id].update(entity);
            }
        }
        return this._items[entity.id];
    };
    return EntityObservableCollection;
}());
exports.EntityObservableCollection = EntityObservableCollection;

},{"../contracts/entityEvent":17}],28:[function(require,module,exports){
"use strict";
var util = require("./util");
var LogLevel = (function () {
    function LogLevel() {
    }
    LogLevel.Trace = "trace";
    LogLevel.Debug = "debug";
    LogLevel.Info = "info";
    LogLevel.Warn = "warn";
    LogLevel.Error = "error";
    return LogLevel;
}());
exports.LogLevel = LogLevel;
var Logger = (function () {
    function Logger(name) {
        this._name = name;
        if (!util.isUndefinedOrNull(Logger.GlueLogger)) {
            this._glueLogger = Logger.GlueLogger.subLogger(name);
        }
    }
    Logger.GetNamed = function (name) {
        return new Logger(name);
    };
    Logger.Get = function (owner) {
        return new Logger(Logger.GetTypeName(owner));
    };
    Logger.prototype.trace = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.trace(message);
        }
        else {
            if (Logger.Level === LogLevel.Trace) {
                console.info(this._getMessage(message, LogLevel.Trace));
            }
        }
    };
    Logger.prototype.debug = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.debug(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace) {
                console.info(this._getMessage(message, LogLevel.Debug));
            }
        }
    };
    Logger.prototype.info = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.info(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace ||
                Logger.Level === LogLevel.Info) {
                console.info(this._getMessage(message, LogLevel.Info));
            }
        }
    };
    Logger.prototype.warn = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.warn(message);
        }
        else {
            if (Logger.Level === LogLevel.Debug ||
                Logger.Level === LogLevel.Trace ||
                Logger.Level === LogLevel.Info ||
                Logger.Level === LogLevel.Warn) {
                console.info(this._getMessage(message, LogLevel.Info));
            }
        }
    };
    Logger.prototype.error = function (message) {
        if (!util.isUndefinedOrNull(this._glueLogger)) {
            this._glueLogger.error(message);
        }
        else {
            console.error(this._getMessage(message, LogLevel.Error));
            console.trace();
        }
    };
    Logger.prototype._getMessage = function (message, level) {
        return "[" + level + "] " + this._name + " - " + message;
    };
    Logger.GetTypeName = function (object) {
        var funcNameRegex = /function (.{1,})\(/;
        var results = (funcNameRegex).exec(object.constructor.toString());
        return (results && results.length > 1) ? results[1] : "";
    };
    Logger.Level = LogLevel.Info;
    return Logger;
}());
exports.Logger = Logger;

},{"./util":31}],29:[function(require,module,exports){
"use strict";
var util = require("../helpers/util");
var nextTick = function (cb) { setTimeout(cb, 0); };
function nodeify(promise, callback) {
    if (!util.isFunction(callback)) {
        return promise;
    }
    promise.then(function (resp) {
        nextTick(function () {
            callback(null, resp);
        });
    }, function (err) {
        nextTick(function () {
            callback(err, null);
        });
    });
}
exports.nodeify = nodeify;
;

},{"../helpers/util":31}],30:[function(require,module,exports){
"use strict";
var logger_1 = require("./logger");
var util = require("../helpers/util");
var ReadyMarker = (function () {
    function ReadyMarker(name, signalsToWait) {
        this._logger = logger_1.Logger.GetNamed("ReadyMarker [" + name + "]");
        this._logger.debug("Initializing ready marker for '" + name + "' with " + signalsToWait + " signals to wait");
        if (signalsToWait <= 0) {
            throw new Error("Invalid signal number. Should be > 0");
        }
        this._signals = signalsToWait;
        this._callbacks = [];
        this._name = name;
    }
    ReadyMarker.prototype.setCallback = function (callback) {
        if (this.isSet()) {
            callback(undefined);
            return;
        }
        else if (this.isError()) {
            callback(this._error);
            return;
        }
        this._callbacks.push(callback);
    };
    ReadyMarker.prototype.signal = function (message) {
        this._logger.debug("Signaled - " + message + " - signals left " + (this._signals - 1));
        this._signals--;
        if (this._signals < 0) {
            throw new Error("Error in ready marker '" + this._name + " - signals are " + this._signals);
        }
        if (this.isSet()) {
            this._callbacks.forEach(function (callback) {
                callback(undefined);
            });
        }
    };
    ReadyMarker.prototype.error = function (error) {
        this._error = error;
        this._callbacks.forEach(function (errorCallback) {
            errorCallback(error);
        });
    };
    ReadyMarker.prototype.isSet = function () {
        if (this.isError()) {
            return false;
        }
        return this._signals === 0;
    };
    ReadyMarker.prototype.isError = function () {
        return !util.isUndefined(this._error);
    };
    ReadyMarker.prototype.getError = function () {
        return this._error;
    };
    return ReadyMarker;
}());
exports.ReadyMarker = ReadyMarker;

},{"../helpers/util":31,"./logger":28}],31:[function(require,module,exports){
"use strict";
function isNumber(arg) {
    return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === 'string';
}
exports.isString = isString;
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isArray(arg) {
    if (Array.isArray) {
        return Array.isArray(arg);
    }
    return toString.call(arg) === '[object Array]';
}
exports.isArray = isArray;
function isUndefined(arg) {
    return typeof arg === 'undefined';
}
exports.isUndefined = isUndefined;
function isUndefinedOrNull(arg) {
    return !arg || typeof arg === 'undefined';
}
exports.isUndefinedOrNull = isUndefinedOrNull;
function isEmpty(arg) {
    for (var prop in arg) {
        if (arg.hasOwnProperty(prop))
            return false;
    }
    return true;
}
exports.isEmpty = isEmpty;
function isFunction(arg) {
    return !!(arg && arg.constructor && arg.call && arg.apply);
}
exports.isFunction = isFunction;
;
function some(array, predicate) {
    for (var index = 0; index < array.length; index++) {
        if (predicate(array[index], index)) {
            return true;
        }
    }
    return false;
}
exports.some = some;
function first(array, predicate) {
    for (var index = 0; index < array.length; index++) {
        if (predicate(array[index], index)) {
            return array[index];
        }
    }
    return undefined;
}
exports.first = first;

},{}],32:[function(require,module,exports){
(function (global){
var connection = require("tick42-gateway-connection");
var client = require("./agm_client");
var server = require("./agm_server");
var instance = require("./agm_instance");
var native_agm = require("./agm_native");
var deprecate = require('util-deprecate');
var pjson = require("../package.json");
//var add_sugar= require("./agm_sugar");
//Init namespace if not already there

//Add a global function that makes an AGM instance
agm = function (configuration) {
	"use strict";

	//We will store the library here
	var agm = {};

	agm.version = pjson.version;

	//Init debug
	if (typeof configuration !== "object") {
		configuration = {};
	}

	//Init child configuration if it is not already passed by user
	var child_configurations = ["connection", "client", "server"];
	child_configurations.forEach(function (conf) {
		if (typeof configuration[conf] !== "object") {
			configuration[conf] = {};
		}
		//Set debug if global debug is not set:
		if (configuration.debug) {
			configuration[conf].debug = true;
		}
	});

	//Init connection
	var c = configuration.connection;
	//Determine if we are given a connection object. If not, create it ourselves:
	agm.connection = (typeof c === "object" && typeof c.send === "function" && typeof c.on === "function") ? c : connection(configuration.connection);

	//Create a connection proxy which sets the product name automatically
	var product_name = "agm";
	var agm_enabled_connection = {
		send: function (type, message) {
			agm.connection.send(product_name, type, message);
		},
		on: function (type, handler) {
			agm.connection.on(product_name, type, handler);
		}

	};

	//Save a reference to the root system object that we are given
	var metrics_root = configuration.metrics;

	//Create subsystems for our modules and save them in their configuration.
	if (metrics_root !== undefined) {
		configuration.client.metrics = metrics_root.subSystem("Client");
		configuration.server.metrics = metrics_root.subSystem("Server");
	}

	//Initialize our modules
	agm.instance = instance(configuration.instance, agm_enabled_connection);
	agm.client = client(agm_enabled_connection, agm.instance, configuration.client);
	agm.server = server(agm_enabled_connection, agm.instance, configuration.server);

	//Add method aliases
	agm.invoke = agm.client.invoke;
	agm.register = agm.server.register;
	agm.registerAsync = agm.server.registerAsync;
	agm.unregister = agm.server.unregister;
	agm.createStream = agm.server.createStream;
	agm.subscribe = agm.client.subscribe;
	agm.servers = agm.client.servers;
	agm.methods = agm.client.methods;
	agm.methods_for_instance = deprecate(agm.client.methods_for_instance, 'glue.agm.client.methods_for_instance() is deprecated and might be removed from future versions of glue. Use glue.agm.client.methodsForInstance() instead') ;
	agm.methodsForInstance = agm.client.methods_for_instance;
	agm.method = agm.client.method;
	agm.method_added = deprecate(agm.client.method_added, 'glue.agm.method_added() is deprecated and might be removed from future versions of glue. Use glue.agm.methodAdded() instead');
	agm.methodAdded = agm.client.method_added;
	agm.method_removed = deprecate(agm.client.method_removed, 'glue.agm.method_removed() is deprecated and might be removed from future versions of glue. Use glue.agm.methodRemoved() instead');
	agm.methodRemoved = agm.client.method_removed;

	agm.server_method_added = deprecate(agm.client.server_method_added, 'glue.agm.server_method_added() is deprecated and might be removed from future versions of glue. Use glue.agm.serverMethodAdded() instead');
	agm.serverMethodAdded = agm.client.server_method_added;
	agm.server_method_removed = deprecate(agm.client.server_method_removed, 'glue.agm.server_method_removed() is deprecated and might be removed from future versions of glue. Use glue.agm.serverMethodRemoved() instead');
	agm.serverMethodRemoved = agm.client.server_method_removed;

	agm.server_added = deprecate(agm.client.server_added, 'glue.agm.server_added() is deprecated and might be removed from future versions of glue. Use glue.agm.serverAdded() instead');
	agm.serverAdded = agm.client.server_added;
	agm.server_removed = deprecate(agm.client.server_removed, 'glue.agm.server_removed() is deprecated and might be removed from future versions of glue. Use glue.agm.serverRemoved() instead');
	agm.serverRemoved = agm.client.server_removed;

	agm.start = agm.server.start;
	agm.stop = agm.server.stop;

	if (global.console !== undefined && agm.debug === true) {
		console.log("AGM started.");
	}

	return agm;
	//return add_sugar(agm);

};

agm = global.htmlContainer !== undefined ? native_agm : agm;

//Export for browsers
if (global.tick42 === undefined) {
	global.tick42 = {};
}
global.tick42.agm = agm;

module.exports = agm;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../package.json":43,"./agm_client":33,"./agm_instance":39,"./agm_native":40,"./agm_server":41,"tick42-gateway-connection":55,"util-deprecate":78}],33:[function(require,module,exports){
(function (global){
/*
 The AGM Client analyses server presences, collects information about their methods and allows users to invoke these methods.
 */
var client_serverstate = require('./agm_client_serverstate');
var client_invocationsstate = require('./agm_client_invocationsstate');
var client_subscriptionstate = require('./agm_client_subscriptionstate');
var helpers = require('./agm_helpers');
var Promise = require('es6-promise').Promise;

module.exports = function (connection, instance, configuration) {
	//Validate configuration
	if (typeof configuration !== 'object') {
		configuration = {};
		if (global.console !== undefined && configuration.debug === true) {
			console.log('Creating an AGM client with default configuration.');
		}
	}
	if (typeof configuration.remove_server_on_n_missing_heartbeats !== 'number') {
		configuration.remove_server_on_n_missing_heartbeats = 3;
	}
	if (typeof configuration.method_response_timeout !== 'number') {
		configuration.method_response_timeout = 3000;
	}
	if (typeof configuration.wait_for_method_timeout !== 'number') {
		configuration.wait_for_method_timeout = 3000;
	}
	//Instantiate the module which keeps track of all available servers and methods
	var servers = client_serverstate(configuration, instance);
	//..and when you receive a heartbeat/presence from a server, delegate its processing to the module:
	connection.on('ServerPresenceMessage', function (msg) {
		servers.process_presence(msg, true);
	});
	connection.on('ServerHeartbeatMessage', function (msg) {
		servers.process_presence(msg, false);
	});
	//Instantiate the module that handles method execution and responses
	var response = client_invocationsstate(
		configuration,
		instance,
		function (m) {
		connection.send('MethodInvocationRequestMessage', m);
	});
	//..and instantiate the module that handles subscription to Streaming methods
	var subState = client_subscriptionstate(
		configuration,
		instance,
		function (m) {
			connection.send('MethodInvocationRequestMessage', m);
		});
	//..and delegate responses to them.
	connection.on('MethodInvocationResultMessage', function(msg){
		if(msg && msg.EventStreamAction && msg.EventStreamAction !== 0){
			subState.processPublisherMsg(msg);
		} else {
			response.process_method_response(msg);
		}
	});


//   //Adds client callbacks which are executed when a new method is added or stops being available
//   function method_added(callback) {
//     if (typeof callback === 'function') {
//       //Add the callback
//       configuration.on_method_added = callback;
//       //Call the callback for all the method which were added before the callback was registered.
//       servers.get_methods().forEach(function (method) {
//         callback(method);
//       });
//     } else {
//       throw '\'method_added\' must be called with a function as an argument';
//     }
//   }
//   function method_removed(callback) {
//     if (typeof callback === 'function') {
//       //Add the callback
//       configuration.on_method_removed = callback;
//     } else {
//       throw '\'method_removed\' must be called with a function as an argument';
//     }
//   }

//   //Adds client callbacks which are executed when a new method is added or stops being available
//   function server_added(callback) {
//     if (typeof callback === 'function') {
//       //Add the callback
//       configuration.on_server_added = callback;
//       //Call the callback for all the method which were added before the callback was registered.
//       servers.get_servers().forEach(function (server) {
//         callback(server);
//       });
//     } else {
//       throw '\'server_added\' must be called with a function as an argument';
//     }
//   }
//   function server_removed(callback) {
//     if (typeof callback === 'function') {
//       //Add the callback
//       configuration.on_server_removed = callback;
//     } else {
//       throw '\'server_removed\' must be called with a function as an argument';
//     }
//   }

	function subscribe(name, options, successCallback, errorCallback) {
		//options can have arguments:{}, target: 'best'/'all'/{server_instance}, waitTimeoutMs:3000

		function callSubstateSubscribe(targetServers, name, options, successProxy, errorProxy){
			if (global.console !== undefined && configuration.debug === true) {
				console.log('>>> Subscribing to "' + name + '" on ' + targetServers.length + ' servers');
			}

			subState.subscribe(
				{ name: name },
				options.arguments,
				targetServers,
				{ method_response_timeout: options.waitTimeoutMs },
				successProxy,
				errorProxy
			);
		}

		var promise = new Promise(function (resolve, reject) {

			var successProxy = function (args) { resolve(args); };
			var errorProxy   = function (args) { reject(args); };

			if (options === undefined) {
				options = {};
			}
			var target = options.target;
			if (target === undefined) {
				target = 'best';
			}
			if (typeof target === "string" && target !== "all" && target !== "best") {
				reject({message: '"' + target + '" is not a valid target. Valid targets are "all", "best", or an instance.'});
			}
			if (typeof options.waitTimeoutMs !== 'number' || options.waitTimeoutMs !== options.waitTimeoutMs /*NaN*/) {
				options.waitTimeoutMs = configuration.wait_for_method_timeout;
			}

			var currentServers = servers_for_method_and_target(name, target);

			//...including the MethodRequestSubject for the streaming method
			//don't check if the method is streaming or not, subscribing to non-streaming method has to invoke it

			if (currentServers.length === 0) {
				setTimeout( function() {
					var lateServers = servers_for_method_and_target(name, target);
					//TODO: change to use the methodAdded handler
					//TODO: set agm.methodAdded and if(waitTimeout>=0){setTimeout}
					callSubstateSubscribe(lateServers, name, options, successProxy, errorProxy)

				}, options.waitTimeoutMs)

			} else {
				callSubstateSubscribe(currentServers, name, options, successProxy, errorProxy)
			}
		});

		return helpers.promisify(promise, successCallback, errorCallback);
	}

	//Abstract get_method and get_servers functions
	//They rely on  get_method and get_servers from the "servers" module
	//In those ones you don't need to specify all of the method's props to find it.
	function get_method(method_filter) {
		if (typeof method_filter === 'string') {
			method_filter = {name: method_filter};
		}
		//Do not execute for empty filter
		if (method_filter === undefined) {
			return;
		}
		var exact_match = servers.get_method(method_filter);
		//Try calling the original "get_method" function (it will work if all method properties are specified):
		if (exact_match !== undefined) {
			return exact_match  //Take all available methods and iterate them until we find a match
				;
		} else {
			return takeWhile(servers.get_methods(), function (method) {
				return method_match(method_filter, method);
			});
		}
	}

	function get_methods(method_filter) {
		if (method_filter === undefined) {
			return servers.get_methods();
		}
		if (typeof method_filter === 'string') {
			method_filter = {name: method_filter};
		}
		return servers.get_methods().filter(function (method) {
			return method_match(method_filter, method);
		});
	}

	//Retrieves all servers that support any of several methods, listed as an array
	function get_methods_for_instance(instance_filter) {
		var exact_match = servers.get_methods(instance_filter);
		//Try calling the original "get_methods" function (it will work if all instance properties are specified):
		if (exact_match.length !== 0) {
			return exact_match;
		} else {
			var method_ids = get_servers().filter(function (server) {
				return instance_match(instance_filter, server);
			}).reduce(function (methods, server) {
				servers.get_method_ids(server).forEach(function (method_id) {
					methods[method_id] = true;
				});
				return methods;
			}, {});
			return Object.keys(method_ids).map(function (method_id) {
				return servers.get_method(method_id);
			});
		}
	}

	//Retrieves all servers that support a given method
	function get_servers(method_filter) {
		//No method - get all servers
		if (method_filter === undefined) {
			return servers.get_servers();
		}
		//Non-existing method - return an empty array
		var method = get_method(method_filter);
		if (method === undefined) {
			return [];
		}
		//Else, return servers for method
		return servers.get_servers(method);
	}


	//Retrieves all servers that support any of several methods, listed as an array
	function servers_for_methods(methods) {
		return methods.reduce(function (so_far, method) {
			return so_far.concat(servers.get_servers(method, true));//(the second argument is there because we also need the request subject)
		}, []).sort(servers.compare_servers);
	}

	function servers_for_method_and_target(method_filter, target) {
		//Get the methods which match the filter
		var methods = get_methods(method_filter);
		//Determine where to execute the method(s) (the "target" argument)
		//Get all servers that support the method(s) and get the ones that match the target criteria
		return filter_by_target(target, servers_for_methods(methods));
	}


	//Invokes an AGM method (mostly it does input checking), the actual job is done by "request.invoke"
	function invoke(method_filter, argument_obj, target, additional_options, success, error) {
		var promise = new Promise(function (resolve, reject) {
			var successProxy, errorProxy;

			successProxy = function (args) {
				//var parsed = JSON.parse(args);
				resolve(args);
			};
			errorProxy = function (args) {
				//var parsed = JSON.parse(args);
				reject(args);
			};
			//Add default params
			if (argument_obj === undefined) {
				argument_obj = {};
			}
			if (target === undefined) {
				target = 'best';
			}
			if (typeof target === "string" && target !== "all" && target !== "best") {
				reject({message: '"' + target + '" is not a valid target. Valid targets are "all" and "best".'});
			}
			if (additional_options === undefined) {
				additional_options = {};
			}

			if (additional_options.method_response_timeout === undefined) {
				additional_options.method_response_timeout = configuration.method_response_timeout;
			}
			if (additional_options.wait_for_method_timeout === undefined) {
				additional_options.wait_for_method_timeout = configuration.wait_for_method_timeout;
			}


			//Check if the arguments are an object
			if (typeof argument_obj !== 'object') {
				reject({message: 'The method arguments must be an object.'});
			}

			if (typeof method_filter === 'string') {
				method_filter = {name: method_filter};
			}

			var servers = servers_for_method_and_target(method_filter, target);

			if (servers.length === 0) {

				invoke_unexisting(method_filter, argument_obj, target, additional_options, successProxy, errorProxy);

			} else if (servers.length === 1) {
				if (global.console !== undefined && configuration.debug === true) {
					console.log('>>> Invoking "' + method_filter.name + '" on 1 server');
				}

				response.invoke(method_filter, argument_obj, servers[0], additional_options, successProxy, errorProxy);

			} else {
				if (global.console !== undefined && configuration.debug === true) {
					console.log('>>> Invoking "' + method_filter.name + '" on ' + servers.length + ' servers');
				}

				invoke_on_all(method_filter, argument_obj, servers, additional_options, successProxy, errorProxy);
			}
		});

		return helpers.promisify(promise, success, error);
	}


	//Called when the user tries to invoke a method which does not exist
	function invoke_unexisting(method_filter, argument_obj, target, additional_options, success, error) {
		var server_found = false;

		if (additional_options.wait_for_method_timeout === 0) {
			call_error();
		} else {
			setTimeout(function () {
				configuration.server_method_added = configuration.server_method_added.filter(function (callback) {
					return callback !== new_server;
				});
				if (!server_found) {
					call_error();
				}
			}, additional_options.wait_for_method_timeout);

			register_callback("server_method_added", identity, new_server);
		}


		function new_server() {
			if (server_found) {
				return;
			}
			var server = servers_for_method_and_target(method_filter, target)[0];
			if (server !== undefined) {
				server_found = true;
				response.invoke(method_filter, argument_obj, server, additional_options, success, error);
			}
		}


		function call_error() {
			//Check if the method exists and if it doesnt', return an error
			if (get_methods(method_filter).length === 0) {
				error({
					method: method_filter,
					called_with: argument_obj,
					message: 'I could not find a method with those properties: ' + JSON.stringify(method_filter)
				});
			} else {
				error({
					method: method_filter,
					called_with: argument_obj,
					message: 'I could not find servers with these properties: ' + JSON.stringify(target)
				});
				return;
			}
		}

	}


	//Called when the invokes a method with multiple targets
	//Calls a method for all servers and unifies the results they return into one:
	function invoke_on_all(method, argument_obj, servers, additional_options, success, error) {
		//Here we will store the results that the servers return
		var successes = [];
		var errors = [];
		//These are the callbacks
		var success_callback = function (result) {
			successes.push(result);
			send_response(successes, errors);
		};
		var error_callback = function (result) {
			errors.push(result);
			send_response(successes, errors);
		};
		//Call the method for all targets
		servers.forEach(function (server) {
			response.invoke(method, argument_obj, server, additional_options, success_callback, error_callback);
		});


		//Calls the main success and error callbacks with the aggregated results
		function send_response() {
			//wait till everybody is finished
			if (successes.length + errors.length < servers.length) {
				return;
			}
			//Execute the "success" callback
			if (successes.length !== 0) {
				var result = successes.reduce(function (obj, success) {
					obj.method = success.method;
					obj.called_with = success.called_with;
					obj.returned = success.returned;
					obj.all_return_values.push({
						executed_by: success.executed_by,
						returned: success.returned
					});
					obj.executed_by = success.executed_by;
					return obj;
				}, {all_return_values: []});

				//If we get errors from one of the servers add them to the success object that will be resolved.
				if (errors.length !== 0) {
					result.all_errors = [];
					errors.forEach(function (obj) {
						result.all_errors.push({
							//executed_by : obj.executed_by, // we don't get executed_by object from the error response
							name: obj.method.name,
							message: obj.message
						});
					});
				}

				success(result);

			} else if (errors.length !== 0) { //Execute the "error" callback
				error(errors.reduce(function (obj, error) {
					obj.method = error.method;
					obj.called_with = error.called_with;
					obj.message = error.message;
					obj.all_errors.push({
						executed_by: error.executed_by,
						message: error.message
					});
					//obj.executed_by = success.executed_by;
					return obj;
				}, {all_errors: []}));
			}
		}
	}


	var register_callback = helpers.save_callback_in.bind(this, configuration);

	var apply_on_servers = apply_on.bind(null, servers.get_servers);
	var apply_on_methods = apply_on.bind(null, servers.get_methods);
	var identity = function (a) {
		return a;
	};

	return {
		subscribe: subscribe,
		invoke: invoke,
		method: get_method,
		servers: get_servers,
		methods: get_methods,
		methods_for_instance: get_methods_for_instance,
		method_added: register_callback.bind(null, "method_added", apply_on_methods),
		method_removed: register_callback.bind(null, "method_removed", identity),
		server_added: register_callback.bind(null, "server_added", apply_on_servers),
		server_removed: register_callback.bind(null, "server_removed", identity),
		server_method_added: register_callback.bind(null, "server_method_added", identity),
		server_method_removed: register_callback.bind(null, "server_method_removed", identity),
		parse_signature: helpers.signature_parse_friendly
	};
};


//in server_method_added we try to curry the following:
//	configuration, "server_method_added", functionwhichreturnsfirstarg

//Filters an array of servers and returns the ones which match the target criteria
function filter_by_target(target, servers) {
	//If the user specified target as string:
	if (typeof target === 'string') {
		if (target === 'all') {
			target = servers;
		} else if (target === 'best') {
			target = servers[0] !== undefined ? [servers[0]] : [];  //If the user specified the target as server filter
		}
	} else {
		if (!Array.isArray(target)) {
			target = [target];
		}
		var unexisting_servers = [];
		//Retrieve all servers that match the filters
		target = target.reduce(function (matches, filter) {
			//Add matches for each filter
			var my_matches = servers.filter(function (server) {
				return instance_match(filter, server);
			});
			return matches.concat(my_matches);
		}, []);
	}
	return target;
}


//Matches a server definition against a server filter
function instance_match(instance_filter, instance_definition) {
	return contains_props(instance_filter, instance_definition);
}


//Matches a method definition against a method filter
function method_match(method_filter, method_definition) {
	return contains_props(method_filter, method_definition);
}


//Helpers

function contains_props(filter, object) {
	return Object.keys(filter).reduce(function (match, prop) {
		if (filter[prop].constructor === RegExp) {
			if (!filter[prop].test(object[prop])) {
				return false;
			}
			else {
				return match;
			}
		} else {
			if (String(filter[prop]).toLowerCase() !== String(object[prop]).toLowerCase()) {
				return false;
			}
			else {
				return match;
			}
		}
	}, true);
}


function takeWhile(array, pred) {
	var sz = array.length;
	for (var index = 0; index < sz; index++) {
		if (pred(array[index]) === true) {
			break;
		}
	}
	return array[index];
}


function apply_on(objects, func) {
	return objects().map(func);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_client_invocationsstate":34,"./agm_client_serverstate":36,"./agm_client_subscriptionstate":37,"./agm_helpers":38,"es6-promise":8}],34:[function(require,module,exports){
(function (global){
/*
 The Invcationsstate module handles AGM method invocations. via the 'invoke' method
 It sends and receives all invocation-related messages, via the "process_response" method
 that it exposes and via the "send_request" callback

 */

var helpers = require("./agm_helpers");

module.exports = function (configuration, instance, send_request) {
	"use strict";

	//Here we store all pending callbacks
	var pending_callbacks = {};


	//Invokes an AGM method to a single AGM server, given valid input.
	function invoke(method, argument_obj, target, stuff, success, error) {
		//Generate a unique invocation ID, for this invocation
		var invocation_id = Math.floor(Math.random() * 10000000000);

		//Register the user's callbacks
		register_invocation(invocation_id, {
			method: method,
			called_with: argument_obj
		}, success, error, stuff.method_response_timeout);

		//Get a response subject for this invocation
		instance.response_subject(method, function (response_subject) {

			//Construct a message
			var message = {
				MethodRequestSubject: target.request_subject,
				MethodResponseSubject: response_subject,
				Client: instance.info(),
				Context: {
					ArgumentsJson: argument_obj,
					InvocationId: invocation_id,
					ObjectType: stuff.object_type,
					DisplayContext: stuff.display_context,
					MethodName: method.name,
					ExecutionServer: target,
					Timeout: stuff.method_response_timeout
				}
			};
			//Send it

			send_request(message);
			if (global.console !== undefined && configuration.debug === true) {
				console.debug("%c>>> sending MethodInvocationRequestMessage", "background-color:hsla(198, 51%, 79%, 0.5)");
				console.debug("%c" + JSON.stringify(message), "background-color:hsla(198, 51%, 79%, 0.5)");
			}

		});
	}


	//Adds callbacks for a given invocation ID
	function register_invocation(invocation_id, response, success, error, timeout) {
		//Adds the callbacks
		pending_callbacks[invocation_id] = {response: response, success: success, error: error};
		//Schedules to throw a timeout if nobody answers
		setTimeout(function () {
			if (pending_callbacks[invocation_id] === undefined) {
				return;
			}
			error({
				method: response.method, called_with: response.argument_obj,
				message: "Timeout reached"
			});
			delete pending_callbacks[invocation_id];
		}, timeout);
	}

	function process_method_response(message) {
		//Finds the appropriate callback
		var callback = pending_callbacks[message.InvocationId];
		if (callback !== undefined) {
			if (global.console !== undefined && configuration.debug === true) {
				console.debug("%c<<< receiving MethodInvocationResultMessage", "background-color:hsla(118, 51%, 79%, 0.5)");
				console.debug("%c" + JSON.stringify(message), "background-color:hsla(118, 51%, 79%, 0.5)");
			}
			//If the server returned success, execute the success callback
			if (message.Status === 0 && typeof callback.success === "function") {
				//parse the result
				var result = message.ResultContextJson;
				//If the result is an empty object, there is no result
				if (result && Object.keys(result).length === 0) {
					result = undefined;
				}

				//Log that we received a result
				if (global.console !== undefined && configuration.debug === true) {
					console.log('<<<  "' + callback.response.method.name + '" was executed by ' + JSON.stringify(helpers.preprocess_server(message.Server)));
				}
				//Execute the success callback
				callback.success({
					method: callback.response.method,
					called_with: callback.response.called_with,
					executed_by: helpers.preprocess_server(message.Server),
					returned: result,
					message: message.ResultMessage,
					log_details: message.ResultLogDetails
				});
				//Else, return an error
			} else if (typeof callback.error === "function") {
				if (global.console !== undefined && configuration.debug === true) {
					console.log('<<<  "' + callback.response.method.name + '" was executed with error by ' + JSON.stringify(helpers.preprocess_server(message.Server)));
				}
				callback.error({
					method: callback.response.method,
					called_with: callback.response.called_with,
					message: message.ResultMessage,
					log_details: message.ResultLogDetails,
					status: message.status
				});
			}
			//Finally, remove the callbacks
			delete pending_callbacks[message.InvocationId];
		}
	}

	return {process_method_response: process_method_response, invoke: invoke};
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":38}],35:[function(require,module,exports){
(function (global){
/*
 The Methodstate module, keeps the state of available AGM methods in the network.
 */

var helpers = require("./agm_helpers");

module.exports = function (configuration) {
	//A list of all available AGM methods
	var methods = {};

	//Save the reference to the metric function if it exists
	var objectMetric = (configuration.metrics !== undefined) ? configuration.metrics.numberMetric.bind(configuration.metrics) : function () {
	};

	//Adds a new server to a method. Creates the method if it is not created previously.
	function add_server_to_method(method_info, server_id, server_info) {
		//Get the method ID
		var method_id = get_method_id(method_info);


		//One method can have several request subjects per server.
		//So the request subject is actually not a property of the method
		var request_subject = method_info.request_subject;
		delete  method_info.request_subject;


		//Copy the method and server objects to a format suitable for sending to users
		var method_info_friendly = helpers.clone_object(method_info);
		var server_info_friendly = helpers.clone_object(server_info);


		var method = methods[method_id];

		//If the method does not exist, create it
		if (method === undefined) {
			//Save the info
			method = methods[method_id] = {info: method_info, servers: {}};
			//Add request_subject
			method = add_request_subject(method, server_id, request_subject);

			//Execute user callbacks
			helpers.execute_all_with(configuration.method_added, method_info_friendly);
			//Log and publish metrics
			if (global.console !== undefined && console.table !== undefined && configuration.debug === true) {
				console.log(">>>>>> New method detected: " + JSON.stringify(method_info_friendly));
				console.table(get_methods());
			}
			objectMetric("Methods total count", Object.keys(methods).length);
		} else {
			//Else, just add the request subject
			method = add_request_subject(method, server_id, request_subject);
		}
		//Execute user callbacks
		helpers.execute_all_with(configuration.server_method_added, {
			method: method_info_friendly,
			server: server_info_friendly
		});
	}

	//Adds request subject for server and method
	function add_request_subject(method, server_id, request_subject) {
		method.servers[server_id] = request_subject;
		return method;
	}


	//Removes a server from a method. Deletes the method if there are no more servers left.
	function remove_server_from_method(method_id, server_id, server_info) {
		//Obtain info about the method before removing it.
		var method_info_friendly = get_method(method_id);
		var server_info_friendly = helpers.clone_object(server_info);


		//Remove the server from the list
		var servers = methods[method_id].servers;
		delete servers[server_id];
		//Remove the method if there aren't any servers left
		if (Object.keys(servers).length === 0) {
			var callback = configuration.on_method_removed;
			helpers.execute_all_with(configuration.method_removed, method_info_friendly);
			//remove method
			delete methods[method_id];
			//Log and metrics
			if (global.console !== undefined && console.table !== undefined && configuration.debug === true) {
				console.log("<<<<<< Method stopped being available: " + JSON.stringify(method_info_friendly));
				console.table(get_methods());
			}
			objectMetric("Methods total count", Object.keys(methods).length);
		}
		//Execute user callbacks
		helpers.execute_all_with(configuration.server_method_removed, {
			method: method_info_friendly,
			server: server_info_friendly
		});

	}

	//Generates a unique if for a method
	function get_method_id(m) {
		//Setting properies to defaults:
		var accepts = m.accepts !== undefined ? m.accepts : "";
		var returns = m.returns !== undefined ? m.returns : "";
		var version = m.version !== undefined ? m.version : 0;
		return (m.name + accepts + returns + version).toLowerCase();
	}


	//Retrieve all methods
	function get_methods() {
		return Object.keys(methods).map(function (method) {
			return helpers.clone_object(methods[method].info);
		});
	}

	//Retrieve an array of the ID's of the servers for a method
	function get_servers_for_method(method_info) {
		var method = methods[get_method_id(method_info)];
		if (method !== undefined) {
			return method.servers;
		}
		else {
			return {};
		}
	}

	//Retrieves a copy of the method, by its ID
	function get_method(method_id) {
		if (typeof method_id === "object") {
			method_id = get_method_id(method_id);
		}
		if (methods[method_id] !== undefined)
		//We clone the method definition so it can be mutated without affecting the original
			return helpers.clone_object(methods[method_id].info);
	}


	return {
		get_methods: get_methods,
		get_method: get_method,
		get_method_id: get_method_id,
		add_server_to_method: add_server_to_method,
		remove_server_from_method: remove_server_from_method,
		get_servers_for_method: get_servers_for_method
	};

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":38}],36:[function(require,module,exports){
(function (global){
/*
 The Serverstate module processes server presences and keeps the state of available AGM servers in the network.
 */
var helpers = require("./agm_helpers");

var get_server_id = helpers.get_server_id;

var client_methodstate = require("./agm_client_methodstate");

module.exports = function (configuration, instance) {
	"use strict";

	//A list of all the servers in the network
	var servers = {};

	//Instantiates the "methodstate" module
	var methods = client_methodstate(configuration);


	//Processes a presence message from a server
	function process_presence(presence, is_presence) {
		//console.log(presence.Instance)
		//Get server info.
		var serverinfo = helpers.preprocess_server(presence.Instance);

		if (is_presence) {
			// Ignore messages for dead servers
			// If it is a new server, register it.
			if (!exists(serverinfo)) {
				add_server(serverinfo);
			}

			if (presence.PublishingInterval) {
				set_timeout(serverinfo, presence.PublishingInterval);
			}
		}

		//Finally, update the methods
		if (presence.MethodDefinitions !== undefined) {
			update_methods(serverinfo, presence.MethodDefinitions);
		}

	}

	//This function sets a timeout which removes the server unless
	//the function is called again before the timeout is over
	function set_timeout(serverinfo, duration) {

		if (duration === -1) return;
		//Retrieve the server
		var server_id = get_server_id(serverinfo);
		var server = servers[server_id];
		//Stop the previous timeout
		if (server.bomb !== undefined) {
			clearTimeout(server.bomb);
		}
		//Set a new one
		server.bomb = setTimeout(function () {
			remove_server(serverinfo);
		}, duration * configuration.remove_server_on_n_missing_heartbeats + 1);

	}

	//Checks if a servers exists
	function exists(serverinfo) {
		var server_id = get_server_id(serverinfo);
		return servers[server_id] !== undefined;
	}

	//Register a server
	function add_server(serverinfo) {
		//Obtain a server ID and store the new server
		var server_id = get_server_id(serverinfo);
		servers[server_id] = {info: serverinfo, methods: [], bomb: undefined};

		//Log in console
		if (global.console !== undefined && console.table !== undefined && configuration.debug === true) {
			console.log(">>>>>> New server detected: " + JSON.stringify(serverinfo));
			console.table(get_servers());
		}

		//Execute user callbacks
		helpers.execute_all_with(configuration.server_added, serverinfo);

		return server_id;
	}

	//Unregisters a server
	function remove_server(serverinfo) {
		//Obtain a server ID
		var server_id = get_server_id(serverinfo);
		//Remove the server's methods
		servers[server_id].methods.forEach(function (method_id) {
			methods.remove_server_from_method(method_id, server_id, serverinfo);
		});
		//Remove the server itself
		delete servers[server_id];
		//Log in console
		if (global.console !== undefined && console.table !== undefined && configuration.debug === true) {
			console.log("<<<<<< Server stopped being available:" + JSON.stringify(serverinfo));
			console.table(get_servers());
		}

		//Execute user callbacks
		helpers.execute_all_with(configuration.server_removed, serverinfo);
	}

	//Updates the methods of a server
	function update_methods(serverinfo, new_methods) {
		var server_id = get_server_id(serverinfo);
		//Get an array of the methods the server had before we started this
		var old_methods_ids = servers[server_id].methods;
		//Get an array of the methods that the server has now
		new_methods = new_methods.map(helpers.preprocess_method).reduce(function (obj, method) {
			obj[methods.get_method_id(method)] = method;
			return obj;
		}, {});
		//For each of the old methods
		old_methods_ids.forEach(function (method_id) {
			//Check if it is still there
			if (new_methods[method_id] === undefined) {
				//If it isn't, remove it
				methods.remove_server_from_method(method_id, server_id, serverinfo);
			} else {
				//If it is there in both the old array and the new one, we don't need to add it again
				new_methods[method_id] = undefined;
			}
		});
		//Now add the new methods
		var new_methods_ids = Object.keys(new_methods);
		new_methods_ids.forEach(function (id) {
			if (new_methods[id] !== undefined) {
				methods.add_server_to_method(new_methods[id], server_id, serverinfo);
			}
		});
		//Now all we have to do is replace the list of methods the server has
		servers[server_id].methods = new_methods_ids;

	}

	//Get all servers for a given method
	function get_servers(method, include_request_subject) {
		var server_ids;
		//If there isn't a method get the ID's of all servers
		if (method === undefined) {
			server_ids = Object.keys(servers);
			//Else, get a list of the servers that have the method
		} else {
			var ids_to_request_subjects = methods.get_servers_for_method(method);
			server_ids = Object.keys(ids_to_request_subjects);
		}
		//Format the list
		return server_ids.map(function (server_id) {
			var server = helpers.clone_object(servers[server_id].info);
			//Include the request subject for each server for each method:
			if (include_request_subject) {
				server.request_subject = ids_to_request_subjects[server_id];
			}
			return server;
		}).sort(compare_servers);
	}

	//A comparer function. Sorts the servers based on availability
	function compare_servers(server1, server2) {
		var s1 = 0;
		var s2 = 0;
		//+2 if the server is on the same machine
		if (server1.machine === instance.machine) {
			s1 = s1 + 2;
		}
		if (server2.machine === instance.machine) {
			s2 = s2 + 2;
		}
		//+1 if it runs under the same user
		if (server1.user === instance.user) {
			s1 = s1 + 1;
		}
		if (server2.user === instance.user) {
			s2 = s2 + 1;
		}
		return s2 - s1;
	}

	function get_method_ids(server) {
		return servers[get_server_id(server)].methods;
	}


	//Get all methods for a given server
	function get_methods(server) {
		//If there is no server specified, return all
		if (server === undefined) {
			return methods.get_methods();
			//Else, get the methods from the server object
		} else if (exists(server)) {
			return get_method_ids(server).map(function (method_id) {
				return methods.get_method(method_id);
			});
			//If the server is specified, but it does not exist, return an empty array
		} else {
			return [];
		}
	}

	return {
		process_presence: process_presence,
		get_methods: get_methods,
		get_method_ids: get_method_ids,
		get_servers: get_servers,
		get_method: methods.get_method,
		exists: exists,
		compare_servers: compare_servers
	};
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_client_methodstate":35,"./agm_helpers":38}],37:[function(require,module,exports){
(function (global){
/*
 The Subscription-state module handles AGM stream subscriptions via the 'subscribe' method
 It sends and receives all invocation-related messages, via the "process_response" method
 that it exposes and via the "SendRequest" callback

 */

var helpers = require("./agm_helpers");

module.exports = function (configuration, instance, SendRequest) {
	"use strict";

	var STATUS_AWAITING_ACCEPT = 'awaitingAccept'; // not even one server has accepted yet
	var STATUS_SUBSCRIBED = 'subscribed'; // at least one server has responded as 'Accepting'
	var ERR_MSG_SUB_FAILED = 'Subscription failed.';
	var ERR_MSG_SUB_REJECTED = 'Subscription rejected.';
	var ON_CLOSE_MSG_SERVER_INIT = 'ServerInitiated';
	var ON_CLOSE_MSG_CLIENT_INIT = 'ClientInitiated';

	var subscriptionsList = {};

	//Preps and sends a request to subscribe to a single AGM stream publisher.
	function subscribe(streamingMethod, argument_obj, targetServers, stuff, success, error) {

		if(targetServers.length === 0){
			error(ERR_MSG_SUB_FAILED);
			return;
		}

		//This same Id will be passed to all the servers (as 'InvocationId')
		// so they can respond back with it during the initial handshake
		var subscriptionId = 'subscriptionId_' + helpers.generateRandom();

		//Register the user's callbacks
		var pendingSub = registerSubscription(
			subscriptionId,
			{
				method: streamingMethod,
				called_with: argument_obj
			},
			success,
			error,
			stuff.method_response_timeout
		);

		if(typeof pendingSub !== 'object'){
			error(ERR_MSG_SUB_FAILED);
			return;
		}

		//Send a subscription request to each server
		targetServers.forEach(function(target){

			//Get a response subject for this invocation
			instance.response_subject(streamingMethod, function (responseSubject) {

				//Add server to the list of ones the client is expecting a response from
				pendingSub.trackedServers.push({
					server: undefined,
					streamId: undefined,
					streamSubjects: {
						global: undefined,
						private: undefined
					},
					methodRequestSubject: target.request_subject,
					methodResponseSubject: responseSubject
				});

				//Construct a message
				var message = {
					EventStreamAction: 1, //"Subscribe" = client wishes to subscribe
					MethodRequestSubject: target.request_subject,
					MethodResponseSubject: responseSubject,
					Client: instance.info(),
					Context: {
						ArgumentsJson: argument_obj,
						InvocationId: subscriptionId,
						ObjectType: stuff.object_type,
						DisplayContext: stuff.display_context,
						MethodName: streamingMethod.name,
						ExecutionServer: target,
						Timeout: stuff.method_response_timeout
					}
				};

				//Send it
				SendRequest(message);

				if (global.console !== undefined && configuration.debug === true) {
					console.debug("%c>>> sending MethodInvocationRequestMessage", "background-color:hsla(198, 51%, 79%, 0.5)");
					console.debug("%c" + JSON.stringify(message), "background-color:hsla(198, 51%, 79%, 0.5)");
				}
			});

		});

	}


	function registerSubscription(subscriptionId, response, success, error, timeout){

		subscriptionsList[subscriptionId] = {
			status:STATUS_AWAITING_ACCEPT,
			response: response,
			success: success,
			error: error,
			trackedServers: [],
			handlers: {
				onData: [],
				onClosed: []
				//onFailed: []
			},
			queued: {
				data: [],
				closers: []
			},
			timeoutId: undefined
		};


		subscriptionsList[subscriptionId].timeoutId = setTimeout(function () {
			if (subscriptionsList[subscriptionId] === undefined) {
				return; //no such subscription
			}

			var subscription = subscriptionsList[subscriptionId]


			if (subscription.status === STATUS_AWAITING_ACCEPT) {
				error({
					method: response.method, called_with: response.called_with,
					message: ERR_MSG_SUB_FAILED
				});

				//None of the target servers has answered the subscription attempt
				delete subscriptionsList[subscriptionId];

			} else if (
				subscription.status === STATUS_SUBSCRIBED
				&& subscription.trackedServers.length > 0
			){
				//clean the trackedServers
				subscription.trackedServers = subscription.trackedServers.filter(function(server){
					return (typeof server.streamId === 'string' && server.streamId !== 'string')
				});

				subscription.timeoutId = undefined;

				if(subscription.trackedServers.length === 0){
					//There are no open streams, some servers accepted then closed very quickly
					//	(that's why the status changed but there's no good server with a StreamId)

					//call the onClosed handlers
					var closersCount = subscription.queued.closers.length;
					var closingServer = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;

					subscription.handlers.onClosed.forEach(function(callback){
						if(typeof callback === 'function'){
							callback({
								message: ON_CLOSE_MSG_SERVER_INIT,
								requestArguments: subscription.response.called_with,
								server: closingServer,
								stream: subscription.response.method
							})
						}
					});

					delete subscriptionsList[subscriptionId];
				}
			}
		}, timeout);

		return subscriptionsList[subscriptionId]
	}

	function processPublisherMsg(msg){
		if( ! (msg && msg.EventStreamAction && msg.EventStreamAction !== 0) ){
			return;
		}

		if(msg.EventStreamAction === 2) {

			serverIsKickingASubscriber(msg);

		} else if(msg.EventStreamAction === 3) {

			serverAcknowledgesGoodSubscription(msg);

		} else if(msg.EventStreamAction === 5) {

			serverHasPushedSomeDataIntoTheStream(msg);
		}

	}

	/** msg 'Response' Actions */
	//action 2
	function serverIsKickingASubscriber(msg){

		//Note: this might be either the server rejecting a subscription request OR closing an existing subscription

		//Get ALL subscriptions
		var keys = Object.keys(subscriptionsList);

		//If it is a rejection there may be an InvocationId, it can narrow the search
		if(typeof msg.InvocationId === 'string' && msg.InvocationId !== ''){
			keys = keys.filter(function(k){
				return k === msg.InvocationId;
			})
		}

		var deletionsList = [];

		//Find the kicking/rejecting server and remove it from the subscription.trackedServers[]
		keys.forEach(function(key){
			if(typeof subscriptionsList[key] !== 'object'){
				return;
			}

			subscriptionsList[key].trackedServers = subscriptionsList[key].trackedServers.filter(function(server){
				var isRejecting = (
					server.methodRequestSubject === msg.MethodRequestSubject
					&& server.methodResponseSubject === msg.MethodResponseSubject
				);

				var isKicking = (
					server.streamId === msg.StreamId
					&& (
						server.streamSubjects.global === msg.EventStreamSubject
						|| server.streamSubjects.private === msg.EventStreamSubject
					)
				);

				var isRejectingOrKicking = isRejecting || isKicking;

				return ! isRejectingOrKicking;
			});

			if(subscriptionsList[key].trackedServers.length === 0){
				deletionsList.push(key);
			}
		});

		//Call onClosed OR error()
		// and remove the subscription
		deletionsList.forEach(function(key){
			if(typeof subscriptionsList[key] !== 'object'){
				return;
			}

			if (
				subscriptionsList[key].status === STATUS_AWAITING_ACCEPT
				&& typeof subscriptionsList[key].timeoutId === 'number'
			){

				subscriptionsList[key].error(ERR_MSG_SUB_REJECTED);
				clearTimeout(subscriptionsList[key].timeoutId);

			} else {

				//The timeout may or may not have expired yet,
				// but the status is 'subscribed' and trackedServers is now empty

				subscriptionsList[key].handlers.onClosed.forEach(function(callback){
					if(typeof callback === 'function'){
						callback({
							message: ON_CLOSE_MSG_SERVER_INIT,
							requestArguments: subscriptionsList[key].response.called_with,
							server: msg.Server,
							stream: subscriptionsList[key].response.method
						});
					}
				});

			}

			delete subscriptionsList[key];

		});
	}

	//action 3
	function serverAcknowledgesGoodSubscription(msg){

		var subscriptionId = msg.InvocationId;

		var subscription = subscriptionsList[subscriptionId];

		if(typeof subscription !== 'object'){
			return;
		}

		var acceptingServer = subscription.trackedServers.filter( function(server) {
			return (
				server.methodRequestSubject === msg.MethodRequestSubject
				&& server.methodResponseSubject === msg.MethodResponseSubject
			)
		})[0];

		if(typeof acceptingServer !== 'object'){
			return;
		}

		var isFirstResponse = ( subscription.status === STATUS_AWAITING_ACCEPT );

		subscription.status = STATUS_SUBSCRIBED;

		var privateStreamSubject = generatePrivateStreamSubject(subscription.response.method.name);

		if(typeof acceptingServer.streamId === 'string' && acceptingServer.streamId !== ''){
			return; //already accepted previously
		}

		acceptingServer.server = msg.Server;
		acceptingServer.streamId = msg.StreamId;
		acceptingServer.streamSubjects.global = msg.EventStreamSubject;
		acceptingServer.streamSubjects.private = privateStreamSubject;
		//acceptingServer.methodResponseSubject stays the same

		var confirmatoryRequest = {
			EventStreamAction: 3, //"Subscribed" = client confirms intention to subscribe
			EventStreamSubject: privateStreamSubject,
			StreamId: msg.StreamId,
			MethodRequestSubject: msg.MethodRequestSubject,
			MethodResponseSubject: acceptingServer.methodResponseSubject,
			Client: instance.info(),
			Context:{
				ArgumentsJson: subscription.response.called_with,
				MethodName: subscription.response.method.name
			}
		};

		SendRequest(confirmatoryRequest);

		if(isFirstResponse){
			//Pass in the subscription object
			subscription.success({
				onData: function(dataCallback){
					if(typeof dataCallback !== "function"){
						throw new TypeError('The data callback must be a function.')
					}

					this.handlers.onData.push(dataCallback)
					if(this.handlers.onData.length === 1 && this.queued.data.length > 0){
						this.queued.data.forEach(function(dataItem){
							dataCallback(dataItem)
						})
					}
				}.bind(subscription),
				onClosed: function(closedCallback){
					if(typeof closedCallback !== "function"){
						throw new TypeError('The callback must be a function.')
					}
					this.handlers.onClosed.push(closedCallback)
				}.bind(subscription),
				onFailed:function(failedCallback){},
				close: closeSubscription.bind(subscription, subscriptionId),
				requestArguments: subscription.response,
				serverInstance: msg.Server,
				stream: subscription.response.method
			});
		}
	}

	//action 5
	function serverHasPushedSomeDataIntoTheStream(msg){

		//Find the subscription of interest by trawling the dictionary
		for(var key in subscriptionsList){
			if(subscriptionsList.hasOwnProperty( key ) && typeof subscriptionsList[key] === 'object'){

				var isPrivateData = undefined;

				var trackedServersFound = subscriptionsList[key].trackedServers.filter(function(ls){
					return (
						ls.streamId === msg.StreamId
						&& ( ls.streamSubjects.global === msg.EventStreamSubject
								 || ls.streamSubjects.private === msg.EventStreamSubject )
					);
				});

				if(trackedServersFound.length === 0){
					isPrivateData = undefined
				} else if(trackedServersFound[0].streamSubjects.global === msg.EventStreamSubject) {
					isPrivateData = false
				} else if (trackedServersFound[0].streamSubjects.private === msg.EventStreamSubject) {
					isPrivateData = true
				}

				if(isPrivateData !== undefined){
					//create the arrivedData object
					var receivedStreamData = {
						data: msg.ResultContextJson,
						server:msg.Server,
						requestArguments: subscriptionsList[key].response.called_with ||  {},
						message: msg.ResultMessage,
						private: isPrivateData
					};

					var onDataHandlers = subscriptionsList[key].handlers.onData;
					var queuedData = subscriptionsList[key].queued.data;

					if( Array.isArray(onDataHandlers) ){
						if(onDataHandlers.length > 0){
							onDataHandlers.forEach(function(callback){
								if(typeof callback === "function"){
									callback(receivedStreamData)
								}
							})
						} else {
							queuedData.push(receivedStreamData)
						}
					}
				}
			}
		}//end for-in
	}

	/** (subscription) Methods */
	function closeSubscription(subId){

		instance.response_subject({}, function (responseSubject) {
			this.trackedServers.forEach(function(server){
				SendRequest({
					EventStreamAction: 2,
					Client: instance.info(),
					MethodRequestSubject: server.methodRequestSubject,
					MethodResponseSubject: responseSubject,
					StreamId: server.streamId,
					EventStreamSubject: server.streamSubjects.private
				});
			});
		}.bind(this));

		var sub = this;

		//Call the onClosed handlers
		this.handlers.onClosed.forEach(function(callback){
			if(typeof callback === 'function'){
				callback({
					message: ON_CLOSE_MSG_CLIENT_INIT,
					requestArguments: sub.response.called_with || {},
					server: sub.trackedServers[sub.trackedServers.length - 1].server,
					stream: sub.response.method
				})
			}
		});

		delete subscriptionsList[subId];
	}

	function generatePrivateStreamSubject(methodName){

		var appInfo = instance.info();

		var privateStreamSubject = 'ESSpriv-jsb_'
			+ appInfo.ApplicationName
			+ '_on_' + methodName + '_'
			+ helpers.generateRandom();

		return privateStreamSubject;
	}

	return { //an instance of the subState
		subscribe: subscribe,
		processPublisherMsg: processPublisherMsg
	};
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":38}],38:[function(require,module,exports){
(function (global){
//Converts server properties from camel to snake case
function preprocess_server(m) {
	return {
		machine: m.MachineName,
		pid: m.ProcessId,
		started: m.ProcessStartTime,
		user: m.UserName,
		application: m.ApplicationName,
		environment: m.Environment,
		region: m.Region,
		service_name: m.ServiceName,
		metrics_repository_id: m.MetricsRepositoryId,
		state: m.State
	};
}

function clone_object(method) {
	var new_method = {};
	for (var i in method) {
		//Remove undefined values from object before passing it to the user
		if (method[i] !== undefined && method[i] !== "" && method[i] !== 0) {
			new_method[i] = method[i];
		}
	}
	return new_method;
}

//Helper: preprocesses the method definition
function preprocess_method(method_info) {
	var method = method_info.Method;
	return {
		name: method.Name,
		accepts: method.InputSignature,
		returns: method.ResultSignature,
		request_subject: method_info.MethodRequestSubject,
		description: method.Description,
		display_name: method.DisplayName,
		version: method.Version,
		object_types: method.ObjectTypeRestrictions
	};
}


function save_callback_in(callback_obj, event, on_callback_add, callback) {
	if (typeof callback === 'function') {
		callback_obj[event] = callback_obj[event] || [];
		callback_obj[event].push(callback);
		on_callback_add(callback);
	} else {
		throw '"' + event + '" must be called with a function as an argument';
	}
}

function execute_all_with(callbacks, input) {
	if (typeof callbacks === "object") {
		callbacks.forEach(function (callback) {
			callback(input);
		});
	}
}

//Generates a unique ID for a server
function get_server_id(serverinfo) {
	if (serverinfo === undefined) {
		return undefined;
	}
	//The matching is case-insensitive
	return (serverinfo.application + serverinfo.user + serverinfo.started + serverinfo.pid).toLowerCase();
}

function promisify(promise, successCallback, errorCallback) {
	if (typeof successCallback !== 'function' && typeof errorCallback !== 'function') {
		return promise;
	}

	if (typeof successCallback !== 'function') {
		successCallback = function (args) {
			if (global.console !== undefined && agm.debug === true) {
				console.log("Success!");
			}
		};
	} else if (typeof errorCallback !== 'function') {
		errorCallback = function (args) {
			if (global.console !== undefined && agm.debug === true) {
				console.log("An error occurred.");
			}
		};
	}

	promise.then(successCallback, errorCallback);
}

function generateRandom(){
	return Math.floor(Math.random() * 10000000000);
}

function isJustPlainUserObject(input){

	if(typeof input !== 'object' || input === null){
		return false;
	}

	if(Object.prototype.toString.call(input) !== '[object Object]'){
		return false;
	}

	var proto;

	if ( typeof Object.getPrototypeOf !== 'function' ) {
		if ( typeof 'test'.__proto__ === 'object' ) {
			proto = input.__proto__;
		} else {
			if(input.constructor === undefined){
				return false;
			}
			// May fail if the constructor was mutated
			proto = input.constructor.prototype;
		}
	} else {
		proto = Object.getPrototypeOf(input);
	}

	if(proto === null || proto === undefined) {
		return true;
	}

	var consTor = Object.prototype.hasOwnProperty.call(proto, 'constructor') && proto.constructor;

	return (
		typeof consTor == 'function'
		&& consTor instanceof consTor //checks if at the end of the prototype chain
		&& funcToString.call(consTor) === funcToString.call(Object) //checks if the Object constructor is there
	);
}

module.exports = {
	get_server_id: get_server_id,
	execute_all_with: execute_all_with,
	save_callback_in: save_callback_in,
	preprocess_server: preprocess_server,
	preprocess_method: preprocess_method,
	clone_object: clone_object,
	promisify: promisify,
	generateRandom: generateRandom,
	isJustPlainUserObject: isJustPlainUserObject
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],39:[function(require,module,exports){
(function (global){
/*
 The AGM instance collects information about the machine we are in, 
 and interacts with the .NET gateway in other ways, 
 to deliver full AGM compatibility to AGM.JS.

 To do so, it relies on the default AGM client.
 */

var document = global.document || global.process;

module.exports = function (c, connection) {
	var instance = {};
	//Generate default instance properties
	instance.ApplicationName = document.title + Math.floor(Math.random() * 1000000000);
	instance.ProcessId = Math.floor(Math.random() * 1000000000);
	instance.ProcessStartTime = new Date().getTime();

	//Apply user-submitted instance properties 
	if (typeof c === "object") {
		if (c.application !== undefined) {
			instance.ApplicationName = c.application;
		}
		instance.MachineName = c.machine;
		instance.UserName = c.user;
		instance.Environment = c.environment;
		instance.Region = c.region;
		instance.ServiceName = c.service_name;
		instance.MetricsRepositoryId = c.metrics_repository_id;
		instance.State = 1;
	}
	var identity_updated = false;
	connection.on("Instance", function (i) {
		if (identity_updated) {
			return;
		}
		if (instance.MachineName === undefined) {
			instance.MachineName = i.MachineName;
		}
		if (instance.UserName === undefined) {
			instance.UserName = i.UserName;
		}
		if (instance.Environment === undefined) {
			instance.Environment = i.Environment;
		}
		if (instance.Region === undefined) {
			instance.Region = i.Region;
		}
		if (instance.ServiceName === undefined) {
			instance.ServiceName = i.ServiceName;
		}
		if (instance.MetricsRepositoryId === undefined) {
			instance.MetricsRepositoryId = i.MetricsRepositoryId;
		}
		if (instance.State === undefined) {
			instance.State = i.State;
		}
		if (global.console !== undefined && global.console.table !== undefined && agm.debug === true) {
			console.log("Received instance with info from Gateway.");
		}
		identity_updated = true;
	});
	//Create a method for accessing a property
	function create_getter(property) {
		return instance[property];
	}

	//Generates a request subject for a method
	//Delegates it to the .NET gateway if it is online, 
	//to create subjects which are valid in the scope of the transport that is being used.
	var req_subject = 0;

	function request_subject(method_identifier, callback) {
		callback("req" + (req_subject++) + instance.ProcessId);
	}

	//Generates a response subject subject for a method invocation
	//Delegates it to the .NET gateway if it is online, 
	//to create subjects which are valid in the scope of the transport that is being used.
	var resp_subject = 0;

	function response_subject(method_identifier, callback) {
		callback("resp" + (resp_subject++) + instance.ProcessId);
	}

	//Returns all instance properties
	function info() {
		return instance;
	}

	return {
		request_subject: request_subject,
		response_subject: response_subject,
		info: info,
		application: create_getter("ApplicationName"),
		pid: create_getter("ProcessId"),
		user: create_getter("UserName"),
		machine: create_getter("MachineName")

	};

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],40:[function(require,module,exports){
(function (global){
var Promise = require('es6-promise').Promise;
var h = require("./agm_helpers");

module.exports = function (configuration) {
	function stringToObject(param, stringPropName) {
		if (typeof param == 'string') {
			var obj = {};
			obj[stringPropName] = param;
			return obj;
		}

		return param;
	}

	// helper function for parsing dates properly
	function agmParse(str) {
		return JSON.parse(str, function (k, v) {
			if (typeof v !== 'string') {
				return v;
			}

			// pre-seed - this should be a bit faster than indexOf
			if (v[0] !== dateTimeIdentifier[0]) {
				return v;
			}

			if (v.indexOf(dateTimeIdentifier) !== 0) {
				return v;
			}

			var unixTimestampMs = v.substr(lenOfIdentitifier);
			return new Date(parseFloat(unixTimestampMs));
		});
	}

	/**
	 * Converts a target argument to object ready to be passed to Agm facade
	 * @param target
	 */
	function targetArgToObject(target) {

		target = target || 'best';

		if (typeof target === "string") {
			if (target !== "all" && target !== "best") {
				throw new Error('"' + target + '" is not a valid target. Valid targets are "all" and "best".');
			}
			return {target: target};
		} else {
			if (!Array.isArray(target)) {
				target = [target];
			}

			target = target.map(function (e) {
				return convertInstanceToRegex(e);
			});

			return {serverFilter: target};
		}
	}

	function convertInstanceToRegex(instance) {
		var instance_converted = {};

		Object.keys(instance).forEach(function (key) {
			var propValue = instance[key];
			instance_converted[key] = propValue;

			if (typeof propValue === "undefined" || propValue === null) {
				return;
			}

			if (typeof propValue === "string") {
				// do exact matching if user passed a string
				instance_converted[key] = "^" + instance[key] + "$";
			}
			else if (instance[key].constructor === RegExp) {
				instance_converted[key] = instance[key].source;
			}
			else {
				instance_converted[key] = instance[key];
			}
		});
		return instance_converted;
	}

	var result = {

		// Registers a JavaScript function as an AGM method, thus making it available other AGM instances on the same transport.
		register: function (methodInfo, callback) {

			var pv = this.agmFacade.protocolVersion;

			if (pv && pv >= 3) {
				// for newer HC use the version where we don't pass arguments as JSON (because of different issues)
				this.agmFacade.register(JSON.stringify(stringToObject(methodInfo, "name")),
					callback,
					true); // return as objects
			} else {
				this.agmFacade.register(JSON.stringify(stringToObject(methodInfo, "name")),
					function (arg) {
						var result = callback(JSON.parse(arg), arguments[1]);
						return JSON.stringify(result);
					});
			}
		},

		registerAsync: function (methodInfo, callback) {
			if (!this.agmFacade.registerAsync) {
				throw new Error('not supported in that version of HtmlContainer');
			}

			this.agmFacade.registerAsync(stringToObject(methodInfo, 'name'),
				function(args, instance, tracker) {
					// execute the user callback
					callback(args,
						instance,
						function (successArgs) {
							tracker.success(successArgs);
						},
						function (error) {
							tracker.error(error)
						});
				});
		},

		unregister: function (methodFilter) {
			this.agmFacade.unregister(JSON.stringify(stringToObject(methodFilter, "name")));
		},

		// Invokes an AGM method asynchronously.
		invoke: function (methodFilter, args, target, options, successCallback, errorCallback) {

			var promise = new Promise(function (resolve, reject) {

				if (!args) {
					args = {};
				}

				if (typeof args !== 'object') {
					reject({message: 'The method arguments must be an object.'});
				}

				if (!options) {
					options = {};
				}

				target = targetArgToObject(target);

				if (this.agmFacade.invoke2) {
					// invoke ver2 - do not stringify arguments and result values
					this.agmFacade.invoke2(
						JSON.stringify(stringToObject(methodFilter, "name")),
						args,
						JSON.stringify(target),
						JSON.stringify(options),
						function (args) {
							resolve(args)
						},
						function (err) {
							reject(err)
						}
					);
				} else {
					var successProxy, errorProxy;

					successProxy = function (args) {
						var parsed = JSON.parse(args);
						resolve(parsed);
					};
					errorProxy = function (args) {
						var parsed = JSON.parse(args);
						reject(parsed);
					};
					this.agmFacade.invoke(
						JSON.stringify(stringToObject(methodFilter, "name")),
						JSON.stringify(args),
						JSON.stringify(target),
						JSON.stringify(options),
						successProxy,
						errorProxy
					);
				}

			}.bind(this));

			return h.promisify(promise, successCallback, errorCallback);
		},

		// Registers a handler which notifies you when a new AGM method is available.
		methodAdded: function (callback) {
			this.agmFacade.methodAdded(callback);
		},

		// Registers a handler which notifies you when an AGM method stops being available.
		methodRemoved: function (callback) {
			this.agmFacade.methodRemoved(callback);
		},

		serverAdded: function (callback) {
			this.agmFacade.serverAdded(callback);
		},

		serverRemoved: function (callback) {
			this.agmFacade.serverRemoved(callback);
		},

		serverMethodAdded: function (callback) {
			this.agmFacade.serverMethodAdded(callback);
		},

		serverMethodRemoved: function (callback) {
			this.agmFacade.serverMethodRemoved(callback);
		},

		// Retrieves a list of AGM servers (instances) optionally filtered by method.
		servers: function (methodFilter) {
			var jsonResult = this.agmFacade.servers(JSON.stringify(methodFilter));
			return agmParse(jsonResult);
		},

		// Retrieves a list of methods that matches a given filter. You can use this to check if a given method exists.
		methods: function (methodFilter) {
			var jsonResult = this.agmFacade.methods(JSON.stringify(methodFilter));
			return agmParse(jsonResult);
		},

		methodsForInstance: function (instanceFilter) {
			var jsonResult = this.agmFacade.methodsForInstance(JSON.stringify(instanceFilter));
			return agmParse(jsonResult);
		},

		// streaming support
		subscribe: function (name, options, successCallback, errorCallback) {
			var promise = new Promise(function (resolve, reject) {
				if (options === undefined) {
					options = {};
				}
				options.args = JSON.stringify(options.arguments || {});
				options.target = targetArgToObject(options.target);

				this.agmFacade.subscribe2(name,
					JSON.stringify(options),
					function (stream) {
						resolve(stream);
					},
					function (error) {
						reject(error);
					}
				);
			}.bind(this));

			return h.promisify(promise, successCallback, errorCallback);
		},

		createStream: function (streamDef, callbacks, successCallback, errorCallback) {
			var promise = new Promise(function (resolve, reject) {
				if (typeof streamDef === "string") {
					streamDef = {name: streamDef};
				}

				if (!callbacks) {
					callbacks = {};
				}

				this.agmFacade.createStream2(
					JSON.stringify(streamDef),
					// TODO - wrap to transform params
					callbacks.subscriptionRequestHandler,
					// TODO - wrap to transform params
					callbacks.subscriptionAddedHandler,
					// TODO - wrap to transform params
					callbacks.subscriptionRemovedHandler,
					// success handler
					function (stream) {
						resolve(stream);
					},
					// error handler
					function (error) {
						reject(error);
					}
				);
			}.bind(this));

			return h.promisify(promise, successCallback, errorCallback);
		}
	};

	result.version = "2.3.1";

	// add metrics
	if (configuration !== undefined && configuration.metrics !== undefined) {
		configuration.metrics.metricsIdentity = configuration.metrics.identity;


		// quick and dirty - we need to stringify the configuration so we need to replace the metrics object (which has circular references)
		// with an object that holds only the properties needed
		var metricsConfig = {
			metricsIdentity: configuration.metrics.metricsIdentity,
			path: configuration.metrics.path
		};
		configuration.metrics = metricsConfig;
	}
	
	//create new AGM façade for this instance
	var facade = global.htmlContainer.jsAgmFacade;
	var configAsString = JSON.stringify(configuration, function( key, value) {
		if( key == 'logger') {
			return '';
		} else {
			return value;
		}
	});
	result.instance = facade.init(configAsString);
	result.agmFacade = facade;

	// date parsing
	var dateTimeIdentifier = result.agmFacade.jsonValueDatePrefix;

	// deprecated API
	result.create_stream = result.createStream;
	result.methods_for_instance = result.methodsForInstance;
	result.method_added = result.methodAdded;
	result.method_removed = result.methodRemoved;
	result.server_added = result.serverAdded;
	result.server_removed = result.serverRemoved;
	result.server_method_added = result.serverMethodAdded;
	result.server_method_removed = result.serverMethodRemoved;

	return result;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":38,"es6-promise":8}],41:[function(require,module,exports){
(function (global){
/*
 The AGM Server allows users register AGM methods.
 It exposes these methods to AGM clients (using presence messages) and listens for their invocation
 */

var helpers = require("./agm_helpers");
var Promise = require('es6-promise').Promise;
var stream_publisher = require("./agm_stream_publisher");

module.exports = function (connection, instance, configuration) {

	//Validate configuration
	if (typeof configuration !== "object") {
		configuration = {};

		if (global.console !== undefined && configuration.debug === true) {
			console.log('Creating an AGM server with default configuration.');
		}
	}
	//Add defaults
	if (typeof configuration.heartbeat_interval !== "number") {
		configuration.heartbeat_interval = 5000;
	}

	if (typeof configuration.presence_interval !== "number") {
		configuration.presence_interval = 10000;
	}

	//Save the reference to the metric function if it exists
	var metric = (configuration.metrics !== undefined) ? configuration.metrics.numberMetric.bind(configuration.metrics) : function () {
	};
	//An array of the server's methods
	var methods = [];

	var presence_timer;

	var heartbeat_timer;

	if (heartbeat_timer === undefined) {
		heartbeat_timer = setInterval(send_heartbeat, configuration.heartbeat_interval);
	}

	//Initialise the stream publisher module
	var publisher = stream_publisher(connection, instance, configuration, methods);

	function announceNewMethod(newMethod){

		methods.push(newMethod);

		//Send presence so the clients know we have it
		send_presence();
		//Start sending presence regularly (if we aren't already doing it)
		if (presence_timer === undefined) {
			presence_timer = setInterval(send_presence, configuration.presence_interval);
		}
		metric("Registered methods", methods.length);
	}

	// registers a new agm method
	function register(methodDefinition, callback) {

		registerCore(methodDefinition, function(context, resultCallback){
			// get the result as direct invocation of the callback and return it using resultCallback
			try{
				var result = callback(context.args, context.instance);
				resultCallback(null, result);
			} catch (e) {
				resultCallback(e, null);
			}
		});

	}

	// registers a new asyn agm method (the result can be returned in async way)
	function registerAsync(methodDefinition, callback) {

		registerCore(methodDefinition, function(context, resultCallback){
			// invoke the callback passing success and error callbacks
			try{
				callback(context.args, context.instance,
					// success callback
					function(result){
						resultCallback(null, result);
					},
					// error callback
					function (e) {
						resultCallback(e, null);
					});
			} catch (e) {
				resultCallback(e, null);
			}
		});
	}

	// core method for registering agm method
	function registerCore(methodDefinition, the_function) {
		// transform the definition
		if (typeof methodDefinition === "string") {
			methodDefinition = {name: methodDefinition};
		}

		//Get a request subject for this method
		instance.request_subject(methodDefinition, function (requestSubject) {

			var method = convert_method(methodDefinition);
			method.MethodRequestSubject = requestSubject;

			//Add the method (store the unformatted definition in order to do checkups in the unregister method)
			announceNewMethod({
				method: method,
				definition: methodDefinition,
				the_function: the_function
			});

		});
	}

	function createStream(streamDef, callbacks, successCallback, errorCallback){
		// in callbacks we have subscriptionRequestHandler, subscriptionAddedHandler, subscriptionRemovedHandler

		var promise = new Promise(function (resolve, reject) {
			if (typeof streamDef === "string") {

				if(streamDef === '') {
					reject("Invalid stream name.");
				}

				streamDef = {name: streamDef};
			}

			if (!callbacks) {
				callbacks = {};
			}

			if(typeof callbacks.subscriptionRequestHandler !== "function"){
				callbacks.subscriptionRequestHandler = function(request){
					request.accept();
				}
			}

			//Get a request subject, set the streaming bit then push into methods[]
			instance.request_subject(streamDef, function (requestSubject) {
				var streamConverted = convert_method(streamDef);
				streamConverted.MethodRequestSubject = requestSubject;
				streamConverted.Method.Flags = 32; //100000 bitmask with the largest flag (streaming: true)

				var newStreamingMethod = {
					method: streamConverted,
					definition: {
						accepts: streamDef.accepts,
						description: streamDef.description,
						displayName: streamDef.displayName,
						name: streamDef.name,
						objectTypes: streamDef.objectTypes,
						returns: streamDef.returns,
						supportsStreaming: true
					},
					streamCallbacks: callbacks,
					globalEventStreamSubject: streamDef.name + '.jsStream.' + helpers.generateRandom(),
					subscriptions: [],
					branchKeyToStreamIdMap: [] //[ {branchKey: '', streamId: 'strj_nds786y2378yb'}, {...}, ...]
				};

				announceNewMethod(newStreamingMethod);

				resolve({
					branches: function(){
						return publisher.getBranchList(newStreamingMethod)
					},
					close: function(){
						publisher.closeAllSubscriptions(newStreamingMethod);
						unregister(newStreamingMethod.definition)
					},
					definition: {
						accepts: streamDef.accepts,
						description: streamDef.description,
						displayName: streamDef.displayName,
						name: streamDef.name,
						objectTypes: streamDef.objectTypes,
						returns: streamDef.returns,
						supportsStreaming: true
					},
					name: streamDef.name,
					push: function(data, branches){
						if(typeof branches !== 'string' && !Array.isArray(branches) && branches !== undefined){
							throw new Error('invalid branches should be string or string array');
						}
						//TODO validate if is plain object
						if(typeof data !== 'object'){
							throw new Error('Invalid arguments. Data must be an object.')
						}
						publisher.pushData(newStreamingMethod, data, branches)
					},
					subscriptions: function(){
						return publisher.getSubscriptionList(newStreamingMethod);
					}
				});
			});

		});

		return helpers.promisify(promise, successCallback, errorCallback);
	}

	var invocations = 0;

	//Listens for method invocations
	connection.on("MethodInvocationRequestMessage", function (message) {
		//Find the method
		var method = methods.filter(function(m){
			return m.method.MethodRequestSubject === message.MethodRequestSubject;
		})[0];

		//Stop if the message isn't for us
		if (method === undefined) {
			return;
		}

		// some logging if enabled
		if (global.console !== undefined && configuration.debug === true) {
			console.debug("%c<<< receiving MethodInvocationRequestMessage", "background-color:hsla(198, 51%, 79%, 0.5)");
			console.debug("%c" + JSON.stringify(message), "background-color:hsla(198, 51%, 79%, 0.5)");
		}
		metric("Invocations count", invocations++);

		//TODO see if have to move this earlier - i.e. if some messages from Client don't have MethodRequestSubject
		//Check if message is stream-related : defer publisher
		if (publisher.isStreamMsg(message, method)){
			publisher.processSubscriberMsg(message, method);
			return;
		}

		//Execute it and save the result
		method.the_function({args:message.Context.ArgumentsJson, instance:message.Client}, function(err, result) {
			if (err) {
				// handle error case
				if (typeof err.message == 'string') {
					err = err.message;
				} else if (typeof err !== 'string') {
					err = '';
				}
			}

			//Don't send result if the client does not require it
			if (message.MethodResponseSubject === "null") {
				return;
			}

			//The AGM library only transfers objects. If the result is not an object, put it in one
			if (result && (typeof result !== "object" || result.constructor === Array)) {
				result = {_result: result};
			}

			var resultMessage = {
				MethodRequestSubject: message.MethodRequestSubject,
				MethodResponseSubject: message.MethodResponseSubject,
				MethodName: method.method.Method.Name,
				InvocationId: message.Context.InvocationId,
				ResultContextJson: result,
				Server: instance.info(),
				ResultMessage: err,
				Status: err ? 1 : 0
			};
			//Send result
			connection.send("MethodInvocationResultMessage", resultMessage);

			if (global.console !== undefined && configuration.debug === true) {
				console.debug("%c>>> sending MethodInvocationResultMessage", "background-color:hsla(118, 51%, 79%, 0.5)");
				console.debug("%c" + JSON.stringify(resultMessage), "background-color:hsla(118, 51%, 79%, 0.5)");
			}
		});
	});

	//Constructs a heartbeat message
	function construct_heartbeat() {
		return {
			PublishingInterval: configuration.heartbeat_interval,
			Instance: instance.info()
		};
	}

	//Constructs a presence message
	function construct_presence() {
		var p = {
			PublishingInterval: configuration.presence_interval,
			Instance: instance.info()
		};
		p.MethodDefinitions = methods.map(function (method) {
			return method.method;
		});
		return p;
	}

	//True if we should be broadcasting presences and heartbeats, false otherwise
	var broadcasting = true;

	function start() {
		broadcasting = true;
	}

	function stop() {
		broadcasting = false;
	}

	//Sends a presence
	function send_presence() {
		if (broadcasting) {
			connection.send("ServerPresenceMessage", construct_presence());
		}
	}

	//Sends a heartbeat
	function send_heartbeat() {
		if (broadcasting) {
			connection.send("ServerHeartbeatMessage", construct_heartbeat());
		}
	}


	//Converts the method definition from camel case to snake case
	function convert_method(method_identifier) {
		//If we are given a string instead of an object, we presume that is the method's name:
		if (typeof method_identifier === "string") {
			method_identifier = {name: method_identifier};
		}

		//Set default values
		if (typeof method_identifier.version !== "number") {
			method_identifier.version = 0;
		}


		//Convert the method definition to the format that AGM requires
		return {
			Method: {
				Name: method_identifier.name,
				InputSignature: method_identifier.accepts,
				ResultSignature: method_identifier.returns,
				Description: method_identifier.description,
				DisplayName: method_identifier.display_name,
				Version: method_identifier.version,
				ObjectTypeRestrictions: method_identifier.object_types
			}
		};
	}

	function contains_props(filter, object) {
		var match = true;
		Object.keys(filter).forEach(function (prop) {
			if (filter[prop] !== object[prop]) {
				match = false;
			}
		});
		return match;
	}

	//Unregisters a previously registered AGM method
	function unregister(method_filter) {
		if (typeof method_filter === "string") {
			method_filter = {name: method_filter};
		}
		methods = methods.filter(function (method) {
			return !contains_props(method_filter, method.definition);
		});
		metric("Registered methods", methods.length);
	}

	return {register: register, registerAsync: registerAsync, unregister: unregister, start: start, stop: stop, createStream: createStream};
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./agm_helpers":38,"./agm_stream_publisher":42,"es6-promise":8}],42:[function(require,module,exports){
var Promise = require('es6-promise').Promise;
var helpers = require("./agm_helpers");

var publisher = module.exports = function(connection, instance, configuration, methods){

	function sendResult(message){
		if(typeof message !== 'object'){
			throw new Error('Invalid message.');
		}

		if(typeof message.Status !== 'number'){
			message.Status = 0;
		}

		connection.send("MethodInvocationResultMessage", message);
	}

	function isStreamMsgForStreamingMethod(msg, method){
		return (
			msg
			&& msg.EventStreamAction
			&& msg.EventStreamAction !== 0
			&& typeof method === 'object'
			&& method.definition.supportsStreaming === true
		);
	}

	function processSubscriberMsg(msg, streamingMethod){
		if( ! (msg && msg.EventStreamAction && msg.EventStreamAction !== 0) ){
			return;
		}

		if(msg.EventStreamAction === 1) {
			clientWishesToSubscribe(msg, streamingMethod);

		} else if(msg.EventStreamAction === 2) {
			clientWishesToUnsubscribe(msg, streamingMethod);

		} else if(msg.EventStreamAction === 3) {
			clientAcknowledgesItDidSubscribe(msg, streamingMethod);

		} else if(msg.EventStreamAction === 4) {
			clientPerSubHeartbeat(msg);
		}
	}

	/** msg 'Request' Actions */
	//action 1
	function clientWishesToSubscribe(msg, streamingMethod){

		if( ! (
			streamingMethod
			&& streamingMethod.streamCallbacks
			&& typeof streamingMethod.streamCallbacks.subscriptionRequestHandler === 'function') )
		{
			return;
		}

		//Pass-in the request object
		streamingMethod.streamCallbacks.subscriptionRequestHandler({
			accept: acceptRequestOnBranch.bind(null, msg, streamingMethod, ''),
			acceptOnBranch: acceptRequestOnBranch.bind(null, msg, streamingMethod),
			arguments: msg.Context.ArgumentsJson || {},
			instance: msg.Client,
			reject: rejectRequest.bind(null, msg, streamingMethod)
		});
	}

	//action 2
	function clientWishesToUnsubscribe(msg, streamingMethod){

		if( ! (
			streamingMethod
			&& Array.isArray(streamingMethod.subscriptions)
			&& streamingMethod.subscriptions.length > 0)
		){
			return;
		}

		closeIndividualSubscription(streamingMethod, msg.StreamId, msg.EventStreamSubject, false)
	}

	//action 3
	function clientAcknowledgesItDidSubscribe(msg, streamingMethod){
		//Client indicates it is listening to a specific StreamId

		if(typeof msg.StreamId !== 'string' || msg.StreamId === ''){
			return;
		}

		var branchKey = getBranchKey(streamingMethod, msg.StreamId);

		if( typeof branchKey !== 'string'){
			return;
		}

		if( ! Array.isArray(streamingMethod.subscriptions )){
			return;
		}

		var subscription = {
			branchKey: branchKey,
			instance: msg.Client,
			arguments: msg.Context.ArgumentsJson,
			streamId: msg.StreamId,
			privateEventStreamSubject: msg.EventStreamSubject,
			methodResponseSubject: msg.MethodResponseSubject
		};

		//Subscription back-obj is stored
		streamingMethod.subscriptions.push(subscription);

		var subFrontObj = conjureSubscriptionFrontObj(streamingMethod, subscription);
		var subAddedHandler = streamingMethod.streamCallbacks.subscriptionAddedHandler;
		if(typeof subAddedHandler === 'function'){
			//Pass-in the subscription object
			subAddedHandler(subFrontObj);
		}
	}

	//action 4
	function clientPerSubHeartbeat(){
		//A client may have multiple subscriptions, each one having its own heartbeat
		//Currently not implemented by the GW or the client
	}


	/** (request) Methods */
	function acceptRequestOnBranch(msg, streamingMethod, branch){
		if( typeof branch !== "string" ){
			branch = '';
		}

		var streamId = getStreamId(streamingMethod, branch);

		sendResult({
			EventStreamAction: 3,
			EventStreamSubject: streamingMethod.globalEventStreamSubject,
			InvocationId: msg.Context.InvocationId,
			MethodName:streamingMethod.method.Method.Name,
			MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
			MethodResponseSubject: msg.MethodResponseSubject,
			MethodVersion: streamingMethod.method.Method.Version,
			ResultMessage: "Accepted",
			Server: instance.info(),
			StreamId: streamId
		});
	}

	function getBranchKey(streamingMethod, streamId){
		if(typeof streamId !== 'string' || typeof streamingMethod !== 'object'){
			return;
		}

		var needle = streamingMethod.branchKeyToStreamIdMap.filter(function(branch){
			return branch.streamId === streamId;
		})[0];

		if(typeof needle !== 'object' || typeof needle.key !== 'string'){
			return;
		}

		return needle.key;
	}

	function getStreamId(streamingMethod, branchKey){
		if(typeof branchKey !== 'string'){
			branchKey = '';
		}

		var needleBranch = streamingMethod.branchKeyToStreamIdMap.filter(function(branch){
			return branch.key === branchKey;
		})[0];

		var streamId = ( needleBranch ? needleBranch.streamId : undefined ) ;

		if(typeof	streamId !== 'string' || streamId === ''){
			streamId = generateNewStreamId(streamingMethod.method.Method.Name);
			streamingMethod.branchKeyToStreamIdMap.push({key: branchKey, streamId: streamId});
		}

		return streamId;
	}

	function generateNewStreamId(streamingMethodName){
		var appInfo = instance.info();

		var newStreamId = 'streamId-jsb'
			+ '_of_' + streamingMethodName + '_'
			+ '_by_' + appInfo.ApplicationName + '_'
			+ helpers.generateRandom();

		return newStreamId;
	}

	function rejectRequest(msg, streamingMethod, reason){
		if(typeof reason !== 'string'){
			reason = '';
		}

		sendResult({
			EventStreamAction: 2,
			EventStreamSubject: streamingMethod.globalEventStreamSubject,
			//InvocationId: msg.Context.InvocationId,
			MethodName:streamingMethod.method.Method.Name,
			MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
			MethodResponseSubject: msg.MethodResponseSubject,
			MethodVersion: streamingMethod.method.Method.Version,
			ResultMessage: reason,
			Server: instance.info(),
			StreamId: 'default_rejection_streamId'
		});
	}

	/** (subscription) Methods */
	function conjureSubscriptionFrontObj(streamingMethod, subscription){
		//expose a subscription to the user
		return {
			arguments: subscription.arguments || {},
			branchKey: subscription.branchKey,
			close: closeIndividualSubscription.bind(
				null,
				streamingMethod,
				subscription.streamId,
				subscription.privateEventStreamSubject,
				true
			),
			instance: subscription.instance,
			push: pushDataToSingle.bind(null, streamingMethod, subscription),
			stream: streamingMethod.definition
		};
	}

	function conjureBranchFrontObj(streamingMethod, branchKey){
		//expose a branch to the user
		return {
			key: branchKey,
			subscriptions: getSubscriptionList.bind(null, streamingMethod, branchKey),
			close: closeMultipleSubscriptions.bind(null, streamingMethod, branchKey),
			push: function(data){ pushToBranch(streamingMethod, data, branchKey) }
		};
	}

	function closeIndividualSubscription(streamingMethod, streamId, privateEventStreamSubject, sendKickMessage){

		var subscription = streamingMethod.subscriptions.filter( function(subItem) {
			return (
				subItem.privateEventStreamSubject === privateEventStreamSubject
				&& subItem.streamId === streamId
			);
		})[0];

		if (typeof subscription !== 'object'){
			return; //unrecognised subscription
		}

		var initialLength = streamingMethod.subscriptions.length;

		streamingMethod.subscriptions = streamingMethod.subscriptions.filter( function(subItem) {
			return !(
				subItem.privateEventStreamSubject === subscription.privateEventStreamSubject
				&& subItem.streamId === subscription.streamId
			);
		});

		var filteredLength = streamingMethod.subscriptions.length;

		if( filteredLength !== (initialLength - 1) ){
			return; //the subscription wasn't removed
		}

		if(sendKickMessage === true){
			sendResult({
				EventStreamAction: 2,
				EventStreamSubject: privateEventStreamSubject,
				MethodName: streamingMethod.method.Method.Name,
				MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
				MethodResponseSubject: subscription.methodResponseSubject,
				MethodVersion: streamingMethod.method.Method.Version,
				ResponseContextJson: {},
				Server: instance.info(),
				StreamId: subscription.streamId,
				Status:0
			});
		}

		var subRemovedHandler = streamingMethod.streamCallbacks.subscriptionRemovedHandler;
		if(typeof subRemovedHandler === 'function'){
			var subscriber = subscription.instance;
			subRemovedHandler(subscriber)
		}
	}

	function closeMultipleSubscriptions(streamingMethod, branchKey){
		if(typeof streamingMethod !== 'object' || !Array.isArray(streamingMethod.branchKeyToStreamIdMap)){
			return;
		}

		var streamList = streamingMethod.branchKeyToStreamIdMap;

		if(typeof branchKey === 'string'){
			streamList = streamingMethod.branchKeyToStreamIdMap.filter(function(br){
				return ( typeof br === 'object' && br.key === branchKey );
			});
		}

		//TODO: consider getting the unique branch keys from 'live subscribers'

		streamList.forEach(function(br){
			var streamId = br.streamId;

			sendResult({
				EventStreamAction: 2,
				EventStreamSubject: streamingMethod.globalEventStreamSubject,
				MethodName: streamingMethod.method.Method.Name,
				MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
				Server: instance.info(),
				StreamId: streamId,
				Status: 0
			});
		});
	}

	function pushDataToSingle(streamingMethod, subscription, data){

		//TODO validate data is a plain object
		if(typeof data !== 'object'){
			throw new Error('Invalid arguments. Data must be an object.');
		}

		sendResult({
			EventStreamAction: 5,
			EventStreamSubject: subscription.privateEventStreamSubject,
			MethodName: streamingMethod.method.Method.Name,
			MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
			ResultContextJson: data,
			Server: instance.info(),
			StreamId: subscription.streamId
		});
	}

	function pushToBranch(streamingMethod, data, branches){
		if(typeof streamingMethod !== 'object' || !Array.isArray(streamingMethod.branchKeyToStreamIdMap)){
			return;
		}

		//TODO validate data is a plain object
		if(typeof data !== 'object'){
			throw new Error('Invalid arguments. Data must be an object.');
		}

		if(typeof branches === 'string'){
			branches = [branches]; //user wants to push to single branch
		} else if(!Array.isArray(branches) || branches.length <= 0){
			branches = null;
		}

		//get the StreamId's from the method's branch map
		var streamIdList = streamingMethod.branchKeyToStreamIdMap
			.filter(function(br){
				return (
					branches === null
					|| ( !!br && typeof br.key === 'string' && branches.indexOf(br.key) >= 0 )
				);
			}).map(function(br){
				return br.streamId;
			});

		streamIdList.forEach(function (streamId) {

			sendResult({
				EventStreamAction: 5,
				EventStreamSubject: streamingMethod.globalEventStreamSubject,
				MethodName: streamingMethod.method.Method.Name,
				MethodRequestSubject: streamingMethod.method.MethodRequestSubject,
				ResultContextJson: data,
				Server: instance.info(),
				StreamId: streamId
			});

		});


	}

	function getSubscriptionList(streamingMethod, branchKey){
		if(typeof streamingMethod !== 'object'){
			return [];
		}

		var subscriptions = [];

		if(typeof branchKey !== 'string'){
			subscriptions = streamingMethod.subscriptions;
		} else {
			subscriptions = streamingMethod.subscriptions.filter(function(sub){
				return sub.branchKey === branchKey;
			});
		}

		return subscriptions.map(function(sub){
			return conjureSubscriptionFrontObj(streamingMethod, sub);
		});
	}

	function getBranchList(streamingMethod){
		if(typeof streamingMethod !== 'object'){
			return [];
		}

		var uniqueBranchNames = getUniqueBranchNames(streamingMethod);

		return uniqueBranchNames.map(function(branchKey){

			return conjureBranchFrontObj(streamingMethod, branchKey);

		});
	}

	function getUniqueBranchNames(streamingMethod){
		var keysWithDuplicates = streamingMethod.subscriptions.map(function(sub){
			var result = null;
			if(typeof sub === 'object' && typeof sub.branchKey === 'string'){
				result = sub.branchKey;
			}
			return result;
		});

		var seen = [];

		var branchArray = keysWithDuplicates.filter(function(bKey) {
			if(bKey === null || seen.indexOf(bKey) >= 0) {
				return false;
			}
			seen.push(bKey);
			return true;
		});

		return branchArray;
	}

	return { //an instance fo the publisher
		isStreamMsg: isStreamMsgForStreamingMethod,
		processSubscriberMsg: processSubscriberMsg,
		pushData: pushToBranch,
		closeAllSubscriptions: closeMultipleSubscriptions,
		getSubscriptionList:getSubscriptionList,
		getBranchList: getBranchList,
		generateNewStreamId: generateNewStreamId
	};
};

},{"./agm_helpers":38,"es6-promise":8}],43:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-agm@2.3.1",
      "C:\\work\\stash\\GLUE-dev\\js-glue"
    ]
  ],
  "_from": "tick42-agm@2.3.1",
  "_id": "tick42-agm@2.3.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-agm",
  "_nodeVersion": "6.3.0",
  "_npmUser": {},
  "_npmVersion": "3.8.5",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-agm",
    "raw": "tick42-agm@2.3.1",
    "rawSpec": "2.3.1",
    "scope": null,
    "spec": "2.3.1",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_shasum": "0f9a2ef417cda7684b73dd055abc77490b988646",
  "_shrinkwrap": null,
  "_spec": "tick42-agm@2.3.1",
  "_where": "C:\\work\\stash\\GLUE-dev\\js-glue",
  "author": {
    "name": "Tick42",
    "url": "http://www.tick42.com"
  },
  "bin": {
    "agm": "bin/agm"
  },
  "bugs": {
    "url": "https://jira.tick42.com/browse/APPCTRL"
  },
  "dependencies": {
    "es6-promise": "^3.0.2",
    "inquirer": "^0.8.5",
    "tick42-gateway-connection": "^1.1.2",
    "util-deprecate": "^1.0.2"
  },
  "description": "JavaScript AGM",
  "devDependencies": {
    "blanket": "^1.1.6",
    "bluebird": "^2.9.30",
    "browserify-versionify": "^1.0.6",
    "grunt": "^0.4.5",
    "grunt-browserify": "^3.3.0",
    "grunt-cli": "^0.1.0",
    "grunt-contrib-clean": "^0.6.0",
    "grunt-contrib-connect": "^0.9.0",
    "grunt-contrib-jshint": "^0.11.0",
    "grunt-contrib-qunit": "^0.5.2",
    "grunt-contrib-uglify": "^0.6.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-exorcise": "^1.0.0",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "uglifyify": "^3.0.1"
  },
  "dist": {
    "shasum": "0f9a2ef417cda7684b73dd055abc77490b988646",
    "tarball": "http://192.168.0.234:4873/tick42-agm/-/tick42-agm-2.3.1.tgz"
  },
  "gitHead": "f33fb8ed4a56832a7b0cdb9b67717571868d27cb",
  "keywords": [
    "agm",
    "javascript",
    "library"
  ],
  "main": "library/agm.js",
  "name": "tick42-agm",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "scripts": {
    "build": "npm install && grunt",
    "prepublish": "grunt",
    "start": "grunt watch",
    "test": "grunt qunit"
  },
  "title": "Tick42 AGM",
  "version": "2.3.1"
}

},{}],44:[function(require,module,exports){
(function (global){
var application = require("./application");
var instance = require("./instance");
var helpers = require("./helpers");

module.exports = global.app_manager = function app_manager(agm, windows) {

	var apps = application(agm, function () {
		return instances;
	});
	var instances = instance(agm, apps);
	var manager = {
		applications: apps.all,
		application: apps.get_by_id,
		on_app_added: helpers.add_callback("added").bind(apps),
		on_app_available: helpers.add_callback("available").bind(apps),
		on_app_removed: helpers.add_callback("removed").bind(apps),
		on_app_unavailable: helpers.add_callback("unavailable").bind(apps),

		instances: instances.all,
		on_instance_started: helpers.add_callback("started").bind(instances),
		on_instance_stopped: helpers.add_callback("stopped").bind(instances),
		on_instance_updated: helpers.add_callback("updated").bind(instances),

		get_branches: function (success, error) {
			agm.invoke("T42.ACS.GetBranches", {}, "best", {}, function (e) {
				if (success) {
					success(helpers.vals(e.returned.Branches));
				}
			}, error);
		},
		get_current_branch: function (success, error) {
			agm.invoke("T42.ACS.GetCurrentBranch", {}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Branch);
				}
			}, error);
		},
		set_current_branch: function (branch, success, error) {
			agm.invoke("T42.ACS.SetCurrentBranch", {Branch: branch}, "best", {}, success, error);
		},
		current_user: function (success, error) {
			agm.invoke("T42.ACS.GetUser", {}, "best", {}, success, error);
		},
		get_functional_entitlement: function (fn, success, error) {
			agm.invoke("T42.ACS.GetFunctionalEntitlement", {Function: fn}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Entitlement);
				}
			}, error);
		},
		get_functional_entitlement_branch: function (fn, br, success, error) {
			agm.invoke("T42.ACS.GetFunctionalEntitlement", {Function: fn, Branch: br}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Entitlement);
				}
			}, error);
		},
		can_i: function (fn, success, error) {
			agm.invoke("T42.ACS.CanI", {Function: fn}, "best", {}, success, error);
		},

		can_i_branch: function(fn, branch, success, error) {
			agm.invoke("T42.ACS.CanI", {Function: fn, Branch: branch}, "best", {}, success, error);
		},

		exit: function () {
			agm.invoke("T42.ACS.Shutdown", {}, "all", {},
				function (a) {
					console.log(a);
				},
				function (e) {
					console.log(e);
				});
		},

		set_region: function (region, success, error){
			agm.invoke("T42.ACS.SetConfigurationRegion", {Region: region}, "best", {}, success, error);
		},

		get_region: function(success, error){
			agm.invoke("T42.ACS.GetConfigurationRegion", {}, "best", {}, function (e) {
				if (success) {
					success(e.returned.Region);
				}
			}, error);
		},

		_trigger_app_event: apps._trigger,
		_trigger_instance_event: instances._trigger

	};

	function call_with(prop, func) {
		return function (result) {
			func(result[prop]);
		};

	}
	//Create event bindings

	//Tell the app when its instances are added/removed

	manager.on_instance_started(function (instance) {
		if (instance.application) {
			//Trigger "instance_started" event on application
			manager._trigger_app_event("instance_started", instance, instance.application.name);

			//Trigger "window_opened" event on instance
			var container;
			if (windows) {
				var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
				container = instance.application.configuration.container;
				glue.agm.invoke("T42.Wnd.FindById", {windowId: instance.id}, {application: container}, {}, window_opened, function(e){console.log(e)});
			}
		}

		function window_opened(a) {
			//Wrap the window in a window object, using the glue windows lib
			var w = a.returned [Object.keys(a.returned)[0]];
			var win = glue.windows._from_event(w.windowName, container, w.url, w.windowId, w.windowStyleAttributes, w.windowTitle);

			//Trigger the window opened event
			manager._trigger_instance_event("window_added", win, id);
		}
	});

	manager.on_instance_stopped(function (instance) {
		if (instance.application) {
			manager._trigger_app_event("instance_stopped", instance, instance.application.name);

			var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
			manager._trigger_instance_event("window_removed", {}, id);

		}
	});

	manager.on_instance_updated(function (instance) {
		if (instance.application) {
		// manager._trigger_app_event("instance_stopped", instance, instance.application.name);

		// var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
		// manager._trigger_instance_event("title_changed", {}, id);
		}
	});
	//When an app is removed, remove also its instances

	manager.on_app_removed(function (app) {
		app.instances.forEach(function (instance) {
			var id = (instance.context && instance.context.guid) ? instance.context.guid : instance.id;
			manager._trigger_instance_event("stopped", {}, id);
		});
	});
	var branch_changed_callback;
	manager.on_branches_changed = function (callback) {
		branch_changed_callback = callback;
	};

	function on_branch_changed(e) {
		if (typeof branch_changed_callback === "function") {
			branch_changed_callback(helpers.vals(e));
		}
	}

	function handle_app_ready(app) {
		if (app.IsReady) {
			manager._trigger_app_event("available", app);
		} else {

			manager._trigger_app_event("unavailable", app);
		}
	}

	function app_failed(e) {
		manager._trigger_instance_event("error", e, e.Context.guid);
	}

	if (agm && agm.subscribe) {

		manager.agm = agm;
		var handlers = [
			{event: "OnApplicationAdded", trigger: "added", on: apps},
			{event: "OnApplicationRemoved", trigger: "removed", on: apps},
			{event: "OnApplicationChanged", trigger: "changed", on: apps},
			{event: "OnApplicationStarted", trigger: "started", on: instances},
			{event: "OnApplicationStopped", trigger: "stopped", on: instances},
			{event: "OnApplicationUpdated", trigger: "updated", on: instances},
			{event: "OnApplicationAgmServerReady", trigger: "agm_ready", on: instances},
			{event: "OnApplicationReady", func: handle_app_ready},
			{event: "OnBranchesModified", func: on_branch_changed},
			{event: "OnApplicationStartFailed", raw_func: app_failed}
		];

         agm.serverMethodAdded(function (resp) {
             if ((resp.server.application.indexOf('AppManager') !== -1 && resp.method.name.indexOf('T42.ACS.OnEvent') !== -1)) {
                agm.subscribe("T42.ACS.OnEvent", {target: "all"})
                    .then(function (subscription) {
                        subscription.onData(function (streamData) {
                            var events = streamData.data;
                            handlers.forEach(function (handler) {
                                var objects = events[handler.event];
                                if (objects) {

                                    if (handler.raw_func !== undefined) {
                                        handler.raw_func(objects);
                                        return;
                                    }

                                    helpers.vals(objects).forEach(function (object) {
                                        if (handler.on !== undefined) {
                                            handler.on._trigger(handler.trigger, object);
                                        } else {
                                            handler.func(object);
                                        }
                                    });
                                }
                            });
                        })
                    });
             }
         });
	}

	manager.version = "2.3.1";

	return manager;
};

global.tick42 = global.tick42 ||{};
global.tick42.app_manager = global.app_manager;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./application":45,"./helpers":47,"./instance":48}],45:[function(require,module,exports){
var event_manager = require("./event_manager");
var helpers = require("./helpers");

module.exports = function(agm, instances) {
	var app_proto = helpers.add_callbacks({

		start: function (params, success, error) {
			params = params || {};
			params.guid = params.guid || Math.floor(Math.random() * 10000000);
			if (agm) {
				agm.invoke("T42.ACS.StartApplication", {Name: this.name, Context: params}, "best", {}, function (e) {
				}, error);
			}
			return instances()._trigger("create", {Context: params});

		}

	}, ["added", "removed", "available", "unavailable", "instance_started", "instance_stopped", "changed"], "on_");

//constructor, init_event, id_field


	function update_app(props, obj) {
		obj.name = props.Name;
		obj.title = props.Title;
		obj.version = props.Version;
		obj.instances = [];
		obj.configuration = {};
		obj.configuration.auto_start = props.AutoStart;
		obj.configuration.caption = props.Caption;
		obj.configuration.hidden = props.IsHidden;
		obj.configuration.container = props.ApplicationName;
		//obj.disabled = props.IsDisabled;
		obj.configuration.allow_multiple = props.AllowMultiple;
		obj.available = props.IsReady || false;
		obj.icon = props.Icon;
		obj.sortOrder = props.SortOrder;
		obj.userProperties = props.UserProperties;
		return obj;
	}

	return event_manager({
		create: function create_app(props) {
			return update_app(props, Object.create(app_proto));
		},
		update: update_app,
		init_event: "added",
		exit_event: "removed",
		id_field: "Name",
		callbacks: {
			available: function () {
				this.available = true;
			},
			changed: function (props) {
				this.icon = props.Icon;
				this.title = props.Title;
				this.configuration.caption = props.Caption;
			},
			unavailable: function () {
				this.available = false;
			},
			instance_started: function (instance) {
				this.instances.push(instance);
			},
			instance_stopped: function (instance) {
				this.instances = this.instances.filter(function (my_instance) {
					return my_instance !== instance;
				});
			}
		}
	});

};

},{"./event_manager":46,"./helpers":47}],46:[function(require,module,exports){
var helpers = require("./helpers");

function exec_callbacks(obj, arr, val) {
	if (arr !== undefined) {
		arr.forEach(function (callback) {
			callback.call(obj, val);
		});
	}
}

module.exports = function create_environment(settings) {
	var objects = {};
	var global_callbacks = {};
	return {
		all: function () {
			return helpers.vals(objects);
		},
		get_by_id: function (id) {
			return objects[id];
		},
		_trigger: function (type, props, id) {
			id = id || ( typeof settings.id_field === "function" ? settings.id_field(props) : props[settings.id_field]);

			//Quit if we receive an event for an object before initiating it.
			if (objects[id] === undefined && ( type !== settings.init_event && type !== settings.create_event)) {
				//console.log ("Received '"+type+"' event before '"+settings.init_event+"'");
				return;
			}


			//Create or retrieve an object, representing the entity
			var obj = objects[id] = objects[id] || init_object(settings.create(props));

			if (type === settings.init_event) {
				//Quit if we receive a init event for an object that is already active
				if (obj.active) {
					//console.log ("Received second '"+settings.init_event+"' for app "+id);
					return;
					//Else, make it active
				} else {
					obj.active = true;
					settings.update(props, obj);
				}
				//When the entity is removed, set it to non-active
			} else if (type === settings.exit_event) {
				obj.active = false;

				//When a create event is received, just return the object without doing anything else
			} else if (type === settings.create_event) {
				return obj;

			} else if (type === settings.update_event) {
				settings.update(props, obj);
			}

			//Execute system callbacks
			if (settings.callbacks[type] !== undefined) {
				settings.callbacks[type].call(obj, props);
			}

			// make sure that errors in user specified callbacks does not
			// break our library
			try {
				//Execute global callbacks
				exec_callbacks(undefined, global_callbacks[type], obj);

				//Execute user-defined callbacks that are attached to the object
				exec_callbacks(obj, obj.callbacks[type], props);
			}
			catch (e){
				console.error(e);
			}
			//When the entity is removed, remove all callbacks (after you execute them)
			if (type === settings.exit_event) {
				obj.callbacks = {};
			}
			return obj;

		},
		//Expose the global callbacks object so that user can register some
		callbacks: global_callbacks
	};
};

function init_object(object) {
	object.callbacks = {};
	object.active = false;
	return object;
}

},{"./helpers":47}],47:[function(require,module,exports){
function noop(){}

function exec_if(condition) {
	return function (app, callback) {
		if (condition(app)) {
			callback.call(app);
		}
	};
}

exports.add_callbacks = function add_callbacks(object, events, prefix) {
	events.forEach(function (event) {
		if (typeof event === "string") {
			event = {name: event, trigger_when: noop};
		}

		object[prefix + event.name] = exports.add_callback(event.name, exec_if(event.trigger_when));
	});
	return object;

};

exports.add_callback = function add_callback( key, on_add ){
	return function(callback){
		var obj = this.callbacks;
		if(obj[key]===undefined){obj[key] = [callback];}
		else {obj[key].push(callback);}
		if(typeof on_add === "function"){on_add(this, callback);}
		return this;
	};
};

exports.vals = function vals(obj) {
	return Object.keys(obj).reduce(function (arr, key) {
		arr.push(obj[key]);
		return arr;
	}, []);
};

},{}],48:[function(require,module,exports){
var event_manager = require("./event_manager");
var helpers = require("./helpers");

module.exports = function(agm, apps) {
	var instance_proto = helpers.add_callbacks({
		stop: function (params, success, error) {
			agm.invoke("T42.ACS.StopApplication", {Name: this.application.name, Id: this.id}, "best", {}, function (e) {
				console.log(e);
			}, error);
		},
		activate: function (params, success, error) {
			agm.invoke("T42.ACS.ActivateApplication", {Name: this.application.name, Id: this.id}, "best", {}, function (e) {
				console.log(e);
			}, error);
		}
	}, [
		{
			name: "window_added", trigger_when: function (app)  	{
			return app.active && app.main_window !== undefined;
		}
		},
		{
			name: "window_removed", trigger_when: function (app) {
			return app.main_window === undefined;
		}
		},
		{
			name: "started", trigger_when: function (app) {
			return app.id !== undefined && app.active;
		}
		},
		{
			name: "stopped", trigger_when: function (app) {
			return app.id !== undefined && !app.active;
		}
		},
		{
			name: "agm_ready", trigger_when: function (app) {
			return app.active && app.agm !== undefined;
		}
		},
    {
      name: "error", trigger_when: function (app) {
      return app.error !== undefined;
    }
		},
	], "on_");

	function update_instance(props, obj) {
		obj.id = props.Id;
		obj.application = apps.get_by_id(props.Name);
		obj.context = props.Context;
		obj.title = props.Title;
		return obj;
	}

	return event_manager({
		create: function (props) {
			return update_instance(props, Object.create(instance_proto));
		},
		update: update_instance,
		create_event: "create",
		init_event: "started",
		exit_event: "stopped",
    update_event: "updated",
		id_field: function (e) {
			return e.Context !== undefined && e.Context.guid !== undefined ? e.Context.guid : e.Id;
		},
		callbacks: {
			agm_ready: function (e) {
				//get the first AGM
				var server_name = Object.keys(e.AgmServers)[0];
				//Attach it to the object
				this.agm = convert_agm_instance(e.AgmServers[server_name]);
			},
			error: function (e) {
				this.error = e;
			},
			window_added: function (win) {
				this.main_window = win;
				this.windows = this.windows || [];
				this.windows.push(win);
			},
			window_removed: function () {
				this.main_window = undefined;
				this.windows = [];
			}
		}
	});
};

function convert_agm_instance(agm) {
	return {
		machine: agm.machineName,
		user: agm.userName,
		environment: agm.environment,
		application: agm.applicationName

	};
}

},{"./event_manager":46,"./helpers":47}],49:[function(require,module,exports){
/**
 * @module appconfig
 */
'use strict';

var _ = require('./util');
var Model = require('./model');
var helpers = require('./helpers');

var events = {
  connect: 'connect',
  disconnect: 'disconnect',
  update: 'update',
  status: 'status'
};

var EventBus = function () {
  var subscriptionsByType;
  var on = function (type, once, callback, scope) {
    if (!_.isFunction(callback)) {
      return;
    }

    var subscription = {
      type: type,
      once: once,
      callback: callback,
      scope: scope
    };

    var subscriptions = subscriptionsByType[type];
    if (typeof subscriptions === 'undefined') {
      subscriptions = subscriptionsByType[type] = [];
    }
    subscription.id = subscriptions.push(subscription) - 1;
    return subscription;
  };

  var emit = function () {
    var args = [].slice.call(arguments);
    var type = args.splice(0, 1)[0];
    var subscriptions = subscriptionsByType[type];
    if (typeof subscriptions === 'undefined') {
      subscriptions = subscriptionsByType[type] = [];
    }
    subscriptions.forEach(function (subscription) {
      if (!subscription) {
        return;
      }

      try {
        subscription.callback.apply(subscription.scope, args);
      } catch (x) {
        _.warn('Exception during execution of callback', subscription, args, x);
      }
      if (subscription.once) {
        off(subscription);
      }
    });
  };
  var off = function (subscription) {
    var subscriptions = subscriptionsByType[subscription.type];
    if (typeof subscriptions !== 'undefined') {
      delete subscriptions[subscription.id];
    }
  };

  var resume = function (subscription) {
    if (typeof subscription.id === 'undefined') {
      return on(subscription.type, subscription.once, subscription.callback, subscription.scope);
    } else {
      var subscriptions = subscriptionsByType[subscription.type];
      if (typeof subscriptions === 'undefined') {
        subscriptions = subscriptionsByType[subscription.type] = [];
      }
      subscriptions[subscription.id] = subscription;
      return subscription;
    }
  };

  var reset = function () {
    if (typeof subscriptionsByType !== 'undefined') {
      Object.keys(subscriptionsByType).forEach(function (type) {
        var subscriptions = subscriptionsByType[type];
        if (typeof subscriptions !== 'undefined') {
          subscriptions.forEach(function (subscription) {
            delete subscription.id;
          });
        }
      });
    }
    subscriptionsByType = {};
  };
  reset();
  return {
    on: on,
    emit: emit,
    off: off,
    resume: resume,
    reset: reset

  };
};

var AppConfig = function () {

  var defaultListen  = true;
  var gateway;
  var initGateway;
  var bus = new EventBus();
  var model = new Model(bus);

  var root = require('./props')(model.root);
  var self = this;

  var gatewayConnection;
  var pollingIntervalId;
  var clearPollingInterval = function () {
    if (typeof pollingIntervalId !== 'undefined') {
      clearInterval(pollingIntervalId);
    }
  };

  // Public API
  self.init = function (settings) {
    settings = settings || {};
    var isIdentityValid = typeof settings.identity === 'object' &&
      Object.keys(settings.identity).length > 0;

    if (isIdentityValid) {
      self.identity = settings.identity;
    }
    defaultListen = settings.defaultListen || defaultListen;
    if (!self.identity) {
      throw new TypeError('identity must be non empty object.');
    }

    model.separator = settings.defaultSeparator || model.separator;

    self.schema = settings.schema || self.schema || 'ApplicationConfiguration';

    initGateway = _.isFunction(settings.gateway) ?
      settings.gateway :
      function () {
        if (typeof settings.gateway === 'undefined') {
          settings.gateway = {};
        }
        if (typeof settings.gateway.instance === 'undefined') {
          settings.gateway.instance = _.uuid();
        }
        return require('./gateway')(settings.gateway);
      };
  };

  self.connect = function (listen, callback, scope) {
    clearPollingInterval();
    var subscription;
    if (arguments.length > 0) {
      if (_.isFunction(listen)) {
        callback = listen;
        scope = callback;
        listen = defaultListen;
      }
      subscription = bus.on(events.connect, true, callback, scope);
    }

    var error;
    if (!self.identity) {
      error = 'identity is not specified. did you forget to call init()?';
    } else {
      if (!gateway) {
        gateway = initGateway();
      }
      if (!listen) {
        gatewayConnection =
          gateway.connect(
            self.schema,
            self.identity,
            false,
            function (error, snapshot, updates) {
              if (typeof error === 'undefined') {
                model.applySnapshot(snapshot);
              }
              bus.emit(events.connect, error);
            },
            function (error, status) {
              bus.emit(events.status, error, status);
            });
      } else {
        var connectEmitted = false;
        gatewayConnection = gateway.connect(
          self.schema,
          self.identity,
          true,
          function (error, snapshot, updates) {
            if (typeof snapshot !== 'undefined') {
              model.applySnapshot(snapshot);
            }
            if (typeof updates !== 'undefined') {
              model.applyUpdates(updates);
            }
            if (!connectEmitted) {
              connectEmitted = true;
              bus.emit(events.connect, error);
            }
          },
          function (error, status) {
            var LISTEN_NOT_SUPPORTED = 8;
            if (status.code === LISTEN_NOT_SUPPORTED) {
              pollingIntervalId = setInterval(function () {
                gateway.disconnect(gatewayConnection);
                gatewayConnection = gateway.connect(self.schema, self.identity, false, function (error, snapshot) {
                  model.applySnapshot(snapshot, false);
                });
              }, 2000);
            }
          });
      }
    }

    if (error) {
      setTimeout(bus.emit, 0, events.connect, error);
      throw new Error(error);
    }

    return subscription;

  };

  self.props = function (section, separator) {
    return root.props(section, separator);
  };

  self.modify = function (modifications, callback, scope) {
    if (typeof modifications === 'object') {
      modifications = [modifications];
    }
    var subscription = bus.on(events.update, true, callback, scope);

    return subscription;
  };

  self.onConnect = function (callback, scope) {
    return bus.on(events.connect, false, callback, scope);

  };

  self.onDisconnect = function (callback, scope) {
    return bus.on(events.disconnect, false, callback, scope);
  };

  self.off = function (subscription) {
    if (subscription) {
      bus.off(subscription);
    }
  };

  self.on = function (subscription) {
    if (subscription) {
      bus.resume(subscription);
    }
  };

  self.disconnect = function (callback, scope) {
    if (_.isFunction(callback)) {
      bus.on(events.disconnect, true, callback, scope);
    }
    clearPollingInterval();
    if (typeof gateway !== 'undefined') {
      gateway.disconnect(gatewayConnection, function (error) {
        bus.emit(events.disconnect, error);
      });
      gateway = undefined;
    } else {
      bus.emit(events.disconnect, 'not connected');
    }
  };
};

AppConfig.prototype.identityEqual = helpers.identityEqual;
AppConfig.prototype.identityToString = helpers.identityToString;

module.exports = function () {
  return new AppConfig();
};

},{"./gateway":50,"./helpers":51,"./model":52,"./props":53,"./util":54}],50:[function(require,module,exports){
'use strict';

var gatewayConnection = require('tick42-gateway-connection');
var helpers = require('./helpers');
var identityToString = helpers.identityToString;
var PRODUCT = 'appconfig';

var GatewayTransport = function (options) {
  var connection;
  var dataHandlers = {};
  var statusHandlers = {};
  options = options || {};

  function handleStatusMessage(msg) {
    var handler = statusHandlers[msg.instance];
    if (handler) {
      handler(msg.error, msg.status);
    }
  }
  function handleDataMessage(msg) {
    var schema = msg.schema;
    var schemaHandlers = dataHandlers[schema];
    if (typeof schemaHandlers === 'undefined') {
      return;
    }
    var identityKey = identityToString(msg.identity, true);
    var identityHandlers = schemaHandlers[identityKey];
    if (typeof identityHandlers === 'undefined') {
      return;
    }
    identityHandlers.forEach(function (handler) {
      if (handler) {
        handler(msg.error, msg.snapshot, msg.updates);
      }
    });
  }
  function ensureConnection() {
    if (typeof(connection) === 'undefined') {
      if (typeof options.connection !== 'undefined')
      {
        connection = options.connection;
      }
      else {
        connection = gatewayConnection(options.settings, options.custom_connection);
      }
    }
  }
  var dataSubscription;
  var statusSubscription;
  var connect = function (schema, identity, listen, handler, statusHandler) {
    ensureConnection();
    var schemaHandlers = dataHandlers[schema];
    if (typeof schemaHandlers === 'undefined') {
      schemaHandlers = dataHandlers[schema] = {};
    }
    var identityKey = identityToString(identity, true);
    var identityHandlers = schemaHandlers[identityKey];
    if (typeof identityHandlers === 'undefined') {
      identityHandlers = schemaHandlers[identityKey] = [];
    }
    var handlerToRegister;
    var index;
    if (listen) {
      handlerToRegister = handler;
    } else {
      handlerToRegister = function (error, snapshot, updates) {
        handler(error, snapshot, updates);
        delete identityHandlers[index];
      };
    }

    index = identityHandlers.push(handlerToRegister) - 1;

    if (typeof (dataSubscription) === 'undefined') {
      dataSubscription = connection.on(PRODUCT, GatewayTransport.MessageType.DATA, function (msg) {
        handleDataMessage(msg);
      });
    }
    var instance = options.instance;
    statusHandlers[instance] = statusHandler;
    if (typeof (statusSubscription) === 'undefined') {
      statusSubscription = connection.on(PRODUCT, GatewayTransport.MessageType.STATUS, function (msg) {
        handleStatusMessage(msg);
      });
    }

    var msg = {
      schema: schema,
      identity: identity,
      instance: instance,
      listen: listen
    };
    connection.send(PRODUCT, GatewayTransport.MessageType.CONNECT, msg);
    return {
      schema: schema,
      identity: identity,
      listen: listen,
      handler: handler,
      index : index
    };
  };

  var modify = function (schema, identity, modifications) {
    ensureConnection();
    connection.send(PRODUCT, GatewayTransport.MessageType.MODIFY, modifications);
  };
  var disconnect = function (descriptor) {
    var schemaHandlers = dataHandlers[descriptor.schema];
    if (typeof schemaHandlers !== 'undefined') {
      var identityKey = identityToString(descriptor.identity, true);
      var identityHandlers = schemaHandlers[identityKey];
      if (typeof identityHandlers !== 'undefined') {
        var handler = identityHandlers[descriptor.index];
        if (typeof handler !== 'undefined') {
          var msg = {
            schema: descriptor.schema,
            identity: descriptor.identity,
            instance: options.instance
          };
          connection.send(GatewayTransport.MessageType.DISCONNECT, msg);
          delete identityHandlers[descriptor.index];
        }
        if (identityHandlers.length === 0) {
          delete schemaHandlers[identityKey];
        }
      }
      if (Object.keys(schemaHandlers).length === 0) {
        delete dataHandlers[descriptor.schema];
      }
    }
    if (Object.keys(dataHandlers).length === 0) {
      if (typeof (dataSubscription) !== 'undefined') {
        connection.off(dataSubscription);
      }
    }
    delete statusHandlers[descriptor.instance];
    if (Object.keys(statusHandlers).length === 0) {
      if (typeof statusSubscription !== 'undefined') {
        connection.off(statusSubscription);
      }
    }
  };
  return {
    connect: connect,
    modify: modify,
    disconnect: disconnect
  };
};

GatewayTransport.MessageType = {
  // { schema: 'ApplicationConfiguration', identity: {}, listen: true, instance: '' }
  CONNECT: 'connect',
  // { schema: 'ApplicationConfiguration', identity: {}, instance: '' }
  DISCONNECT: 'disconnect',
  // { schema: 'ApplicationConfiguration', identity: {}, updates: [], instance: '' }
  MODIFY: 'modify',
  // { schema: 'ApplicationConfiguration', identity: {}, error: '', snapshot: {defaultKeyValue: '', keys: [], props: {}}, updates: [] }
  DATA: 'data',
  // { schema: 'ApplicationConfiguration', identity: {}, instance: '', status: '', error: '' }
  STATUS: 'status'
};

module.exports = GatewayTransport;

},{"./helpers":51,"tick42-gateway-connection":55}],51:[function(require,module,exports){
'use strict';

function escapeIdentityText(text) {
  if (typeof text === 'string') {
    return text.replace(/[\\]/g, '\\\\').replace(/[:]/g, '\\:');
  } else {
    return text;
  }
}

function identityToString(identity, includeKeys, separator, order) {
  if (typeof(identity) === 'undefined') {
    return null;
  }
  separator = separator || '/';
  var keys = Object.keys(identity);
  if (typeof(order) === 'function') {
    keys.sort(order);
  } else {
    keys.sort();
  }
  return keys.map(function (key) {
    return includeKeys ? (escapeIdentityText(key) + ':' + escapeIdentityText(identity[key])) : identity[key];
  }).join(separator);
}

function identityEqual(identity1, identity2) {
  return identityToString(identity1, true) === identityToString(identity2, true);
}

function flatten(props, separator, name) {
  separator = separator || '.';
  var prefix = name ? name + separator : '';
  var val = {};
  Object.keys(props).forEach(function (key) {
    if (key.indexOf(prefix) !== 0) {
      return;
    }
    var path = key.substring(prefix.length);
    var target = val;
    var parts = path.split(separator);
    var i;
    for (i = 0; i < parts.length - 1; i++) {
      if (!target[parts[i]]) {
        target[parts[i]] = {};
      }
      target = target[parts[i]];
    }
    target[parts[i]] = props[key].value;
  });
  return val;
}

function propEqual(lhs, rhs) {
  if (lhs.value !== rhs.value) {
    return false;
  }
  for (var i = 0; i < lhs.underlying.length; i++) {
    var lhsUnderlying = lhs.underlying[i];
    var rhsUnderlying = rhs.underlying[i] || {};
    if (lhsUnderlying.value !== rhsUnderlying.value || !identityEqual(lhsUnderlying.parent, rhsUnderlying.parent)) {
      return false;
    }
  }
  return true;
}

module.exports = {
  flatten: flatten,
  propEqual: propEqual,
  identityToString: identityToString,
  identityEqual: identityEqual
};

},{}],52:[function(require,module,exports){
'use strict';

var propEqual = require('./helpers').propEqual;

var UpdateType = {
  Added: 'Added',
  Changed: 'Changed',
  Removed: 'Removed'
};

var Model = function (bus, separator) {
  this.bus = bus;
  this.root = new ViewModel(this, '', separator || '.');
  this.views = {};
};

var ViewModel = function (model, path, separator) {
  var self = this;
  self.model = model;
  self.props = {};
  self.separator = separator || model.separator;
  self.path = path;
};

ViewModel.prototype.getViewModel = function (name, separator) {
  var path = this.path + name + (separator ? separator : '.');
  var model = this.model;
  if (path === '') {
    return model.root;
  }
  if (!model.views[path]) {
    var bestParent = '';
    // fill subview references and choose best parent props to copy from.
    Object.keys(model.views).forEach(function (key) {
      if (path.indexOf(key) === 0) {
        if (bestParent.length < key.length) {
          bestParent = key;
        }
        // keep subviews sorted.
        var subviews = model.views[key].subviews;
        for (var i = 0; i < subviews.length; i++) {
          if (subviews[i].indexOf(path)) {
            subviews.splice(i, 0, path);
            return;
          }
        }
        subviews.push(path);
      }
    });
    var viewModel = new ViewModel(model, path, separator);

    var parentProps = bestParent === '' ? model.root.props : model.views[bestParent].model.props;
    Object.keys(parentProps).forEach(function (key) {
      var prop = parentProps[key];
      if (prop.name.indexOf(path) === 0) {
        var name = prop.name.substring(path.length);
        viewModel.props[name] = prop;
      }
    });

    model.views[path] = {
      subviews: [],
      model: viewModel
    };
  }
  return model.views[path].model;
};

ViewModel.prototype.on = function (callback, scope) {
  return this.model.on(this.path, callback, scope);
};

Model.prototype.on = function (path, callback, scope) {
  var type = updateTypeForPath(path);
  return this.bus.on(type, false, callback, scope);
};

Model.prototype.applySnapshot = function (snapshot, isSnapshot) {
  isSnapshot = typeof isSnapshot === 'undefined' ? true : isSnapshot;

  var updates = toUpdates(isSnapshot ? {} : this.root.props, snapshot.props);
  applyUpdatesAndEmitEvents(this, updates, isSnapshot);
};

function updateTypeForPath(path) {
  var type = 'update';
  if (path !== '') {
    type = type + '|' + path;
  }
  return type;
}

// shallow copy
function cloneUpdateForPath(update, path) {
  var clone = {
    type: update.type,
    name: update.name.substring(path.length)
  };

  switch (update.type) {
    case UpdateType.Changed:
      clone.oldValue = update.oldValue;
      /* falls through */
    case UpdateType.Added:
      clone.value = update.value;
      break;
    case UpdateType.Removed:
      /* falls through */
    default:
      break;
  }
  return clone;
}

function applyUpdatesAndEmitEvents(model, updates, isSnapshot) {
  var views = Object.keys(model.views);
  var effectiveUpdates = {
    '': updates
  };
  if (views.length > 0) {
    // sort views for prefix search
    if (views.length > 1) {
      views.sort();
    }
    updates.forEach(function (update) {
      for (var i = 0; i < views.length; views++) {
        if (update.name.indexOf(views[i]) === 0) {
          break;
        }
      }
      var view = views[i];
      if (typeof view === 'undefined') {
        return;
      }
      effectiveUpdates[view].push(cloneUpdateForPath(update, view));
    });
  }

  var affectedPaths = Object.keys(effectiveUpdates);
  if (affectedPaths.length > 1) {
    affectedPaths.sort();
  }
  affectedPaths.forEach(function (path) {
    var viewModel = path === '' ? model.root : model.views[path].model;
    if (isSnapshot) {
      viewModel.props = {};
    }
    effectiveUpdates[path].forEach(function (update) {
      switch (update.type) {
        case UpdateType.Added:
          // fall-through
        case UpdateType.Changed:
          // changed works even for missing properties
          viewModel.props[update.name] = update.value;
          break;
        case UpdateType.Removed:
          delete viewModel.props[update.name];
          break;
        default:
          // do nothing
          break;
      }
    });
  });
  affectedPaths.forEach(function (path) {
    var type = updateTypeForPath(path);
    model.bus.emit(type, isSnapshot, updates);
  });
}
Model.prototype.applyUpdates = function (updates) {
  applyUpdatesAndEmitEvents(this, updates, false);
};

function toUpdates(image, snapshot) {
  snapshot = snapshot || {};
  var updates = [];
  var toDelete = Object.keys(image);
  Object.keys(snapshot).forEach(function (key) {
    var update = {};
    if (typeof image[key] === 'undefined') {
      update.type = UpdateType.Added;
    } else {
      if (!propEqual(image[key], snapshot[key])) {
        update.type = UpdateType.Changed;
        update.oldValue = image[key];
      }
      for (var i = 0; i < toDelete.length; toDelete++) {
        if (toDelete[i] === key) {
          break;
        }
      }
      if (typeof toDelete[i] !== 'undefined') {
        toDelete.splice(i, 1);
      }
    }
    if (update.type) {
      update.value = snapshot[key];
      update.name = key;
      updates.push(update);
    }
  });
  toDelete.forEach(function (key) {
    updates.push({
      type: UpdateType.Removed,
      name: key
    });
  });
  return updates;
}

module.exports = Model;

},{"./helpers":51}],53:[function(require,module,exports){
'use strict';
var flatten = require('./helpers').flatten;

var Props = function (model) {
  var prop = function (name) {
    return model.props[name];
  };
  var val = function val(name) {
    if (typeof name === 'undefined' || typeof model.props[name] === 'undefined') {
      return flatten(model.props, model.separator, name);
    }
    return model.props[name].value;
  };

  var props = function (section, separator) {
    section = section || '';
    if (section === '') {
      // TODO: support separator change for '' (same) section.
      return self;
    }
    separator = separator || model.separator;
    return new Props(model.getViewModel(section, separator));
  };
  var forEach = function (callback, scope) {
    Object.keys(model.props).forEach(function (key) {
      callback.call(scope, model.props[key]);
    });
  };
  var onUpdate = function (callback, scope) {
    model.on(callback, scope);
  };
  var self = {
    prop: prop,
    val: val,
    props: props,
    forEach: forEach,
    onUpdate: onUpdate
  };
  return self;
};

module.exports = Props;

},{"./helpers":51}],54:[function(require,module,exports){
'use strict';

var uuid = function () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0;
    var v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
};
var isFunction = function (value) {
  if (value === undefined || value === null) {
    return false;
  }
  return typeof value === 'function';
};

var isString = function (value) {
  return typeof value === 'string';
};

var levels = {
  debug: 'debug',
  info: 'info',
  warn: 'warn',
  error: 'error'
};
var log = function (level, args) {
  if (console) {
    var logger = console[level];
    if (isFunction(logger)) {
      var now = new Date();
      [].splice.call(args, 0, 0, now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds());
      logger.apply(console, args);
    }
  }
};
var info = function () {
  log(levels.info, arguments);
};

var warn = function () {
  log(levels.warn, arguments);
};

var debug = function () {
  log(levels.debug, arguments);
};

module.exports = {
  uuid: uuid,
  isFunction: isFunction,
  isString: isString,
  log: log,
  warn: warn,
  info: info,
  debug: debug
};

},{}],55:[function(require,module,exports){
(function (global){
var connection = function (settings, custom_connection){
	settings = settings||{};
	//The message handlers that have to be executed for each received message
	var message_handlers = {};
	
	var ids = 0;
	
	var connection = {
		//Executes appropriate message handlers for the message type.
		_handle_message: function (message){
			 //Retrieve handlers for the message type
			 var handlers = message_handlers[message.type];
			 if(handlers !==undefined){
				 //Execute them
				 Object.keys(handlers).forEach(function(handler_id){
					var handler = handlers[handler_id];
					if(handler!==undefined){handler(message.message);}
				 });
			 }
		},
		//Attaches a handler
		on: function(product, type, message_handler){
		   if(message_handlers[type] === undefined){message_handlers[type] = {};}
		   var id = ids++;
		   message_handlers[type][id]= message_handler;
		   return {type:type, id:id};
		},
		
		//Remove a handler 
		off: function(info){
			delete message_handlers[info.type][info.id];
		},
		//Dummy functions for transports that are always connected
		connected:function(a){a();},
		disconnected:function(){},
		version: "1.3.1"
	};

	function create_custom_connection(connection){
		connection.send = function(product, type, message){
			custom_connection.publish({type:type, message:message});
		};
		custom_connection.subscribe(connection._handle_message);
		return connection;
	}

	if(settings.websocket_url!==undefined){
		return require("./ws")(connection, settings);
  }else if(settings.http_url !== undefined){
    return require("./http")(connection, settings);
  }else if(global.fin !==undefined){
		return require("./fin")(connection, settings);
	}else if(custom_connection!==undefined){
		return create_custom_connection(connection, settings);
	//Connect via HTML Container facade
	}else if (global.htmlContainer!==undefined){
		return require("./cont")(connection, settings);
	}else {
		throw "No connection. Make sure you are running the application from OpenFin, or Tick42 HTML Container or fill the 'connection.websocket_url' property.";
	}
};

if(global.tick42===undefined){global.tick42 = {};}
global.tick42.connection = connection;

module.exports = connection;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./cont":56,"./fin":57,"./http":58,"./ws":59}],56:[function(require,module,exports){
(function (global){
module.exports = function(connection){
	var connection_id =  Math.floor(1e10 * Math.random()).toString();
	//Route messages to facade(s)
	connection.send = function (product, type, message){
		if(product ==="metrics"){
			global.htmlContainer.metricsFacade.send(type, JSON.stringify(message));
		}else if(product ==="log"){
			global.htmlContainer.loggingFacade.send(type, JSON.stringify(message));
		}else if (product == "appconfig") {
            global.htmlContainer.appConfigFacade.send(type, JSON.stringify(message), connection_id);
        }
	};
	if (global.htmlContainer.appConfigFacade !== undefined) {
        global.htmlContainer.appConfigFacade.initConnection(
            connection_id,
            function (messageAsJson) {
                return connection._handle_message(JSON.parse(messageAsJson));
            });
    }
	global.connections = global.connections||{}; 
	//Expose function for sending messages:
	global.connections['connection'+connection_id] = connection._handle_message;

	return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],57:[function(require,module,exports){
(function (global){
module.exports = function(connection, settings){
	if(global.console!==undefined&& settings.debug===true){
		console.log("Attemping to connect to Gateway via OpenFin Inter Application Bus.");
	}

	//A function for sending a message 
	connection.send = function(product, type, message){
		fin.desktop.InterApplicationBus.publish("AGM", {type:type, message:message});
	};
	//A function that receives messages
	fin.desktop.InterApplicationBus.subscribe('*','AGM', connection._handle_message);
	if(global.console!==undefined&& settings.debug===true){
		console.log("Connected to OpenFin transport.");
	}
	
	return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],58:[function(require,module,exports){
(function (global){
module.exports = function (connection, settings) {
  var url = settings.http_url;
  // polling interval in ms, default is 1 second
  var interval = settings.http_interval_ms;
  if (!interval) interval = 1000;

  function log_debug(message) {
    if (global.console !== undefined && (settings.debug === true || settings.trace === true)) {
      console.log(message);
    }
  }

  function log_trace(message) {
    if (global.console !== undefined && settings.trace === true) {
      console.log(message);
    }
  }

  log_debug("Attemping to connect to Gateway via HTTP with url '" + url + "' and polling interval " + interval + " ms");

  poll(url, interval, 0, function (items) {
    for (var index = 0; index < items.length; index++) {
      connection._handle_message(items[index]);
    }
  });

  connection.send = function (product, type, message, id) {
    var msg = JSON.stringify({ type: type, message: message, id: id });
    http_post(url, msg);
  };

  /**
   * Polls data from a given url on some interval
   * @param url       Base server url. A sequence url param may be added based on the seq param
   * @param interval  Interval (in ms) between polling requestts
   * @param seq       Next sequence number we should ask for (if 0 the server will return the last known message)
   * @param ondata    Data callback    
   */
  function poll(url, interval, seq, ondata) {
    // construct the get Url - if seq != 0 add as url param to get 
    // only messages after this sequence
    var getUrl = url;

    if (seq !== 0) {
      getUrl = url + "?sequence=" + seq + "&no-cache=" + new Date().getTime();
    }    
        
    // create a request    
    var xmlhttp = createCORSRequest("GET", getUrl, function () {
      if (seq === 0){
        log_debug("Connected to Gateway on " + url);
      }
      log_trace("Response from '" + getUrl + "' is " + xmlhttp.responseText);
      var message = JSON.parse(xmlhttp.responseText);
      // the server returns the number of the next sequence that we must query for
      var nextSeq = message.nextSequence;
      // call user callbacke    
      ondata(message.data);
      // re-schedule
      setTimeout(function () {
        poll(url, interval, nextSeq, ondata);
      }, interval);
    });

    xmlhttp.onerror = function (ev) {
      console.log("Error polling data from http server '" + getUrl + "' - " + ev);
      // re-schedule
      setTimeout(function () {
        poll(url, interval, seq, ondata);
      }, interval);
    };

    log_trace("Sending GET to '" + getUrl + "'");
    xmlhttp.send();
  }

  /** 
   * POSTs a message to a given url 
   */
  function http_post(url, message) {
    // create a request    
    var xmlhttp = createCORSRequest("POST", url);
    log_trace("Sending POST to '" + url + "' : " + message);
    xmlhttp.send(message);
  }

  /** 
   * Creates CORS request (cross domain requests) for different browsers - XMLHttpRequest withCredentials
   * for Chrome and FF and XDomainRequest for IE
   */
  function createCORSRequest(method, url, result_callback) {
    var xhr = new XMLHttpRequest();    
    
    if ("withCredentials" in xhr) {
      // Check if the XMLHttpRequest object has a "withCredentials" property.
      // "withCredentials" only exists on XMLHTTPRequest2 objects.
      xhr.open(method, url, true);
      if (typeof result_callback !== "undefined"){
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4 && xhr.status == 200) {
            result_callback();
          }
        };
      }
    } else if (typeof XDomainRequest != "undefined") {
      // Otherwise, check if XDomainRequest.
      // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
      xhr = new XDomainRequest();
      xhr.open(method, url);
      if (typeof result_callback !== "undefined"){
        xhr.onload = result_callback;
      }
    } else {
      // Otherwise, CORS is not supported by the browser.
      xhr = null;
    }
    return xhr;
  }
 
  return connection;
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
(function (global){
module.exports = function(connection, settings){
	var connected = false;
	
	//Load the 'ws' library, but only if we are running under node js
	var WebSocket = require("detect-node")?require("ws"):global.WebSocket;
	
	function initiate_socket(){
		if(global.console!==undefined&& settings.debug===true){
			console.log("Attemping to connect to Gateway via WebSocket.");
		}

		var ws = new WebSocket(settings.websocket_url);
		//Add user callbacks
		ws.onclose = function(event){
			if(typeof settings.disconnected==="function"){settings.disconnected(settings.websocket_url, event);}
			connected = false;
		};
		//Log on connection
		ws.onopen = function(){
			if(typeof settings.connected==="function"){settings.connected(settings.websocket_url);}
			if(global.console!==undefined && settings.debug===true){
				console.log("Connected to WS URL "+settings.websocket_url);
			}
			connected = true;
		};
		//Attach handler
		ws.onmessage = function(message){
			connection._handle_message(JSON.parse(message.data));
		};
		return ws;
	}
	
	//Initiate a new socket (this gets re-executed on reconnect)
	var socket = initiate_socket();
	
	//Create a function for sending a message
	connection.send = function(product, type, message, id){
		//If we are connected send the message
		if(socket.readyState ===1){
			socket.send(JSON.stringify({type:type, message:message, id:id}));
		//If we are not connected and we are not attempting to connect right now, attempt to connect
		}else if (socket.readyState !==0){
			socket = initiate_socket();
		}
	};
	connection.websocket_url = function(a){
		settings.websocket_url = a;
		socket.close();
		socket = initiate_socket();
	};
	
	connection.connected = function(a){
		if(connected){a(settings.websocket_url);}
		settings.connected = a;
	};
	connection.disconnected = function(a){
		settings.disconnected = a;
	};
	
	return connection;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-node":5,"ws":79}],60:[function(require,module,exports){
var asciiTable = require("ascii-table");
var tick42Connection = require("tick42-gateway-connection");

var levels = [ 'trace', 'debug', 'info', 'warn', 'error', 'off' ];

function serializePath(path) {
	return path.length === 0 ? "" : path.join(".");
}

var isConnection = function(c) {
	return typeof c === "object" && typeof c.send === "function" && typeof c.on === "function";
};

function getLevel(logger, level) {
	//Retrieves the console or publish level of a logger
	//logger - the logger for which to retrieve the level
	//level - a string which can either be "publishLevel" for retrieving the publish level or "c_level" for retrieving the console level.
	if (logger[level] !== undefined) {
		return logger[level];
	} else if (logger.parent !== undefined) {
		return getLevel(logger.parent, level);
	}
}

function messageToTable(title, rows) {
	//Display message as table in file
	var keys = getAllKeys(rows);
	//fill rows with message properties
	var tableRows = rows.map(function (obj) {
		return keys.map(function (key) {
			return obj[key];
		});
	});

	var table_message = asciiTable.factory({
		title: title,
		heading: keys,
		rows: tableRows
	});
	return table_message.toString();
}

function getAllKeys(data) {
	//Accepts an array of objects and returns an array of all the keys from all objects
	var allKeys = [];

	data.forEach(function (obj) {
		Object.keys(obj).forEach(function (key) {
			if (allKeys.indexOf(key) === -1) {
				allKeys.push(key);
			}
		});
	});
	return allKeys;
}

function logger(configuration) {
	if (typeof configuration.connection !== "object") {
		configuration.connection = {};
	}

	//Set debug for the connection module if global debug is set
	configuration.connection.debug = configuration.debug;

	//Init connection
	//Determine if we are given a ready 'connection' object or a configuration.
	var connection = isConnection(configuration.connection) ? configuration.connection : tick42Connection(configuration.connection);

	var idKeys = ["system", "service", "instance"];

	//Convert instance to string, throw exceptions if it is not full
	var instance_str = idKeys.map(function (key) {
		var prop = configuration.identity[key];
		if (typeof prop !== "string") {
			throw 'Please specify "' + key + '" in your identity';
		}
		return prop;
	}).join("/");

	var loggerProto = {
		subLogger: function (name) {
			//Check if the sublogger is already created
			var existingSublogger = this.subloggers.filter(function (subLogger) {
				return subLogger.name === name;
			})[0];

			if (existingSublogger !== undefined) {
				return existingSublogger;
			}

			//Check if the name isn't the same as one of the parent properties
			Object.keys(this).forEach(function (key) {
				if (key === name) {
					throw 'This sub logger name is not allowed.';
				}
			});
			//Check if the name isn't the same as one of the parent methods
			Object.keys(loggerProto).forEach(function (key) {
				if (key === name) {
					throw 'This sub logger name is not allowed.';
				}
			});

			var path = this.path.slice(0);
			path.push(this.name);
			return createLogger(name, path, this);
		},

		publishLevel: function (level) {
			if (level !== null && level !== undefined) {
				this._publishLevel = level;
			}
			return getLevel(this, "_publishLevel");
		},

		consoleLevel: function (level) {
			if (level !== null && level !== undefined) {
				this._consoleLevel = level;
			}
			return getLevel(this, "_consoleLevel");
		},

		metricsLevel: function (level, metricsSystem) {
			if (level !== null && level !== undefined) {
				this._metricLevel = level;
			}

			if (metricsSystem !== undefined) {
				if (typeof metricsSystem === "object" && typeof metricsSystem.objectMetric === "function") {
					this.metricSystem = metricsSystem;
				} else {
					throw "Please specify metric system ";
				}
			}
		},

		table: function (message) {
			//message must be in an array, to be displayed as table
			if (!Array.isArray(message)) {
				throw 'The message must be in an array';
			}

			//Retrieve logger name and levels
			var loggerName = getLoggerName(this);

			//Publish in console
			if (shouldPublish(getLevel(this, '_consoleLevel'), 'info')) {
				console.info(loggerName + ':');
				console.table(message);
			}
			//Publish in file
			if (shouldPublish(getLevel(this, '_publishLevel'), 'info')) {
				connection.send('log', 'LogMessage', {
					instance: instance_str,
					level: levels.indexOf('info'),
					logger: loggerName,
					message: messageToTable(loggerName, message)
				});
			}
		},

		log: function (message, level) {
			publishMessage(this, level || "info", message);
		}
	};

	function createLogger(name, path, parent) {
		var logger = Object.create(loggerProto);
		logger.name = name;
		logger.path = path;
		logger.subloggers = [];
		logger.parent = parent;
		if (parent !== undefined) {
			//add sublogger to subloggers array
			parent.subloggers.push(logger);
			//add easy access to sublogger
			parent[logger.name] = logger;
			//create metric system
			if (parent.metricSystem !== undefined) {
				logger.metricsLevel('warn', parent.metricSystem.subSystem(logger.name));
			}
		}
		levels.forEach(function (level) {
			logger[level] = function (message) {
				publishMessage(logger, level, message);
			};
		});

		logger.off = function(){};

		logger.version = "2.0.3";

		return logger;
	}

	function publishMessage(logger, level, message) {
		//Retrieve logger name and levels
		var logger_name = getLoggerName(logger);

		//Add stack trace if the message is an error
		if (level === 'error') {
			var e = new Error();
			if (e.stack) {
				message = message + "\n" + (e.stack.split("\n").slice(3).join("\n"));
			}
		}

		//Publish in console
		if (shouldPublish(getLevel(logger, '_consoleLevel'), level)) {
			console[level](logger_name + ": " + message);
		}
		//Publish in file
		if (shouldPublish(getLevel(logger, '_publishLevel'), level)) {
			connection.send('log', 'LogMessage', {
				instance: instance_str,
				level: levels.indexOf(level),
				logger: logger_name,
				message: message
			});
		}

		//Publish in metrics
		if (shouldPublish(getLevel(logger, '_metricLevel'), level)) {
			if (logger.metricSystem !== undefined) {
				logger.metricSystem.objectMetric('LogMessage', {
					Time: new Date(),
					Logger: logger_name,
					Level: level,
					Message: message
				});

				if (level == 'error'){
					logger.metricSystem.setState(100, message);
				}
			}
		}
	}

	var shouldPublish = function (publishLevel, messageLevel) {
		return (!publishLevel || levels.indexOf(publishLevel) <= levels.indexOf(messageLevel));
	};

	var getLoggerName = function (logger) {
		var loggerPathAndName = logger.path.slice();
		loggerPathAndName.push(logger.name);
		return "[" + serializePath(loggerPathAndName) + "]";
	};

	var mainLogger = createLogger("main", [], undefined);
	mainLogger.publishLevel("warn");
	mainLogger.consoleLevel("info");
	mainLogger.metricsLevel("warn");

	return mainLogger;
}

if (typeof window !== 'undefined') {
	window.tick42 = window.tick42 || {};
	window.tick42.log = logger;
}

module.exports = logger;

},{"ascii-table":3,"tick42-gateway-connection":55}],61:[function(require,module,exports){
"use strict";
var objectMetric_1 = require("../metrics/objectMetric");
var stringMetric_1 = require("../metrics/stringMetric");
var numberMetric_1 = require("../metrics/numberMetric");
var timestampMetric_1 = require("../metrics/timestampMetric");
var MetricSerializer = (function () {
    function MetricSerializer() {
    }
    MetricSerializer.metricToMessage = function (metric) {
        var def = MetricSerializer._getMetricDefinition(metric.name, metric.value, metric.path, metric.type, metric.description, metric.period, metric.resolution);
        return {
            id: metric.id,
            instance: metric.repo.instance,
            definition: def,
            value: MetricSerializer._serializeValue(metric.value, metric),
        };
    };
    MetricSerializer._getMetricDefinition = function (name, value, path, type, description, resolution, period) {
        var def = {
            name: name,
            description: description,
            type: type ? type : MetricSerializer._getTypeFromValue(value),
            path: path,
            resolution: resolution,
            period: period
        };
        if (def.type === objectMetric_1.ObjectMetric.type) {
            def.Composite = Object.keys(value).reduce(function (arr, key) {
                var val = value[key];
                arr.push(MetricSerializer._getMetricDefinition(key, val, path));
                return arr;
            }, []);
        }
        return def;
    };
    MetricSerializer._serializeValue = function (value, metric) {
        if (value && value.constructor === Date) {
            return {
                value: {
                    type: this._valueTypes.indexOf("date"),
                    value: value.valueOf(),
                    isArray: false
                }
            };
        }
        else if (typeof value === "object") {
            return {
                CompositeValue: Object.keys(value).reduce(function (arr, key) {
                    var val = MetricSerializer._serializeValue(value[key]);
                    val.InnerMetricName = key;
                    arr.push(val);
                    return arr;
                }, [])
            };
        }
        else {
            var valueType = metric ? metric.getValueType() : undefined;
            valueType = valueType | this._valueTypes.indexOf(typeof value);
            return { value: { type: valueType, value: value, isArray: false } };
        }
    };
    MetricSerializer._getTypeFromValue = function (value) {
        var typeAsString = value.constructor === Date ? 'timestamp' : typeof value;
        switch (typeAsString) {
            case 'string':
                return stringMetric_1.StringMetric.type;
            case 'number':
                return numberMetric_1.NumberMetric.type;
            case 'timestamp':
                return timestampMetric_1.TimestampMetric.type;
            case 'object':
                return objectMetric_1.ObjectMetric.type;
        }
        return 0;
    };
    MetricSerializer._valueTypes = [
        "boolean",
        "int",
        "number",
        "long",
        "string",
        "date",
        "object"];
    return MetricSerializer;
}());
exports.MetricSerializer = MetricSerializer;

},{"../metrics/numberMetric":66,"../metrics/objectMetric":67,"../metrics/stringMetric":70,"../metrics/timestampMetric":72}],62:[function(require,module,exports){
"use strict";
var metricSerializer_1 = require("./metricSerializer");
var MetricsBridge = (function () {
    function MetricsBridge(repo, connection) {
        var _this = this;
        this._repo = repo;
        this._connection = connection;
        connection.on('metrics', "MetricsSnapshotRequest", function (instanceInfo) {
            if (instanceInfo.Instance !== repo.instance) {
                return;
            }
            _this.sendFull(_this._repo);
        });
    }
    MetricsBridge.prototype.sendFull = function (repo) {
        var rootSystem = repo.root;
        if (!rootSystem) {
            return;
        }
        if (rootSystem.subSystems.length == 0) {
            return;
        }
        this.sendFullSystem(rootSystem);
    };
    MetricsBridge.prototype.sendFullSystem = function (s) {
        var _this = this;
        this.createSystem(s);
        s.subSystems.forEach(function (sub) {
            _this.sendFullSystem((sub));
        });
        s.metrics.forEach(function (m) {
            _this.createMetric(m);
        });
    };
    MetricsBridge.prototype.createMetric = function (metric) {
        this._send("CreateMetric", metricSerializer_1.MetricSerializer.metricToMessage(metric));
    };
    MetricsBridge.prototype.updateMetric = function (metric) {
        this._send("UpdateMetric", metricSerializer_1.MetricSerializer.metricToMessage(metric));
    };
    MetricsBridge.prototype.createSystem = function (system) {
        if (system.parent !== undefined) {
            this._send("CreateMetricSystem", {
                id: system.id,
                instance: system.repo.instance,
                definition: { name: system.name, description: system.description, path: system.path }
            });
        }
    };
    MetricsBridge.prototype.updateSystem = function (system, state) {
        this._send("UpdateMetricSystem", {
            id: system.id,
            instance: system.repo.instance,
            state: state
        });
    };
    MetricsBridge.prototype.heartbeat = function (repo, interval) {
        this._send("HeartbeatMetrics", { publishingInterval: interval, instance: repo.instance });
    };
    MetricsBridge.prototype._send = function (type, message) {
        this._connection.send("metrics", type, message);
    };
    return MetricsBridge;
}());
exports.MetricsBridge = MetricsBridge;

},{"./metricSerializer":61}],63:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var AddressMetric = (function (_super) {
    __extends(AddressMetric, _super);
    function AddressMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, AddressMetric.type, value || '');
    }
    AddressMetric.type = 8;
    return AddressMetric;
}(metric_1.Metric));
exports.AddressMetric = AddressMetric;

},{"./metric":65}],64:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var CountMetric = (function (_super) {
    __extends(CountMetric, _super);
    function CountMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, CountMetric.type, value || 0);
    }
    CountMetric.prototype.increment = function () {
        this.incrementBy(1);
    };
    CountMetric.prototype.decrement = function () {
        this.decrementBy(1);
    };
    CountMetric.prototype.incrementBy = function (n) {
        this.update((this.value || 0) + n);
    };
    CountMetric.prototype.decrementBy = function (n) {
        this.update((this.value || 0) - n);
    };
    CountMetric.prototype.getValueType = function () {
        return 3;
    };
    CountMetric.type = 3;
    return CountMetric;
}(metric_1.Metric));
exports.CountMetric = CountMetric;

},{"./metric":65}],65:[function(require,module,exports){
"use strict";
var Metric = (function () {
    function Metric(def, parent, transport, type, value) {
        this.name = def.name;
        this.description = def.description;
        this.period = def.period;
        this.resolution = def.resolution;
        this.system = parent;
        this.repo = parent.repo;
        this.id = parent.path + "/" + this.name;
        this.value = value;
        this.type = type;
        this.path = parent.path.slice(0);
        this.path.push(parent.name);
        this._transport = transport;
        this._transport.createMetric(this);
    }
    Metric.prototype.update = function (value) {
        this.value = value;
        this._transport.updateMetric(this);
    };
    Metric.prototype.getValueType = function () {
        return undefined;
    };
    Metric.type = 0;
    return Metric;
}());
exports.Metric = Metric;

},{}],66:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var NumberMetric = (function (_super) {
    __extends(NumberMetric, _super);
    function NumberMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, NumberMetric.type, value || 0);
    }
    NumberMetric.prototype.increment = function () {
        this.incrementBy(1);
    };
    NumberMetric.prototype.decrement = function () {
        this.decrementBy(1);
    };
    NumberMetric.prototype.incrementBy = function (n) {
        this.update((this.value || 0) + n);
    };
    NumberMetric.prototype.decrementBy = function (n) {
        this.update((this.value || 0) - n);
    };
    NumberMetric.type = 2;
    return NumberMetric;
}(metric_1.Metric));
exports.NumberMetric = NumberMetric;

},{"./metric":65}],67:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var ObjectMetric = (function (_super) {
    __extends(ObjectMetric, _super);
    function ObjectMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, ObjectMetric.type, value);
    }
    ObjectMetric.prototype.update = function (value) {
        _super.prototype.update.call(this, value);
    };
    ObjectMetric.type = 11;
    return ObjectMetric;
}(metric_1.Metric));
exports.ObjectMetric = ObjectMetric;

},{"./metric":65}],68:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var RateMetric = (function (_super) {
    __extends(RateMetric, _super);
    function RateMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, RateMetric.type, value || 0);
    }
    RateMetric.type = 4;
    return RateMetric;
}(metric_1.Metric));
exports.RateMetric = RateMetric;

},{"./metric":65}],69:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var StatisticsMetric = (function (_super) {
    __extends(StatisticsMetric, _super);
    function StatisticsMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, StatisticsMetric.type, value || 0);
    }
    StatisticsMetric.type = 6;
    return StatisticsMetric;
}(metric_1.Metric));
exports.StatisticsMetric = StatisticsMetric;

},{"./metric":65}],70:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var StringMetric = (function (_super) {
    __extends(StringMetric, _super);
    function StringMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, StringMetric.type, value || '');
    }
    StringMetric.type = 1;
    return StringMetric;
}(metric_1.Metric));
exports.StringMetric = StringMetric;

},{"./metric":65}],71:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var TimespanMetric = (function (_super) {
    __extends(TimespanMetric, _super);
    function TimespanMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, TimespanMetric.type, value || false);
    }
    TimespanMetric.prototype.start = function () {
        this.update(true);
    };
    TimespanMetric.prototype.stop = function () {
        this.update(false);
    };
    TimespanMetric.type = 10;
    return TimespanMetric;
}(metric_1.Metric));
exports.TimespanMetric = TimespanMetric;

},{"./metric":65}],72:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var metric_1 = require("./metric");
var TimestampMetric = (function (_super) {
    __extends(TimestampMetric, _super);
    function TimestampMetric(def, parent, transport, value) {
        _super.call(this, def, parent, transport, TimestampMetric.type, value || new Date());
    }
    TimestampMetric.prototype.now = function () {
        this.update(new Date());
    };
    TimestampMetric.type = 7;
    return TimestampMetric;
}(metric_1.Metric));
exports.TimestampMetric = TimestampMetric;

},{"./metric":65}],73:[function(require,module,exports){
"use strict";
var system_1 = require("./system");
var transport_1 = require("./bridge/transport");
var Repository = (function () {
    function Repository(config) {
        this._config = config;
        this._transport = new transport_1.MetricsBridge(this, config.connection);
        this.instance = config.identity.system + '/' + config.identity.service + '/' + config.identity.instance;
        this.identity = config.identity;
        this._startHeartbeating();
        this.root = new system_1.System('', this, this._transport);
        this._initSystemMetrics(this.root, config.clickStream || config.clickStream === undefined);
    }
    Repository.prototype._startHeartbeating = function () {
        var _this = this;
        this._transport.heartbeat(this, this._config.settings.heartbeatInterval);
        setInterval(function () {
            _this._transport.heartbeat(_this, _this._config.settings.heartbeatInterval);
        }, this._config.settings.heartbeatInterval);
    };
    Repository.prototype._initSystemMetrics = function (rootSystem, useClickStream) {
        if (typeof navigator !== 'undefined') {
            rootSystem.stringMetric('UserAgent', navigator.userAgent);
        }
        if (useClickStream && typeof document !== 'undefined') {
            var clickStream_1 = rootSystem.subSystem("ClickStream");
            var documentClickHandler = function (e) {
                if (!e.target) {
                    return;
                }
                clickStream_1.objectMetric("LastBrowserEvent", {
                    type: "click",
                    timestamp: new Date(),
                    target: {
                        className: e.target ? e.target.className : '',
                        id: e.target.id,
                        type: '<' + e.target.tagName.toLowerCase() + '>',
                        href: e.target.href || ""
                    }
                });
            };
            clickStream_1.objectMetric("Page", {
                title: document.title,
                page: window.location.href
            });
            if (document.addEventListener) {
                document.addEventListener('click', documentClickHandler);
            }
            else {
                document.attachEvent('onclick', documentClickHandler);
            }
        }
    };
    return Repository;
}());
exports.Repository = Repository;

},{"./bridge/transport":62,"./system":74}],74:[function(require,module,exports){
"use strict";
var numberMetric_1 = require("./metrics/numberMetric");
var timespanMetric_1 = require("./metrics/timespanMetric");
var stringMetric_1 = require("./metrics/stringMetric");
var addressMetric_1 = require("./metrics/addressMetric");
var objectMetric_1 = require("./metrics/objectMetric");
var timestampMetric_1 = require("./metrics/timestampMetric");
var countMetric_1 = require("./metrics/countMetric");
var statisticsMetric_1 = require("./metrics/statisticsMetric");
var rateMetric_1 = require("./metrics/rateMetric");
var System = (function () {
    function System(name, repo, transport, parent, description) {
        this.metrics = [];
        this.subSystems = [];
        this.name = name;
        this.description = description || '';
        this.repo = repo;
        this.parent = parent;
        this._transport = transport;
        this.path = this._buildPath(this.parent);
        this.id = (this.path.length > 0 ? this.path.join('/') + '/' : '') + this.name;
        this.identity = repo.identity;
        this.root = repo.root;
        this._transport.createSystem(this);
    }
    System.prototype.subSystem = function (name, description) {
        if (!name || name.length === 0) {
            throw new Error('name is required');
        }
        var matchingSystems = this.subSystems.filter(function (s) { return s.name === name; });
        if (matchingSystems.length > 0) {
            return matchingSystems[0];
        }
        var system = new System(name, this.repo, this._transport, this, description);
        this.subSystems.push(system);
        return system;
    };
    System.prototype.setState = function (state, description) {
        this._transport.updateSystem(this, { state: state, description: description });
    };
    System.prototype.stringMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, stringMetric_1.StringMetric.type, value, function (metricDef) {
            return new stringMetric_1.StringMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.numberMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, numberMetric_1.NumberMetric.type, value, function (metricDef) {
            return new numberMetric_1.NumberMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.countMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, countMetric_1.CountMetric.type, value, function (metricDef) {
            return new countMetric_1.CountMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.addressMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, addressMetric_1.AddressMetric.type, value, function (metricDef) {
            return new addressMetric_1.AddressMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.objectMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, objectMetric_1.ObjectMetric.type, value, function (metricDef) {
            return new objectMetric_1.ObjectMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.timespanMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, timespanMetric_1.TimespanMetric.type, value, function (metricDef) {
            return new timespanMetric_1.TimespanMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.timestampMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, timestampMetric_1.TimestampMetric.type, value, function (metricDef) {
            return new timestampMetric_1.TimestampMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.rateMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, rateMetric_1.RateMetric.type, value, function (metricDef) {
            return new rateMetric_1.RateMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype.statiticsMetric = function (definition, value) {
        var _this = this;
        return this._getOrCreateMetric(definition, statisticsMetric_1.StatisticsMetric.type, value, function (metricDef) {
            return new statisticsMetric_1.StatisticsMetric(metricDef, _this, _this._transport, value);
        });
    };
    System.prototype._unionToMetricDef = function (definition) {
        var metricDef;
        if (typeof definition === 'string') {
            metricDef = { name: definition };
        }
        else {
            metricDef = definition;
        }
        if (metricDef.name === undefined) {
            throw new Error('Metric name is required.');
        }
        return metricDef;
    };
    System.prototype._getOrCreateMetric = function (definition, expectedType, value, createFunc) {
        var metricDef = this._unionToMetricDef(definition);
        var matchingMetrics = this.metrics.filter(function (m) { return m.name === metricDef.name; });
        if (matchingMetrics.length > 0) {
            var existingMetric = matchingMetrics[0];
            if (existingMetric.type !== expectedType) {
                throw new Error('A metric named ' + metricDef.name + ' is already defined with different type');
            }
            if (typeof value !== 'undefined') {
                existingMetric.update(value);
            }
            return existingMetric;
        }
        var newMetric = createFunc(metricDef);
        this.metrics.push(newMetric);
        return newMetric;
    };
    System.prototype._buildPath = function (system) {
        if (!system || !system.parent) {
            return [];
        }
        var path = this._buildPath(system.parent);
        path.push(system.name);
        return path;
    };
    return System;
}());
exports.System = System;

},{"./metrics/addressMetric":63,"./metrics/countMetric":64,"./metrics/numberMetric":66,"./metrics/objectMetric":67,"./metrics/rateMetric":68,"./metrics/statisticsMetric":69,"./metrics/stringMetric":70,"./metrics/timespanMetric":71,"./metrics/timestampMetric":72}],75:[function(require,module,exports){
"use strict";
var repository_1 = require("./core/repository");
var tick42_gateway_connection_1 = require('tick42-gateway-connection');
var windowAsAny = typeof window === 'undefined' ? (new Object()) : window;
windowAsAny.tick42 = windowAsAny.tick42 || {};
windowAsAny.tick42.metrics = windowAsAny.tick42.metrics || function (config) {
    if (!config.identity) {
        throw new Error('Identity missing from metrics configuration');
    }
    if (!config.identity.service || typeof config.identity.service !== 'string') {
        throw new Error('Service missing or invalid in metrics identity configuration');
    }
    if (!config.identity.system || typeof config.identity.system !== 'string') {
        throw new Error('System missing or invalid in metrics identity configuration');
    }
    if (!config.identity.instance || typeof config.identity.instance !== 'string') {
        throw new Error('Instancemissing or invalid in metrics identity configuration');
    }
    config.settings = config.settings || {};
    config.settings.heartbeatInterval = config.settings.heartbeatInterval || 15000;
    if (typeof config.connection !== "object") {
        config.connection = {};
    }
    if (!(typeof config.connection === "object" && typeof config.connection.send === "function" && typeof config.connection.on === "function")) {
        config.connection = tick42_gateway_connection_1.connection(config.connection);
    }
    var repo = new repository_1.Repository(config);
    repo['version'] = repo.root['version'] = '2.0.13';
    return repo.root;
};
module.exports = windowAsAny.tick42.metrics;

},{"./core/repository":73,"tick42-gateway-connection":55}],76:[function(require,module,exports){
var windows = function (agm) {

	var deprecate = require('util-deprecate');
	if (agm.subscribe) {
		agm.serverMethodAdded(function (resp) {
			if ((resp.server.application.indexOf('HtmlContainer.') !== -1 && resp.server.application.indexOf('.Internal') !== -1) && resp.method.name.indexOf('T42.Wnd.WindowStateChanged') !== -1) {
				agm.subscribe("T42.Wnd.WindowStateChanged", {target: "all"}).then(function (stream) {
					stream.onData(function (streamData) {
						update_window(streamData.data, determinateCorrectContainer(streamData.server.application));
					});
					// attach callbacks
					//stream.on("end", handleStreamClosed);
					//stream.on("close", handleStreamClosed);
				});
			}
		});
	}
	//Store windows that are tracked by ID and receive updates
	var windows = {};

	function update_window(window_info, container_name) {

		var window_id = container_name + "." + window_info.windowName;

		var the_window = windows[window_id];

		if (the_window === undefined) {
			//If the user is subscribed for the global events, create the window object.
			if (get_callbacks(window_added_callbacks, container_name).length > 0 || get_callbacks(window_removed_callbacks, container_name).length > 0) {
				the_window = a_window_from(window_info.windowName, container_name, window_info.url, window_info.windowId, window_info.windowStyleAttributes,window_info.windowTitle);
			} else {
				return;
			}
		}

		if (the_window.id === undefined) {
			the_window.id = window_info.windowId;
			exec_callbacks(the_window.callbacks.on_available, the_window);
		}

		if (window_info.state === "TitleChanged") {
			the_window.title = window_info.windowTitle;
			exec_callbacks(the_window.callbacks.onTitleChanged, window_info.windowTitle);
		}

		if (the_window.url !== window_info.url) {
			the_window.url = window_info.url;
			exec_callbacks(the_window.callbacks.on_url_changed, window_info.url);
		}

		if (window_info.state === "Created") {
			//Execute global "window_added" callbacks
			exec_callbacks(get_callbacks(window_added_callbacks, container_name), the_window);
		}

		//Clear the window on close event
		if (window_info.state === "Closed") {
			//Execute global "window_removed" callbacks
			exec_callbacks(get_callbacks(window_removed_callbacks, container_name), the_window);
			//Execute window-specific "window_removed" callbacks
			exec_callbacks(the_window.callbacks.onClose);
			//Refresh the window object state
			the_window.id = undefined;
			the_window.callbacks = {};

			return;
		}

		//ButtonClicked
		if (window_info.state === "ButtonClicked") {
			//Execute global "window_added" callbacks
			if(the_window.buttons !== undefined && Object.keys(the_window.buttons).length !== 0){
				the_window.callbacks.onTabButton.forEach(function (callback) {
					callback(window_info.buttonId,the_window.buttons[window_info.buttonId].info);
				});
			}
		}
	}

	//Create a dictionary to store the callbacks for the method "window_added".
	var window_added_callbacks = {
		containers_callbacks: {},
		all_containers_callbacks: []
	};

	//Create a dictionary to store the callbacks for the method "window_removed".
	var window_removed_callbacks = {
		containers_callbacks: {},
		all_containers_callbacks: []
	};

	//Creates a new window object or returns an existing one
	//Accepts window name, container and URL
	//Returns a window object.

	//It is not guaranteed to return the window with the same URL and ID
	function a_window_from(name, container, url, id, windowStyles, title) {

		var window_id = determinateCorrectContainer(container) + "." + name;

		var existing_window = windows[window_id];

		if (existing_window !== undefined) {

			//If the window is closed, update the URL in the reference
			if (!existing_window.opened()) {
				existing_window.url = url;
			}
			return existing_window;
		} else {

			//Init object
			var window_obj = Object.create(window_proto);
			window_obj.name = name;
			window_obj.container = container;
			window_obj.url = url;
			window_obj.id = id;
			window_obj.callbacks = {};

			//Insert AGM server properties
			window_obj.application = window_id;

			//setting window title
			window_obj.title = title;

			//Adding windowStyleAttributes
			if (windowStyles !== undefined && typeof windowStyles !== 'object') {
				window_obj.windowStyleAttributes = JSON.parse(windowStyles);
			} else if (windowStyles !== undefined && typeof windowStyles === 'object') {
				window_obj.windowStyleAttributes = windowStyles;
			}
			else {
				window_obj.windowStyleAttributes = {};
			}

			//Init empty array for buttons
			window_obj.buttons = {};

			windows[window_id] = window_obj;

			return window_obj;
		}
	}

	//Binds a given window object to an actual window
	function bind_window(the_window, success, error) {

		//Typically the binding occurs when we receive an event, so we will retrieve some info about the window
		//and if it exists we will trigger an artificial event with it.

		//Check if the window isn't already bound
		if (the_window.id === undefined) {

			//checking for container
			var target = container_filter(the_window.container);
			if (target === undefined) {
				if (typeof error === "function") {
					error("No such container");
				}
			}

			//Retrieve window parameters
			agm.invoke("T42.Wnd.FindByName", {windowName: the_window.name}, target, {}, bind_from_info, error);

		} else {
			invoke_agm_success_callback(success, the_window);
		}
		return the_window;

		function bind_from_info(e) {
			//Retrieve window info (a bit hacky because the response format is weird)
			var window_info = vals(e.returned)[0];

			if (window_info === undefined) {
				if (typeof error === "function") {
					error("we cound not open/find this window");
				}
			} else {
				//Trigger an event
				window_info.state = "Attached";
				update_window(window_info, the_window.container);

				//Exec user callback
				invoke_agm_success_callback(success, the_window);
			}
		}
	}

	//Functions for opening, closing, resizing windows
	var window_proto = {

		open: function (dimensions, style, success, error) {

			//A wrapper for the standard AGM "open" function

			var the_window = this;

			//Init style objects if they are null
			dimensions = dimensions || {};
			style = style || {};

			//Take out the sticky-windows related properties from the style object

			var isSticky = style.isSticky;
			delete style.isSticky;

			var stickyGroup = style.stickyGroup;
			delete style.stickyGroup;
			delete style.hasMoveAreaThickness;
			delete style.hasSizeAreaThickness;

			//checking for container
			var target = container_filter(the_window.container);
			if (target === undefined) {
				if (typeof error === "function") {
					error("No such container");
				}
			}

			agm.invoke("T42.Html.CreateWindow",
				{
					//Window name and url
					windowName: the_window.name, url: the_window.url,
					//dimensions
					top: dimensions.top, left: dimensions.left, width: dimensions.width, height: dimensions.height,
					//Stickywindows - related props
					isSticky: isSticky, stickyGroup: stickyGroup,
					//Style attributes
					windowStyleAttributes: JSON.stringify(style)

				},
				target,
				{},
				opened,
				cannot_open);

			function opened(message) {
				//Add id to the current windows because the current HTML Container
				//doesn't support tracking the updates of the window
				if (message.returned !== undefined) {
					the_window.id = message.returned.id;
				}
				invoke_agm_success_callback(success, the_window);
			}

			function cannot_open(e) {
				//Call the error callback
				if (typeof error === "function") {
					error(e);
				}

				//Try to bind the returned object in case...
				bind_window(the_window);
			}

			return the_window;
		},

		setStyle: function (style, success, error) {
			return agm_action("T42.Wnd.SetWindowStyle").call(this, success, error, {windowStyleAttributes: JSON.stringify(style)});
		},

		opened: function () {
			return this.id !== undefined;
		},

		onAvailable: add_callback("on_available", function (the_window, callback) {
			if (the_window.opened()) {
				callback(the_window);
			}
		}),

		close: agm_action("T42.Wnd.Close"),

		collapse: agm_action("T42.Wnd.Collapse"),

		onClose: add_callback("onClose"),

		navigate: function (url, success, error) {
			return agm_action("T42.Html.OpenUrl").call(this, success, error, {url: url});
		},

		onUrlChanged: add_callback("onUrlChanged"),

		onTitleChanged: add_callback("onTitleChanged", function(the_window,callback){
			callback(the_window.title);
		}),

		focus: agm_action("T42.Wnd.Activate"),

		setTitle: function (title, success, error) {

			var target = container_filter(this.container);
			if (target === undefined) {
				if (typeof error !== 'function') {
					return;
				} else {
					error("No container");
				}
			}

			//Invoke the AGM method
			agm.invoke("T42.Wnd.SetWindowTitle", {
				windowId: this.id,
				title: title
			}, target, {}, title_is_set.bind(this), title_cannot_be_set);

			function title_is_set() {
				invoke_agm_success_callback(success, this);
			}

			function title_cannot_be_set(e) {
				invoke_agm_error_callback(error, e);
			}
		},

		getDetails: function (success, error) {
			var window_id = this.id;

			var target = container_filter(this.container);
			if (target === undefined) {
				if (typeof error !== 'function') {
					return;
				} else {
					error("No container");
				}
			}

			agm.invoke("T42.Wnd.FindById", {windowId: this.id}, target, {}, returned_dimensions, cannot_return_dimensions);

			function returned_dimensions(value) {
				invoke_agm_success_callback(success, value.returned[window_id]);
			}

			function cannot_return_dimensions(e) {
				invoke_agm_error_callback(error, e);
			}
		},

		moveResize: function (dimensions, success, error) {
			return agm_action("T42.Wnd.resizeAndMove").call(this, success, error, dimensions);
		},

		maximize: agm_action("T42.Wnd.Maximize"),

		restore: agm_action("T42.Wnd.Restore"),

		minimize: agm_action("T42.Wnd.Minimize"),

		maximizeRestore: agm_action("T42.Wnd.MaximizeOrRestoreDown"),

		onTabButton: add_callback("onTabButton"),

		addTabButton:  function (buttonInfo, success, error) {

			var target = container_filter(this.container);
			if (target === undefined)  {
				if (typeof error !== 'function') {
					return;
				} else {
					error("No container");
				}
			}
			if(typeof buttonInfo === 'undefined'){
				if (typeof error !== 'function') {
					return;
				} else {
					error("No button info");
				}
			}

			if(buttonInfo.buttonId === undefined){
				if (typeof error !== 'function') {
					return;
				} else {
					error("No buttonId");
				}
			}

			if(buttonInfo.imageBase64 === undefined){
				if (typeof error !== 'function') {
					return;
				} else {
					error("No imageBase64");
				}
			}

			var buttonInfo = {
				buttonId: buttonInfo.buttonId,
				tooltip: buttonInfo.tooltip,
				order: buttonInfo.order,
				imageBase64: buttonInfo.imageBase64,
				hoverImageBase64:  buttonInfo.hoverImageBase64,
				clickImageBase64: buttonInfo.clickImageBase64,
			};

			//Invoke the AGM method
			agm.invoke("T42.Wnd.AddButton", {
				windowId: this.id,
				buttonInfo:buttonInfo
			}, target, {}, buttonIsAdded.bind(this), buttonCannotBeAdded.bind(this));

			function buttonIsAdded() {
				var _buttonId = buttonInfo.buttonId;
				this.buttons[_buttonId] = {
					id: _buttonId,
					info:buttonInfo
				};
				invoke_agm_success_callback(success, this);
			}

			function buttonCannotBeAdded(e) {
				invoke_agm_error_callback(error, e);
			}
		}
	};

	// deprecates
	window_proto.set_style = deprecate(window_proto.setStyle, 'window.set_style() is deprecated and might be removed from future versions of glue. Use window.setStyle() instead');
	window_proto.on_available = deprecate(window_proto.onAvailable, 'window.on_available() is deprecated and might be removed from future versions of glue. Use window.onAvailable() instead');
	window_proto.on_close = deprecate(window_proto.onClose, 'window.on_close() is deprecated and might be removed from future versions of glue. Use window.onClose() instead');
	window_proto.on_url_changed = deprecate(window_proto.onUrlChanged, 'window.on_url_changed() is deprecated and might be removed from future versions of glue. Use window.onUrlChanged() instead');
	window_proto.set_title = deprecate(window_proto.setTitle, 'window.set_title() is deprecated and might be removed from future versions of glue. Use window.setTitle() instead');
	window_proto.get_details = deprecate(window_proto.getDetails, 'window.get_details() is deprecated and might be removed from future versions of glue. Use window.getDetails() instead');
	window_proto.move_resize = deprecate(window_proto.moveResize, 'window.move_resize() is deprecated and might be removed from future versions of glue. Use window.moveResize() instead');
	window_proto.maximize_restore = deprecate(window_proto.maximizeRestore, 'window.maximize_restore() is deprecated and might be removed from future versions of glue. Use window.maximizeRestore() instead');

	//Adds an alias of an AGM method in the Window prototype
	function agm_action(action) {
		return function (success, error, args) {

			//Stop if the window is closed
			if (this.url === undefined) {
				if (typeof error === "function") {
					error("Cannot execute a command on a closed window.");
				}

				return;
			}

			//Add the window ID to the arguments
			args = args || {};
			args.windowId = this.id;

			//Invoke the AGM method
			agm.invoke(action, args, container_filter(this.container), {}, fulfilled, error);

			var the_window = this;

			function fulfilled() {
				invoke_agm_success_callback(success, the_window);
			}

			return this;
		};
	}

	function determinateCorrectContainer(containerName) {
		// determinate HC or Browser
		var isHtmlContainer = typeof htmlContainer !== 'undefined';
		var containerFullName = "HtmlContainer.";

		//Container name is optional. if is undefined
		if (containerName === undefined) {
			if (isHtmlContainer) {
				containerFullName += htmlContainer.containerName;
			} else {
				var selectedContainers = getAvailableServers();
				if (selectedContainers.length === 0) {
					containerFullName = undefined;
				} else {
					containerFullName = selectedContainers[0].application;
				}
			}
		} else {
			var firstDotIndex = containerName.indexOf('.');
			var dashIndex = containerName.indexOf('-');
			var lastDotIndex = containerName.indexOf('.', dashIndex);
			//here is a full pattern - just pass it
			if (firstDotIndex !== -1 && dashIndex > firstDotIndex && lastDotIndex !== -1) {
				containerFullName = containerName;
			} else {
				if (isHtmlContainer) {
					if (htmlContainer.env.env !== undefined || htmlContainer.env.region !== undefined) {
						// Here we have partial name of Container in HC
						if (containerName.indexOf(htmlContainer.env.env) === -1 && containerName.indexOf(htmlContainer.env.region) === -1) {
							containerFullName += htmlContainer.env.env + '-' + htmlContainer.env.region + '.';
						}
						containerFullName += containerName;
						//Better to check if exist server with similar container? and if it passed wrong container to throw an exception?
					}
				}
				else {
					var matchingServers = getAvailableServersByName(containerName);
					if (matchingServers.length > 0) {
						containerFullName = matchingServers[0].application;
					} else {
						containerFullName = undefined;
					}
				}
			}
		}
		return containerFullName;
	}

	function getAvailableServers() {
		return agm.servers().reduce(function (memo, server) {
			if (server.application.indexOf('HtmlContainer.') !== -1) {
				if (server.application.indexOf('.Internal') !== -1) {
					memo.unshift(server);
				} else {
					memo.push(server);
				}
			}
			return memo;
		}, []);
	}

	function getAvailableServersByName(nameServer) {
		return agm.servers().filter(function (server) {
			var splittedServerName = server.application.split('.')[2];
			return splittedServerName === nameServer;
		});
	}

	function container_filter(name) {
		if (determinateCorrectContainer(name)) {
			return {application: determinateCorrectContainer(name)};
		} else {
			return undefined;
		}

	}

	//The API itself
	var api = {

		my: function () {
			var h;
			if (typeof window !== 'undefined') {
				h = window.htmlContainer;
			}
			//Retrieve the current window (the onw in which your application currently resides).
			return h === undefined ? undefined : a_window_from(h.browserWindowName, h.containerName, window.location.href, h.windowId);
		},

		open: function (name, url, container, dimensions, style, success, error) {
			var target = determinateCorrectContainer(container);
			if (target === undefined) {
				if (typeof error !== 'function') {
					return;
				} else {
					error("No container");
				}
			}
			return a_window_from(name, target, url, undefined, style).open(dimensions, style, success, error);
		},

		find: function (name, container, success, error) {
			return bind_window(a_window_from(name, determinateCorrectContainer(container)), success, error);
		},
		_from_event: a_window_from,

		list: function (container, success, error) {
			if (typeof success !== 'function') {
				return;
			}

			var target = container_filter(container);
			if (target === undefined) {
				if (typeof error !== 'function') {
					return;
				} else {
					error("No container");
				}
			}

			agm.invoke("T42.Wnd.ListWindows", {}, target, {wait_for_method_timeout: 15000}, listed, cannot_list);

			function listed(value) {
				if (value.returned === undefined) {
					success([]);
					return;
				}
				var result = vals(value.returned).map(function (opened_window) {
					return a_window_from(opened_window.windowName, determinateCorrectContainer(container), opened_window.url, opened_window.windowId, opened_window.windowStyleAttributes, opened_window.windowTitle);
				});
				success(result);
			}

			function cannot_list(e) {
				invoke_agm_error_callback(error, e);
			}
		},

		//Add callback for window added for the list of containers.
		windowAdded: function (callback, container) {
			//Add the current callback to the callback dictionary.
			put_callbacks(window_added_callbacks, callback, container);

			//Execute all the callbacks for already existing windows.

			//Get all existing html containers.
			api.containerAdded(function (server) {
				//If the user is subscribed to the container
				if (container === undefined || container === server) {
					//list all the windows in the container.
					api.list(server,
						function (list_of_windows) {
							//execute the callback for each window.
							list_of_windows.forEach(function (existing_window) {
								callback(existing_window);
							});
						},
						//Error callback if the windows cannot be listed.
						function (e) {
							console.log('Unable to load existing windows. ' + e);
						}
					);
				}
			});
		},

		windowRemoved: function (callback, container) {
			//Add the current callback to the callback dictionary.
			put_callbacks(window_removed_callbacks, callback, container);
		},

		containerAdded: function (callback) {
			agm.serverAdded(function (server) {
				if (server.application.indexOf('HtmlContainer.') !== -1) {
					invoke_agm_success_callback(callback, server.application);
				}
			});
		},

		containerRemoved: function (callback) {
			agm.serverRemoved(function (server) {
				if (server.application.indexOf('HtmlContainer.') !== -1) {
					invoke_agm_success_callback(callback, server.application);
				}
			});
		}
	};

	// deprecates
	api.window_added = deprecate(api.windowAdded, 'window.window_added() is deprecated and might be removed from future versions of glue. Use window.windowAdded() instead');
	api.window_removed = deprecate(api.windowRemoved, 'window.window_removed() is deprecated and might be removed from future versions of glue. Use window.windowRemoved() instead');
	api.container_added = deprecate(api.containerAdded, 'window.container_added() is deprecated and might be removed from future versions of glue. Use window.containerAdded() instead');
	api.container_removed = deprecate(api.containerRemoved, 'window.container_removed() is deprecated and might be removed from future versions of glue. Use window.containerRemoved() instead');


	var PackageJson = require("../package.json");
	api.version = PackageJson.version;

	return api;
};

if (typeof window !== 'undefined') {
	window.tick42 = window.tick42 || {};
	window.tick42.windows = windows;
}

module.exports = windows;


function add_callback(key, on_add) {
	return function (callback) {
		var obj = this.callbacks;
		if (obj[key] === undefined) {
			obj[key] = [callback];
		}
		else {
			obj[key].push(callback);
		}
		if (typeof on_add === "function") {
			on_add(this, callback);
		}
	};
}

function exec_callbacks(arr, val) {
	if (arr !== undefined) {
		arr.forEach(function (callback) {
			callback(val);
		});
	}
}

function vals(obj) {
	return Object.keys(obj).reduce(function (arr, key) {
		arr.push(obj[key]);
		return arr;
	}, []);
}

function container_from_filter(filter) {
	return filter.application.match(/HtmlContainer\.(.*?)$/)[1];
}

function invoke_agm_success_callback(callback, callback_argument) {
	if (typeof callback === "function") {
		callback(callback_argument);
	}
}

function invoke_agm_error_callback(callback, error) {
	if (typeof callback === "function") {
		callback(error.message);
	}
}

function get_callbacks(callbacks, container_name) {
	if (callbacks.containers_callbacks[container_name] !== undefined) {
		return callbacks.all_containers_callbacks.concat(callbacks.containers_callbacks[container_name]);
	} else {
		return callbacks.all_containers_callbacks;
	}
}

function put_callbacks(global_callbacks, callback, container) {
	if (container === undefined) {
		global_callbacks.all_containers_callbacks.push(callback);
	} else {
		if (global_callbacks.containers_callbacks[container] === undefined) {
			global_callbacks.containers_callbacks[container] = [callback];
		} else {
			global_callbacks.containers_callbacks[container].push(callback);
		}
	}
}

},{"../package.json":77,"util-deprecate":78}],77:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "tick42-windows@2.2.0",
      "C:\\work\\stash\\GLUE-dev\\js-glue"
    ]
  ],
  "_from": "tick42-windows@2.2.0",
  "_id": "tick42-windows@2.2.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/tick42-windows",
  "_nodeVersion": "5.3.0",
  "_npmUser": {},
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "name": "tick42-windows",
    "raw": "tick42-windows@2.2.0",
    "rawSpec": "2.2.0",
    "scope": null,
    "spec": "2.2.0",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "http://192.168.0.234:4873/tick42-windows/-/tick42-windows-2.2.0.tgz",
  "_shasum": "48fa8d468e57de21456deb133ffcfdb5787c7851",
  "_shrinkwrap": null,
  "_spec": "tick42-windows@2.2.0",
  "_where": "C:\\work\\stash\\GLUE-dev\\js-glue",
  "author": {
    "name": "Tick42"
  },
  "dependencies": {
    "util-deprecate": "^1.0.2"
  },
  "description": "A windowing API for the Tick42 HTML Container",
  "devDependencies": {
    "blanket": "^1.1.6",
    "browserify-versionify": "^1.0.4",
    "grunt": "^0.4.5",
    "grunt-browserify": "^3.3.0",
    "grunt-cli": "^0.1.13",
    "grunt-contrib-clean": "^0.6.0",
    "grunt-contrib-connect": "^0.9.0",
    "grunt-contrib-jshint": "^0.11.2",
    "grunt-contrib-qunit": "^0.5.2",
    "grunt-contrib-uglify": "^0.6.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-exorcise": "^1.0.1",
    "phantomjs": "^1.9.12",
    "qunitjs": "^1.15.0",
    "uglifyify": "^3.0.1"
  },
  "directories": {
    "test": "tests"
  },
  "dist": {
    "shasum": "48fa8d468e57de21456deb133ffcfdb5787c7851",
    "tarball": "http://192.168.0.234:4873/tick42-windows/-/tick42-windows-2.2.0.tgz"
  },
  "gitHead": "b522b338ea4b73e73d466be1b2de54dd4e125eab",
  "license": "ISC",
  "main": "library/windows.js",
  "name": "tick42-windows",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "https://bmarinov@stash.tick42.com:8443/scm/ofgw/js-windows.git"
  },
  "scripts": {
    "prepublish": "npm update & grunt",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "2.2.0"
}

},{}],78:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],79:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],80:[function(require,module,exports){
module.exports={
  "name": "tick42-glue",
  "version": "2.9.1",
  "description": "A JavaScript library which provides support for Tick42 GLUE.",
  "main": "library/glue.js",
  "bin": {
    "init-dev-mode": "bin/init-dev-mode.js",
    "remove-installed-dependencies": "bin/remove-installed-dependencies.js",
    "remove-development-dependencies": "bin/remove-development-dependencies.js",
    "build": "./bin/build.js",
    "clean": "./bin/clean.js",
    "file-versionify": "bin/file-versionify.js",
    "minify": "./bin/minify.js"
  },
  "scripts": {
    "lint": "jshint library",
    "test": "npm run lint & mocha --require ./test/test_helper \"test/**/*.js\"",
    "build": "node bin/clean.js & node bin/build.js & node bin/minify & node bin/file-versionify",
    "build:dev": "node bin/clean & node bin/build",
    "prepublish": "npm update & npm run build",
    "init:develop": "node bin/init-dev-mode",
    "clear:develop": "node bin/remove-development-dependencies",
    "watch": "onchange \"./library/*.js\" \"./node_modules/tick42-*/library/*.js\"  \"./node_modules/tick42-*/library_js/*.js\" \"../node_modules/tick42-*/library/*.js\"  \"../node_modules/tick42-*/library_js/*.js\" -iv -e \"./bin\" -- npm run build:dev",
    "watch:develop": "node bin/remove-installed-dependencies & npm run watch",
    "watch:prod": "npm install & npm run watch"
  },
  "repository": {
    "type": "git",
    "url": "https://bmarinov@stash.tick42.com:8443/scm/ofgw/js-glue.git"
  },
  "author": {
    "name": "Tick42",
    "url": "http://www.tick42.com"
  },
  "license": "ISC",
  "dependencies": {
    "cuid": "^1.3.8",
    "detect-node": "^2.0.3",
    "es5-shim": "^4.1.14",
    "tick42-activity": "^2.0.0",
    "tick42-agm": "^2.1.6",
    "tick42-app-manager": "^2.0.0",
    "tick42-appconfig": "^0.0.0",
    "tick42-gateway-connection": "^1.1.6",
    "tick42-logger": "^2.0.3",
    "tick42-metrics": "^2.0.13",
    "tick42-windows": "^2.0.2"
  },
  "devDependencies": {
    "browserify": "^13.0.0",
    "browserify-replacify": "^0.0.4",
    "browserify-versionify": "^1.0.4",
    "chai": "^3.5.0",
    "fs": "0.0.2",
    "jsdom": "^8.1.0",
    "jshint": "^2.9.1",
    "minifyify": "^7.3.2",
    "mocha": "^2.4.5",
    "onchange": "^2.1.2",
    "shelljs": "^0.6.0"
  }
}

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWJyYXJ5L2dsdWUuanMiLCJub2RlX21vZHVsZXMvYXNjaWktdGFibGUvYXNjaWktdGFibGUuanMiLCJub2RlX21vZHVsZXMvYXNjaWktdGFibGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3VpZC9kaXN0L2Jyb3dzZXItY3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9kZXRlY3Qtbm9kZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtc2hpbS9lczUtc2hhbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtc2hpbS9lczUtc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9BUEkvYWN0aXZpdHlBUEkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvQVBJL2FjdGl2aXR5TWFuYWdlbWVudEFQSS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9BUEkvYWN0aXZpdHlNeUFQSS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9hY3Rpdml0eUNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9hY3Rpdml0eU1vZHVsZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9icmlkZ2VzL2hjQnJpZGdlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2NvbnRyYWN0cy9hY3Rpdml0eVN0YXR1cy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9jb250cmFjdHMvZW50aXR5RXZlbnQuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvY29yZS9hY3Rpdml0eUFHTS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9jb3JlL2FjdGl2aXR5TWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9jb3JlL2xvY2FsV2luZG93RmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9jb3JlL3Byb3h5V2luZG93RmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9lbnRpdGllcy9hY3Rpdml0eS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9lbnRpdGllcy9hY3Rpdml0eUVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9lbnRpdGllcy9hY3Rpdml0eVR5cGUuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvZW50aXRpZXMvYWN0aXZpdHlXaW5kb3cuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvZW50aXRpZXMvd2luZG93VHlwZS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9oZWxwZXJzL2VudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2hlbHBlcnMvbG9nZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hY3Rpdml0eS9saWJyYXJ5X2pzL2hlbHBlcnMvcHJvbWlzZUV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFjdGl2aXR5L2xpYnJhcnlfanMvaGVscGVycy9yZWFkeU1hcmtlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWN0aXZpdHkvbGlicmFyeV9qcy9oZWxwZXJzL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFnbS9saWJyYXJ5L2FnbS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX2NsaWVudF9pbnZvY2F0aW9uc3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fY2xpZW50X21ldGhvZHN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fY2xpZW50X3NlcnZlcnN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fY2xpZW50X3N1YnNjcmlwdGlvbnN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21faGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL2xpYnJhcnkvYWdtX2luc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fbmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fc2VydmVyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hZ20vbGlicmFyeS9hZ21fc3RyZWFtX3B1Ymxpc2hlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYWdtL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9hcHBfbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9hcHBsaWNhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwLW1hbmFnZXIvbGlicmFyeS9ldmVudF9tYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHAtbWFuYWdlci9saWJyYXJ5L2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcC1tYW5hZ2VyL2xpYnJhcnkvaW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9zcmMvanMvYXBwY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1hcHBjb25maWcvc3JjL2pzL2dhdGV3YXkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWFwcGNvbmZpZy9zcmMvanMvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL3NyYy9qcy9tb2RlbC5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL3NyYy9qcy9wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItYXBwY29uZmlnL3NyYy9qcy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS9jb25uZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS9jb250LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb24vbGlicmFyeS9maW4uanMiLCJub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L2h0dHAuanMiLCJub2RlX21vZHVsZXMvdGljazQyLWdhdGV3YXktY29ubmVjdGlvbi9saWJyYXJ5L3dzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1sb2dnZXIvbGlicmFyeS9sb2dnZXIuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL2JyaWRnZS9tZXRyaWNTZXJpYWxpemVyLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9icmlkZ2UvdHJhbnNwb3J0LmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL2FkZHJlc3NNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3MvY291bnRNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3MvbWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL251bWJlck1ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy9vYmplY3RNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL21ldHJpY3MvcmF0ZU1ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy9zdGF0aXN0aWNzTWV0cmljLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi1tZXRyaWNzL2xpYnJhcnlfanMvY29yZS9tZXRyaWNzL3N0cmluZ01ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy90aW1lc3Bhbk1ldHJpYy5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL2NvcmUvbWV0cmljcy90aW1lc3RhbXBNZXRyaWMuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL3JlcG9zaXRvcnkuanMiLCJub2RlX21vZHVsZXMvdGljazQyLW1ldHJpY3MvbGlicmFyeV9qcy9jb3JlL3N5c3RlbS5qcyIsIm5vZGVfbW9kdWxlcy90aWNrNDItbWV0cmljcy9saWJyYXJ5X2pzL21ldHJpY3NNb2R1bGUuanMiLCJub2RlX21vZHVsZXMvdGljazQyLXdpbmRvd3MvbGlicmFyeS93aW5kb3dzLmpzIiwibm9kZV9tb2R1bGVzL3RpY2s0Mi13aW5kb3dzL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3dzL2xpYi9icm93c2VyLmpzIiwicGFja2FnZS5qc29uIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6b0JBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25qQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDamhFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDalhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uKCkge1xuXHQvL0RvIG5vdCBkbyBhbnl0aGluZyBpZiB0aGVyZSBpcyBubyBzdXBwb3J0IG9mIEVDTUFTY3JpcHQgNVxuXHRpZiAodHlwZW9mIFtdLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXF1aXJlKFwiZXM1LXNoaW1cIik7XG5cdFx0cmVxdWlyZShcImVzNS1zaGltL2VzNS1zaGFtXCIpO1xuXHR9XG5cblx0dmFyIG1ldHJpY3MgPSByZXF1aXJlKFwidGljazQyLW1ldHJpY3NcIik7XG5cdHZhciBhZ20gPSByZXF1aXJlKFwidGljazQyLWFnbVwiKTtcblx0dmFyIGdhdGV3YXlDb25uZWN0aW9uID0gcmVxdWlyZShcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25cIik7XG5cdHZhciBsb2dnZXIgPSByZXF1aXJlKFwidGljazQyLWxvZ2dlclwiKTtcblx0dmFyIGFwcGNvbmZpZyA9IHJlcXVpcmUoXCJ0aWNrNDItYXBwY29uZmlnL3NyYy9qcy9hcHBjb25maWdcIik7XG5cdHZhciB3aW5kb3dzID0gcmVxdWlyZShcInRpY2s0Mi13aW5kb3dzXCIpO1xuXHR2YXIgYXBwTWFuYWdlciA9IHJlcXVpcmUoXCJ0aWNrNDItYXBwLW1hbmFnZXJcIik7XG5cdHZhciBhY3Rpdml0eSA9IHJlcXVpcmUoXCJ0aWNrNDItYWN0aXZpdHlcIik7XG5cdHZhciBwanNvbiA9IHJlcXVpcmUoXCIuLi9wYWNrYWdlLmpzb25cIik7XG5cdHZhciBjdWlkID0gcmVxdWlyZSgnY3VpZCcpO1xuXG5cdC8vRG8gbm90IGRvIGFueXRoaW5nIGlmIHRoZSB1c2VyIHR1cm5lZCBvZmYgdGhlIGF1dG8gaW5pdGlhbGl6YXRpb25cblx0Ly9cblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5nbHVlX2F1dG9faW5pdGlhbGl6ZSA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvL0luaXQgdGhlIEdMVUUgbmFtZXNwYWNlXG5cdHZhciBnbHVlID0ge307XG5cdGdsdWUudmVyc2lvbiA9IHBqc29uLnZlcnNpb247XG5cdC8vQmFzZSBjb25maWd1cmF0aW9ucy4gTGF0ZXIgdGhleSBhcmUgdXBkYXRlZCBkZXBlbmRpbmcgb24gdGhlIHJ1bnRpbWUuXG5cdHZhciBsb2dnZXJDb25maWd1cmF0aW9uID0ge2lkZW50aXR5OiB7c3lzdGVtOiBcIlRpY2s0MlwifX07XG5cdHZhciBtZXRyaWNzQ29uZmlndXJhdGlvbiA9IHtpZGVudGl0eToge3N5c3RlbTogXCJUaWNrNDJcIn19O1xuXHR2YXIgYWdtQ29uZmlndXJhdGlvbiA9IHtpbnN0YW5jZToge30sIHNlcnZlcjoge3ByZXNlbmNlX2ludGVydmFsOiAzMDAwfX07XG5cblx0Ly9IZXJlIHdlIHdpbGwgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIGNvbm5lY3Rpb24gd2l0aCB0aGUgU2VydmljZSBQcm92aWRlclxuXHRnbHVlLmNvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XG5cdHZhciBhcHBfbmFtZTtcblxuXHQvL0lmIHdlIGFyZSBydW5uaW5nIGluIGFuIEhUTUwgQ29udGFpbmVyLCB1c2UgdGhlIEhUTUwgQ29udGFpbmVyIGVudmlyb25tZW50IHZhcmlhYmxlc1xuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmh0bWxDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vR2VuZXJhdGUgQUdNIGFwcCBuYW1lXG5cdFx0YXBwX25hbWUgPSB3aW5kb3cuYWdtX2FwcGxpY2F0aW9uIHx8IHdpbmRvdy5odG1sQ29udGFpbmVyLmNvbnRhaW5lck5hbWUgKyBcIi5cIiArIHdpbmRvdy5odG1sQ29udGFpbmVyLmJyb3dzZXJXaW5kb3dOYW1lO1xuXG5cdFx0Ly9GaWxsIGxvZ2dlciBjb25maWd1cmF0aW9ucyB3aXRoIGN1c3RvbSBwcm9wZXJ0aWVzXG5cdFx0YWdtQ29uZmlndXJhdGlvbi5pbnN0YW5jZS5hcHBsaWNhdGlvbiA9IGFwcF9uYW1lO1xuXHRcdGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHkuc3lzdGVtID0gXCJIdG1sQ29udGFpbmVyLlwiICsgd2luZG93Lmh0bWxDb250YWluZXIuY29udGFpbmVyTmFtZTtcblx0XHRsb2dnZXJDb25maWd1cmF0aW9uLmlkZW50aXR5LnNlcnZpY2UgPSBcIkpTLlwiICsgd2luZG93Lmh0bWxDb250YWluZXIuYnJvd3NlcldpbmRvd05hbWU7XG5cdFx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5pbnN0YW5jZSA9IFwiflwiICsgd2luZG93Lmh0bWxDb250YWluZXIubWFjaGluZU5hbWU7XG5cblx0XHRpZiAod2luZG93Lmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlICE9PSB1bmRlZmluZWQgJiYgd2luZG93Lmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlLmNvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyBJbml0aWFsaXplIEFwcENvbmZpZ1xuXHRcdFx0Z2x1ZS5hcHBjb25maWcgPSBhcHBjb25maWcoKTtcblx0XHRcdGdsdWUuYXBwY29uZmlnLmluaXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRmdW5jdGlvbiBzdXBwbGFudCh0ZW1wbGF0ZSkge1xuXHRcdFx0XHRcdHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHsoW157fV0qKVxcfS9nLCBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcztcblx0XHRcdFx0XHRcdGtleS5zcGxpdCgnLicpLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBtYXRjaDtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBzZXR0aW5ncyA9IHdpbmRvdy5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZS5jb25maWc7XG5cdFx0XHRcdHZhciBpZGVudGl0eSA9IHt9O1xuXHRcdFx0XHRPYmplY3Qua2V5cyhzZXR0aW5ncy5pZGVudGl0eSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gc3VwcGxhbnQoc2V0dGluZ3MuaWRlbnRpdHlba2V5XSk7XG5cdFx0XHRcdFx0aWRlbnRpdHlba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2V0dGluZ3MuaWRlbnRpdHkgPSBpZGVudGl0eTtcblx0XHRcdFx0cmV0dXJuIHNldHRpbmdzO1xuXHRcdFx0fSgpKTtcblx0XHR9XG5cblx0XHQvL0luaXQgdGhlIENvbm5lY3Rpb25cblx0XHRnbHVlLmNvbm5lY3Rpb24gPSBnYXRld2F5Q29ubmVjdGlvbigpO1xuXG5cdFx0Ly9JZiB3ZSBhcmUgcnVubmluZyBpbiBub3JtYWwgYnJvd3NlciwgY29ubmVjdCB2aWEgV2Vic29ja2V0XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNvbm5lY3Rpb25fY29uZmlnID0ge307XG5cdFx0dmFyIHVpZF9wcmVmaXg7XG5cdFx0aWYgKHJlcXVpcmUoXCJkZXRlY3Qtbm9kZVwiKSB8fCAoJ1dlYlNvY2tldCcgaW4gd2luZG93ICYmIHdpbmRvdy5XZWJTb2NrZXQuQ0xPU0lORyA9PT0gMikpIHtcblx0XHRcdHVpZF9wcmVmaXggPSBcIldTXCI7XG5cdFx0XHQvL1dlYnNvY2tldCBVUkwgKHRoaXMgaXMgdGhlIGRlZmF1bHQgdGhhdCBpcyB1c2VkIGluIHRoZSBkZW1vIFdTIHNlcnZlcikgRGVmYXVsdHMgdG8gaW5zZWN1cmUuXG5cdFx0XHR2YXIgZGVmYXVsdF93c191cmwgPSAnd3M6Ly9sb2NhbGhvc3Q6MjIwMzcnO1xuXHRcdFx0aWYgKHdpbmRvdyAmJiB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHMnKSB7XG5cdFx0XHRcdGRlZmF1bHRfd3NfdXJsID0gJ3dzczovL2xvY2FsaG9zdDoyMjAzNydcblx0XHRcdH1cblx0XHRcdGNvbm5lY3Rpb25fY29uZmlnLndlYnNvY2tldF91cmwgPSB3aW5kb3cgJiYgd2luZG93LmdsdWVfd3NfdXJsIHx8IGRlZmF1bHRfd3NfdXJsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpZiBubyBzdXBwb3J0IGZvciBXZWJTb2NrZXQgdXNlIEhUVFBcblx0XHRcdHVpZF9wcmVmaXggPSBcIkhUVFBcIjtcblx0XHRcdC8vIGRvbid0IG1ha2UgaW5zZWN1cmUgcmVxdWVzdHMgZnJvbSBzZWN1cmUgZW52XG5cdFx0XHR2YXIgZGVmYXVsdF9odHRwX3VybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHA6JyA/IFwiaHR0cDovL2xvY2FsaG9zdDoyMjAzN1wiIDogXCJodHRwczovL2xvY2FsaG9zdDoyMjAzN1wiO1xuXHRcdFx0Y29ubmVjdGlvbl9jb25maWcuaHR0cF91cmwgPSB3aW5kb3cuZ2x1ZV9odHRwX3VybCB8fCBkZWZhdWx0X2h0dHBfdXJsO1xuXHRcdH1cblxuXHRcdC8vR2VuZXJhdGUgYXBwbGljYXRpb24gVUlEIHRvIGFsbG93IGZvciB0aGUgc2FtZSBhcHBsaWNhdGlvbiB0byBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG5cdFx0dmFyIHVpZCA9IHVpZF9wcmVmaXggKyBjdWlkKCk7XG5cblx0XHQvL0dlbmVyYXRlIEFHTSBhcHAgbmFtZVxuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LnRpdGxlKSB7XG5cdFx0XHRhcHBfbmFtZSA9ICBkb2N1bWVudC50aXRsZSArIHVpZFxuXHRcdH0gZWxzZSBpZiAod2luZG93ICYmIHdpbmRvdy5hZ21fYXBwbGljYXRpb24pIHtcblx0XHRcdGFwcF9uYW1lID0gd2luZG93LmFnbV9hcHBsaWNhdGlvbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXBwX25hbWUgPSB1aWQ7XG5cdFx0fVxuXG5cdFx0Ly9GaWxsIGNvbmZpZ3VyYXRpb25zIHdpdGggY3VzdG9tIHByb3BlcnRpZXNcblx0XHRhZ21Db25maWd1cmF0aW9uLmluc3RhbmNlLmFwcGxpY2F0aW9uID0gYXBwX25hbWU7XG5cdFx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zeXN0ZW0gPSBcIkJyb3dzZXJcIjtcblx0XHRsb2dnZXJDb25maWd1cmF0aW9uLmlkZW50aXR5LnNlcnZpY2UgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQudGl0bGUgfHwgJ3Vua25vd24nIDogJ3Vua25vd24nO1xuXHRcdGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHkuaW5zdGFuY2UgPSBcIn5cIiArIHVpZDtcblxuXHRcdC8vIEluaXQgdGhlIENvbm5lY3Rpb24gYW5kIHNwZWNpZnkgdGhlIFVSTCBvZiB0aGUgV2ViIFNvY2tldCBzZXJ2ZXIgdGhhdCB3ZSBhcmUgY29ubmVjdGluZyB0by5cblx0XHRnbHVlLmNvbm5lY3Rpb24gPSBnYXRld2F5Q29ubmVjdGlvbihjb25uZWN0aW9uX2NvbmZpZyk7XG5cdH1cblxuXHQvL1BsYWNlIHRoZSBDb25uZWN0aW9uLCBhcyBwYXJ0IG9mIHRoZSBjb21wb25lbnRzJyBjb25maWd1cmF0aW9uXG5cdGxvZ2dlckNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiA9IGdsdWUuY29ubmVjdGlvbjtcblx0bWV0cmljc0NvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiA9IGdsdWUuY29ubmVjdGlvbjtcblx0YWdtQ29uZmlndXJhdGlvbi5jb25uZWN0aW9uID0gZ2x1ZS5jb25uZWN0aW9uO1xuXG5cdC8vT3ZlcnJpZGUgc29tZSBwcm9wcyB3aXRoIGVudmlyb25tZW50IHZhcmlhYmxlcywgaWYgcHJvdmlkZWRcblx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zeXN0ZW0gPSB3aW5kb3cgJiYgd2luZG93LmdsdWVfbWV0cmljX3N5c3RlbSB8fCBsb2dnZXJDb25maWd1cmF0aW9uLmlkZW50aXR5LnN5c3RlbTtcblx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5zZXJ2aWNlID0gd2luZG93ICYmIHdpbmRvdy5nbHVlX21ldHJpY19zZXJ2aWNlIHx8IGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHkuc2VydmljZTtcblx0bG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5pbnN0YW5jZSA9IHdpbmRvdyAmJiB3aW5kb3cuZ2x1ZV9tZXRyaWNfaW5zdGFuY2UgfHwgbG9nZ2VyQ29uZmlndXJhdGlvbi5pZGVudGl0eS5pbnN0YW5jZTtcblxuXHQvL0luaXRpYWxpemUgTG9nZ2VyICh1c2VzIHRoZSBzYW1lIGNvbmZpZ3VyYXRpb24gYXMgTWV0cmljcylcblx0Z2x1ZS5sb2dnZXIgPSBsb2dnZXIobG9nZ2VyQ29uZmlndXJhdGlvbik7XG5cblx0Ly9GaWxsIG1ldHJpY3MgY29uZmlndXJhdGlvbiB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgbWV0cmljcyBjb25maWd1cmF0aW9uc1xuXHRtZXRyaWNzQ29uZmlndXJhdGlvbi5pZGVudGl0eSA9IGxvZ2dlckNvbmZpZ3VyYXRpb24uaWRlbnRpdHk7XG5cdG1ldHJpY3NDb25maWd1cmF0aW9uLmxvZ2dlciA9IGdsdWUubG9nZ2VyLnN1YkxvZ2dlcihcIm1ldHJpY3NcIik7XG5cblx0Ly9Jbml0aWFsaXplIE1ldHJpY3MgYW5kIHNhdmUgaW50byB0aGUgJ2dsdWUnIGdsb2JhbCB2YXJpYWJsZVxuXHR2YXIgcm9vdE1ldHJpY3MgPSBtZXRyaWNzKG1ldHJpY3NDb25maWd1cmF0aW9uKTtcblx0Z2x1ZS5tZXRyaWNzID0gcm9vdE1ldHJpY3Muc3ViU3lzdGVtKFwiQXBwXCIpO1xuXG5cdC8vSW5pdGlhbGl6ZSB0aGUgbWV0cmljcyBzeXN0ZW0gaW4gdGhlIGxvZ2dlcidzIFwibWV0cmljc19sZXZlbFwiIG1ldGhvZFxuXHRnbHVlLmxvZ2dlci5tZXRyaWNzTGV2ZWwoXCJ3YXJuXCIsIGdsdWUubWV0cmljcy5wYXJlbnQuc3ViU3lzdGVtKFwiTG9nRXZlbnRzXCIpKTtcblxuXHRhZ21Db25maWd1cmF0aW9uLmluc3RhbmNlLmFwcGxpY2F0aW9uID0gd2luZG93ICYmIHdpbmRvdy5nbHVlX2FnbV9hcHBsaWNhdGlvbiB8fCBhZ21Db25maWd1cmF0aW9uLmluc3RhbmNlLmFwcGxpY2F0aW9uO1xuXG5cdC8vSW5jbHVkZSB0aGUgbWV0cmljIHJlcG8gaW4gdGhlIEFHTSBjb25maWd1cmF0aW9uIChzbyB0aGF0IEFHTSBjYW4gYnJvYWRjYXN0IG1ldHJpY3MpXG5cdGFnbUNvbmZpZ3VyYXRpb24ubWV0cmljcyA9IHJvb3RNZXRyaWNzLnN1YlN5c3RlbShcIkFHTVwiKTtcblxuXHQvL0luaXRpYWxpemUgQUdNIHNhdmUgaW50byB0aGUgJ2dsdWUnIGdsb2JhbCB2YXJpYWJsZVxuXHRnbHVlLmFnbSA9IGFnbShhZ21Db25maWd1cmF0aW9uKTtcblxuXHQvLyBBZGQgYWN0aXZpdHkgaW4gdGhlIGNvbnRhaW5lciBvbmx5XG5cdHZhciBhY3Rpdml0aWVzRmFjYWRlID0gd2luZG93ICYmIHdpbmRvdy5odG1sQ29udGFpbmVyID8gd2luZG93Lmh0bWxDb250YWluZXIuYWN0aXZpdHlGYWNhZGUgOiB1bmRlZmluZWQ7XG5cdGlmICh0eXBlb2YgYWN0aXZpdGllc0ZhY2FkZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdHZhciBhY3Rpdml0eUxvZ2dlciA9IGdsdWUubG9nZ2VyLnN1YkxvZ2dlcihcImFjdGl2aXR5XCIpO1xuXHRcdGFjdGl2aXR5TG9nZ2VyLnB1Ymxpc2hMZXZlbChcImRlYnVnXCIpO1xuXHRcdGFjdGl2aXR5TG9nZ2VyLmNvbnNvbGVMZXZlbChcImluZm9cIik7XG5cdFx0YWN0aXZpdHlMb2dnZXIubWV0cmljc0xldmVsKFwib2ZmXCIpO1xuXHRcdGdsdWUuYWN0aXZpdGllcyA9IGFjdGl2aXR5KHthZ206IGdsdWUuYWdtLCBsb2dnZXI6IGFjdGl2aXR5TG9nZ2VyfSk7XG5cdH1cblxuXHRnbHVlLndpbmRvd3MgPSB3aW5kb3dzKGdsdWUuYWdtKTtcblxuXHQvLyBjYW1lbCBjYXNlIGZvciBBcHAgTWFuYWdlclxuXHRnbHVlLmFwcE1hbmFnZXIgPSBhcHBNYW5hZ2VyKGdsdWUuYWdtLCBnbHVlLndpbmRvd3MpO1xuXG5cdGdsdWUuaW5mbyA9IHtcblx0XHRnbHVlVmVyc2lvbjogcGpzb24udmVyc2lvbixcblx0XHRhY3Rpdml0aWVzOiBnbHVlLmFjdGl2aXRpZXMgPyBnbHVlLmFjdGl2aXRpZXMudmVyc2lvbiA6ICd1bmtub3duJyxcblx0XHRtZXRyaWNzOiBnbHVlLm1ldHJpY3MucmVwby52ZXJzaW9uLFxuXHRcdGFnbTogZ2x1ZS5hZ20udmVyc2lvbixcblx0XHR3aW5kb3dzOiBnbHVlLndpbmRvd3MudmVyc2lvbixcblx0XHRsb2dnZXI6IGdsdWUubG9nZ2VyLnZlcnNpb24sXG5cdFx0YXBwTWFuYWdlcjogZ2x1ZS5hcHBNYW5hZ2VyLnZlcnNpb24sXG5cdFx0Y29ubmVjdGlvbjogZ2x1ZS5jb25uZWN0aW9uLnZlcnNpb25cblx0fTtcblxuXHQvLyBubyBjb25mbGljdCBmdW5jdGlvblxuXHR2YXIgb3JpZ2luYWxHbHVlID0gd2luZG93ICYmIHdpbmRvdy5nbHVlO1xuXHRnbHVlLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcblx0XHR3aW5kb3cuZ2x1ZSA9IG9yaWdpbmFsR2x1ZTtcblx0XHRyZXR1cm4gZ2x1ZTtcblx0fTtcblxuXHQvLyBmZWVkYmFjayBvcHRpb25cblx0Z2x1ZS5mZWVkYmFjayA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghZ2x1ZS5hZ20pe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGdsdWUuYWdtLmludm9rZShcIlQ0Mi5BQ1MuRmVlZGJhY2tcIiwge30sIFwiYmVzdFwiKTtcblx0fTtcblxuXHQvL0V4cG9ydCBHTFVFXG5cdGlmICh3aW5kb3cpIHtcblx0XHR3aW5kb3cuZ2x1ZSA9IGdsdWU7XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBnbHVlO1xufSgpKTtcbiIsIi8qKlxuICogKGMpIDIwMTMgQmVhdSBTb3JlbnNlblxuICogTUlUIExpY2Vuc2VkXG4gKiBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vc29yZW5zZW4vYXNjaWktdGFibGVcbiAqL1xuXG47KGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgLCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuLyoqXG4gKiBBc2NpaVRhYmxlIGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB0aXRsZSBvciBKU09OIHRhYmxlXG4gKiBAcGFyYW0ge09iamVjdH0gdGFibGUgb3B0aW9uc1xuICogIC0gYHByZWZpeGAgLSBzdHJpbmcgcHJlZml4IGFkZGVkIHRvIGVhY2ggbGluZSBvbiByZW5kZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBBc2NpaVRhYmxlKG5hbWUsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB0aGlzLnJlc2V0KG5hbWUpXG59XG5cbi8qIVxuICogQ3VycmVudCBsaWJyYXJ5IHZlcnNpb24sIHNob3VsZCBtYXRjaCBgcGFja2FnZS5qc29uYFxuICovXG5cbkFzY2lpVGFibGUuVkVSU0lPTiA9ICcwLjAuOCdcblxuLyohXG4gKiBBbGlnbm1lbnQgY29uc3RhbnRzXG4gKi9cblxuQXNjaWlUYWJsZS5MRUZUID0gMFxuQXNjaWlUYWJsZS5DRU5URVIgPSAxXG5Bc2NpaVRhYmxlLlJJR0hUID0gMlxuXG4vKiFcbiAqIFN0YXRpYyBtZXRob2RzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdGFibGUgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHRpdGxlIG9yIEpTT04gdGFibGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YWJsZSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUuZmFjdG9yeSA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBBc2NpaVRhYmxlKG5hbWUsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogQWxpZ24gdGhlIGEgc3RyaW5nIGF0IHRoZSBnaXZlbiBsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGlucHV0XG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaW5nIGxlbmd0aFxuICogQHBhcmFtIHtOdW1iZXJ9IHBhZGRpbmcgY2hhcmFjdGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUuYWxpZ24gPSBmdW5jdGlvbihkaXIsIHN0ciwgbGVuLCBwYWQpIHtcbiAgaWYgKGRpciA9PT0gQXNjaWlUYWJsZS5MRUZUKSByZXR1cm4gQXNjaWlUYWJsZS5hbGlnbkxlZnQoc3RyLCBsZW4sIHBhZClcbiAgaWYgKGRpciA9PT0gQXNjaWlUYWJsZS5SSUdIVCkgcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25SaWdodChzdHIsIGxlbiwgcGFkKVxuICBpZiAoZGlyID09PSBBc2NpaVRhYmxlLkNFTlRFUikgcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25DZW50ZXIoc3RyLCBsZW4sIHBhZClcbiAgcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25BdXRvKHN0ciwgbGVuLCBwYWQpXG59XG5cbi8qKlxuICogTGVmdCBhbGlnbiBhIHN0cmluZyBieSBwYWRkaW5nIGl0IGF0IGEgZ2l2ZW4gbGVuZ3RoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmluZyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWRkaW5nIGNoYXJhY3RlciAob3B0aW9uYWwsIGRlZmF1bHQgJycpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUuYWxpZ25MZWZ0ID0gZnVuY3Rpb24oc3RyLCBsZW4sIHBhZCkge1xuICBpZiAoIWxlbiB8fCBsZW4gPCAwKSByZXR1cm4gJydcbiAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkIHx8IHN0ciA9PT0gbnVsbCkgc3RyID0gJydcbiAgaWYgKHR5cGVvZiBwYWQgPT09ICd1bmRlZmluZWQnKSBwYWQgPSAnICdcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICB2YXIgYWxlbiA9IGxlbiArIDEgLSBzdHIubGVuZ3RoXG4gIGlmIChhbGVuIDw9IDApIHJldHVybiBzdHJcbiAgcmV0dXJuIHN0ciArIEFycmF5KGxlbiArIDEgLSBzdHIubGVuZ3RoKS5qb2luKHBhZClcbn1cblxuLyoqXG4gKiBDZW50ZXIgYWxpZ24gYSBzdHJpbmcgYnkgcGFkZGluZyBpdCBhdCBhIGdpdmVuIGxlbmd0aFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpbmcgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFkZGluZyBjaGFyYWN0ZXIgKG9wdGlvbmFsLCBkZWZhdWx0ICcnKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLmFsaWduQ2VudGVyID0gZnVuY3Rpb24oc3RyLCBsZW4sIHBhZCkge1xuICBpZiAoIWxlbiB8fCBsZW4gPCAwKSByZXR1cm4gJydcbiAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkIHx8IHN0ciA9PT0gbnVsbCkgc3RyID0gJydcbiAgaWYgKHR5cGVvZiBwYWQgPT09ICd1bmRlZmluZWQnKSBwYWQgPSAnICdcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICB2YXIgbkxlbiA9IHN0ci5sZW5ndGhcbiAgICAsIGhhbGYgPSBNYXRoLmZsb29yKGxlbiAvIDIgLSBuTGVuIC8gMilcbiAgICAsIG9kZHMgPSBNYXRoLmFicygobkxlbiAlIDIpIC0gKGxlbiAlIDIpKVxuICAgICwgbGVuID0gc3RyLmxlbmd0aFxuXG4gIHJldHVybiBBc2NpaVRhYmxlLmFsaWduUmlnaHQoJycsIGhhbGYsIHBhZCkgXG4gICAgKyBzdHJcbiAgICArIEFzY2lpVGFibGUuYWxpZ25MZWZ0KCcnLCBoYWxmICsgb2RkcywgcGFkKVxufVxuXG4vKipcbiAqIFJpZ2h0IGFsaWduIGEgc3RyaW5nIGJ5IHBhZGRpbmcgaXQgYXQgYSBnaXZlbiBsZW5ndGhcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaW5nIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHBhZGRpbmcgY2hhcmFjdGVyIChvcHRpb25hbCwgZGVmYXVsdCAnJylcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5hbGlnblJpZ2h0ID0gZnVuY3Rpb24oc3RyLCBsZW4sIHBhZCkge1xuICBpZiAoIWxlbiB8fCBsZW4gPCAwKSByZXR1cm4gJydcbiAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkIHx8IHN0ciA9PT0gbnVsbCkgc3RyID0gJydcbiAgaWYgKHR5cGVvZiBwYWQgPT09ICd1bmRlZmluZWQnKSBwYWQgPSAnICdcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICB2YXIgYWxlbiA9IGxlbiArIDEgLSBzdHIubGVuZ3RoXG4gIGlmIChhbGVuIDw9IDApIHJldHVybiBzdHJcbiAgcmV0dXJuIEFycmF5KGxlbiArIDEgLSBzdHIubGVuZ3RoKS5qb2luKHBhZCkgKyBzdHJcbn1cblxuLyoqXG4gKiBBdXRvIGFsaWduIHN0cmluZyB2YWx1ZSBiYXNlZCBvbiBvYmplY3QgdHlwZVxuICpcbiAqIEBwYXJhbSB7QW55fSBvYmplY3QgdG8gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaW5nIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHBhZGRpbmcgY2hhcmFjdGVyIChvcHRpb25hbCwgZGVmYXVsdCAnJylcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5hbGlnbkF1dG8gPSBmdW5jdGlvbihzdHIsIGxlbiwgcGFkKSB7XG4gIGlmIChzdHIgPT09IHVuZGVmaW5lZCB8fCBzdHIgPT09IG51bGwpIHN0ciA9ICcnXG4gIHZhciB0eXBlID0gdG9TdHJpbmcuY2FsbChzdHIpXG4gIHBhZCB8fCAocGFkID0gJyAnKVxuICBsZW4gPSArbGVuXG4gIGlmICh0eXBlICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHN0ciA9IHN0ci50b1N0cmluZygpXG4gIH1cbiAgaWYgKHN0ci5sZW5ndGggPCBsZW4pIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzogcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25SaWdodChzdHIsIGxlbiwgcGFkKVxuICAgICAgZGVmYXVsdDogcmV0dXJuIEFzY2lpVGFibGUuYWxpZ25MZWZ0KHN0ciwgbGVuLCBwYWQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJcbn1cblxuLyoqXG4gKiBGaWxsIGFuIGFycmF5IGF0IGEgZ2l2ZW4gc2l6ZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhcnJheSBzaXplXG4gKiBAcGFyYW0ge0FueX0gZmlsbCB2YWx1ZVxuICogQHJldHVybiB7QXJyYXl9IGZpbGxlZCBhcnJheVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLmFycmF5RmlsbCA9IGZ1bmN0aW9uKGxlbiwgZmlsbCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGxlbjsgaSsrKSB7XG4gICAgYXJyW2ldID0gZmlsbDtcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbi8qIVxuICogSW5zdGFuY2UgbWV0aG9kc1xuICovXG5cbi8qKlxuICogUmVzZXQgdGhlIHRhYmxlIHN0YXRlIGJhY2sgdG8gZGVmYXVsdHNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHRpdGxlIG9yIEpTT04gdGFibGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUucmVzZXQgPSBcbkFzY2lpVGFibGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24obmFtZSkge1xuICB0aGlzLl9fbmFtZSA9ICcnXG4gIHRoaXMuX19uYW1lQWxpZ24gPSBBc2NpaVRhYmxlLkNFTlRFUlxuICB0aGlzLl9fcm93cyA9IFtdXG4gIHRoaXMuX19tYXhDZWxscyA9IDBcbiAgdGhpcy5fX2FsaWducyA9IFtdXG4gIHRoaXMuX19jb2xNYXhlcyA9IFtdXG4gIHRoaXMuX19zcGFjaW5nID0gMVxuICB0aGlzLl9faGVhZGluZyA9IG51bGxcbiAgdGhpcy5fX2hlYWRpbmdBbGlnbiA9IEFzY2lpVGFibGUuQ0VOVEVSXG4gIHRoaXMuc2V0Qm9yZGVyKClcblxuICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICB0aGlzLl9fbmFtZSA9IG5hbWVcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHRoaXMuZnJvbUpTT04obmFtZSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFNldCB0aGUgdGFibGUgYm9yZGVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhvcml6b250YWwgZWRnZXMgKG9wdGlvbmFsLCBkZWZhdWx0IGB8YClcbiAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJ0aWNhbCBlZGdlcyAob3B0aW9uYWwsIGRlZmF1bHQgYC1gKVxuICogQHBhcmFtIHtTdHJpbmd9IHRvcCBjb3JuZXJzIChvcHRpb25hbCwgZGVmYXVsdCBgLmApXG4gKiBAcGFyYW0ge1N0cmluZ30gYm90dG9tIGNvcm5lcnMgKG9wdGlvbmFsLCBkZWZhdWx0IGAnYClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc2V0Qm9yZGVyID0gZnVuY3Rpb24oZWRnZSwgZmlsbCwgdG9wLCBib3R0b20pIHtcbiAgdGhpcy5fX2JvcmRlciA9IHRydWVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBmaWxsID0gdG9wID0gYm90dG9tID0gZWRnZVxuICB9XG4gIHRoaXMuX19lZGdlID0gZWRnZSB8fCAnfCdcbiAgdGhpcy5fX2ZpbGwgPSBmaWxsIHx8ICctJ1xuICB0aGlzLl9fdG9wID0gdG9wIHx8ICcuJ1xuICB0aGlzLl9fYm90dG9tID0gYm90dG9tIHx8IFwiJ1wiXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0YWJsZSBib3JkZXJzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5yZW1vdmVCb3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX2JvcmRlciA9IGZhbHNlXG4gIHRoaXMuX19lZGdlID0gJyAnXG4gIHRoaXMuX19maWxsID0gJyAnXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogU2V0IHRoZSBjb2x1bW4gYWxpZ25tZW50IGF0IGEgZ2l2ZW4gaW5kZXhcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29sdW1uIGluZGV4XG4gKiBAcGFyYW0ge051bWJlcn0gYWxpZ25tZW50IGRpcmVjdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zZXRBbGlnbiA9IGZ1bmN0aW9uKGlkeCwgZGlyKSB7XG4gIHRoaXMuX19hbGlnbnNbaWR4XSA9IGRpclxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIFNldCB0aGUgdGl0bGUgb2YgdGhlIHRhYmxlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24obmFtZSkge1xuICB0aGlzLl9fbmFtZSA9IG5hbWVcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRpdGxlIG9mIHRoZSB0YWJsZVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gdGl0bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19uYW1lXG59XG5cbi8qKlxuICogU2V0IHRhYmxlIHRpdGxlIGFsaWdubWVudFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc2V0VGl0bGVBbGlnbiA9IGZ1bmN0aW9uKGRpcikge1xuICB0aGlzLl9fbmFtZUFsaWduID0gZGlyXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQXNjaWlUYWJsZSBzb3J0aW5nIHNob3J0Y3V0IHRvIHNvcnQgcm93c1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRpbmcgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgdGhpcy5fX3Jvd3Muc29ydChtZXRob2QpXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogU29ydCByb3dzIGJhc2VkIG9uIHNvcnQgbWV0aG9kIGZvciBnaXZlbiBjb2x1bW5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29sdW1uIGluZGV4XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0aW5nIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zb3J0Q29sdW1uID0gZnVuY3Rpb24oaWR4LCBtZXRob2QpIHtcbiAgdGhpcy5fX3Jvd3Muc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIG1ldGhvZChhW2lkeF0sIGJbaWR4XSlcbiAgfSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBTZXQgdGFibGUgaGVhZGluZyBmb3IgY29sdW1uc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuc2V0SGVhZGluZyA9IGZ1bmN0aW9uKHJvdykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgfHwgdG9TdHJpbmcuY2FsbChyb3cpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcm93ID0gc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIH1cbiAgdGhpcy5fX2hlYWRpbmcgPSByb3dcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBHZXQgdGFibGUgaGVhZGluZyBmb3IgY29sdW1uc1xuICpcbiAqIEByZXR1cm4ge0FycmF5fSBjb3B5IG9mIGhlYWRpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLmdldEhlYWRpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19oZWFkaW5nLnNsaWNlKClcbn1cblxuLyoqXG4gKiBTZXQgaGVhZGluZyBhbGlnbm1lbnRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLnNldEhlYWRpbmdBbGlnbiA9IGZ1bmN0aW9uKGRpcikge1xuICB0aGlzLl9faGVhZGluZ0FsaWduID0gZGlyXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQWRkIGEgcm93IG9mIGluZm9ybWF0aW9uIHRvIHRoZSB0YWJsZVxuICogXG4gKiBAcGFyYW0gey4uLnxBcnJheX0gYXJndW1lbnQgdmFsdWVzIGluIG9yZGVyIG9mIGNvbHVtbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuYWRkUm93ID0gZnVuY3Rpb24ocm93KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSB8fCB0b1N0cmluZy5jYWxsKHJvdykgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByb3cgPSBzbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgfVxuICB0aGlzLl9fbWF4Q2VsbHMgPSBNYXRoLm1heCh0aGlzLl9fbWF4Q2VsbHMsIHJvdy5sZW5ndGgpXG4gIHRoaXMuX19yb3dzLnB1c2gocm93KVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEdldCBhIGNvcHkgb2YgYWxsIHJvd3Mgb2YgdGhlIHRhYmxlXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGNvcHkgb2Ygcm93c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5nZXRSb3dzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcm93cy5zbGljZSgpLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICByZXR1cm4gcm93LnNsaWNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBBZGQgcm93cyBpbiB0aGUgZm9ybWF0IG9mIGEgcm93IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHJvdyBtYXRyaXhcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuYWRkUm93TWF0cml4ID0gZnVuY3Rpb24ocm93cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmFkZFJvdyhyb3dzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQWRkIHJvd3MgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhcnJheSwgcHJvY2Vzc2VkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbiByb3dDYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gKiBAcGFyYW0gKEZ1bmN0aW9uKSByb3dDYWxsYmFja1xuICogQHBhcmFtIChCb29sZWFuKSBhc01hdHJpeCAtIGNvbnRyb2xzIGlmIHRoZSByb3cgY3JlYXRlZCBieSByb3dDYWxsYmFjayBzaG91bGQgYmUgYXNzaWduZWQgYXMgcm93IG1hdHJpeFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5hZGREYXRhID0gZnVuY3Rpb24oZGF0YSwgcm93Q2FsbGJhY2ssIGFzTWF0cml4KSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZm9yICh2YXIgaW5kZXggPSAwLCBsaW1pdCA9IGRhdGEubGVuZ3RoOyBpbmRleCA8IGxpbWl0OyBpbmRleCsrKSB7XG4gICAgdmFyIHJvdyA9IHJvd0NhbGxiYWNrKGRhdGFbaW5kZXhdKTtcbiAgICBpZihhc01hdHJpeCkge1xuICAgICAgdGhpcy5hZGRSb3dNYXRyaXgocm93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRSb3cocm93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuICAvKipcbiAqIFJlc2V0IHRoZSBjdXJyZW50IHJvdyBzdGF0ZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuY2xlYXJSb3dzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19yb3dzID0gW11cbiAgdGhpcy5fX21heENlbGxzID0gMFxuICB0aGlzLl9fY29sTWF4ZXMgPSBbXVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEFwcGx5IGFuIGV2ZW4gc3BhY2VkIGNvbHVtbiBqdXN0aWZpY2F0aW9uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBvbiAvIG9mZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5zZXRKdXN0aWZ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgJiYgKHZhbCA9IHRydWUpXG4gIHRoaXMuX19qdXN0aWZ5ID0gISF2YWxcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBjdXJyZW50IGluc3RhbmNlIHRvIGEgSlNPTiBzdHJ1Y3R1cmVcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGpzb24gcmVwcmVzZW50YXRpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdGl0bGU6IHRoaXMuZ2V0VGl0bGUoKVxuICAsIGhlYWRpbmc6IHRoaXMuZ2V0SGVhZGluZygpXG4gICwgcm93czogdGhpcy5nZXRSb3dzKClcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIHRoZSB0YWJsZSBmcm9tIGEgSlNPTiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbiByZXByZXNlbnRhdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5wYXJzZSA9IFxuQXNjaWlUYWJsZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRoaXNcbiAgICAuY2xlYXIoKVxuICAgIC5zZXRUaXRsZShvYmoudGl0bGUpXG4gICAgLnNldEhlYWRpbmcob2JqLmhlYWRpbmcpXG4gICAgLmFkZFJvd01hdHJpeChvYmoucm93cylcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIHRhYmxlIHdpdGggdGhlIGN1cnJlbnQgaW5mb3JtYXRpb25cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCB0YWJsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5yZW5kZXIgPVxuQXNjaWlUYWJsZS5wcm90b3R5cGUudmFsdWVPZiA9XG5Bc2NpaVRhYmxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGJvZHkgPSBbXVxuICAgICwgbUxlbiA9IHRoaXMuX19tYXhDZWxsc1xuICAgICwgbWF4ID0gQXNjaWlUYWJsZS5hcnJheUZpbGwobUxlbiwgMClcbiAgICAsIHRvdGFsID0gbUxlbiAqIDNcbiAgICAsIHJvd3MgPSB0aGlzLl9fcm93c1xuICAgICwganVzdGlmeVxuICAgICwgYm9yZGVyID0gdGhpcy5fX2JvcmRlclxuICAgICwgYWxsID0gdGhpcy5fX2hlYWRpbmcgXG4gICAgICAgID8gW3RoaXMuX19oZWFkaW5nXS5jb25jYXQocm93cylcbiAgICAgICAgOiByb3dzXG5cbiAgLy8gQ2FsY3VsYXRlIG1heCB0YWJsZSBjZWxsIGxlbmd0aHMgYWNyb3NzIGFsbCByb3dzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJvdyA9IGFsbFtpXVxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbUxlbjsgaysrKSB7XG4gICAgICB2YXIgY2VsbCA9IHJvd1trXVxuICAgICAgbWF4W2tdID0gTWF0aC5tYXgobWF4W2tdLCBjZWxsID8gY2VsbC50b1N0cmluZygpLmxlbmd0aCA6IDApXG4gICAgfVxuICB9XG4gIHRoaXMuX19jb2xNYXhlcyA9IG1heFxuICBqdXN0aWZ5ID0gdGhpcy5fX2p1c3RpZnkgPyBNYXRoLm1heC5hcHBseShudWxsLCBtYXgpIDogMFxuXG4gIC8vIEdldCBcbiAgbWF4LmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIHRvdGFsICs9IGp1c3RpZnkgPyBqdXN0aWZ5IDogeCArIHNlbGYuX19zcGFjaW5nXG4gIH0pXG4gIGp1c3RpZnkgJiYgKHRvdGFsICs9IG1heC5sZW5ndGgpXG4gIHRvdGFsIC09IHRoaXMuX19zcGFjaW5nXG5cbiAgLy8gSGVhZGluZ1xuICBib3JkZXIgJiYgYm9keS5wdXNoKHRoaXMuX3NlcGVyYXRvcih0b3RhbCAtIG1MZW4gKyAxLCB0aGlzLl9fdG9wKSlcbiAgaWYgKHRoaXMuX19uYW1lKSB7XG4gICAgYm9keS5wdXNoKHRoaXMuX3JlbmRlclRpdGxlKHRvdGFsIC0gbUxlbiArIDEpKVxuICAgIGJvcmRlciAmJiBib2R5LnB1c2godGhpcy5fc2VwZXJhdG9yKHRvdGFsIC0gbUxlbiArIDEpKVxuICB9XG4gIGlmICh0aGlzLl9faGVhZGluZykge1xuICAgIGJvZHkucHVzaCh0aGlzLl9yZW5kZXJSb3codGhpcy5fX2hlYWRpbmcsICcgJywgdGhpcy5fX2hlYWRpbmdBbGlnbikpXG4gICAgYm9keS5wdXNoKHRoaXMuX3Jvd1NlcGVyYXRvcihtTGVuLCB0aGlzLl9fZmlsbCkpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9fcm93cy5sZW5ndGg7IGkrKykge1xuICAgIGJvZHkucHVzaCh0aGlzLl9yZW5kZXJSb3codGhpcy5fX3Jvd3NbaV0sICcgJykpXG4gIH1cbiAgYm9yZGVyICYmIGJvZHkucHVzaCh0aGlzLl9zZXBlcmF0b3IodG90YWwgLSBtTGVuICsgMSwgdGhpcy5fX2JvdHRvbSkpXG5cbiAgdmFyIHByZWZpeCA9IHRoaXMub3B0aW9ucy5wcmVmaXggfHwgJydcbiAgcmV0dXJuIHByZWZpeCArIGJvZHkuam9pbignXFxuJyArIHByZWZpeClcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBsaW5lIHNlcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpbmcgc2l6ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZGUgdmFsdWVzIChkZWZhdWx0ICd8JylcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLl9zZXBlcmF0b3IgPSBmdW5jdGlvbihsZW4sIHNlcCkge1xuICBzZXAgfHwgKHNlcCA9IHRoaXMuX19lZGdlKVxuICByZXR1cm4gc2VwICsgQXNjaWlUYWJsZS5hbGlnblJpZ2h0KHNlcCwgbGVuLCB0aGlzLl9fZmlsbClcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByb3cgc2VwZXJhdG9yXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBzZXBlcmF0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkFzY2lpVGFibGUucHJvdG90eXBlLl9yb3dTZXBlcmF0b3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJsYW5rcyA9IEFzY2lpVGFibGUuYXJyYXlGaWxsKHRoaXMuX19tYXhDZWxscywgdGhpcy5fX2ZpbGwpXG4gIHJldHVybiB0aGlzLl9yZW5kZXJSb3coYmxhbmtzLCB0aGlzLl9fZmlsbClcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIHRhYmxlIHRpdGxlIGluIGEgY2VudGVyZWQgYm94XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmluZyBzaXplXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCB0aXRsZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQXNjaWlUYWJsZS5wcm90b3R5cGUuX3JlbmRlclRpdGxlID0gZnVuY3Rpb24obGVuKSB7XG4gIHZhciBuYW1lID0gJyAnICsgdGhpcy5fX25hbWUgKyAnICdcbiAgICAsIHN0ciA9IEFzY2lpVGFibGUuYWxpZ24odGhpcy5fX25hbWVBbGlnbiwgbmFtZSwgbGVuIC0gMSwgJyAnKVxuICByZXR1cm4gdGhpcy5fX2VkZ2UgKyBzdHIgKyB0aGlzLl9fZWRnZVxufVxuXG4vKipcbiAqIFJlbmRlciBhbiBpbnZkaXZpZHVhbCByb3dcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSByb3dcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW4gc2VwZXJhdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWwgcm93IGFsaWdubWVudCAob3B0aW9uYWwsIGRlZmF1bHQgYGF1dG9gKVxuICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgcm93XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Bc2NpaVRhYmxlLnByb3RvdHlwZS5fcmVuZGVyUm93ID0gZnVuY3Rpb24ocm93LCBzdHIsIGFsaWduKSB7XG4gIHZhciB0bXAgPSBbJyddXG4gICAgLCBtYXggPSB0aGlzLl9fY29sTWF4ZXNcblxuICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuX19tYXhDZWxsczsgaysrKSB7XG4gICAgdmFyIGNlbGwgPSByb3dba11cbiAgICAgICwganVzdCA9IHRoaXMuX19qdXN0aWZ5ID8gTWF0aC5tYXguYXBwbHkobnVsbCwgbWF4KSA6IG1heFtrXVxuICAgICAgLy8gLCBwYWQgPSBrID09PSB0aGlzLl9fbWF4Q2VsbHMgLSAxID8ganVzdCA6IGp1c3QgKyB0aGlzLl9fc3BhY2luZ1xuICAgICAgLCBwYWQgPSBqdXN0XG4gICAgICAsIGNBbGlnbiA9IHRoaXMuX19hbGlnbnNba11cbiAgICAgICwgdXNlID0gYWxpZ25cbiAgICAgICwgbWV0aG9kID0gJ2FsaWduQXV0bydcbiAgXG4gICAgaWYgKHR5cGVvZiBhbGlnbiA9PT0gJ3VuZGVmaW5lZCcpIHVzZSA9IGNBbGlnblxuXG4gICAgaWYgKHVzZSA9PT0gQXNjaWlUYWJsZS5MRUZUKSBtZXRob2QgPSAnYWxpZ25MZWZ0J1xuICAgIGlmICh1c2UgPT09IEFzY2lpVGFibGUuQ0VOVEVSKSBtZXRob2QgPSAnYWxpZ25DZW50ZXInXG4gICAgaWYgKHVzZSA9PT0gQXNjaWlUYWJsZS5SSUdIVCkgbWV0aG9kID0gJ2FsaWduUmlnaHQnXG5cbiAgICB0bXAucHVzaChBc2NpaVRhYmxlW21ldGhvZF0oY2VsbCwgcGFkLCBzdHIpKVxuICB9XG4gIHZhciBmcm9udCA9IHRtcC5qb2luKHN0ciArIHRoaXMuX19lZGdlICsgc3RyKVxuICBmcm9udCA9IGZyb250LnN1YnN0cigxLCBmcm9udC5sZW5ndGgpXG4gIHJldHVybiBmcm9udCArIHN0ciArIHRoaXMuX19lZGdlXG59XG5cbi8qIVxuICogQWxpYXNlc1xuICovXG5cbi8vIENyZWF0ZSBtZXRob2Qgc2hvcnRjdXRzIHRvIGFsbCBhbGlnbm1lbnQgbWV0aG9kcyBmb3IgZWFjaCBkaXJlY3Rpb25cbjtbJ0xlZnQnLCAnUmlnaHQnLCAnQ2VudGVyJ10uZm9yRWFjaChmdW5jdGlvbihkaXIpIHtcbiAgdmFyIGNvbnN0YW50ID0gQXNjaWlUYWJsZVtkaXIudG9VcHBlckNhc2UoKV1cblxuICA7WydzZXRBbGlnbicsICdzZXRUaXRsZUFsaWduJywgJ3NldEhlYWRpbmdBbGlnbiddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgLy8gQ2FsbCB0aGUgYmFzZSBtZXRob2Qgd2l0aCB0aGUgZGlyZWN0aW9uIGNvbnN0YW50IGFzIHRoZSBsYXN0IGFyZ3VtZW50XG4gICAgQXNjaWlUYWJsZS5wcm90b3R5cGVbbWV0aG9kICsgZGlyXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KGNvbnN0YW50KVxuICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKVxuICAgIH1cbiAgfSlcbn0pXG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IEFzY2lpVGFibGVcbn0gZWxzZSB7XG4gIHRoaXMuQXNjaWlUYWJsZSA9IEFzY2lpVGFibGVcbn1cblxufSkuY2FsbCh0aGlzKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9hc2NpaS10YWJsZScpIiwiLyoqXG4gKiBjdWlkLmpzXG4gKiBDb2xsaXNpb24tcmVzaXN0YW50IFVJRCBnZW5lcmF0b3IgZm9yIGJyb3dzZXJzIGFuZCBub2RlLlxuICogU2VxdWVudGlhbCBmb3IgZmFzdCBkYiBsb29rdXBzIGFuZCByZWNlbmN5IHNvcnRpbmcuXG4gKiBTYWZlIGZvciBlbGVtZW50IElEcyBhbmQgc2VydmVyLXNpZGUgbG9va3Vwcy5cbiAqXG4gKiBFeHRyYWN0ZWQgZnJvbSBDTENUUlxuICpcbiAqIENvcHlyaWdodCAoYykgRXJpYyBFbGxpb3R0IDIwMTJcbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxuLypnbG9iYWwgd2luZG93LCBuYXZpZ2F0b3IsIGRvY3VtZW50LCByZXF1aXJlLCBwcm9jZXNzLCBtb2R1bGUgKi9cbihmdW5jdGlvbiAoYXBwKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIG5hbWVzcGFjZSA9ICdjdWlkJyxcbiAgICBjID0gMCxcbiAgICBibG9ja1NpemUgPSA0LFxuICAgIGJhc2UgPSAzNixcbiAgICBkaXNjcmV0ZVZhbHVlcyA9IE1hdGgucG93KGJhc2UsIGJsb2NrU2l6ZSksXG5cbiAgICBwYWQgPSBmdW5jdGlvbiBwYWQobnVtLCBzaXplKSB7XG4gICAgICB2YXIgcyA9IFwiMDAwMDAwMDAwXCIgKyBudW07XG4gICAgICByZXR1cm4gcy5zdWJzdHIocy5sZW5ndGgtc2l6ZSk7XG4gICAgfSxcblxuICAgIHJhbmRvbUJsb2NrID0gZnVuY3Rpb24gcmFuZG9tQmxvY2soKSB7XG4gICAgICByZXR1cm4gcGFkKChNYXRoLnJhbmRvbSgpICpcbiAgICAgICAgICAgIGRpc2NyZXRlVmFsdWVzIDw8IDApXG4gICAgICAgICAgICAudG9TdHJpbmcoYmFzZSksIGJsb2NrU2l6ZSk7XG4gICAgfSxcblxuICAgIHNhZmVDb3VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgYyA9IChjIDwgZGlzY3JldGVWYWx1ZXMpID8gYyA6IDA7XG4gICAgICBjKys7IC8vIHRoaXMgaXMgbm90IHN1YmxpbWluYWxcbiAgICAgIHJldHVybiBjIC0gMTtcbiAgICB9LFxuXG4gICAgYXBpID0gZnVuY3Rpb24gY3VpZCgpIHtcbiAgICAgIC8vIFN0YXJ0aW5nIHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyIG1ha2VzXG4gICAgICAvLyBpdCBIVE1MIGVsZW1lbnQgSUQgZnJpZW5kbHkuXG4gICAgICB2YXIgbGV0dGVyID0gJ2MnLCAvLyBoYXJkLWNvZGVkIGFsbG93cyBmb3Igc2VxdWVudGlhbCBhY2Nlc3NcblxuICAgICAgICAvLyB0aW1lc3RhbXBcbiAgICAgICAgLy8gd2FybmluZzogdGhpcyBleHBvc2VzIHRoZSBleGFjdCBkYXRlIGFuZCB0aW1lXG4gICAgICAgIC8vIHRoYXQgdGhlIHVpZCB3YXMgY3JlYXRlZC5cbiAgICAgICAgdGltZXN0YW1wID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKS50b1N0cmluZyhiYXNlKSxcblxuICAgICAgICAvLyBQcmV2ZW50IHNhbWUtbWFjaGluZSBjb2xsaXNpb25zLlxuICAgICAgICBjb3VudGVyLFxuXG4gICAgICAgIC8vIEEgZmV3IGNoYXJzIHRvIGdlbmVyYXRlIGRpc3RpbmN0IGlkcyBmb3IgZGlmZmVyZW50XG4gICAgICAgIC8vIGNsaWVudHMgKHNvIGRpZmZlcmVudCBjb21wdXRlcnMgYXJlIGZhciBsZXNzXG4gICAgICAgIC8vIGxpa2VseSB0byBnZW5lcmF0ZSB0aGUgc2FtZSBpZClcbiAgICAgICAgZmluZ2VycHJpbnQgPSBhcGkuZmluZ2VycHJpbnQoKSxcblxuICAgICAgICAvLyBHcmFiIHNvbWUgbW9yZSBjaGFycyBmcm9tIE1hdGgucmFuZG9tKClcbiAgICAgICAgcmFuZG9tID0gcmFuZG9tQmxvY2soKSArIHJhbmRvbUJsb2NrKCk7XG5cbiAgICAgICAgY291bnRlciA9IHBhZChzYWZlQ291bnRlcigpLnRvU3RyaW5nKGJhc2UpLCBibG9ja1NpemUpO1xuXG4gICAgICByZXR1cm4gIChsZXR0ZXIgKyB0aW1lc3RhbXAgKyBjb3VudGVyICsgZmluZ2VycHJpbnQgKyByYW5kb20pO1xuICAgIH07XG5cbiAgYXBpLnNsdWcgPSBmdW5jdGlvbiBzbHVnKCkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoMzYpLFxuICAgICAgY291bnRlcixcbiAgICAgIHByaW50ID0gYXBpLmZpbmdlcnByaW50KCkuc2xpY2UoMCwxKSArXG4gICAgICAgIGFwaS5maW5nZXJwcmludCgpLnNsaWNlKC0xKSxcbiAgICAgIHJhbmRvbSA9IHJhbmRvbUJsb2NrKCkuc2xpY2UoLTIpO1xuXG4gICAgICBjb3VudGVyID0gc2FmZUNvdW50ZXIoKS50b1N0cmluZygzNikuc2xpY2UoLTQpO1xuXG4gICAgcmV0dXJuIGRhdGUuc2xpY2UoLTIpICtcbiAgICAgIGNvdW50ZXIgKyBwcmludCArIHJhbmRvbTtcbiAgfTtcblxuICBhcGkuZ2xvYmFsQ291bnQgPSBmdW5jdGlvbiBnbG9iYWxDb3VudCgpIHtcbiAgICAvLyBXZSB3YW50IHRvIGNhY2hlIHRoZSByZXN1bHRzIG9mIHRoaXNcbiAgICB2YXIgY2FjaGUgPSAoZnVuY3Rpb24gY2FsYygpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgY291bnQgPSAwO1xuXG4gICAgICAgIGZvciAoaSBpbiB3aW5kb3cpIHtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgfSgpKTtcblxuICAgIGFwaS5nbG9iYWxDb3VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9O1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICBhcGkuZmluZ2VycHJpbnQgPSBmdW5jdGlvbiBicm93c2VyUHJpbnQoKSB7XG4gICAgcmV0dXJuIHBhZCgobmF2aWdhdG9yLm1pbWVUeXBlcy5sZW5ndGggK1xuICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5sZW5ndGgpLnRvU3RyaW5nKDM2KSArXG4gICAgICBhcGkuZ2xvYmFsQ291bnQoKS50b1N0cmluZygzNiksIDQpO1xuICB9O1xuXG4gIC8vIGRvbid0IGNoYW5nZSBhbnl0aGluZyBmcm9tIGhlcmUgZG93bi5cbiAgaWYgKGFwcC5yZWdpc3Rlcikge1xuICAgIGFwcC5yZWdpc3RlcihuYW1lc3BhY2UsIGFwaSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGFwaTtcbiAgfSBlbHNlIHtcbiAgICBhcHBbbmFtZXNwYWNlXSA9IGFwaTtcbiAgfVxuXG59KHRoaXMuYXBwbGl0dWRlIHx8IHRoaXMpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cbi8vIE9ubHkgTm9kZS5KUyBoYXMgYSBwcm9jZXNzIHZhcmlhYmxlIHRoYXQgaXMgb2YgW1tDbGFzc11dIHByb2Nlc3NcbnRyeSB7XG4gbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScgXG59IGNhdGNoKGUpIHt9XG4iLCIvKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuICogQGxpY2Vuc2UgZXM1LXNoaW0gQ29weXJpZ2h0IDIwMDktMjAxNSBieSBjb250cmlidXRvcnMsIE1JVCBMaWNlbnNlXG4gKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG4vLyB2aW06IHRzPTQgc3RzPTQgc3c9NCBleHBhbmR0YWJcblxuLy8gQWRkIHNlbWljb2xvbiB0byBwcmV2ZW50IElJRkUgZnJvbSBiZWluZyBwYXNzZWQgYXMgYXJndW1lbnQgdG8gY29uY2F0ZW5hdGVkIGNvZGUuXG47XG5cbi8vIFVNRCAoVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uKVxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvdGVtcGxhdGVzL3JldHVybkV4cG9ydHMuanNcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGdsb2JhbCBkZWZpbmUsIGV4cG9ydHMsIG1vZHVsZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGNhbGwgPSBGdW5jdGlvbi5jYWxsO1xuICAgIHZhciBwcm90b3R5cGVPZk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyIG93bnMgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuaGFzT3duUHJvcGVydHkpO1xuICAgIHZhciBpc0VudW1lcmFibGUgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUpO1xuICAgIHZhciB0b1N0ciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC50b1N0cmluZyk7XG5cbiAgICAvLyBJZiBKUyBlbmdpbmUgc3VwcG9ydHMgYWNjZXNzb3JzIGNyZWF0aW5nIHNob3J0Y3V0cy5cbiAgICB2YXIgZGVmaW5lR2V0dGVyO1xuICAgIHZhciBkZWZpbmVTZXR0ZXI7XG4gICAgdmFyIGxvb2t1cEdldHRlcjtcbiAgICB2YXIgbG9va3VwU2V0dGVyO1xuICAgIHZhciBzdXBwb3J0c0FjY2Vzc29ycyA9IG93bnMocHJvdG90eXBlT2ZPYmplY3QsICdfX2RlZmluZUdldHRlcl9fJyk7XG4gICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG4gICAgICAgIGRlZmluZUdldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZUdldHRlcl9fKTtcbiAgICAgICAgZGVmaW5lU2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18pO1xuICAgICAgICBsb29rdXBHZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBHZXR0ZXJfXyk7XG4gICAgICAgIGxvb2t1cFNldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cFNldHRlcl9fKTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuICAgIH1cblxuICAgIHZhciBpc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG8pIHtcbiAgICAgICAgcmV0dXJuIG8gPT0gbnVsbCB8fCAodHlwZW9mIG8gIT09ICdvYmplY3QnICYmIHR5cGVvZiBvICE9PSAnZnVuY3Rpb24nKTtcbiAgICB9O1xuXG4gICAgLy8gRVM1IDE1LjIuMy4yXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjJcbiAgICBpZiAoIU9iamVjdC5nZXRQcm90b3R5cGVPZikge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzI2lzc3VlLzJcbiAgICAgICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL29iamVjdGdldHByb3RvdHlwZW9mL1xuICAgICAgICAvLyByZWNvbW1lbmRlZCBieSBmc2NoYWVmZXIgb24gZ2l0aHViXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHN1cmUsIGFuZCB3ZWJyZWZsZWN0aW9uIHNheXMgXl9eXG4gICAgICAgIC8vIC4uLiB0aGlzIHdpbGwgbmVyZXZlciBwb3NzaWJseSByZXR1cm4gbnVsbFxuICAgICAgICAvLyAuLi4gT3BlcmEgTWluaSBicmVha3MgaGVyZSB3aXRoIGluZmluaXRlIGxvb3BzXG4gICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKG9iamVjdCkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgICAgIHZhciBwcm90byA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICBpZiAocHJvdG8gfHwgcHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvU3RyKG9iamVjdC5jb25zdHJ1Y3RvcikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb3JyZWN0bHkgcmV0dXJuIG51bGwgZm9yIE9iamVjdHMgY3JlYXRlZCB3aXRoIGBPYmplY3QuY3JlYXRlKG51bGwpYFxuICAgICAgICAgICAgICAgIC8vIChzaGFtbWVkIG9yIG5hdGl2ZSkgb3IgYHsgX19wcm90b19fOiBudWxsfWAuICBBbHNvIHJldHVybnMgbnVsbCBmb3JcbiAgICAgICAgICAgICAgICAvLyBjcm9zcy1yZWFsbSBvYmplY3RzIG9uIGJyb3dzZXJzIHRoYXQgbGFjayBgX19wcm90b19fYCBzdXBwb3J0IChsaWtlXG4gICAgICAgICAgICAgICAgLy8gSUUgPDExKSwgYnV0IHRoYXQncyB0aGUgYmVzdCB3ZSBjYW4gZG8uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy4zXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjNcblxuICAgIHZhciBkb2VzR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29yayA9IGZ1bmN0aW9uIGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKG9iamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqZWN0LnNlbnRpbmVsID0gMDtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgJ3NlbnRpbmVsJykudmFsdWUgPT09IDA7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHdvcmtzIGlmIGl0J3MgZ2l2ZW4uIE90aGVyd2lzZSwgc2hpbSBwYXJ0aWFsbHkuXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yV29ya3NPbk9iamVjdCA9IGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKHt9KTtcbiAgICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmtzT25Eb20gPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgaWYgKCFnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3Jrc09uRG9tIHx8ICFnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3Jrc09uT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRmFsbGJhY2sgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHx8IGdldE93blByb3BlcnR5RGVzY3JpcHRvckZhbGxiYWNrKSB7XG4gICAgICAgIHZhciBFUlJfTk9OX09CSkVDVCA9ICdPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIGNhbGxlZCBvbiBhIG5vbi1vYmplY3Q6ICc7XG5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1QgKyBvYmplY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICAgICAgICAgIC8vIGZvciBJOCdzIERPTSBlbGVtZW50cy5cbiAgICAgICAgICAgIGlmIChnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvcjtcblxuICAgICAgICAgICAgLy8gSWYgb2JqZWN0IGRvZXMgbm90IG93bnMgcHJvcGVydHkgcmV0dXJuIHVuZGVmaW5lZCBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIGlmICghb3ducyhvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBvYmplY3QgaGFzIGEgcHJvcGVydHkgdGhlbiBpdCdzIGZvciBzdXJlIGBjb25maWd1cmFibGVgLCBhbmRcbiAgICAgICAgICAgIC8vIHByb2JhYmx5IGBlbnVtZXJhYmxlYC4gRGV0ZWN0IGVudW1lcmFiaWxpdHkgdGhvdWdoLlxuICAgICAgICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBpc0VudW1lcmFibGUob2JqZWN0LCBwcm9wZXJ0eSksXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBJZiBKUyBlbmdpbmUgc3VwcG9ydHMgYWNjZXNzb3IgcHJvcGVydGllcyB0aGVuIHByb3BlcnR5IG1heSBiZSBhXG4gICAgICAgICAgICAvLyBnZXR0ZXIgb3Igc2V0dGVyLlxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSBgX19sb29rdXBHZXR0ZXJfX2Agd2lsbCByZXR1cm4gYSBnZXR0ZXIgZXZlblxuICAgICAgICAgICAgICAgIC8vIGlmIG9iamVjdCBoYXMgb3duIG5vbiBnZXR0ZXIgcHJvcGVydHkgYWxvbmcgd2l0aCBhIHNhbWUgbmFtZWRcbiAgICAgICAgICAgICAgICAvLyBpbmhlcml0ZWQgZ2V0dGVyLiBUbyBhdm9pZCBtaXNiZWhhdmlvciB3ZSB0ZW1wb3JhcnkgcmVtb3ZlXG4gICAgICAgICAgICAgICAgLy8gYF9fcHJvdG9fX2Agc28gdGhhdCBgX19sb29rdXBHZXR0ZXJfX2Agd2lsbCByZXR1cm4gZ2V0dGVyIG9ubHlcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIG93bmVkIGJ5IGFuIG9iamVjdC5cbiAgICAgICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gb2JqZWN0Ll9fcHJvdG9fXztcbiAgICAgICAgICAgICAgICB2YXIgbm90UHJvdG90eXBlT2ZPYmplY3QgPSBvYmplY3QgIT09IHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHJlY3Vyc2lvbiBwcm9ibGVtLCBicmVha2luZyBpbiBPcGVyYSBNaW5pIHdoZW5cbiAgICAgICAgICAgICAgICAvLyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycpXG4gICAgICAgICAgICAgICAgLy8gb3IgYW55IG90aGVyIE9iamVjdC5wcm90b3R5cGUgYWNjZXNzb3JcbiAgICAgICAgICAgICAgICBpZiAobm90UHJvdG90eXBlT2ZPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgdmFyIHNldHRlciA9IGxvb2t1cFNldHRlcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgIGlmIChub3RQcm90b3R5cGVPZk9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIHdlIGhhdmUgZ2V0dGVyIGFuZCBzZXR0ZXIgd2UgY2FuIHB1dCB2YWx1ZXMgYmFjay5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyIHx8IHNldHRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGdldHRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNldCA9IHNldHRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCB3YXMgYWNjZXNzb3IgcHJvcGVydHkgd2UncmUgZG9uZSBhbmQgcmV0dXJuIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgYWRkaW5nIGB2YWx1ZWAgdG8gdGhlIGRlc2NyaXB0b3IuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgZ290IHRoaXMgZmFyIHdlIGtub3cgdGhhdCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB0aGF0IGlzXG4gICAgICAgICAgICAvLyBub3QgYW4gYWNjZXNzb3Igc28gd2Ugc2V0IGl0IGFzIGEgdmFsdWUgYW5kIHJldHVybiBkZXNjcmlwdG9yLlxuICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy40XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjRcbiAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuNVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy41XG4gICAgaWYgKCFPYmplY3QuY3JlYXRlKSB7XG5cbiAgICAgICAgLy8gQ29udHJpYnV0ZWQgYnkgQnJhbmRvbiBCZW52aWUsIE9jdG9iZXIsIDIwMTJcbiAgICAgICAgdmFyIGNyZWF0ZUVtcHR5O1xuICAgICAgICB2YXIgc3VwcG9ydHNQcm90byA9ICEoeyBfX3Byb3RvX186IG51bGwgfSBpbnN0YW5jZW9mIE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBwcm9kdWNlcyBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBPcGVyYSBNaW5pID0+IG5vdCBhIHJlbGlhYmxlIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0LnByb3RvdHlwZS5fX3Byb3RvX18gPT09IG51bGxcblxuICAgICAgICAvLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4gICAgICAgIC8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4gICAgICAgIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG4gICAgICAgIHZhciBzaG91bGRVc2VBY3RpdmVYID0gZnVuY3Rpb24gc2hvdWxkVXNlQWN0aXZlWCgpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBlYXJseSBpZiBkb2N1bWVudC5kb21haW4gbm90IHNldFxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5kb21haW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGhpcyBzdXBwb3J0cyBJRTggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgdXNlZFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbiAgICAgICAgLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbiAgICAgICAgdmFyIGdldEVtcHR5VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIGdldEVtcHR5VmlhQWN0aXZlWCgpIHtcbiAgICAgICAgICAgIHZhciBlbXB0eTtcbiAgICAgICAgICAgIHZhciB4RG9jO1xuXG4gICAgICAgICAgICB4RG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSAnc2NyaXB0JztcbiAgICAgICAgICAgIHhEb2Mud3JpdGUoJzwnICsgc2NyaXB0ICsgJz48LycgKyBzY3JpcHQgKyAnPicpO1xuICAgICAgICAgICAgeERvYy5jbG9zZSgpO1xuXG4gICAgICAgICAgICBlbXB0eSA9IHhEb2MucGFyZW50V2luZG93Lk9iamVjdC5wcm90b3R5cGU7XG4gICAgICAgICAgICB4RG9jID0gbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiB1c2luZyBhbiBpZnJhbWVcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBhY3RpdmV4IGFwcHJvYWNoIHdhcyBhZGRlZFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbiAgICAgICAgdmFyIGdldEVtcHR5VmlhSUZyYW1lID0gZnVuY3Rpb24gZ2V0RW1wdHlWaWFJRnJhbWUoKSB7XG4gICAgICAgICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgZW1wdHk7XG5cbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zY3JpcHQtdXJsICovXG4gICAgICAgICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JztcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2NyaXB0LXVybCAqL1xuXG4gICAgICAgICAgICBlbXB0eSA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdC5wcm90b3R5cGU7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKiBnbG9iYWwgZG9jdW1lbnQgKi9cbiAgICAgICAgaWYgKHN1cHBvcnRzUHJvdG8gfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY3JlYXRlRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgX19wcm90b19fOiBudWxsIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gb2xkIElFIF9fcHJvdG9fXyBjYW4ndCBiZSB1c2VkIHRvIG1hbnVhbGx5IHNldCBgbnVsbGAsIG5vciBkb2VzXG4gICAgICAgICAgICAvLyBhbnkgb3RoZXIgbWV0aG9kIGV4aXN0IHRvIG1ha2UgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBub3RoaW5nLFxuICAgICAgICAgICAgLy8gYXNpZGUgZnJvbSBPYmplY3QucHJvdG90eXBlIGl0c2VsZi4gSW5zdGVhZCwgY3JlYXRlIGEgbmV3IGdsb2JhbFxuICAgICAgICAgICAgLy8gb2JqZWN0IGFuZCAqc3RlYWwqIGl0cyBPYmplY3QucHJvdG90eXBlIGFuZCBzdHJpcCBpdCBiYXJlLiBUaGlzIGlzXG4gICAgICAgICAgICAvLyB1c2VkIGFzIHRoZSBwcm90b3R5cGUgdG8gY3JlYXRlIG51bGxhcnkgb2JqZWN0cy5cbiAgICAgICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBhcHByb2FjaCB0byB1c2VcbiAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbiAgICAgICAgICAgICAgICB2YXIgZW1wdHkgPSBzaG91bGRVc2VBY3RpdmVYKCkgPyBnZXRFbXB0eVZpYUFjdGl2ZVgoKSA6IGdldEVtcHR5VmlhSUZyYW1lKCk7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgZW1wdHkuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVtcHR5Lmhhc093blByb3BlcnR5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW1wdHkuaXNQcm90b3R5cGVPZjtcbiAgICAgICAgICAgICAgICBkZWxldGUgZW1wdHkudG9Mb2NhbGVTdHJpbmc7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVtcHR5LnRvU3RyaW5nO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS52YWx1ZU9mO1xuXG4gICAgICAgICAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBlbXB0eTtcbiAgICAgICAgICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IGZ1dHVyZSBjYWxsc1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcblxuICAgICAgICAgICAgdmFyIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBUeXBlID0gZnVuY3Rpb24gVHlwZSgpIHt9OyAvLyBBbiBlbXB0eSBjb25zdHJ1Y3Rvci5cblxuICAgICAgICAgICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IGNyZWF0ZUVtcHR5KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcm90b3R5cGUgIT09IG51bGwgJiYgaXNQcmltaXRpdmUocHJvdG90eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uIGBwYXJlbnRgIGNhbiBiZSBgbnVsbGBcbiAgICAgICAgICAgICAgICAgICAgLy8gT1IgKmFueSogYGluc3RhbmNlb2YgT2JqZWN0YCAgKE9iamVjdHxGdW5jdGlvbnxBcnJheXxSZWdFeHB8ZXRjKVxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYHR5cGVvZmAgdGhvLCBiL2MgaW4gb2xkIElFLCBET00gZWxlbWVudHMgYXJlIG5vdCBgaW5zdGFuY2VvZiBPYmplY3RgXG4gICAgICAgICAgICAgICAgICAgIC8vIGxpa2UgdGhleSBhcmUgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2luZyBgT2JqZWN0LmNyZWF0ZWAgb24gRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzLi4uZXJyLi4ucHJvYmFibHkgaW5hcHByb3ByaWF0ZSwgYnV0IHRoZSBuYXRpdmUgdmVyc2lvbiBhbGxvd3MgZm9yIGl0LlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgcHJvdG90eXBlIG1heSBvbmx5IGJlIGFuIE9iamVjdCBvciBudWxsJyk7IC8vIHNhbWUgbXNnIGFzIENocm9tZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgVHlwZSgpO1xuICAgICAgICAgICAgICAgIC8vIElFIGhhcyBubyBidWlsdC1pbiBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmdldFByb3RvdHlwZU9mYFxuICAgICAgICAgICAgICAgIC8vIG5laXRoZXIgYF9fcHJvdG9fX2AsIGJ1dCB0aGlzIG1hbnVhbGx5IHNldHRpbmcgYF9fcHJvdG9fX2Agd2lsbFxuICAgICAgICAgICAgICAgIC8vIGd1YXJhbnRlZSB0aGF0IGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIHdpbGwgd29yayBhcyBleHBlY3RlZCB3aXRoXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIGBPYmplY3QuY3JlYXRlYFxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuNlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy42XG5cbiAgICAvLyBQYXRjaCBmb3IgV2ViS2l0IGFuZCBJRTggc3RhbmRhcmQgbW9kZVxuICAgIC8vIERlc2lnbmVkIGJ5IGhheCA8aGF4LmdpdGh1Yi5jb20+XG4gICAgLy8gcmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3VlcyNpc3N1ZS81XG4gICAgLy8gSUU4IFJlZmVyZW5jZTpcbiAgICAvLyAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RkMjgyOTAwLmFzcHhcbiAgICAvLyAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RkMjI5OTE2LmFzcHhcbiAgICAvLyBXZWJLaXQgQnVnczpcbiAgICAvLyAgICAgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTM2NDIzXG5cbiAgICB2YXIgZG9lc0RlZmluZVByb3BlcnR5V29yayA9IGZ1bmN0aW9uIGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsob2JqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2VudGluZWwnLCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gJ3NlbnRpbmVsJyBpbiBvYmplY3Q7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgZGVmaW5lUHJvcGVydHkgd29ya3MgaWYgaXQncyBnaXZlbi4gT3RoZXJ3aXNlLFxuICAgIC8vIHNoaW0gcGFydGlhbGx5LlxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdCA9IGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoe30pO1xuICAgICAgICB2YXIgZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgZG9lc0RlZmluZVByb3BlcnR5V29yayhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgIGlmICghZGVmaW5lUHJvcGVydHlXb3Jrc09uT2JqZWN0IHx8ICFkZWZpbmVQcm9wZXJ0eVdvcmtzT25Eb20pIHtcbiAgICAgICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXNGYWxsYmFjayA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZGVmaW5lUHJvcGVydHlGYWxsYmFjaykge1xuICAgICAgICB2YXIgRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiA9ICdQcm9wZXJ0eSBkZXNjcmlwdGlvbiBtdXN0IGJlIGFuIG9iamVjdDogJztcbiAgICAgICAgdmFyIEVSUl9OT05fT0JKRUNUX1RBUkdFVCA9ICdPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbGVkIG9uIG5vbi1vYmplY3Q6ICc7XG4gICAgICAgIHZhciBFUlJfQUNDRVNTT1JTX05PVF9TVVBQT1JURUQgPSAnZ2V0dGVycyAmIHNldHRlcnMgY2FuIG5vdCBiZSBkZWZpbmVkIG9uIHRoaXMgamF2YXNjcmlwdCBlbmdpbmUnO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZShvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVF9UQVJHRVQgKyBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVF9ERVNDUklQVE9SICsgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBkZWZpbmVQcm9wZXJ0eVxuICAgICAgICAgICAgLy8gZm9yIEk4J3MgRE9NIGVsZW1lbnRzLlxuICAgICAgICAgICAgaWYgKGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHlGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBpdCdzIGEgZGF0YSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICAvLyBmYWlsIHNpbGVudGx5IGlmICd3cml0YWJsZScsICdlbnVtZXJhYmxlJywgb3IgJ2NvbmZpZ3VyYWJsZSdcbiAgICAgICAgICAgICAgICAvLyBhcmUgcmVxdWVzdGVkIGJ1dCBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAvLyBhbHRlcm5hdGUgYXBwcm9hY2g6XG4gICAgICAgICAgICAgICAgaWYgKCAvLyBjYW4ndCBpbXBsZW1lbnQgdGhlc2UgZmVhdHVyZXM7IGFsbG93IGZhbHNlIGJ1dCBub3QgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAoJ3dyaXRhYmxlJyBpbiBkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLndyaXRhYmxlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoJ2VudW1lcmFibGUnIGluIGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCdjb25maWd1cmFibGUnIGluIGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKVxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RoaXMgaW1wbGVtZW50YXRpb24gb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5IGRvZXMgbm90IHN1cHBvcnQgY29uZmlndXJhYmxlLCBlbnVtZXJhYmxlLCBvciB3cml0YWJsZS4nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycyAmJiAobG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcGVydHkpIHx8IGxvb2t1cFNldHRlcihvYmplY3QsIHByb3BlcnR5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXMgYWNjZXNzb3JzIGFyZSBzdXBwb3J0ZWQgb25seSBvbiBlbmdpbmVzIGltcGxlbWVudGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBgX19wcm90b19fYCB3ZSBjYW4gc2FmZWx5IG92ZXJyaWRlIGBfX3Byb3RvX19gIHdoaWxlIGRlZmluaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcHJvcGVydHkgdG8gbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgaGl0IGFuIGluaGVyaXRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3Nvci5cbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGVPZk9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRpbmcgYSBwcm9wZXJ0eSBhbnl3YXkgc2luY2UgZ2V0dGVyIC8gc2V0dGVyIG1heSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZpbmVkIG9uIG9iamVjdCBpdHNlbGYuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyBvcmlnaW5hbCBgX19wcm90b19fYCBiYWNrIG5vdy5cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0dldHRlciA9ICdnZXQnIGluIGRlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1NldHRlciA9ICdzZXQnIGluIGRlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0FjY2Vzc29ycyAmJiAoaGFzR2V0dGVyIHx8IGhhc1NldHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ290IHRoYXQgZmFyIHRoZW4gZ2V0dGVycyBhbmQgc2V0dGVycyBjYW4gYmUgZGVmaW5lZCAhIVxuICAgICAgICAgICAgICAgIGlmIChoYXNHZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lR2V0dGVyKG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NldHRlcikge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVTZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvci5zZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy43XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjdcbiAgICBpZiAoIU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIHx8IGRlZmluZVByb3BlcnRpZXNGYWxsYmFjaykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBkZWZpbmVQcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnRpZXNGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBzaGltIGlmIHRoZSByZWFsIG9uZSBkb2Vzbid0IHdvcmtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgcHJvcGVydGllc1twcm9wZXJ0eV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuMi4zLjhcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuOFxuICAgIGlmICghT2JqZWN0LnNlYWwpIHtcbiAgICAgICAgT2JqZWN0LnNlYWwgPSBmdW5jdGlvbiBzZWFsKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Quc2VhbCBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbWlzbGVhZGluZyBhbmQgYnJlYWtzIGZlYXR1cmUtZGV0ZWN0aW9uLCBidXRcbiAgICAgICAgICAgIC8vIGFsbG93cyBcInNlY3VyYWJsZVwiIGNvZGUgdG8gXCJncmFjZWZ1bGx5XCIgZGVncmFkZSB0byB3b3JraW5nXG4gICAgICAgICAgICAvLyBidXQgaW5zZWN1cmUgY29kZS5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy45XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjlcbiAgICBpZiAoIU9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZShvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmZyZWV6ZSBjYW4gb25seSBiZSBjYWxsZWQgb24gT2JqZWN0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbWlzbGVhZGluZyBhbmQgYnJlYWtzIGZlYXR1cmUtZGV0ZWN0aW9uLCBidXRcbiAgICAgICAgICAgIC8vIGFsbG93cyBcInNlY3VyYWJsZVwiIGNvZGUgdG8gXCJncmFjZWZ1bGx5XCIgZGVncmFkZSB0byB3b3JraW5nXG4gICAgICAgICAgICAvLyBidXQgaW5zZWN1cmUgY29kZS5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IGEgUmhpbm8gYnVnIGFuZCBwYXRjaCBpdFxuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKCkge30pO1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICBPYmplY3QuZnJlZXplID0gKGZ1bmN0aW9uIChmcmVlemVPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBmcmVlemUob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJlZXplT2JqZWN0KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfShPYmplY3QuZnJlZXplKSk7XG4gICAgfVxuXG4gICAgLy8gRVM1IDE1LjIuMy4xMFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xMFxuICAgIGlmICghT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG4gICAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QucHJldmVudEV4dGVuc2lvbnMgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIE9iamVjdHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1pc2xlYWRpbmcgYW5kIGJyZWFrcyBmZWF0dXJlLWRldGVjdGlvbiwgYnV0XG4gICAgICAgICAgICAvLyBhbGxvd3MgXCJzZWN1cmFibGVcIiBjb2RlIHRvIFwiZ3JhY2VmdWxseVwiIGRlZ3JhZGUgdG8gd29ya2luZ1xuICAgICAgICAgICAgLy8gYnV0IGluc2VjdXJlIGNvZGUuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuMTFcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTFcbiAgICBpZiAoIU9iamVjdC5pc1NlYWxlZCkge1xuICAgICAgICBPYmplY3QuaXNTZWFsZWQgPSBmdW5jdGlvbiBpc1NlYWxlZChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmlzU2VhbGVkIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuMTJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTJcbiAgICBpZiAoIU9iamVjdC5pc0Zyb3plbikge1xuICAgICAgICBPYmplY3QuaXNGcm96ZW4gPSBmdW5jdGlvbiBpc0Zyb3plbihvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qob2JqZWN0KSAhPT0gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmlzRnJvemVuIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBPYmplY3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEVTNSAxNS4yLjMuMTNcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuMTNcbiAgICBpZiAoIU9iamVjdC5pc0V4dGVuc2libGUpIHtcbiAgICAgICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIDEuIElmIFR5cGUoTykgaXMgbm90IE9iamVjdCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgICBpZiAoT2JqZWN0KG9iamVjdCkgIT09IG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5pc0V4dGVuc2libGUgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIE9iamVjdHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyLiBSZXR1cm4gdGhlIEJvb2xlYW4gdmFsdWUgb2YgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIE8uXG4gICAgICAgICAgICB2YXIgbmFtZSA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKG93bnMob2JqZWN0LCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gJz8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0W25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG93bnMob2JqZWN0LCBuYW1lKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG59KSk7XG4iLCIvKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuICogQGxpY2Vuc2UgZXM1LXNoaW0gQ29weXJpZ2h0IDIwMDktMjAxNSBieSBjb250cmlidXRvcnMsIE1JVCBMaWNlbnNlXG4gKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG4vLyB2aW06IHRzPTQgc3RzPTQgc3c9NCBleHBhbmR0YWJcblxuLy8gQWRkIHNlbWljb2xvbiB0byBwcmV2ZW50IElJRkUgZnJvbSBiZWluZyBwYXNzZWQgYXMgYXJndW1lbnQgdG8gY29uY2F0ZW5hdGVkIGNvZGUuXG47XG5cbi8vIFVNRCAoVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uKVxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvdGVtcGxhdGVzL3JldHVybkV4cG9ydHMuanNcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGdsb2JhbCBkZWZpbmUsIGV4cG9ydHMsIG1vZHVsZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEJyaW5ncyBhbiBlbnZpcm9ubWVudCBhcyBjbG9zZSB0byBFQ01BU2NyaXB0IDUgY29tcGxpYW5jZVxuICAgICAqIGFzIGlzIHBvc3NpYmxlIHdpdGggdGhlIGZhY2lsaXRpZXMgb2YgZXJzdHdoaWxlIGVuZ2luZXMuXG4gICAgICpcbiAgICAgKiBBbm5vdGF0ZWQgRVM1OiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vIChzcGVjaWZpYyBsaW5rcyBiZWxvdylcbiAgICAgKiBFUzUgU3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VjbWEtMjYyLnBkZlxuICAgICAqIFJlcXVpcmVkIHJlYWRpbmc6IGh0dHA6Ly9qYXZhc2NyaXB0d2VibG9nLndvcmRwcmVzcy5jb20vMjAxMS8xMi8wNS9leHRlbmRpbmctamF2YXNjcmlwdC1uYXRpdmVzL1xuICAgICAqL1xuXG4gICAgLy8gU2hvcnRjdXQgdG8gYW4gb2Z0ZW4gYWNjZXNzZWQgcHJvcGVydGllcywgaW4gb3JkZXIgdG8gYXZvaWQgbXVsdGlwbGVcbiAgICAvLyBkZXJlZmVyZW5jZSB0aGF0IGNvc3RzIHVuaXZlcnNhbGx5LiBUaGlzIGFsc28gaG9sZHMgYSByZWZlcmVuY2UgdG8ga25vd24tZ29vZFxuICAgIC8vIGZ1bmN0aW9ucy5cbiAgICB2YXIgJEFycmF5ID0gQXJyYXk7XG4gICAgdmFyIEFycmF5UHJvdG90eXBlID0gJEFycmF5LnByb3RvdHlwZTtcbiAgICB2YXIgJE9iamVjdCA9IE9iamVjdDtcbiAgICB2YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xuICAgIHZhciBGdW5jdGlvblByb3RvdHlwZSA9ICRGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgdmFyICRTdHJpbmcgPSBTdHJpbmc7XG4gICAgdmFyIFN0cmluZ1Byb3RvdHlwZSA9ICRTdHJpbmcucHJvdG90eXBlO1xuICAgIHZhciAkTnVtYmVyID0gTnVtYmVyO1xuICAgIHZhciBOdW1iZXJQcm90b3R5cGUgPSAkTnVtYmVyLnByb3RvdHlwZTtcbiAgICB2YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcbiAgICB2YXIgYXJyYXlfc3BsaWNlID0gQXJyYXlQcm90b3R5cGUuc3BsaWNlO1xuICAgIHZhciBhcnJheV9wdXNoID0gQXJyYXlQcm90b3R5cGUucHVzaDtcbiAgICB2YXIgYXJyYXlfdW5zaGlmdCA9IEFycmF5UHJvdG90eXBlLnVuc2hpZnQ7XG4gICAgdmFyIGFycmF5X2NvbmNhdCA9IEFycmF5UHJvdG90eXBlLmNvbmNhdDtcbiAgICB2YXIgYXJyYXlfam9pbiA9IEFycmF5UHJvdG90eXBlLmpvaW47XG4gICAgdmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuICAgIHZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWluID0gTWF0aC5taW47XG5cbiAgICAvLyBIYXZpbmcgYSB0b1N0cmluZyBsb2NhbCB2YXJpYWJsZSBuYW1lIGJyZWFrcyBpbiBPcGVyYSBzbyB1c2UgdG9fc3RyaW5nLlxuICAgIHZhciB0b19zdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAvKiBnbG9iYWwgU3ltYm9sICovXG4gICAgLyogZXNsaW50LWRpc2FibGUgb25lLXZhci1kZWNsYXJhdGlvbi1wZXItbGluZSwgbm8tcmVkZWNsYXJlLCBtYXgtc3RhdGVtZW50cy1wZXItbGluZSAqL1xuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG4gICAgdmFyIGlzQ2FsbGFibGU7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1jYWxsYWJsZSAqLyB2YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZywgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzIC8sIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGbih2YWx1ZSkgeyB0cnkgeyB2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpOyB2YXIgc2luZ2xlU3RyaXBwZWQgPSBmblN0ci5yZXBsYWNlKC9cXC9cXC8uKlxcbi9nLCAnJyk7IHZhciBtdWx0aVN0cmlwcGVkID0gc2luZ2xlU3RyaXBwZWQucmVwbGFjZSgvXFwvXFwqWy5cXHNcXFNdKlxcKlxcLy9nLCAnJyk7IHZhciBzcGFjZVN0cmlwcGVkID0gbXVsdGlTdHJpcHBlZC5yZXBsYWNlKC9cXG4vbWcsICcgJykucmVwbGFjZSgvIHsyfS9nLCAnICcpOyByZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KHNwYWNlU3RyaXBwZWQpOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgLyogbm90IGEgZnVuY3Rpb24gKi8gfSB9LCB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKSB7IHRyeSB7IGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfSBmblRvU3RyLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJywgaXNDYWxsYWJsZSA9IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHsgaWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH0gaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfSBpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfSBpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH0gdmFyIHN0ckNsYXNzID0gdG9fc3RyaW5nLmNhbGwodmFsdWUpOyByZXR1cm4gc3RyQ2xhc3MgPT09IGZuQ2xhc3MgfHwgc3RyQ2xhc3MgPT09IGdlbkNsYXNzOyB9O1xuXG4gICAgdmFyIGlzUmVnZXg7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1yZWdleCAqLyB2YXIgcmVnZXhFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjLCB0cnlSZWdleEV4ZWMgPSBmdW5jdGlvbiB0cnlSZWdleEV4ZWModmFsdWUpIHsgdHJ5IHsgcmVnZXhFeGVjLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgcmVnZXhDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nOyBpc1JlZ2V4ID0gZnVuY3Rpb24gaXNSZWdleCh2YWx1ZSkgeyBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH0gcmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5UmVnZXhFeGVjKHZhbHVlKSA6IHRvX3N0cmluZy5jYWxsKHZhbHVlKSA9PT0gcmVnZXhDbGFzczsgfTtcbiAgICB2YXIgaXNTdHJpbmc7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1zdHJpbmcgKi8gdmFyIHN0clZhbHVlID0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLCB0cnlTdHJpbmdPYmplY3QgPSBmdW5jdGlvbiB0cnlTdHJpbmdPYmplY3QodmFsdWUpIHsgdHJ5IHsgc3RyVmFsdWUuY2FsbCh2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9LCBzdHJpbmdDbGFzcyA9ICdbb2JqZWN0IFN0cmluZ10nOyBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7IGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7IHJldHVybiB0cnVlOyB9IGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfSByZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlTdHJpbmdPYmplY3QodmFsdWUpIDogdG9fc3RyaW5nLmNhbGwodmFsdWUpID09PSBzdHJpbmdDbGFzczsgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG9uZS12YXItZGVjbGFyYXRpb24tcGVyLWxpbmUsIG5vLXJlZGVjbGFyZSwgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmUgKi9cblxuICAgIC8qIGlubGluZWQgZnJvbSBodHRwOi8vbnBtanMuY29tL2RlZmluZS1wcm9wZXJ0aWVzICovXG4gICAgdmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSAkT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgXyBpbiBvYmopIHsgLy8ganNjczppZ25vcmUgZGlzYWxsb3dVbnVzZWRWYXJpYWJsZXNcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqLnggPT09IG9iajtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSgpKTtcbiAgICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IChmdW5jdGlvbiAoaGFzKSB7XG4gICAgICAgIC8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlLCBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbiAgICAgICAgLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbiAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5O1xuICAgICAgICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzLmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSkpO1xuXG4gICAgLy9cbiAgICAvLyBVdGlsXG4gICAgLy8gPT09PT09XG4gICAgLy9cblxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCAvaGVscGVycy9pc1ByaW1pdGl2ZSAqL1xuICAgIHZhciBpc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKGlucHV0KSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IG51bGwgfHwgKHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGUgIT09ICdmdW5jdGlvbicpO1xuICAgIH07XG5cbiAgICB2YXIgaXNBY3R1YWxOYU4gPSAkTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIGlzQWN0dWFsTmFOKHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT09IHg7XG4gICAgfTtcblxuICAgIHZhciBFUyA9IHtcbiAgICAgICAgLy8gRVM1IDkuNFxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbiAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuICAgICAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvSW50ZWdlciAqL1xuICAgICAgICBUb0ludGVnZXI6IGZ1bmN0aW9uIFRvSW50ZWdlcihudW0pIHtcbiAgICAgICAgICAgIHZhciBuID0gK251bTtcbiAgICAgICAgICAgIGlmIChpc0FjdHVhbE5hTihuKSkge1xuICAgICAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcbiAgICAgICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub1ByaW1pdGl2ZSAqL1xuICAgICAgICBUb1ByaW1pdGl2ZTogZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB2YWwsIHZhbHVlT2YsIHRvU3RyO1xuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlT2YgPSBpbnB1dC52YWx1ZU9mO1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGUodmFsdWVPZikpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZU9mLmNhbGwoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9TdHIgPSBpbnB1dC50b1N0cmluZztcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlKHRvU3RyKSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHRvU3RyLmNhbGwoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEVTNSA5LjlcbiAgICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS45XG4gICAgICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9PYmplY3QgKi9cbiAgICAgICAgVG9PYmplY3Q6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICBpZiAobyA9PSBudWxsKSB7IC8vIHRoaXMgbWF0Y2hlcyBib3RoIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJE9iamVjdChvKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvVWludDMyICovXG4gICAgICAgIFRvVWludDMyOiBmdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgICAgICAgICByZXR1cm4geCA+Pj4gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIEZ1bmN0aW9uXG4gICAgLy8gPT09PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVMtNSAxNS4zLjQuNVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbiAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuXG4gICAgZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgICAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgICAgIHZhciBib3VuZDtcbiAgICAgICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjIgW1tDb25zdHJ1Y3RdXVxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBJZiB0YXJnZXQgaGFzIG5vIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLCBhXG4gICAgICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhcHBseS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X2NvbmNhdC5jYWxsKGFyZ3MsIGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBseS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X2NvbmNhdC5jYWxsKGFyZ3MsIGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgICAgIHZhciBib3VuZExlbmd0aCA9IG1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheV9wdXNoLmNhbGwoYm91bmRBcmdzLCAnJCcgKyBpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgQ29udGVudCBTZWN1cml0eSBQb2xpY2llcyBlbmFibGVkIChDaHJvbWUgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgICAgICAvLyBhbmQgc28gdGhpcyBjb2RlIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQuXG4gICAgICAgICAgICBib3VuZCA9ICRGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGFycmF5X2pvaW4uY2FsbChib3VuZEFyZ3MsICcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgICAgICAvLyAyMC4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAgICAgLy8gICBmYWxzZS5cbiAgICAgICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAgICAgLy8gICBbW1NldF1dOiB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSxcbiAgICAgICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyBOT1RFIEZ1bmN0aW9uIG9iamVjdHMgY3JlYXRlZCB1c2luZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBkbyBub3RcbiAgICAgICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgICAgIC8vIFhYWCBjYW4ndCBkZWxldGUgcHJvdG90eXBlIGluIHB1cmUtanMuXG5cbiAgICAgICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgICAgIHJldHVybiBib3VuZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gX1BsZWFzZSBub3RlOiBTaG9ydGN1dHMgYXJlIGRlZmluZWQgYWZ0ZXIgYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBhcyB3ZVxuICAgIC8vIHVzZSBpdCBpbiBkZWZpbmluZyBzaG9ydGN1dHMuXG4gICAgdmFyIG93bnMgPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiAgICB2YXIgdG9TdHIgPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nKTtcbiAgICB2YXIgYXJyYXlTbGljZSA9IGNhbGwuYmluZChhcnJheV9zbGljZSk7XG4gICAgdmFyIGFycmF5U2xpY2VBcHBseSA9IGFwcGx5LmJpbmQoYXJyYXlfc2xpY2UpO1xuICAgIHZhciBzdHJTbGljZSA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuc2xpY2UpO1xuICAgIHZhciBzdHJTcGxpdCA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuc3BsaXQpO1xuICAgIHZhciBzdHJJbmRleE9mID0gY2FsbC5iaW5kKFN0cmluZ1Byb3RvdHlwZS5pbmRleE9mKTtcbiAgICB2YXIgcHVzaENhbGwgPSBjYWxsLmJpbmQoYXJyYXlfcHVzaCk7XG4gICAgdmFyIGlzRW51bSA9IGNhbGwuYmluZChPYmplY3RQcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xuICAgIHZhciBhcnJheVNvcnQgPSBjYWxsLmJpbmQoQXJyYXlQcm90b3R5cGUuc29ydCk7XG5cbiAgICAvL1xuICAgIC8vIEFycmF5XG4gICAgLy8gPT09PT1cbiAgICAvL1xuXG4gICAgdmFyIGlzQXJyYXkgPSAkQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgLy8gRVM1IDE1LjQuNC4xMlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xM1xuICAgIC8vIFJldHVybiBsZW4rYXJnQ291bnQuXG4gICAgLy8gW2J1Z2ZpeCwgaWVsdDhdXG4gICAgLy8gSUUgPCA4IGJ1ZzogW10udW5zaGlmdCgwKSA9PT0gdW5kZWZpbmVkIGJ1dCBzaG91bGQgYmUgXCIxXCJcbiAgICB2YXIgaGFzVW5zaGlmdFJldHVyblZhbHVlQnVnID0gW10udW5zaGlmdCgwKSAhPT0gMTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFycmF5X3Vuc2hpZnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sIGhhc1Vuc2hpZnRSZXR1cm5WYWx1ZUJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuNC4zLjJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKCRBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG4gICAgLy8gVGhlIElzQ2FsbGFibGUoKSBjaGVjayBpbiB0aGUgQXJyYXkgZnVuY3Rpb25zXG4gICAgLy8gaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHN0cmljdCBjaGVjayBvbiB0aGVcbiAgICAvLyBpbnRlcm5hbCBjbGFzcyBvZiB0aGUgb2JqZWN0IHRvIHRyYXAgY2FzZXMgd2hlcmVcbiAgICAvLyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2FzIGFjdHVhbGx5IGEgcmVndWxhclxuICAgIC8vIGV4cHJlc3Npb24gbGl0ZXJhbCwgd2hpY2ggaW4gVjggYW5kXG4gICAgLy8gSmF2YVNjcmlwdENvcmUgaXMgYSB0eXBlb2YgXCJmdW5jdGlvblwiLiAgT25seSBpblxuICAgIC8vIFY4IGFyZSByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHMgcGVybWl0dGVkIGFzXG4gICAgLy8gcmVkdWNlIHBhcmFtZXRlcnMsIHNvIGl0IGlzIGRlc2lyYWJsZSBpbiB0aGVcbiAgICAvLyBnZW5lcmFsIGNhc2UgZm9yIHRoZSBzaGltIHRvIG1hdGNoIHRoZSBtb3JlXG4gICAgLy8gc3RyaWN0IGFuZCBjb21tb24gYmVoYXZpb3Igb2YgcmVqZWN0aW5nIHJlZ3VsYXJcbiAgICAvLyBleHByZXNzaW9ucy5cblxuICAgIC8vIEVTNSAxNS40LjQuMThcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMThcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9hcnJheS9mb3JFYWNoXG5cbiAgICAvLyBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KVxuICAgIC8vIGFuZCBmYWlsdXJlIG9mIGAwIGluIGJveGVkU3RyaW5nYCAoUmhpbm8pXG4gICAgdmFyIGJveGVkU3RyaW5nID0gJE9iamVjdCgnYScpO1xuICAgIHZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcblxuICAgIHZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgICAgIHZhciBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgICAgICB2YXIgdGhyZXdFeGNlcHRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtZXRob2QuY2FsbCgnZm9vJywgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgIH0sICd4Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyZXdFeGNlcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIW1ldGhvZCAmJiAhdGhyZXdFeGNlcHRpb24gJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xuICAgIH07XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBUO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5mb3JFYWNoIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTlcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTlcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L21hcFxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICRBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgdmFyIFQ7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLm1hcCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLm1hcCkpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4yMFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvZmlsdGVyXG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmlsdGVyIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGZbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFja2ZuKHZhbHVlLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHZhbHVlLCBpLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZmlsdGVyKSk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjE2XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE2XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZXZlcnlcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgVDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZXZlcnkgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmICEodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5ldmVyeSkpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4xN1xuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xN1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWVcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbi8qLCB0aGlzQXJnICovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBUO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5zb21lIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5zb21lKSk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjIxXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIxXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9yZWR1Y2VcbiAgICB2YXIgcmVkdWNlQ29lcmNlc1RvT2JqZWN0ID0gZmFsc2U7XG4gICAgaWYgKEFycmF5UHJvdG90eXBlLnJlZHVjZSkge1xuICAgICAgICByZWR1Y2VDb2VyY2VzVG9PYmplY3QgPSB0eXBlb2YgQXJyYXlQcm90b3R5cGUucmVkdWNlLmNhbGwoJ2VzNScsIGZ1bmN0aW9uIChfLCBfXywgX19fLCBsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfSkgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4vKiwgaW5pdGlhbFZhbHVlKi8pIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUgYW5kIGFuIGVtcHR5IGFycmF5XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGZbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYXJyYXkgY29udGFpbnMgbm8gdmFsdWVzLCBubyBpbml0aWFsIHZhbHVlIHRvIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoKytpID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrZm4ocmVzdWx0LCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sICFyZWR1Y2VDb2VyY2VzVG9PYmplY3QpO1xuXG4gICAgLy8gRVM1IDE1LjQuNC4yMlxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvcmVkdWNlUmlnaHRcbiAgICB2YXIgcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QgPSBmYWxzZTtcbiAgICBpZiAoQXJyYXlQcm90b3R5cGUucmVkdWNlUmlnaHQpIHtcbiAgICAgICAgcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QgPSB0eXBlb2YgQXJyYXlQcm90b3R5cGUucmVkdWNlUmlnaHQuY2FsbCgnZXM1JywgZnVuY3Rpb24gKF8sIF9fLCBfX18sIGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9KSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4vKiwgaW5pdGlhbCovKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUsIGVtcHR5IGFycmF5XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHZhciBpID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpLS1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFja2ZuKHJlc3VsdCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSwgIXJlZHVjZVJpZ2h0Q29lcmNlc1RvT2JqZWN0KTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG4gICAgdmFyIGhhc0ZpcmVmb3gySW5kZXhPZkJ1ZyA9IEFycmF5UHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50LyosIGZyb21JbmRleCAqLykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaSA9IEVTLlRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBtYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuNC40LjE1XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE1XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGFzdEluZGV4T2ZcbiAgICB2YXIgaGFzRmlyZWZveDJMYXN0SW5kZXhPZkJ1ZyA9IEFycmF5UHJvdG90eXBlLmxhc3RJbmRleE9mICYmIFswLCAxXS5sYXN0SW5kZXhPZigwLCAtMykgIT09IC0xO1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQvKiwgZnJvbUluZGV4ICovKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSBsZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaSA9IG1pbihpLCBFUy5Ub0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBsZW5ndGggLSBNYXRoLmFicyhpKTtcbiAgICAgICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VhcmNoRWxlbWVudCA9PT0gc2VsZltpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9LCBoYXNGaXJlZm94Mkxhc3RJbmRleE9mQnVnKTtcblxuICAgIC8vIEVTNSAxNS40LjQuMTJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTJcbiAgICB2YXIgc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSBbMSwgMl07XG4gICAgICAgIHZhciByZXN1bHQgPSBhLnNwbGljZSgpO1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IDIgJiYgaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPT09IDA7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIC8vIFNhZmFyaSA1LjAgYnVnIHdoZXJlIC5zcGxpY2UoKSByZXR1cm5zIHVuZGVmaW5lZFxuICAgICAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlfc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCAhc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5KTtcblxuICAgIHZhciBzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgQXJyYXlQcm90b3R5cGUuc3BsaWNlLmNhbGwob2JqLCAwLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIG9iai5sZW5ndGggPT09IDE7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbWF4KEVTLlRvSW50ZWdlcih0aGlzLmxlbmd0aCksIDApO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBkZWxldGVDb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwoYXJncywgdGhpcy5sZW5ndGggLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSA9IEVTLlRvSW50ZWdlcihkZWxldGVDb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH0sICFzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCk7XG4gICAgdmFyIHNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMjk1XG4gICAgICAgIC8vIFNhZmFyaSA3LzggYnJlYWtzIHdpdGggc3BhcnNlIGFycmF5cyBvZiBzaXplIDFlNSBvciBncmVhdGVyXG4gICAgICAgIHZhciBhcnIgPSBuZXcgJEFycmF5KDFlNSk7XG4gICAgICAgIC8vIG5vdGU6IHRoZSBpbmRleCBNVVNUIGJlIDggb3IgbGFyZ2VyIG9yIHRoZSB0ZXN0IHdpbGwgZmFsc2UgcGFzc1xuICAgICAgICBhcnJbOF0gPSAneCc7XG4gICAgICAgIGFyci5zcGxpY2UoMSwgMSk7XG4gICAgICAgIC8vIG5vdGU6IHRoaXMgdGVzdCBtdXN0IGJlIGRlZmluZWQgKmFmdGVyKiB0aGUgaW5kZXhPZiBzaGltXG4gICAgICAgIC8vIHBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzMxM1xuICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YoJ3gnKSA9PT0gNztcbiAgICB9KCkpO1xuICAgIHZhciBzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzI5NVxuICAgICAgICAvLyBPcGVyYSAxMi4xNSBicmVha3Mgb24gdGhpcywgbm8gaWRlYSB3aHkuXG4gICAgICAgIHZhciBuID0gMjU2O1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIGFycltuXSA9ICdhJztcbiAgICAgICAgYXJyLnNwbGljZShuICsgMSwgMCwgJ2InKTtcbiAgICAgICAgcmV0dXJuIGFycltuXSA9PT0gJ2EnO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBPID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgQSA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IEVTLlRvVWludDMyKE8ubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gRVMuVG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxTdGFydCA9IHJlbGF0aXZlU3RhcnQgPCAwID8gbWF4KChsZW4gKyByZWxhdGl2ZVN0YXJ0KSwgMCkgOiBtaW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgoRVMuVG9JbnRlZ2VyKGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcblxuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgdmFyIGZyb207XG4gICAgICAgICAgICB3aGlsZSAoayA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9ICRTdHJpbmcoYWN0dWFsU3RhcnQgKyBrKTtcbiAgICAgICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBBW2tdID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgayArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICB2YXIgaXRlbUNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRvO1xuICAgICAgICAgICAgaWYgKGl0ZW1Db3VudCA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgayA9IGFjdHVhbFN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBtYXhLID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPCBtYXhLKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gJFN0cmluZyhrICsgaXRlbUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG93bnMoTywgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBPW3RvXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBrICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsgPSBsZW47XG4gICAgICAgICAgICAgICAgdmFyIG1pbksgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGl0ZW1Db3VudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA+IG1pbkspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9bayAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBrIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtQ291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgICAgIGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA+IGFjdHVhbFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB0byA9ICRTdHJpbmcoayArIGl0ZW1Db3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9bdG9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrID0gYWN0dWFsU3RhcnQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgT1trXSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE8ubGVuZ3RoID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpdGVtQ291bnQ7XG5cbiAgICAgICAgICAgIHJldHVybiBBO1xuICAgICAgICB9XG4gICAgfSwgIXNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzIHx8ICFzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyk7XG5cbiAgICB2YXIgb3JpZ2luYWxKb2luID0gQXJyYXlQcm90b3R5cGUuam9pbjtcbiAgICB2YXIgaGFzU3RyaW5nSm9pbkJ1ZztcbiAgICB0cnkge1xuICAgICAgICBoYXNTdHJpbmdKb2luQnVnID0gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbCgnMTIzJywgJywnKSAhPT0gJzEsMiwzJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhc1N0cmluZ0pvaW5CdWcgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGFzU3RyaW5nSm9pbkJ1Zykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgICAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBzZXAgPSB0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyA/ICcsJyA6IHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxKb2luLmNhbGwoaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiB0aGlzLCBzZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYXNTdHJpbmdKb2luQnVnKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzSm9pblVuZGVmaW5lZEJ1ZyA9IFsxLCAyXS5qb2luKHVuZGVmaW5lZCkgIT09ICcxLDInO1xuICAgIGlmIChoYXNKb2luVW5kZWZpbmVkQnVnKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcCA9IHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnID8gJywnIDogc2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEpvaW4uY2FsbCh0aGlzLCBzZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYXNKb2luVW5kZWZpbmVkQnVnKTtcbiAgICB9XG5cbiAgICB2YXIgcHVzaFNoaW0gPSBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICAgICAgdmFyIE8gPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIG4gPSBFUy5Ub1VpbnQzMihPLmxlbmd0aCk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBPW24gKyBpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBPLmxlbmd0aCA9IG4gKyBpO1xuICAgICAgICByZXR1cm4gbiArIGk7XG4gICAgfTtcblxuICAgIHZhciBwdXNoSXNOb3RHZW5lcmljID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnB1c2guY2FsbChvYmosIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgb2JqLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2Ygb2JqWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhvYmosIDApO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5X3B1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdXNoU2hpbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSwgcHVzaElzTm90R2VuZXJpYyk7XG5cbiAgICAvLyBUaGlzIGZpeGVzIGEgdmVyeSB3ZWlyZCBidWcgaW4gT3BlcmEgMTAuNiB3aGVuIHB1c2hpbmcgYHVuZGVmaW5lZFxuICAgIHZhciBwdXNoVW5kZWZpbmVkSXNXZWlyZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFyci5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgYXJyLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgYXJyWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhhcnIsIDApO1xuICAgIH0oKSk7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwgeyBwdXNoOiBwdXNoU2hpbSB9LCBwdXNoVW5kZWZpbmVkSXNXZWlyZCk7XG5cbiAgICAvLyBFUzUgMTUuMi4zLjE0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMTBcbiAgICAvLyBGaXggYm94ZWQgc3RyaW5nIGJ1Z1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgc2xpY2U6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5U2xpY2VBcHBseShhcnIsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LCBzcGxpdFN0cmluZyk7XG5cbiAgICB2YXIgc29ydElnbm9yZXNOb25GdW5jdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWzEsIDJdLnNvcnQobnVsbCk7XG4gICAgICAgICAgICBbMSwgMl0uc29ydCh7fSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0oKSk7XG4gICAgdmFyIHNvcnRUaHJvd3NPblJlZ2V4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIHByb2JsZW0gaW4gRmlyZWZveCA0LCBpbiB3aGljaCBgdHlwZW9mIC9hLyA9PT0gJ2Z1bmN0aW9uJ2BcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFsxLCAyXS5zb3J0KC9hLyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0oKSk7XG4gICAgdmFyIHNvcnRJZ25vcmVzVW5kZWZpbmVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYXBwbGllcyBpbiBJRSA4LCBmb3Igb25lLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWzEsIDJdLnNvcnQodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZUZuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmVGbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlTb3J0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNvbXBhcmVGbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuc29ydCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheVNvcnQodGhpcywgY29tcGFyZUZuKTtcbiAgICAgICAgfVxuICAgIH0sIHNvcnRJZ25vcmVzTm9uRnVuY3Rpb25zIHx8ICFzb3J0SWdub3Jlc1VuZGVmaW5lZCB8fCAhc29ydFRocm93c09uUmVnZXgpO1xuXG4gICAgLy9cbiAgICAvLyBPYmplY3RcbiAgICAvLyA9PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVM1IDE1LjIuMy4xNFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xNFxuXG4gICAgLy8gaHR0cDovL3doYXR0aGVoZWFkc2FpZC5jb20vMjAxMC8xMC9hLXNhZmVyLW9iamVjdC1rZXlzLWNvbXBhdGliaWxpdHktaW1wbGVtZW50YXRpb25cbiAgICB2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtKHsgJ3RvU3RyaW5nJzogbnVsbCB9LCAndG9TdHJpbmcnKTtcbiAgICB2YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG4gICAgdmFyIGhhc1N0cmluZ0VudW1CdWcgPSAhb3ducygneCcsICcwJyk7XG4gICAgdmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbiAgICB9O1xuICAgIHZhciBibGFja2xpc3RlZEtleXMgPSB7XG4gICAgICAgICR3aW5kb3c6IHRydWUsXG4gICAgICAgICRjb25zb2xlOiB0cnVlLFxuICAgICAgICAkcGFyZW50OiB0cnVlLFxuICAgICAgICAkc2VsZjogdHJ1ZSxcbiAgICAgICAgJGZyYW1lOiB0cnVlLFxuICAgICAgICAkZnJhbWVzOiB0cnVlLFxuICAgICAgICAkZnJhbWVFbGVtZW50OiB0cnVlLFxuICAgICAgICAkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuICAgICAgICAkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG4gICAgICAgICRleHRlcm5hbDogdHJ1ZVxuICAgIH07XG4gICAgdmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGdsb2JhbHMgd2luZG93ICovXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGsgaW4gd2luZG93KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghYmxhY2tsaXN0ZWRLZXlzWyckJyArIGtdICYmIG93bnMod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0oKSk7XG4gICAgdmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcbiAgICAgICAgICAgIHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZG9udEVudW1zID0gW1xuICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAndG9Mb2NhbGVTdHJpbmcnLFxuICAgICAgICAndmFsdWVPZicsXG4gICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICdpc1Byb3RvdHlwZU9mJyxcbiAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICAgJ2NvbnN0cnVjdG9yJ1xuICAgIF07XG4gICAgdmFyIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbiAgICAvLyB0YWtlbiBkaXJlY3RseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvaXMtYXJndW1lbnRzL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gICAgLy8gY2FuIGJlIHJlcGxhY2VkIHdpdGggcmVxdWlyZSgnaXMtYXJndW1lbnRzJykgaWYgd2UgZXZlciB1c2UgYSBidWlsZCBwcm9jZXNzIGluc3RlYWRcbiAgICB2YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cih2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuICAgIH07XG4gICAgdmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICAgICAgICFpc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICAgICAgaXNDYWxsYWJsZSh2YWx1ZS5jYWxsZWUpO1xuICAgIH07XG4gICAgdmFyIGlzQXJndW1lbnRzID0gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuXG4gICAgZGVmaW5lUHJvcGVydGllcygkT2JqZWN0LCB7XG4gICAgICAgIGtleXM6IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaXNGbiA9IGlzQ2FsbGFibGUob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciBpc0FyZ3MgPSBpc0FyZ3VtZW50cyhvYmplY3QpO1xuICAgICAgICAgICAgdmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuICAgICAgICAgICAgdmFyIGlzU3RyID0gaXNPYmplY3QgJiYgaXNTdHJpbmcob2JqZWN0KTtcblxuICAgICAgICAgICAgaWYgKCFpc09iamVjdCAmJiAhaXNGbiAmJiAhaXNBcmdzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGhlS2V5cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0ZuO1xuICAgICAgICAgICAgaWYgKChpc1N0ciAmJiBoYXNTdHJpbmdFbnVtQnVnKSB8fCBpc0FyZ3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbCh0aGVLZXlzLCAkU3RyaW5nKGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNBcmdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBvd25zKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKHRoZUtleXMsICRTdHJpbmcobmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb250RW51bXNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9udEVudW0gPSBkb250RW51bXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgb3ducyhvYmplY3QsIGRvbnRFbnVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwodGhlS2V5cywgZG9udEVudW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoZUtleXM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gJE9iamVjdC5rZXlzICYmIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNhZmFyaSA1LjAgYnVnXG4gICAgICAgIHJldHVybiAkT2JqZWN0LmtleXMoYXJndW1lbnRzKS5sZW5ndGggPT09IDI7XG4gICAgfSgxLCAyKSk7XG4gICAgdmFyIGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcgPSAkT2JqZWN0LmtleXMgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ0tleXMgPSAkT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggIT09IDEgfHwgYXJnS2V5cy5sZW5ndGggIT09IDEgfHwgYXJnS2V5c1swXSAhPT0gMTtcbiAgICB9KDEpKTtcbiAgICB2YXIgb3JpZ2luYWxLZXlzID0gJE9iamVjdC5rZXlzO1xuICAgIGRlZmluZVByb3BlcnRpZXMoJE9iamVjdCwge1xuICAgICAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxLZXlzKGFycmF5U2xpY2Uob2JqZWN0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sICFrZXlzV29ya3NXaXRoQXJndW1lbnRzIHx8IGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcpO1xuXG4gICAgLy9cbiAgICAvLyBEYXRlXG4gICAgLy8gPT09PVxuICAgIC8vXG5cbiAgICB2YXIgaGFzTmVnYXRpdmVNb250aFllYXJCdWcgPSBuZXcgRGF0ZSgtMzUwOTgyNzMyOTYwMDI5MikuZ2V0VVRDTW9udGgoKSAhPT0gMDtcbiAgICB2YXIgYU5lZ2F0aXZlVGVzdERhdGUgPSBuZXcgRGF0ZSgtMTUwOTg0MjI4OTYwMDI5Mik7XG4gICAgdmFyIGFQb3NpdGl2ZVRlc3REYXRlID0gbmV3IERhdGUoMTQ0OTY2MjQwMDAwMCk7XG4gICAgdmFyIGhhc1RvVVRDU3RyaW5nRm9ybWF0QnVnID0gYU5lZ2F0aXZlVGVzdERhdGUudG9VVENTdHJpbmcoKSAhPT0gJ01vbiwgMDEgSmFuIC00NTg3NSAxMTo1OTo1OSBHTVQnO1xuICAgIHZhciBoYXNUb0RhdGVTdHJpbmdGb3JtYXRCdWc7XG4gICAgdmFyIGhhc1RvU3RyaW5nRm9ybWF0QnVnO1xuICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IGFOZWdhdGl2ZVRlc3REYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgaWYgKHRpbWVab25lT2Zmc2V0IDwgLTcyMCkge1xuICAgICAgICBoYXNUb0RhdGVTdHJpbmdGb3JtYXRCdWcgPSBhTmVnYXRpdmVUZXN0RGF0ZS50b0RhdGVTdHJpbmcoKSAhPT0gJ1R1ZSBKYW4gMDIgLTQ1ODc1JztcbiAgICAgICAgaGFzVG9TdHJpbmdGb3JtYXRCdWcgPSAhKC9eVGh1IERlYyAxMCAyMDE1IFxcZFxcZDpcXGRcXGQ6XFxkXFxkIEdNVFstXFwrXVxcZFxcZFxcZFxcZCg/OiB8JCkvKS50ZXN0KGFQb3NpdGl2ZVRlc3REYXRlLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1RvRGF0ZVN0cmluZ0Zvcm1hdEJ1ZyA9IGFOZWdhdGl2ZVRlc3REYXRlLnRvRGF0ZVN0cmluZygpICE9PSAnTW9uIEphbiAwMSAtNDU4NzUnO1xuICAgICAgICBoYXNUb1N0cmluZ0Zvcm1hdEJ1ZyA9ICEoL15XZWQgRGVjIDA5IDIwMTUgXFxkXFxkOlxcZFxcZDpcXGRcXGQgR01UWy1cXCtdXFxkXFxkXFxkXFxkKD86IHwkKS8pLnRlc3QoYVBvc2l0aXZlVGVzdERhdGUudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgdmFyIG9yaWdpbmFsR2V0RnVsbFllYXIgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0RnVsbFllYXIpO1xuICAgIHZhciBvcmlnaW5hbEdldE1vbnRoID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldE1vbnRoKTtcbiAgICB2YXIgb3JpZ2luYWxHZXREYXRlID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldERhdGUpO1xuICAgIHZhciBvcmlnaW5hbEdldFVUQ0Z1bGxZZWFyID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldFVUQ0Z1bGxZZWFyKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENNb250aCA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENNb250aCk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDRGF0ZSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENEYXRlKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENEYXkgPSBjYWxsLmJpbmQoRGF0ZS5wcm90b3R5cGUuZ2V0VVRDRGF5KTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENIb3VycyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENIb3Vycyk7XG4gICAgdmFyIG9yaWdpbmFsR2V0VVRDTWludXRlcyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENNaW51dGVzKTtcbiAgICB2YXIgb3JpZ2luYWxHZXRVVENTZWNvbmRzID0gY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldFVUQ1NlY29uZHMpO1xuICAgIHZhciBvcmlnaW5hbEdldFVUQ01pbGxpc2Vjb25kcyA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRVVENNaWxsaXNlY29uZHMpO1xuICAgIHZhciBkYXlOYW1lID0gWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXTtcbiAgICB2YXIgbW9udGhOYW1lID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xuICAgIHZhciBkYXlzSW5Nb250aCA9IGZ1bmN0aW9uIGRheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEdldERhdGUobmV3IERhdGUoeWVhciwgbW9udGgsIDApKTtcbiAgICB9O1xuXG4gICAgZGVmaW5lUHJvcGVydGllcyhEYXRlLnByb3RvdHlwZSwge1xuICAgICAgICBnZXRGdWxsWWVhcjogZnVuY3Rpb24gZ2V0RnVsbFllYXIoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldEZ1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHllYXIgPCAwICYmIG9yaWdpbmFsR2V0TW9udGgodGhpcykgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5ZWFyICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5ZWFyO1xuICAgICAgICB9LFxuICAgICAgICBnZXRNb250aDogZnVuY3Rpb24gZ2V0TW9udGgoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldEZ1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRNb250aCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBtb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERhdGU6IGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHllYXIgPSBvcmlnaW5hbEdldEZ1bGxZZWFyKHRoaXMpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRNb250aCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBkYXRlID0gb3JpZ2luYWxHZXREYXRlKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHllYXIgPCAwICYmIG1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGF5cyA9IGRheXNJbk1vbnRoKDAsIHllYXIgKyAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRheXMgLSBkYXRlKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VVRDRnVsbFllYXI6IGZ1bmN0aW9uIGdldFVUQ0Z1bGxZZWFyKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBvcmlnaW5hbEdldFVUQ01vbnRoKHRoaXMpID4gMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWVhciArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWVhcjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VVRDTW9udGg6IGZ1bmN0aW9uIGdldFVUQ01vbnRoKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgICAgICBpZiAoeWVhciA8IDAgJiYgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgICAgICB9LFxuICAgICAgICBnZXRVVENEYXRlOiBmdW5jdGlvbiBnZXRVVENEYXRlKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBub3QgYSBEYXRlIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsR2V0VVRDRGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgMCAmJiBtb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRheXMgPSBkYXlzSW5Nb250aCgwLCB5ZWFyICsgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkYXlzIC0gZGF0ZSkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICB9LCBoYXNOZWdhdGl2ZU1vbnRoWWVhckJ1Zyk7XG5cbiAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGUucHJvdG90eXBlLCB7XG4gICAgICAgIHRvVVRDU3RyaW5nOiBmdW5jdGlvbiB0b1VUQ1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgbm90IGEgRGF0ZSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF5ID0gb3JpZ2luYWxHZXRVVENEYXkodGhpcyk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsR2V0VVRDRGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHZhciBtb250aCA9IG9yaWdpbmFsR2V0VVRDTW9udGgodGhpcyk7XG4gICAgICAgICAgICB2YXIgeWVhciA9IG9yaWdpbmFsR2V0VVRDRnVsbFllYXIodGhpcyk7XG4gICAgICAgICAgICB2YXIgaG91ciA9IG9yaWdpbmFsR2V0VVRDSG91cnModGhpcyk7XG4gICAgICAgICAgICB2YXIgbWludXRlID0gb3JpZ2luYWxHZXRVVENNaW51dGVzKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlY29uZCA9IG9yaWdpbmFsR2V0VVRDU2Vjb25kcyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBkYXlOYW1lW2RheV0gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAoZGF0ZSA8IDEwID8gJzAnICsgZGF0ZSA6IGRhdGUpICsgJyAnICtcbiAgICAgICAgICAgICAgICBtb250aE5hbWVbbW9udGhdICsgJyAnICtcbiAgICAgICAgICAgICAgICB5ZWFyICsgJyAnICtcbiAgICAgICAgICAgICAgICAoaG91ciA8IDEwID8gJzAnICsgaG91ciA6IGhvdXIpICsgJzonICtcbiAgICAgICAgICAgICAgICAobWludXRlIDwgMTAgPyAnMCcgKyBtaW51dGUgOiBtaW51dGUpICsgJzonICtcbiAgICAgICAgICAgICAgICAoc2Vjb25kIDwgMTAgPyAnMCcgKyBzZWNvbmQgOiBzZWNvbmQpICsgJyBHTVQnO1xuICAgICAgICB9XG4gICAgfSwgaGFzTmVnYXRpdmVNb250aFllYXJCdWcgfHwgaGFzVG9VVENTdHJpbmdGb3JtYXRCdWcpO1xuXG4gICAgLy8gT3BlcmEgMTIgaGFzIGAsYFxuICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICAgICAgdG9EYXRlU3RyaW5nOiBmdW5jdGlvbiB0b0RhdGVTdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheSA9IHRoaXMuZ2V0RGF5KCk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5nZXRNb250aCgpO1xuICAgICAgICAgICAgdmFyIHllYXIgPSB0aGlzLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICByZXR1cm4gZGF5TmFtZVtkYXldICsgJyAnICtcbiAgICAgICAgICAgICAgICBtb250aE5hbWVbbW9udGhdICsgJyAnICtcbiAgICAgICAgICAgICAgICAoZGF0ZSA8IDEwID8gJzAnICsgZGF0ZSA6IGRhdGUpICsgJyAnICtcbiAgICAgICAgICAgICAgICB5ZWFyO1xuICAgICAgICB9XG4gICAgfSwgaGFzTmVnYXRpdmVNb250aFllYXJCdWcgfHwgaGFzVG9EYXRlU3RyaW5nRm9ybWF0QnVnKTtcblxuICAgIC8vIGNhbid0IHVzZSBkZWZpbmVQcm9wZXJ0aWVzIGhlcmUgYmVjYXVzZSBvZiB0b1N0cmluZyBlbnVtZXJhdGlvbiBpc3N1ZSBpbiBJRSA8PSA4XG4gICAgaWYgKGhhc05lZ2F0aXZlTW9udGhZZWFyQnVnIHx8IGhhc1RvU3RyaW5nRm9ybWF0QnVnKSB7XG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMgfHwgISh0aGlzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIG5vdCBhIERhdGUgb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheSA9IHRoaXMuZ2V0RGF5KCk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgdmFyIG1vbnRoID0gdGhpcy5nZXRNb250aCgpO1xuICAgICAgICAgICAgdmFyIHllYXIgPSB0aGlzLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICB2YXIgaG91ciA9IHRoaXMuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgIHZhciBtaW51dGUgPSB0aGlzLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgIHZhciBzZWNvbmQgPSB0aGlzLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgIHZhciB0aW1lem9uZU9mZnNldCA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBob3Vyc09mZnNldCA9IE1hdGguZmxvb3IoTWF0aC5hYnModGltZXpvbmVPZmZzZXQpIC8gNjApO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZXNPZmZzZXQgPSBNYXRoLmZsb29yKE1hdGguYWJzKHRpbWV6b25lT2Zmc2V0KSAlIDYwKTtcbiAgICAgICAgICAgIHJldHVybiBkYXlOYW1lW2RheV0gKyAnICcgK1xuICAgICAgICAgICAgICAgIG1vbnRoTmFtZVttb250aF0gKyAnICcgK1xuICAgICAgICAgICAgICAgIChkYXRlIDwgMTAgPyAnMCcgKyBkYXRlIDogZGF0ZSkgKyAnICcgK1xuICAgICAgICAgICAgICAgIHllYXIgKyAnICcgK1xuICAgICAgICAgICAgICAgIChob3VyIDwgMTAgPyAnMCcgKyBob3VyIDogaG91cikgKyAnOicgK1xuICAgICAgICAgICAgICAgIChtaW51dGUgPCAxMCA/ICcwJyArIG1pbnV0ZSA6IG1pbnV0ZSkgKyAnOicgK1xuICAgICAgICAgICAgICAgIChzZWNvbmQgPCAxMCA/ICcwJyArIHNlY29uZCA6IHNlY29uZCkgKyAnIEdNVCcgK1xuICAgICAgICAgICAgICAgICh0aW1lem9uZU9mZnNldCA+IDAgPyAnLScgOiAnKycpICtcbiAgICAgICAgICAgICAgICAoaG91cnNPZmZzZXQgPCAxMCA/ICcwJyArIGhvdXJzT2Zmc2V0IDogaG91cnNPZmZzZXQpICtcbiAgICAgICAgICAgICAgICAobWludXRlc09mZnNldCA8IDEwID8gJzAnICsgbWludXRlc09mZnNldCA6IG1pbnV0ZXNPZmZzZXQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuOS41LjQzXG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS41LjQzXG4gICAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgU3RyaW5nIHZhbHVlIHJlcHJlc2VudCB0aGUgaW5zdGFuY2UgaW4gdGltZVxuICAgIC8vIHJlcHJlc2VudGVkIGJ5IHRoaXMgRGF0ZSBvYmplY3QuIFRoZSBmb3JtYXQgb2YgdGhlIFN0cmluZyBpcyB0aGUgRGF0ZSBUaW1lXG4gICAgLy8gc3RyaW5nIGZvcm1hdCBkZWZpbmVkIGluIDE1LjkuMS4xNS4gQWxsIGZpZWxkcyBhcmUgcHJlc2VudCBpbiB0aGUgU3RyaW5nLlxuICAgIC8vIFRoZSB0aW1lIHpvbmUgaXMgYWx3YXlzIFVUQywgZGVub3RlZCBieSB0aGUgc3VmZml4IFouIElmIHRoZSB0aW1lIHZhbHVlIG9mXG4gICAgLy8gdGhpcyBvYmplY3QgaXMgbm90IGEgZmluaXRlIE51bWJlciBhIFJhbmdlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICB2YXIgbmVnYXRpdmVEYXRlID0gLTYyMTk4NzU1MjAwMDAwO1xuICAgIHZhciBuZWdhdGl2ZVllYXJTdHJpbmcgPSAnLTAwMDAwMSc7XG4gICAgdmFyIGhhc05lZ2F0aXZlRGF0ZUJ1ZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmIG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9JU09TdHJpbmcoKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgPT09IC0xO1xuICAgIHZhciBoYXNTYWZhcmk1MURhdGVCdWcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiBuZXcgRGF0ZSgtMSkudG9JU09TdHJpbmcoKSAhPT0gJzE5NjktMTItMzFUMjM6NTk6NTkuOTk5Wic7XG5cbiAgICB2YXIgZ2V0VGltZSA9IGNhbGwuYmluZChEYXRlLnByb3RvdHlwZS5nZXRUaW1lKTtcblxuICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICAgICAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZSh0aGlzKSB8fCAhaXNGaW5pdGUoZ2V0VGltZSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBZG9wZSBQaG90b3Nob3AgcmVxdWlyZXMgdGhlIHNlY29uZCBjaGVjay5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgY2FsbGVkIG9uIG5vbi1maW5pdGUgdmFsdWUuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB5ZWFyID0gb3JpZ2luYWxHZXRVVENGdWxsWWVhcih0aGlzKTtcblxuICAgICAgICAgICAgdmFyIG1vbnRoID0gb3JpZ2luYWxHZXRVVENNb250aCh0aGlzKTtcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzExMVxuICAgICAgICAgICAgeWVhciArPSBNYXRoLmZsb29yKG1vbnRoIC8gMTIpO1xuICAgICAgICAgICAgbW9udGggPSAobW9udGggJSAxMiArIDEyKSAlIDEyO1xuXG4gICAgICAgICAgICAvLyB0aGUgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQgaXMgc3BlY2lmaWVkIGluIDE1LjkuMS4xNS5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbbW9udGggKyAxLCBvcmlnaW5hbEdldFVUQ0RhdGUodGhpcyksIG9yaWdpbmFsR2V0VVRDSG91cnModGhpcyksIG9yaWdpbmFsR2V0VVRDTWludXRlcyh0aGlzKSwgb3JpZ2luYWxHZXRVVENTZWNvbmRzKHRoaXMpXTtcbiAgICAgICAgICAgIHllYXIgPSAoXG4gICAgICAgICAgICAgICAgKHllYXIgPCAwID8gJy0nIDogKHllYXIgPiA5OTk5ID8gJysnIDogJycpKSArXG4gICAgICAgICAgICAgICAgc3RyU2xpY2UoJzAwMDAwJyArIE1hdGguYWJzKHllYXIpLCAoMCA8PSB5ZWFyICYmIHllYXIgPD0gOTk5OSkgPyAtNCA6IC02KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBwYWQgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgdG8gaGF2ZSB0d28gZGlnaXRzLlxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHN0clNsaWNlKCcwMCcgKyByZXN1bHRbaV0sIC0yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBhZCBtaWxsaXNlY29uZHMgdG8gaGF2ZSB0aHJlZSBkaWdpdHMuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHllYXIgKyAnLScgKyBhcnJheVNsaWNlKHJlc3VsdCwgMCwgMikuam9pbignLScpICtcbiAgICAgICAgICAgICAgICAnVCcgKyBhcnJheVNsaWNlKHJlc3VsdCwgMikuam9pbignOicpICsgJy4nICtcbiAgICAgICAgICAgICAgICBzdHJTbGljZSgnMDAwJyArIG9yaWdpbmFsR2V0VVRDTWlsbGlzZWNvbmRzKHRoaXMpLCAtMykgKyAnWidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LCBoYXNOZWdhdGl2ZURhdGVCdWcgfHwgaGFzU2FmYXJpNTFEYXRlQnVnKTtcblxuICAgIC8vIEVTNSAxNS45LjUuNDRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjUuNDRcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRGF0ZSBvYmplY3QgZm9yIHVzZSBieVxuICAgIC8vIEpTT04uc3RyaW5naWZ5ICgxNS4xMi4zKS5cbiAgICB2YXIgZGF0ZVRvSlNPTklzU3VwcG9ydGVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b0pTT04gJiZcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsICYmXG4gICAgICAgICAgICAgICAgbmV3IERhdGUobmVnYXRpdmVEYXRlKS50b0pTT04oKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoeyAvLyBnZW5lcmljXG4gICAgICAgICAgICAgICAgICAgIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG4gICAgaWYgKCFkYXRlVG9KU09OSXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgdG9KU09OIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCBhcmd1bWVudCBrZXksIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcblxuICAgICAgICAgICAgLy8gMS4gIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCwgZ2l2aW5nIGl0IHRoZSB0aGlzXG4gICAgICAgICAgICAvLyB2YWx1ZSBhcyBpdHMgYXJndW1lbnQuXG4gICAgICAgICAgICAvLyAyLiBMZXQgdHYgYmUgRVMuVG9QcmltaXRpdmUoTywgaGludCBOdW1iZXIpLlxuICAgICAgICAgICAgdmFyIE8gPSAkT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHR2ID0gRVMuVG9QcmltaXRpdmUoTyk7XG4gICAgICAgICAgICAvLyAzLiBJZiB0diBpcyBhIE51bWJlciBhbmQgaXMgbm90IGZpbml0ZSwgcmV0dXJuIG51bGwuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR2ID09PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUodHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA0LiBMZXQgdG9JU08gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0dldF1dIGludGVybmFsIG1ldGhvZCBvZlxuICAgICAgICAgICAgLy8gTyB3aXRoIGFyZ3VtZW50IFwidG9JU09TdHJpbmdcIi5cbiAgICAgICAgICAgIHZhciB0b0lTTyA9IE8udG9JU09TdHJpbmc7XG4gICAgICAgICAgICAvLyA1LiBJZiBJc0NhbGxhYmxlKHRvSVNPKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICAgICAgaWYgKCFpc0NhbGxhYmxlKHRvSVNPKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RvSVNPU3RyaW5nIHByb3BlcnR5IGlzIG5vdCBjYWxsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mXG4gICAgICAgICAgICAvLyAgdG9JU08gd2l0aCBPIGFzIHRoZSB0aGlzIHZhbHVlIGFuZCBhbiBlbXB0eSBhcmd1bWVudCBsaXN0LlxuICAgICAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoTyk7XG5cbiAgICAgICAgICAgIC8vIE5PVEUgMSBUaGUgYXJndW1lbnQgaXMgaWdub3JlZC5cblxuICAgICAgICAgICAgLy8gTk9URSAyIFRoZSB0b0pTT04gZnVuY3Rpb24gaXMgaW50ZW50aW9uYWxseSBnZW5lcmljOyBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgLy8gcmVxdWlyZSB0aGF0IGl0cyB0aGlzIHZhbHVlIGJlIGEgRGF0ZSBvYmplY3QuIFRoZXJlZm9yZSwgaXQgY2FuIGJlXG4gICAgICAgICAgICAvLyB0cmFuc2ZlcnJlZCB0byBvdGhlciBraW5kcyBvZiBvYmplY3RzIGZvciB1c2UgYXMgYSBtZXRob2QuIEhvd2V2ZXIsXG4gICAgICAgICAgICAvLyBpdCBkb2VzIHJlcXVpcmUgdGhhdCBhbnkgc3VjaCBvYmplY3QgaGF2ZSBhIHRvSVNPU3RyaW5nIG1ldGhvZC4gQW5cbiAgICAgICAgICAgIC8vIG9iamVjdCBpcyBmcmVlIHRvIHVzZSB0aGUgYXJndW1lbnQga2V5IHRvIGZpbHRlciBpdHNcbiAgICAgICAgICAgIC8vIHN0cmluZ2lmaWNhdGlvbi5cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuOS40LjJcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuMlxuICAgIC8vIGJhc2VkIG9uIHdvcmsgc2hhcmVkIGJ5IERhbmllbCBGcmllc2VuIChkYW50bWFuKVxuICAgIC8vIGh0dHA6Ly9naXN0LmdpdGh1Yi5jb20vMzAzMjQ5XG4gICAgdmFyIHN1cHBvcnRzRXh0ZW5kZWRZZWFycyA9IERhdGUucGFyc2UoJyswMzM2NTgtMDktMjdUMDE6NDY6NDAuMDAwWicpID09PSAxZTE1O1xuICAgIHZhciBhY2NlcHRzSW52YWxpZERhdGVzID0gIWlzTmFOKERhdGUucGFyc2UoJzIwMTItMDQtMDRUMjQ6MDA6MDAuNTAwWicpKSB8fCAhaXNOYU4oRGF0ZS5wYXJzZSgnMjAxMi0xMS0zMVQyMzo1OTo1OS4wMDBaJykpIHx8ICFpc05hTihEYXRlLnBhcnNlKCcyMDEyLTEyLTMxVDIzOjU5OjYwLjAwMFonKSk7XG4gICAgdmFyIGRvZXNOb3RQYXJzZVkyS05ld1llYXIgPSBpc05hTihEYXRlLnBhcnNlKCcyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSk7XG4gICAgaWYgKGRvZXNOb3RQYXJzZVkyS05ld1llYXIgfHwgYWNjZXB0c0ludmFsaWREYXRlcyB8fCAhc3VwcG9ydHNFeHRlbmRlZFllYXJzKSB7XG4gICAgICAgIC8vIFhYWCBnbG9iYWwgYXNzaWdubWVudCB3b24ndCB3b3JrIGluIGVtYmVkZGluZ3MgdGhhdCB1c2VcbiAgICAgICAgLy8gYW4gYWx0ZXJuYXRlIG9iamVjdCBmb3IgdGhlIGNvbnRleHQuXG4gICAgICAgIC8qIGdsb2JhbCBEYXRlOiB0cnVlICovXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgICAgIHZhciBtYXhTYWZlVW5zaWduZWQzMkJpdCA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG4gICAgICAgIHZhciBoYXNTYWZhcmlTaWduZWRJbnRCdWcgPSBpc0FjdHVhbE5hTihuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCAwLCAwLCBtYXhTYWZlVW5zaWduZWQzMkJpdCArIDEpLmdldFRpbWUoKSk7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWltcGxpY2l0LWdsb2JhbHMgKi9cbiAgICAgICAgRGF0ZSA9IChmdW5jdGlvbiAoTmF0aXZlRGF0ZSkge1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWltcGxpY2l0LWdsb2JhbHMgKi9cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuICAgICAgICAgICAgLy8gRGF0ZS5sZW5ndGggPT09IDdcbiAgICAgICAgICAgIHZhciBEYXRlU2hpbSA9IGZ1bmN0aW9uIERhdGUoWSwgTSwgRCwgaCwgbSwgcywgbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE5hdGl2ZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWlsbGlzID0gbXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNTYWZhcmlTaWduZWRJbnRCdWcgJiYgbGVuZ3RoID49IDcgJiYgbXMgPiBtYXhTYWZlVW5zaWduZWQzMkJpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtcyAvIG1heFNhZmVVbnNpZ25lZDMyQml0KSAqIG1heFNhZmVVbnNpZ25lZDMyQml0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtc1RvU2hpZnQgLyAxZTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbGxpcyAtPSBzVG9TaGlmdCAqIDFlMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbGVuZ3RoID09PSAxICYmICRTdHJpbmcoWSkgPT09IFkgPyAvLyBpc1N0cmluZyhZKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZXhwbGljaXRseSBwYXNzIGl0IHRocm91Z2ggcGFyc2U6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTmF0aXZlRGF0ZShEYXRlU2hpbS5wYXJzZShZKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBtYW51YWxseSBtYWtlIGNhbGxzIGRlcGVuZGluZyBvbiBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA3ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCwgbSwgc2Vjb25kcywgbWlsbGlzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNiA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0sIHNlY29uZHMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA1ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCwgbSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDQgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gMyA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSAyID8gbmV3IE5hdGl2ZURhdGUoWSwgTSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDEgPyBuZXcgTmF0aXZlRGF0ZShZIGluc3RhbmNlb2YgTmF0aXZlRGF0ZSA/ICtZIDogWSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTmF0aXZlRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBOYXRpdmVEYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNQcmltaXRpdmUoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBtaXh1cHMgd2l0aCB1bmZpeGVkIERhdGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMoZGF0ZSwgeyBjb25zdHJ1Y3RvcjogRGF0ZVNoaW0gfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gMTUuOS4xLjE1IERhdGUgVGltZSBTdHJpbmcgRm9ybWF0LlxuICAgICAgICAgICAgdmFyIGlzb0RhdGVFeHByZXNzaW9uID0gbmV3IFJlZ0V4cCgnXicgK1xuICAgICAgICAgICAgICAgICcoXFxcXGR7NH18WystXVxcXFxkezZ9KScgKyAvLyBmb3VyLWRpZ2l0IHllYXIgY2FwdHVyZSBvciBzaWduICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDYtZGlnaXQgZXh0ZW5kZWQgeWVhclxuICAgICAgICAgICAgICAgICcoPzotKFxcXFxkezJ9KScgKyAvLyBvcHRpb25hbCBtb250aCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyg/Oi0oXFxcXGR7Mn0pJyArIC8vIG9wdGlvbmFsIGRheSBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyg/OicgKyAvLyBjYXB0dXJlIGhvdXJzOm1pbnV0ZXM6c2Vjb25kcy5taWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgJ1QoXFxcXGR7Mn0pJyArIC8vIGhvdXJzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIG1pbnV0ZXMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9wdGlvbmFsIDpzZWNvbmRzLm1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIHNlY29uZHMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OihcXFxcLlxcXFxkezEsfSkpPycgKyAvLyBtaWxsaXNlY29uZHMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKT8nICtcbiAgICAgICAgICAgICAgICAnKCcgKyAvLyBjYXB0dXJlIFVUQyBvZmZzZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICdafCcgKyAvLyBVVEMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9mZnNldCBzcGVjaWZpZXIgKy8taG91cnM6bWludXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhbLStdKScgKyAvLyBzaWduIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICcoXFxcXGR7Mn0pJyArIC8vIGhvdXJzIG9mZnNldCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gbWludXRlcyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKScgK1xuICAgICAgICAgICAgICAgICcpPyk/KT8pPycgK1xuICAgICAgICAgICAgJyQnKTtcblxuICAgICAgICAgICAgdmFyIG1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCwgMzY1XTtcblxuICAgICAgICAgICAgdmFyIGRheUZyb21Nb250aCA9IGZ1bmN0aW9uIGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gbW9udGggPiAxID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgbW9udGhzW21vbnRoXSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxOTY5ICsgdCkgLyA0KSAtXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxOTAxICsgdCkgLyAxMDApICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcigoeWVhciAtIDE2MDEgKyB0KSAvIDQwMCkgK1xuICAgICAgICAgICAgICAgICAgICAzNjUgKiAoeWVhciAtIDE5NzApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0b1VUQyA9IGZ1bmN0aW9uIHRvVVRDKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIG1zID0gdDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2FmYXJpU2lnbmVkSW50QnVnICYmIG1zID4gbWF4U2FmZVVuc2lnbmVkMzJCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc1RvU2hpZnQgPSBNYXRoLmZsb29yKG1zIC8gbWF4U2FmZVVuc2lnbmVkMzJCaXQpICogbWF4U2FmZVVuc2lnbmVkMzJCaXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzVG9TaGlmdCA9IE1hdGguZmxvb3IobXNUb1NoaWZ0IC8gMWUzKTtcbiAgICAgICAgICAgICAgICAgICAgcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgbXMgLT0gc1RvU2hpZnQgKiAxZTM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkTnVtYmVyKG5ldyBOYXRpdmVEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIHMsIG1zKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDb3B5IGFueSBjdXN0b20gbWV0aG9kcyBhIDNyZCBwYXJ0eSBsaWJyYXJ5IG1heSBoYXZlIGFkZGVkXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gTmF0aXZlRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvd25zKE5hdGl2ZURhdGUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgRGF0ZVNoaW1ba2V5XSA9IE5hdGl2ZURhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvcHkgXCJuYXRpdmVcIiBtZXRob2RzIGV4cGxpY2l0bHk7IHRoZXkgbWF5IGJlIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGVTaGltLCB7XG4gICAgICAgICAgICAgICAgbm93OiBOYXRpdmVEYXRlLm5vdyxcbiAgICAgICAgICAgICAgICBVVEM6IE5hdGl2ZURhdGUuVVRDXG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIERhdGVTaGltLnByb3RvdHlwZSA9IE5hdGl2ZURhdGUucHJvdG90eXBlO1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogRGF0ZVNoaW1cbiAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBVcGdyYWRlIERhdGUucGFyc2UgdG8gaGFuZGxlIHNpbXBsaWZpZWQgSVNPIDg2MDEgc3RyaW5nc1xuICAgICAgICAgICAgdmFyIHBhcnNlU2hpbSA9IGZ1bmN0aW9uIHBhcnNlKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGlzb0RhdGVFeHByZXNzaW9uLmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlIGRlZmF1bHQgdmFsdWVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgVVRDIG9mZnNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHllYXIgPSAkTnVtYmVyKG1hdGNoWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gJE51bWJlcihtYXRjaFsyXSB8fCAxKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkgPSAkTnVtYmVyKG1hdGNoWzNdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgPSAkTnVtYmVyKG1hdGNoWzRdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlID0gJE51bWJlcihtYXRjaFs1XSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZCA9ICROdW1iZXIobWF0Y2hbNl0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IE1hdGguZmxvb3IoJE51bWJlcihtYXRjaFs3XSB8fCAwKSAqIDEwMDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aW1lIHpvbmUgaXMgbWlzc2VkLCBsb2NhbCBvZmZzZXQgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChFUyA1LjEgYnVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVncy5lY21hc2NyaXB0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xvY2FsVGltZSA9IEJvb2xlYW4obWF0Y2hbNF0gJiYgIW1hdGNoWzhdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25PZmZzZXQgPSBtYXRjaFs5XSA9PT0gJy0nID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCA9ICROdW1iZXIobWF0Y2hbMTBdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlT2Zmc2V0ID0gJE51bWJlcihtYXRjaFsxMV0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNNaW51dGVzT3JTZWNvbmRzT3JNaWxsaXNlY29uZHMgPSBtaW51dGUgPiAwIHx8IHNlY29uZCA+IDAgfHwgbWlsbGlzZWNvbmQgPiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VyIDwgKGhhc01pbnV0ZXNPclNlY29uZHNPck1pbGxpc2Vjb25kcyA/IDI0IDogMjUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW51dGUgPCA2MCAmJiBzZWNvbmQgPCA2MCAmJiBtaWxsaXNlY29uZCA8IDEwMDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoID4gLTEgJiYgbW9udGggPCAxMiAmJiBob3VyT2Zmc2V0IDwgMjQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZU9mZnNldCA8IDYwICYmIC8vIGRldGVjdCBpbnZhbGlkIG9mZnNldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXkgPCAoZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoICsgMSkgLSBkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoKSArIGRheSkgKiAyNCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ciArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCAqIHNpZ25PZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICkgKiA2MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0ICsgbWludXRlICsgbWludXRlT2Zmc2V0ICogc2lnbk9mZnNldCkgKiA2MCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kXG4gICAgICAgICAgICAgICAgICAgICAgICApICogMTAwMCArIG1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9VVEMocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtOC42NGUxNSA8PSByZXN1bHQgJiYgcmVzdWx0IDw9IDguNjRlMTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBOYXRpdmVEYXRlLnBhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbSwgeyBwYXJzZTogcGFyc2VTaGltIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRGF0ZVNoaW07XG4gICAgICAgIH0oRGF0ZSkpO1xuICAgICAgICAvKiBnbG9iYWwgRGF0ZTogZmFsc2UgKi9cbiAgICB9XG5cbiAgICAvLyBFUzUgMTUuOS40LjRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuNFxuICAgIGlmICghRGF0ZS5ub3cpIHtcbiAgICAgICAgRGF0ZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBOdW1iZXJcbiAgICAvLyA9PT09PT1cbiAgICAvL1xuXG4gICAgLy8gRVM1LjEgMTUuNy40LjVcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS43LjQuNVxuICAgIHZhciBoYXNUb0ZpeGVkQnVncyA9IE51bWJlclByb3RvdHlwZS50b0ZpeGVkICYmIChcbiAgICAgICgwLjAwMDA4KS50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gICAgICAoMC45KS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgICAgICgxLjI1NSkudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gICAgICAoMTAwMDAwMDAwMDAwMDAwMDEyOCkudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4gICAgKTtcblxuICAgIHZhciB0b0ZpeGVkSGVscGVycyA9IHtcbiAgICAgICAgYmFzZTogMWU3LFxuICAgICAgICBzaXplOiA2LFxuICAgICAgICBkYXRhOiBbMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiBtdWx0aXBseShuLCBjKSB7XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgdmFyIGMyID0gYztcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCB0b0ZpeGVkSGVscGVycy5zaXplKSB7XG4gICAgICAgICAgICAgICAgYzIgKz0gbiAqIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGF0YVtpXSA9IGMyICUgdG9GaXhlZEhlbHBlcnMuYmFzZTtcbiAgICAgICAgICAgICAgICBjMiA9IE1hdGguZmxvb3IoYzIgLyB0b0ZpeGVkSGVscGVycy5iYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbiBkaXZpZGUobikge1xuICAgICAgICAgICAgdmFyIGkgPSB0b0ZpeGVkSGVscGVycy5zaXplO1xuICAgICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYyArPSB0b0ZpeGVkSGVscGVycy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gPSBNYXRoLmZsb29yKGMgLyBuKTtcbiAgICAgICAgICAgICAgICBjID0gKGMgJSBuKSAqIHRvRml4ZWRIZWxwZXJzLmJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG51bVRvU3RyaW5nOiBmdW5jdGlvbiBudW1Ub1N0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBpID0gdG9GaXhlZEhlbHBlcnMuc2l6ZTtcbiAgICAgICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCB0b0ZpeGVkSGVscGVycy5kYXRhW2ldICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gJFN0cmluZyh0b0ZpeGVkSGVscGVycy5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gdDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gc3RyU2xpY2UoJzAwMDAwMDAnLCAwLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LFxuICAgICAgICBwb3c6IGZ1bmN0aW9uIHBvdyh4LCBuLCBhY2MpIHtcbiAgICAgICAgICAgIHJldHVybiAobiA9PT0gMCA/IGFjYyA6IChuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvZzogZnVuY3Rpb24gbG9nKHgpIHtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIHZhciB4MiA9IHg7XG4gICAgICAgICAgICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgICAgICAgICAgICAgIG4gKz0gMTI7XG4gICAgICAgICAgICAgICAgeDIgLz0gNDA5NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgICAgIHgyIC89IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdG9GaXhlZFNoaW0gPSBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIHZhciBmLCB4LCBzLCBtLCBlLCB6LCBqLCBrO1xuXG4gICAgICAgIC8vIFRlc3QgZm9yIE5hTiBhbmQgcm91bmQgZnJhY3Rpb25EaWdpdHMgZG93blxuICAgICAgICBmID0gJE51bWJlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgICAgIGYgPSBpc0FjdHVhbE5hTihmKSA/IDAgOiBNYXRoLmZsb29yKGYpO1xuXG4gICAgICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOdW1iZXIudG9GaXhlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIG51bWJlciBvZiBkZWNpbWFscycpO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9ICROdW1iZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKGlzQWN0dWFsTmFOKHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ05hTic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyB0b28gYmlnIG9yIHNtYWxsLCByZXR1cm4gdGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgbnVtYmVyXG4gICAgICAgIGlmICh4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSkge1xuICAgICAgICAgICAgcmV0dXJuICRTdHJpbmcoeCk7XG4gICAgICAgIH1cblxuICAgICAgICBzID0gJyc7XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICBzID0gJy0nO1xuICAgICAgICAgICAgeCA9IC14O1xuICAgICAgICB9XG5cbiAgICAgICAgbSA9ICcwJztcblxuICAgICAgICBpZiAoeCA+IDFlLTIxKSB7XG4gICAgICAgICAgICAvLyAxZS0yMSA8IHggPCAxZTIxXG4gICAgICAgICAgICAvLyAtNzAgPCBsb2cyKHgpIDwgNzBcbiAgICAgICAgICAgIGUgPSB0b0ZpeGVkSGVscGVycy5sb2coeCAqIHRvRml4ZWRIZWxwZXJzLnBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICAgICAgICB6ID0gKGUgPCAwID8geCAqIHRvRml4ZWRIZWxwZXJzLnBvdygyLCAtZSwgMSkgOiB4IC8gdG9GaXhlZEhlbHBlcnMucG93KDIsIGUsIDEpKTtcbiAgICAgICAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDsgLy8gTWF0aC5wb3coMiwgNTIpO1xuICAgICAgICAgICAgZSA9IDUyIC0gZTtcblxuICAgICAgICAgICAgLy8gLTE4IDwgZSA8IDEyMlxuICAgICAgICAgICAgLy8geCA9IHogLyAyIF4gZVxuICAgICAgICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMCwgeik7XG4gICAgICAgICAgICAgICAgaiA9IGY7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gNztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSh0b0ZpeGVkSGVscGVycy5wb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgICAgICAgICBqID0gZSAtIDE7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDEgPDwgaik7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMSwgMSk7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDIpO1xuICAgICAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgwLCB6KTtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgxIDw8ICgtZSksIDApO1xuICAgICAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAyLCAyICsgZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZiA+IDApIHtcbiAgICAgICAgICAgIGsgPSBtLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGsgPD0gZikge1xuICAgICAgICAgICAgICAgIG0gPSBzICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDAsIGYgLSBrICsgMikgKyBtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtID0gcyArIHN0clNsaWNlKG0sIDAsIGsgLSBmKSArICcuJyArIHN0clNsaWNlKG0sIGsgLSBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0gPSBzICsgbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHsgdG9GaXhlZDogdG9GaXhlZFNoaW0gfSwgaGFzVG9GaXhlZEJ1Z3MpO1xuXG4gICAgdmFyIGhhc1RvUHJlY2lzaW9uVW5kZWZpbmVkQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAxLjAudG9QcmVjaXNpb24odW5kZWZpbmVkKSA9PT0gJzEnO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0oKSk7XG4gICAgdmFyIG9yaWdpbmFsVG9QcmVjaXNpb24gPSBOdW1iZXJQcm90b3R5cGUudG9QcmVjaXNpb247XG4gICAgZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHtcbiAgICAgICAgdG9QcmVjaXNpb246IGZ1bmN0aW9uIHRvUHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwcmVjaXNpb24gPT09ICd1bmRlZmluZWQnID8gb3JpZ2luYWxUb1ByZWNpc2lvbi5jYWxsKHRoaXMpIDogb3JpZ2luYWxUb1ByZWNpc2lvbi5jYWxsKHRoaXMsIHByZWNpc2lvbik7XG4gICAgICAgIH1cbiAgICB9LCBoYXNUb1ByZWNpc2lvblVuZGVmaW5lZEJ1Zyk7XG5cbiAgICAvL1xuICAgIC8vIFN0cmluZ1xuICAgIC8vID09PT09PVxuICAgIC8vXG5cbiAgICAvLyBFUzUgMTUuNS40LjE0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbiAgICAvLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4gICAgLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcbiAgICAvLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbiAgICAvLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbiAgICAvLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XG4gICAgLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbiAgICAvLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbiAgICAvLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XG4gICAgLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbiAgICAvLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbiAgICAvLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cblxuICAgIGlmIChcbiAgICAgICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XG4gICAgICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAgICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcbiAgICApIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IHR5cGVvZiAoLygpPz8vKS5leGVjKCcnKVsxXSA9PT0gJ3VuZGVmaW5lZCc7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgICB2YXIgbWF4U2FmZTMyQml0SW50ID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxuICAgICAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVnZXgoc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyU3BsaXQodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArIC8vIGluIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrIGFuZCBFUzZcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gbWF4U2FmZTMyQml0SW50XG4gICAgICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRMaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgPyBtYXhTYWZlMzJCaXRJbnQgOiBFUy5Ub1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKG91dHB1dCwgc3RyU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X3B1c2guYXBwbHkob3V0cHV0LCBhcnJheVNsaWNlKG1hdGNoLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IHNwbGl0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yQ29weS5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hDYWxsKG91dHB1dCwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaENhbGwob3V0cHV0LCBzdHJTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBzcGxpdExpbWl0ID8gYXJyYXlTbGljZShvdXRwdXQsIDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcblxuICAgIC8vIFtidWdmaXgsIGNocm9tZV1cbiAgICAvLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuICAgIC8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuICAgIC8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbiAgICAvLyBlbGVtZW50cy5cbiAgICAvLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG4gICAgfSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0clNwbGl0KHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzdHJfcmVwbGFjZSA9IFN0cmluZ1Byb3RvdHlwZS5yZXBsYWNlO1xuICAgIHZhciByZXBsYWNlUmVwb3J0c0dyb3Vwc0NvcnJlY3RseSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBbXTtcbiAgICAgICAgJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtYXRjaCwgZ3JvdXApIHtcbiAgICAgICAgICAgIHB1c2hDYWxsKGdyb3VwcywgZ3JvdXApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyb3Vwcy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGdyb3Vwc1swXSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfSgpKTtcblxuICAgIGlmICghcmVwbGFjZVJlcG9ydHNHcm91cHNDb3JyZWN0bHkpIHtcbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBpc0ZuID0gaXNDYWxsYWJsZShyZXBsYWNlVmFsdWUpO1xuICAgICAgICAgICAgdmFyIGhhc0NhcHR1cmluZ0dyb3VwcyA9IGlzUmVnZXgoc2VhcmNoVmFsdWUpICYmICgvXFwpWyo/XS8pLnRlc3Qoc2VhcmNoVmFsdWUuc291cmNlKTtcbiAgICAgICAgICAgIGlmICghaXNGbiB8fCAhaGFzQ2FwdHVyaW5nR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cl9yZXBsYWNlLmNhbGwodGhpcywgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkUmVwbGFjZVZhbHVlID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxMYXN0SW5kZXggPSBzZWFyY2hWYWx1ZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2VhcmNoVmFsdWUuZXhlYyhtYXRjaCkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlLmxhc3RJbmRleCA9IG9yaWdpbmFsTGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBwdXNoQ2FsbChhcmdzLCBhcmd1bWVudHNbbGVuZ3RoIC0gMl0sIGFyZ3VtZW50c1tsZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlVmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyX3JlcGxhY2UuY2FsbCh0aGlzLCBzZWFyY2hWYWx1ZSwgd3JhcHBlZFJlcGxhY2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuICAgIC8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4gICAgLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuICAgIC8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuICAgIC8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG4gICAgdmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xuICAgIHZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgICAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFN0YXJ0ID0gbWF4KHRoaXMubGVuZ3RoICsgc3RhcnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbCh0aGlzLCBub3JtYWxpemVkU3RhcnQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG5cbiAgICAvLyBFUzUgMTUuNS40LjIwXG4gICAgLy8gd2hpdGVzcGFjZSBmcm9tOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjUuNC4yMFxuICAgIHZhciB3cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAgICAgICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnICtcbiAgICAgICAgJ1xcdTIwMjlcXHVGRUZGJztcbiAgICB2YXIgemVyb1dpZHRoID0gJ1xcdTIwMGInO1xuICAgIHZhciB3c1JlZ2V4Q2hhcnMgPSAnWycgKyB3cyArICddJztcbiAgICB2YXIgdHJpbUJlZ2luUmVnZXhwID0gbmV3IFJlZ0V4cCgnXicgKyB3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKicpO1xuICAgIHZhciB0cmltRW5kUmVnZXhwID0gbmV3IFJlZ0V4cCh3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKiQnKTtcbiAgICB2YXIgaGFzVHJpbVdoaXRlc3BhY2VCdWcgPSBTdHJpbmdQcm90b3R5cGUudHJpbSAmJiAod3MudHJpbSgpIHx8ICF6ZXJvV2lkdGgudHJpbSgpKTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgICAgICAvLyBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvZmFzdGVyLXRyaW0tamF2YXNjcmlwdFxuICAgICAgICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS93aGl0ZXNwYWNlLWRldmlhdGlvbnMvXG4gICAgICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIHRoaXMgKyAnIHRvIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICRTdHJpbmcodGhpcykucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsICcnKS5yZXBsYWNlKHRyaW1FbmRSZWdleHAsICcnKTtcbiAgICAgICAgfVxuICAgIH0sIGhhc1RyaW1XaGl0ZXNwYWNlQnVnKTtcbiAgICB2YXIgdHJpbSA9IGNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlLnRyaW0pO1xuXG4gICAgdmFyIGhhc0xhc3RJbmRleEJ1ZyA9IFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZiAmJiAnYWJj44GC44GEJy5sYXN0SW5kZXhPZign44GC44GEJywgMikgIT09IC0xO1xuICAgIGRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgUyA9ICRTdHJpbmcodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2VhcmNoU3RyID0gJFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgICAgICAgICAgdmFyIG51bVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gJE51bWJlcihhcmd1bWVudHNbMV0pIDogTmFOO1xuICAgICAgICAgICAgdmFyIHBvcyA9IGlzQWN0dWFsTmFOKG51bVBvcykgPyBJbmZpbml0eSA6IEVTLlRvSW50ZWdlcihudW1Qb3MpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbWluKG1heChwb3MsIDApLCBTLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgc2VhcmNoTGVuID0gc2VhcmNoU3RyLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBrID0gc3RhcnQgKyBzZWFyY2hMZW47XG4gICAgICAgICAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgICAgICAgICAgICBrID0gbWF4KDAsIGsgLSBzZWFyY2hMZW4pO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0ckluZGV4T2Yoc3RyU2xpY2UoUywgaywgc3RhcnQgKyBzZWFyY2hMZW4pLCBzZWFyY2hTdHIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGsgKyBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9LCBoYXNMYXN0SW5kZXhCdWcpO1xuXG4gICAgdmFyIG9yaWdpbmFsTGFzdEluZGV4T2YgPSBTdHJpbmdQcm90b3R5cGUubGFzdEluZGV4T2Y7XG4gICAgZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICAgICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTGFzdEluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sIFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZi5sZW5ndGggIT09IDEpO1xuXG4gICAgLy8gRVMtNSAxNS4xLjIuMlxuICAgIC8qIGVzbGludC1kaXNhYmxlIHJhZGl4ICovXG4gICAgaWYgKHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMikge1xuICAgIC8qIGVzbGludC1lbmFibGUgcmFkaXggKi9cbiAgICAgICAgLyogZ2xvYmFsIHBhcnNlSW50OiB0cnVlICovXG4gICAgICAgIHBhcnNlSW50ID0gKGZ1bmN0aW9uIChvcmlnUGFyc2VJbnQpIHtcbiAgICAgICAgICAgIHZhciBoZXhSZWdleCA9IC9eW1xcLStdPzBbeFhdLztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRyaW0oU3RyaW5nKHN0cikpO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0ZWRSYWRpeCA9ICROdW1iZXIocmFkaXgpIHx8IChoZXhSZWdleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ1BhcnNlSW50KHN0cmluZywgZGVmYXVsdGVkUmFkaXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfShwYXJzZUludCkpO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4zXG4gICAgaWYgKDEgLyBwYXJzZUZsb2F0KCctMCcpICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgLyogZ2xvYmFsIHBhcnNlRmxvYXQ6IHRydWUgKi9cbiAgICAgICAgcGFyc2VGbG9hdCA9IChmdW5jdGlvbiAob3JpZ1BhcnNlRmxvYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dFN0cmluZyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlnUGFyc2VGbG9hdChpbnB1dFN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJTbGljZShpbnB1dFN0cmluZywgMCwgMSkgPT09ICctJyA/IC0wIDogcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfShwYXJzZUZsb2F0KSk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZyhuZXcgUmFuZ2VFcnJvcigndGVzdCcpKSAhPT0gJ1JhbmdlRXJyb3I6IHRlc3QnKSB7XG4gICAgICAgIHZhciBlcnJvclRvU3RyaW5nU2hpbSA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzID09PSAndW5kZWZpbmVkJyB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnRXJyb3InO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gJFN0cmluZyhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtc2cgPSB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAkU3RyaW5nKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lICsgJzogJyArIG1zZztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY2FuJ3QgdXNlIGRlZmluZVByb3BlcnRpZXMgaGVyZSBiZWNhdXNlIG9mIHRvU3RyaW5nIGVudW1lcmF0aW9uIGlzc3VlIGluIElFIDw9IDhcbiAgICAgICAgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZXJyb3JUb1N0cmluZ1NoaW07XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgdmFyIGVuc3VyZU5vbkVudW1lcmFibGUgPSBmdW5jdGlvbiAob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoaXNFbnVtKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICdtZXNzYWdlJyk7XG4gICAgICAgIGlmIChFcnJvci5wcm90b3R5cGUubWVzc2FnZSAhPT0gJycpIHtcbiAgICAgICAgICAgIEVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICduYW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZygvYS9taWcpICE9PSAnL2EvZ2ltJykge1xuICAgICAgICB2YXIgcmVnZXhUb1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIHN0ciA9ICcvJyArIHRoaXMuc291cmNlICsgJy8nO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICdnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJ2knO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICdtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNhbid0IHVzZSBkZWZpbmVQcm9wZXJ0aWVzIGhlcmUgYmVjYXVzZSBvZiB0b1N0cmluZyBlbnVtZXJhdGlvbiBpc3N1ZSBpbiBJRSA8PSA4XG4gICAgICAgIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcgPSByZWdleFRvU3RyaW5nO1xuICAgIH1cbn0pKTtcbiIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qYWtlYXJjaGliYWxkL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDMuMi4xXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNNYXliZVRoZW5hYmxlKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheSA9IGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXk7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPSAwO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm47XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuXSA9IGNhbGxiYWNrO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKyAxXSA9IGFyZztcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKz0gMjtcbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID09PSAyKSB7XG4gICAgICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAgICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAgICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgICAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0QXNhcChhc2FwRm4pIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwID0gYXNhcEZuO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgfHwge307XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4gICAgLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgLy8gbm9kZVxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VOZXh0VGljaygpIHtcbiAgICAgIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gdmVydHhcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlVmVydHhUaW1lcigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dChsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgbm9kZS5kYXRhID0gKGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gd2ViIHdvcmtlclxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuOyBpKz0yKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpXTtcbiAgICAgICAgdmFyIGFyZyA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdO1xuXG4gICAgICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaSsxXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByID0gcmVxdWlyZTtcbiAgICAgICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlVmVydHhUaW1lcigpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaDtcbiAgICAvLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VOZXh0VGljaygpO1xuICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhdHRlbXB0VmVydHgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdGhlbiQkdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuXG4gICAgICBpZiAoY2hpbGRbbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRtYWtlUHJvbWlzZShjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbc3RhdGUgLSAxXTtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHRoZW4kJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkdGhlbiQkdGhlbjtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRyZXNvbHZlKG9iamVjdCkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmU7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCgpIHt9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAgID0gdm9pZCAwO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQgPSAxO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCAgPSAyO1xuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SID0gbmV3IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzZWxmRnVsZmlsbG1lbnQoKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkY2Fubm90UmV0dXJuT3duKCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKHByb21pc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW47XG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB0aGVuYWJsZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICAgICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gICAgICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbikge1xuICAgICAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiZcbiAgICAgICAgICB0aGVuID09PSBsaWIkZXM2JHByb21pc2UkdGhlbiQkZGVmYXVsdCAmJlxuICAgICAgICAgIGNvbnN0cnVjdG9yLnJlc29sdmUgPT09IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhlbiA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHRoZW4pKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQ7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaCwgcHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRDtcbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIGxlbmd0aCA9IHN1YnNjcmliZXJzLmxlbmd0aDtcblxuICAgICAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRF0gID0gb25SZWplY3Rpb247XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSkge1xuICAgICAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gICAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdmFyIGhhc0NhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgICAgICB2YWx1ZSwgZXJyb3IsIHN1Y2NlZWRlZCwgZmFpbGVkO1xuXG4gICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgdmFsdWUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGV0YWlsO1xuICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgICAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKXtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpZCA9IDA7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbmV4dElkKCkge1xuICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGlkKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbWFrZVByb21pc2UocHJvbWlzZSkge1xuICAgICAgcHJvbWlzZVtsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEXSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGlkKys7XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRhbGwoZW50cmllcykge1xuICAgICAgcmV0dXJuIG5ldyBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkZGVmYXVsdCh0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRhbGw7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZShlbnRyaWVzKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKCFsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkoZW50cmllcykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJHJhY2U7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3QocmVhc29uKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkcmVqZWN0O1xuXG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNSZXNvbHZlcigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlO1xuICAgIC8qKlxuICAgICAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICAgICAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgICAgIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICAgICAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgIFRlcm1pbm9sb2d5XG4gICAgICAtLS0tLS0tLS0tLVxuXG4gICAgICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgICAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAgICAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAgICAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gICAgICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gICAgICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICAgICAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gICAgICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICAgICAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICAgICAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgICAgIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICAgICAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICAgICAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gICAgICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gICAgICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gICAgICBCYXNpYyBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICBgYGBqc1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gb24gc3VjY2Vzc1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgICAgICAvLyBvbiBmYWlsdXJlXG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQWR2YW5jZWQgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICAgICAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gICAgICBgYGBqc1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICAgICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgICAgIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICAgICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgICAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBjbGFzcyBQcm9taXNlXG4gICAgICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZShyZXNvbHZlcikge1xuICAgICAgdGhpc1tsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEXSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5leHRJZCgpO1xuICAgICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCk7XG4gICAgICAgIHRoaXMgaW5zdGFuY2VvZiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZSA/IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLmFsbCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yYWNlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZXNvbHZlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZWplY3QgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX3NldFNjaGVkdWxlciA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRTY2hlZHVsZXI7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX3NldEFzYXAgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0QXNhcDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fYXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwO1xuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLFxuXG4gICAgLyoqXG4gICAgICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgICAgIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gICAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQ2hhaW5pbmdcbiAgICAgIC0tLS0tLS0tXG5cbiAgICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gICAgICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gICAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdXNlci5uYW1lO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICAgICAgfSk7XG5cbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgICAgIH0pO1xuICAgICAgYGBgXG4gICAgICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBc3NpbWlsYXRpb25cbiAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgICAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICAgICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgU2ltcGxlIEV4YW1wbGVcbiAgICAgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9XG4gICAgICBgYGBcblxuICAgICAgRXJyYmFjayBFeGFtcGxlXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFByb21pc2UgRXhhbXBsZTtcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgYXV0aG9yLCBib29rcztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9XG4gICAgICBgYGBcblxuICAgICAgRXJyYmFjayBFeGFtcGxlXG5cbiAgICAgIGBgYGpzXG5cbiAgICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcblxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuXG4gICAgICB9XG5cbiAgICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFByb21pc2UgRXhhbXBsZTtcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgZmluZEF1dGhvcigpLlxuICAgICAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIHRoZW5cbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICB0aGVuOiBsaWIkZXM2JHByb21pc2UkdGhlbiQkZGVmYXVsdCxcblxuICAgIC8qKlxuICAgICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgICAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN5bmNocm9ub3VzXG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQXV0aG9yKCk7XG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfVxuXG4gICAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgICBmaW5kQXV0aG9yKClbJ2NhdGNoJ10oZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgY2F0Y2hcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgICAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuXG4gICAgICBpZiAoIXRoaXMucHJvbWlzZVtsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEXSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5KGlucHV0KSkge1xuICAgICAgICB0aGlzLl9pbnB1dCAgICAgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgdGhpcy5fZW51bWVyYXRlKCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QodGhpcy5wcm9taXNlLCBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCR2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCAgPSB0aGlzLmxlbmd0aDtcbiAgICAgIHZhciBpbnB1dCAgID0gdGhpcy5faW5wdXQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbihlbnRyeSwgaSkge1xuICAgICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgICAgdmFyIHJlc29sdmUgPSBjLnJlc29sdmU7XG5cbiAgICAgIGlmIChyZXNvbHZlID09PSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0KSB7XG4gICAgICAgIHZhciB0aGVuID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZ2V0VGhlbihlbnRyeSk7XG5cbiAgICAgICAgaWYgKHRoZW4gPT09IGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0ICYmXG4gICAgICAgICAgICBlbnRyeS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0KSB7XG4gICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgYyhsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCB0aGVuKTtcbiAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uKHJlc29sdmUpIHsgcmVzb2x2ZShlbnRyeSk7IH0pLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUoZW50cnkpLCBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbihzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24ocHJvbWlzZSwgaSkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVELCBpLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJHBvbHlmaWxsKCkge1xuICAgICAgdmFyIGxvY2FsO1xuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gICAgICBpZiAoUCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvY2FsLlByb21pc2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdDtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGw7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZSA9IHtcbiAgICAgICdQcm9taXNlJzogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQsXG4gICAgICAncG9seWZpbGwnOiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHRcbiAgICB9O1xuXG4gICAgLyogZ2xvYmFsIGRlZmluZTp0cnVlIG1vZHVsZTp0cnVlIHdpbmRvdzogdHJ1ZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlWydleHBvcnRzJ10pIHtcbiAgICAgIG1vZHVsZVsnZXhwb3J0cyddID0gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1snRVM2UHJvbWlzZSddID0gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHQoKTtcbn0pLmNhbGwodGhpcyk7XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBwcm9taXNlRXh0ZW5zaW9uc18xID0gcmVxdWlyZShcIi4vLi4vaGVscGVycy9wcm9taXNlRXh0ZW5zaW9uc1wiKTtcclxudmFyIGFjdGl2aXR5TWFuYWdlbWVudEFQSV8xID0gcmVxdWlyZShcIi4vYWN0aXZpdHlNYW5hZ2VtZW50QVBJXCIpO1xyXG52YXIgYWN0aXZpdHlBR01fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2FjdGl2aXR5QUdNXCIpO1xyXG52YXIgQWN0aXZpdHlBUEkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlBUEkobWFuYWdlciwgbXkpIHtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSBcIjIuMS43XCI7XHJcbiAgICAgICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5fbXkgPSBteTtcclxuICAgICAgICB0aGlzLmFsbCA9IG5ldyBhY3Rpdml0eU1hbmFnZW1lbnRBUElfMS5BY3Rpdml0eU1hbmFnZW1lbnRBUEkobWFuYWdlciwgbXkpO1xyXG4gICAgfVxyXG4gICAgQWN0aXZpdHlBUEkucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX21hbmFnZXIucmVhZHkoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcyk7XHJcbiAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlBUEkucHJvdG90eXBlLCBcIm15XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX215O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5QVBJLnByb3RvdHlwZSwgXCJhd2FyZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9teS53aW5kb3cgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eUFQSS5wcm90b3R5cGUsIFwiaW5BY3Rpdml0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF3YXJlICYmIHRoaXMuX215LmFjdGl2aXR5ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlBUEkucHJvdG90eXBlLCBcImFnbVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hd2FyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5BY3Rpdml0eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhY3Rpdml0eUFHTV8xLkFjdGl2aXR5QUdNKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9teS5hY3Rpdml0eS5hZ207XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQWN0aXZpdHlBUEk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQWN0aXZpdHlBUEkgPSBBY3Rpdml0eUFQSTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlBUEkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgQWN0aXZpdHlNYW5hZ2VtZW50QVBJID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5TWFuYWdlbWVudEFQSShtYW5hZ2VyLCBteSkge1xyXG4gICAgICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX215ID0gbXk7XHJcbiAgICAgICAgdGhpcy5hY3Rpdml0eVR5cGVzID0ge1xyXG4gICAgICAgICAgICBnZXQ6IHRoaXMuX2dldEFjdGl2aXR5VHlwZXNXcmFwcGVyLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyOiB0aGlzLl9tYW5hZ2VyLnJlZ2lzdGVyQWN0aXZpdHlUeXBlLmJpbmQodGhpcy5fbWFuYWdlciksXHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXI6IHRoaXMuX21hbmFnZXIudW5yZWdpc3RlckFjdGl2aXR5VHlwZS5iaW5kKHRoaXMuX21hbmFnZXIpLFxyXG4gICAgICAgICAgICBzdWJzY3JpYmU6IHRoaXMuX21hbmFnZXIuc3Vic2NyaWJlQWN0aXZpdHlUeXBlRXZlbnRzLmJpbmQodGhpcy5fbWFuYWdlciksXHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGluaXRpYXRlOiB0aGlzLl9tYW5hZ2VyLmluaXRpYXRlLmJpbmQodGhpcy5fbWFuYWdlcilcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMud2luZG93VHlwZXMgPSB7XHJcbiAgICAgICAgICAgIGdldDogdGhpcy5fZ2V0V2luZG93VHlwZXNXcmFwcGVyLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyRmFjdG9yeTogdGhpcy5fbWFuYWdlci5yZWdpc3RlcldpbmRvd0ZhY3RvcnkuYmluZCh0aGlzLl9tYW5hZ2VyKSxcclxuICAgICAgICAgICAgdW5yZWdpc3RlckZhY3Rvcnk6IHRoaXMuX21hbmFnZXIudW5yZWdpc3RlcldpbmRvd0ZhY3RvcnkuYmluZCh0aGlzLl9tYW5hZ2VyKSxcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiB0aGlzLl9tYW5hZ2VyLnN1YnNjcmliZVdpbmRvd1R5cGVFdmVudHMuYmluZCh0aGlzLl9tYW5hZ2VyKSxcclxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6IHVuZGVmaW5lZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy53aW5kb3dzID0ge1xyXG4gICAgICAgICAgICBnZXQ6IHRoaXMuX21hbmFnZXIuZ2V0V2luZG93cy5iaW5kKHRoaXMuX21hbmFnZXIpLFxyXG4gICAgICAgICAgICBzdWJzY3JpYmU6IHRoaXMuX21hbmFnZXIuc3Vic2NyaWJlV2luZG93RXZlbnRzLmJpbmQodGhpcy5fbWFuYWdlciksXHJcbiAgICAgICAgICAgIGFubm91bmNlOiB0aGlzLl9tYW5hZ2VyLmFubm91bmNlV2luZG93LmJpbmQodGhpcy5fbWFuYWdlciksXHJcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNyZWF0ZTogdGhpcy5fbWFuYWdlci5jcmVhdGVXaW5kb3cuYmluZCh0aGlzLl9tYW5hZ2VyKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSB7XHJcbiAgICAgICAgICAgIGdldDogdGhpcy5fbWFuYWdlci5nZXRBY3Rpdml0aWVzLmJpbmQodGhpcy5fbWFuYWdlciksXHJcbiAgICAgICAgICAgIHN1YnNjcmliZTogdGhpcy5fbWFuYWdlci5zdWJzY3JpYmVBY3Rpdml0eUV2ZW50cy5iaW5kKHRoaXMuX21hbmFnZXIpLFxyXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogdW5kZWZpbmVkXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIEFjdGl2aXR5TWFuYWdlbWVudEFQSS5wcm90b3R5cGUuX2dldEFjdGl2aXR5VHlwZXNXcmFwcGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFuYWdlci5nZXRBY3Rpdml0eVR5cGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYW5hZ2VyLmdldEFjdGl2aXR5VHlwZShuYW1lKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZW1lbnRBUEkucHJvdG90eXBlLl9nZXRXaW5kb3dUeXBlc1dyYXBwZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYW5hZ2VyLmdldFdpbmRvd1R5cGVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYW5hZ2VyLmdldFdpbmRvd1R5cGUobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5TWFuYWdlbWVudEFQSTtcclxufSgpKTtcclxuZXhwb3J0cy5BY3Rpdml0eU1hbmFnZW1lbnRBUEkgPSBBY3Rpdml0eU1hbmFnZW1lbnRBUEk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5TWFuYWdlbWVudEFQSS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIi4vLi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgQWN0aXZpdHlNeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eU15KG1hbmFnZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX215QWN0aXZpdHlKb2luZWRDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9teUFjdGl2aXR5UmVtb3ZlZENhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX215Q29udGV4dFVwZGF0ZUNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlci5HZXQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XHJcbiAgICAgICAgbWFuYWdlci5yZWFkeSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhbSkge1xyXG4gICAgICAgICAgICBhbS5zdWJzY3JpYmVBY3Rpdml0eUNvbnRleHRDaGFuZ2VkKF90aGlzLl9zdWJzY3JpYmVNeUNvbnRleHRDaGFuZ2VkLmJpbmQoX3RoaXMpKTtcclxuICAgICAgICAgICAgYW0uc3Vic2NyaWJlV2luZG93RXZlbnRzKF90aGlzLl9zdWJzY3JpYmVNeVdpbmRvd0V2ZW50LmJpbmQoX3RoaXMpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eU15LnByb3RvdHlwZSwgXCJ3aW5kb3dcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLl93aW5kb3cpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3VuY2VkV2luZG93cyA9IHRoaXMuX21hbmFnZXIuYW5ub3VuY2VkV2luZG93cztcclxuICAgICAgICAgICAgICAgIGlmIChhbm5vdW5jZWRXaW5kb3dzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aW5kb3cgPSBhbm5vdW5jZWRXaW5kb3dzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aW5kb3c7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlNeS5wcm90b3R5cGUsIFwiYWN0aXZpdHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbXlXaW4gPSB0aGlzLndpbmRvdztcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwobXlXaW4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBteVdpbi5hY3Rpdml0eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLmNyZWF0ZVdpbmRvdyA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hbmFnZXIuY3JlYXRlV2luZG93KHRoaXMuYWN0aXZpdHksIHdpbmRvd1R5cGUpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eU15LnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFjdGl2aXR5ID0gdGhpcy5hY3Rpdml0eTtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2aXR5LmNvbnRleHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5vbkFjdGl2aXR5Sm9pbmVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fbXlBY3Rpdml0eUpvaW5lZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICB2YXIgbXlXaW4gPSB0aGlzLndpbmRvdztcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwobXlXaW4pICYmICF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG15V2luLmFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhteVdpbi5hY3Rpdml0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLm9uQWN0aXZpdHlMZWZ0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fbXlBY3Rpdml0eVJlbW92ZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNeS5wcm90b3R5cGUub25Db250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX215Q29udGV4dFVwZGF0ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICB2YXIgbXlXaW4gPSB0aGlzLndpbmRvdztcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChteVdpbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWN0aXZpdHkgPSBteVdpbi5hY3Rpdml0eTtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChhY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFjayhhY3Rpdml0eS5jb250ZXh0LCBhY3Rpdml0eS5jb250ZXh0LCBbXSwgYWN0aXZpdHkpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLl9zdWJzY3JpYmVNeUNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKGFjdGl2aXR5LCBjb250ZXh0LCBkZWx0YSwgcmVtb3ZlZCkge1xyXG4gICAgICAgIHZhciBteVdpbiA9IHRoaXMud2luZG93O1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKG15V2luKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBteUFjdGl2aXR5ID0gbXlXaW4uYWN0aXZpdHk7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwobXlBY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0aXZpdHkuaWQgIT09IG15QWN0aXZpdHkuaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ub3RpZnlNeUNvbnRleHRDaGFuZ2VkKGFjdGl2aXR5LCBjb250ZXh0LCBkZWx0YSwgcmVtb3ZlZCk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNeS5wcm90b3R5cGUuX3N1YnNjcmliZU15V2luZG93RXZlbnQgPSBmdW5jdGlvbiAoYWN0aXZpdHksIHdpbmRvdywgZXZlbnQpIHtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLndpbmRvdykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy53aW5kb3cuaWQgIT09IHdpbmRvdy5pZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudCA9PT0gXCJqb2luZWRcIikge1xyXG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlPbkpvaW5lZChhY3Rpdml0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlNeVdpbmRvd0V2ZW50KGFjdGl2aXR5LCB0aGlzLl9teUFjdGl2aXR5UmVtb3ZlZENhbGxiYWNrcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLl9ub3RpZnlNeVdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCBjYWxsYmFja1N0b3JlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNhbGxiYWNrU3RvcmUubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY2FsbGJhY2tTdG9yZVtpbmRleF07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50KGFjdGl2aXR5LCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdlcnJvciBpbiB1c2VyIGNhbGxiYWNrICcgKyBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU15LnByb3RvdHlwZS5fbm90aWZ5TXlDb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgY29udGV4dCwgZGVsdGEsIHJlbW92ZWQpIHtcclxuICAgICAgICBkZWx0YSA9IGRlbHRhIHx8IHt9O1xyXG4gICAgICAgIHJlbW92ZWQgPSByZW1vdmVkIHx8IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9teUNvbnRleHRVcGRhdGVDYWxsYmFja3MubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fbXlDb250ZXh0VXBkYXRlQ2FsbGJhY2tzW2luZGV4XTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQoY29udGV4dCwgZGVsdGEsIHJlbW92ZWQsIGFjdGl2aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oJ2Vycm9yIGluIHVzZXIgY2FsbGJhY2sgJyArIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TXkucHJvdG90eXBlLl9ub3RpZnlPbkpvaW5lZCA9IGZ1bmN0aW9uIChhY3Rpdml0eSkge1xyXG4gICAgICAgIHRoaXMuX25vdGlmeU15V2luZG93RXZlbnQoYWN0aXZpdHksIHRoaXMuX215QWN0aXZpdHlKb2luZWRDYWxsYmFja3MpO1xyXG4gICAgICAgIHRoaXMuX25vdGlmeU15Q29udGV4dENoYW5nZWQoYWN0aXZpdHksIGFjdGl2aXR5LmNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eU15O1xyXG59KCkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHNbJ2RlZmF1bHQnXT0gQWN0aXZpdHlNeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlNeUFQSS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIEFjdGl2aXR5Q29uZmlnID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5Q29uZmlnKCkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFjdGl2aXR5Q29uZmlnO1xyXG59KCkpO1xyXG5leHBvcnRzLkFjdGl2aXR5Q29uZmlnID0gQWN0aXZpdHlDb25maWc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5Q29uZmlnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5yZXF1aXJlKFwiZXM2LXByb21pc2VcIik7XHJcbnZhciBoY0JyaWRnZV8xID0gcmVxdWlyZShcIi4vYnJpZGdlcy9oY0JyaWRnZVwiKTtcclxudmFyIGFjdGl2aXR5TWFuYWdlcl8xID0gcmVxdWlyZShcIi4vY29yZS9hY3Rpdml0eU1hbmFnZXJcIik7XHJcbnZhciBhY3Rpdml0eU15QVBJXzEgPSByZXF1aXJlKFwiLi9BUEkvYWN0aXZpdHlNeUFQSVwiKTtcclxudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgYWN0aXZpdHlDb25maWdfMSA9IHJlcXVpcmUoXCIuL2FjdGl2aXR5Q29uZmlnXCIpO1xyXG52YXIgYWN0aXZpdHlBUElfMSA9IHJlcXVpcmUoXCIuL0FQSS9hY3Rpdml0eUFQSVwiKTtcclxudmFyIGFjdGl2aXR5QUdNXzEgPSByZXF1aXJlKFwiLi9jb3JlL2FjdGl2aXR5QUdNXCIpO1xyXG52YXIgYWN0aXZpdHkgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICBjb25maWcgPSBjb25maWcgfHwgbmV3IGFjdGl2aXR5Q29uZmlnXzEuQWN0aXZpdHlDb25maWc7XHJcbiAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoY29uZmlnLmxvZ0xldmVsKSkge1xyXG4gICAgICAgIGxvZ2dlcl8xLkxvZ2dlci5MZXZlbCA9IGNvbmZpZy5sb2dMZXZlbDtcclxuICAgIH1cclxuICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChjb25maWcubG9nZ2VyKSkge1xyXG4gICAgICAgIGxvZ2dlcl8xLkxvZ2dlci5HbHVlTG9nZ2VyID0gY29uZmlnLmxvZ2dlcjtcclxuICAgIH1cclxuICAgIHZhciBicmlkZ2U7XHJcbiAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQod2luZG93Lmh0bWxDb250YWluZXIpKSB7XHJcbiAgICAgICAgYnJpZGdlID0gbmV3IGhjQnJpZGdlXzFbJ2RlZmF1bHQnXSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWN0aXZpdHkgbm90IHN1cHBvcnRlZCBpbiBpbiBicm93c2VyXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFicmlkZ2UpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGJyaWRnZSB0byBuYXRpdmUgYWN0aXZpdHkgaXMgbmVlZGVkIHRvIGNyZWF0ZSBhY3Rpdml0eSBsaWIuXCIpO1xyXG4gICAgfVxyXG4gICAgYWN0aXZpdHlBR01fMS5BY3Rpdml0eUFHTS5BR00gPSBjb25maWcuYWdtO1xyXG4gICAgdmFyIGFjdGl2aXR5TWFuYWdlciA9IG5ldyBhY3Rpdml0eU1hbmFnZXJfMVsnZGVmYXVsdCddKGJyaWRnZSwgIWNvbmZpZy5kaXNhYmxlQXV0b0Fubm91bmNlKTtcclxuICAgIHZhciBteSA9IG5ldyBhY3Rpdml0eU15QVBJXzFbJ2RlZmF1bHQnXShhY3Rpdml0eU1hbmFnZXIpO1xyXG4gICAgcmV0dXJuIG5ldyBhY3Rpdml0eUFQSV8xLkFjdGl2aXR5QVBJKGFjdGl2aXR5TWFuYWdlciwgbXkpO1xyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGFjdGl2aXR5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eU1vZHVsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIGVudGl0eUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vY29udHJhY3RzL2VudGl0eUV2ZW50XCIpO1xyXG52YXIgYWN0aXZpdHlTdGF0dXNfMSA9IHJlcXVpcmUoXCIuLi9jb250cmFjdHMvYWN0aXZpdHlTdGF0dXNcIik7XHJcbnZhciBhY3Rpdml0eVR5cGVfMSA9IHJlcXVpcmUoXCIuLi9lbnRpdGllcy9hY3Rpdml0eVR5cGVcIik7XHJcbnZhciB3aW5kb3dUeXBlXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvd2luZG93VHlwZVwiKTtcclxudmFyIGFjdGl2aXR5XzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvYWN0aXZpdHlcIik7XHJcbnZhciBhY3Rpdml0eVdpbmRvd18xID0gcmVxdWlyZShcIi4uL2VudGl0aWVzL2FjdGl2aXR5V2luZG93XCIpO1xyXG52YXIgcHJveHlXaW5kb3dGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vY29yZS9wcm94eVdpbmRvd0ZhY3RvcnlcIik7XHJcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2xvZ2dlclwiKTtcclxudmFyIGVudGl0eUV2ZW50XzIgPSByZXF1aXJlKFwiLi4vY29udHJhY3RzL2VudGl0eUV2ZW50XCIpO1xyXG52YXIgcmVhZHlNYXJrZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3JlYWR5TWFya2VyXCIpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3V0aWxcIik7XHJcbnZhciBlbnRpdHlFdmVudF8zID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0cy9lbnRpdHlFdmVudFwiKTtcclxudmFyIEhDQnJpZGdlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEhDQnJpZGdlKGFnbSkge1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5VHlwZUVudGl0eU5hbWUgPSBcImFjdGl2aXR5VHlwZVwiO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1R5cGVFbnRpdHlOYW1lID0gXCJ3aW5kb3dUeXBlXCI7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlFbnRpdHlOYW1lID0gXCJhY3Rpdml0eVwiO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd0VudGl0eU5hbWUgPSBcImFjdGl2aXR5V2luZG93XCI7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyXzEuTG9nZ2VyLkdldCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9sYXN0U2VxID0gMDtcclxuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlID0gW107XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlUeXBlQ2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgdGhpcy5fd2luZG93VHlwZUNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5Q2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgdGhpcy5fd2luZG93Q2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgdGhpcy5fYWdtID0gYWdtO1xyXG4gICAgfVxyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9yZWFkeU1hcmtlciA9IG5ldyByZWFkeU1hcmtlcl8xLlJlYWR5TWFya2VyKFwiSEMgQnJpZGdlXCIsIDEpO1xyXG4gICAgICAgIHRoaXMuX2h0bWxDb250YWluZXIgPSB3aW5kb3cuaHRtbENvbnRhaW5lci5hY3Rpdml0eUZhY2FkZTtcclxuICAgICAgICB0aGlzLl9odG1sQ29udGFpbmVyLmluaXQodGhpcy5fYWdtID8gdGhpcy5fYWdtLmluc3RhbmNlIDogdW5kZWZpbmVkLCB0aGlzLl9oY0V2ZW50SGFuZGxlci5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZWFkeU1hcmtlci5zaWduYWwoXCJJbml0IGRvbmUgZnJvbSBIQ1wiKTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3JlYWR5TWFya2VyLmVycm9yKGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuc2V0Q2FsbGJhY2soZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoXCJFcnJvciBpbml0aWFsaXppbmcgSEMgYnJpZGdlIC0gXCIgKyBlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfdGhpcy5fcmVhZHlNYXJrZXIuZ2V0RXJyb3IoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5faGNFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnRKc29uKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGV2ZW50SnNvbik7XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gSlNPTi5wYXJzZShldmVudEpzb24pO1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudEJ5U2VxKGV2ZW50KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3Byb2Nlc3NFdmVudEJ5U2VxID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIHNlcSA9IGV2ZW50LnNlcXVlbmNlO1xyXG4gICAgICAgIGlmIChzZXEgPT09IHRoaXMuX2xhc3RTZXEgKyAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RTZXErKztcclxuICAgICAgICAgICAgdmFyIG5leHRFdmVudCA9IHRoaXMuX2V2ZW50UXVldWVbc2VxICsgMV07XHJcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZChuZXh0RXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJyZXBsYXlpbmcgbWVzc2FnZSBudW1iZXIgXCIgKyBzZXEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0V2ZW50QnlTZXEobmV4dEV2ZW50KTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudFF1ZXVlW3NlcSArIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudFF1ZXVlW3NlcV0gPSBldmVudDtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiR290IG91dCBvZiBvcmRlciBldmVudCB3aXRoIG51bWJlciBcIiArIHNlcSArIFwiLiBXaWxsIHdhaXQgZm9yIHByZXZpb3VzIGV2ZW50KHMpIGJlZm9yZSByZXBsYXlpbmcuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3Byb2Nlc3NFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBlbnRpdHlUeXBlID0gZXZlbnQuZW50aXR5VHlwZTtcclxuICAgICAgICB2YXIgZXZlbnRDb250ZXh0ID0gdGhpcy5fY29udmVydENvbnRleHQoZXZlbnQuY29udGV4dCk7XHJcbiAgICAgICAgdmFyIGVudGl0eTtcclxuICAgICAgICBzd2l0Y2ggKGVudGl0eVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSB0aGlzLl9hY3Rpdml0eVR5cGVFbnRpdHlOYW1lOlxyXG4gICAgICAgICAgICAgICAgZW50aXR5ID0gSENCcmlkZ2UuX2hjVG9Kc0FjdGl2aXR5VHlwZShldmVudC5lbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHVibGlzaEFjdGl2aXR5VHlwZVN0YXR1c0NoYW5nZShlbnRpdHksIGV2ZW50Q29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSB0aGlzLl93aW5kb3dUeXBlRW50aXR5TmFtZTpcclxuICAgICAgICAgICAgICAgIGVudGl0eSA9IHRoaXMuX2hjVG9Kc1dpbmRvd1R5cGUoZXZlbnQuZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3B1Ymxpc2hXaW5kb3dUeXBlU3RhdHVzQ2hhbmdlKGVudGl0eSwgZXZlbnRDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIHRoaXMuX2FjdGl2aXR5RW50aXR5TmFtZTpcclxuICAgICAgICAgICAgICAgIGVudGl0eSA9IHRoaXMuX2hjVG9Kc0FjdGl2aXR5KGV2ZW50LmVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoQWN0aXZpdHlTdGF0dXNDaGFuZ2UoZW50aXR5LCBldmVudENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgdGhpcy5fd2luZG93RW50aXR5TmFtZTpcclxuICAgICAgICAgICAgICAgIGVudGl0eSA9IEhDQnJpZGdlLl9oY1RvSnNXaW5kb3coZXZlbnQuZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3B1Ymxpc2hBY3Rpdml0eVdpbmRvd0V2ZW50KGVudGl0eSwgZXZlbnRDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX2NvbnZlcnRDb250ZXh0ID0gZnVuY3Rpb24gKGhjQ29udGV4dCkge1xyXG4gICAgICAgIGlmIChoY0NvbnRleHQudHlwZSA9PT0gZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudFR5cGUuU3RhdHVzQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRTdGF0dXMgPSBuZXcgYWN0aXZpdHlTdGF0dXNfMS5BY3Rpdml0eVN0YXR1cyhoY0NvbnRleHQub2xkU3RhdHVzLnN0YXRlLCBoY0NvbnRleHQub2xkU3RhdHVzLnN0YXR1c01lc3NhZ2UsIGhjQ29udGV4dC5vbGRTdGF0dXMuc3RhdHVzVGltZSk7XHJcbiAgICAgICAgICAgIHZhciBuZXdTdGF0dXMgPSBuZXcgYWN0aXZpdHlTdGF0dXNfMS5BY3Rpdml0eVN0YXR1cyhoY0NvbnRleHQubmV3U3RhdHVzLnN0YXRlLCBoY0NvbnRleHQubmV3U3RhdHVzLnN0YXR1c01lc3NhZ2UsIGhjQ29udGV4dC5uZXdTdGF0dXMuc3RhdHVzVGltZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgZW50aXR5RXZlbnRfMS5FbnRpdHlTdGF0dXNDaGFuZ2VFdmVudENvbnRleHQobmV3U3RhdHVzLCBvbGRTdGF0dXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoY0NvbnRleHQudHlwZSA9PT0gZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudFR5cGUuQWN0aXZpdHlXaW5kb3dFdmVudCkge1xyXG4gICAgICAgICAgICB2YXIgYWN0ID0gdGhpcy5faGNUb0pzQWN0aXZpdHkoaGNDb250ZXh0LmFjdGl2aXR5KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBlbnRpdHlFdmVudF8xLkVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0KGFjdCwgaGNDb250ZXh0LmV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGNDb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5Q29udGV4dENoYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGVudGl0eUV2ZW50XzMuQWN0aXZpdHlDb250ZXh0Q2hhbmdlZENvbnRleHQoaGNDb250ZXh0Lm5ld0NvbnRleHQsIGhjQ29udGV4dC51cGRhdGVkLCBoY0NvbnRleHQucmVtb3ZlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudENvbnRleHQoaGNDb250ZXh0LnR5cGUpO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLl9oY1RvSnNXaW5kb3cgPSBmdW5jdGlvbiAoaGNXaW5kb3cpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGFjdGl2aXR5V2luZG93XzFbJ2RlZmF1bHQnXShoY1dpbmRvdy5pZCwgaGNXaW5kb3cubmFtZSwgaGNXaW5kb3cudHlwZSwgaGNXaW5kb3cuYWN0aXZpdHlJZCwgaGNXaW5kb3cuaW5zdGFuY2UsIGhjV2luZG93LmlzSW5kZXBlbmRlbnQpO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5faGNUb0pzQWN0aXZpdHkgPSBmdW5jdGlvbiAoaGNBY3QpIHtcclxuICAgICAgICB2YXIgd2luZG93ID0gaGNBY3Qub3duZXIgPyBIQ0JyaWRnZS5faGNUb0pzV2luZG93KGhjQWN0Lm93bmVyKSA6IG51bGw7XHJcbiAgICAgICAgdmFyIHN0YXR1cyA9IG5ldyBhY3Rpdml0eVN0YXR1c18xLkFjdGl2aXR5U3RhdHVzKGhjQWN0LnN0YXR1cy5zdGF0ZSwgaGNBY3Quc3RhdHVzLnN0YXR1c01lc3NhZ2UsIGhjQWN0LnN0YXR1cy5zdGF0dXNUaW1lKTtcclxuICAgICAgICB2YXIgaGVscGVyV2luZG93cyA9IGhjQWN0LndpbmRvd3MgPyBoY0FjdC53aW5kb3dzLm1hcChmdW5jdGlvbiAodykgeyByZXR1cm4gSENCcmlkZ2UuX2hjVG9Kc1dpbmRvdyh3KTsgfSkgOiBbXTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IEpTT04ucGFyc2UoaGNBY3QuY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhY3Rpdml0eV8xWydkZWZhdWx0J10oaGNBY3QuaWQsIGhjQWN0LnR5cGUubmFtZSwgc3RhdHVzLCBjb250ZXh0LCB3aW5kb3csIGhlbHBlcldpbmRvd3MpO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLl9oY1RvSnNBY3Rpdml0eVR5cGUgPSBmdW5jdGlvbiAoaGNBY3RUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhY3Rpdml0eVR5cGVfMVsnZGVmYXVsdCddKGhjQWN0VHlwZS5uYW1lLCBoY0FjdFR5cGUub3duZXJXaW5kb3dUeXBlLCBoY0FjdFR5cGUuaGVscGVyV2luZG93VHlwZXMsIGhjQWN0VHlwZS5kZXNjcmlwdGlvbik7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLl9oY1RvSnNXaW5kb3dUeXBlID0gZnVuY3Rpb24gKGhjV2luVHlwZSkge1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGhjV2luVHlwZS5mYWN0b3JpZXMpKSB7XHJcbiAgICAgICAgICAgIGhjV2luVHlwZS5mYWN0b3JpZXMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZhY3RvcmllcyA9IGhjV2luVHlwZS5mYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBIQ0JyaWRnZS5faGNUb0pzV2luZG93VHlwZUZhY3RvcnkoZik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3dUeXBlXzFbJ2RlZmF1bHQnXShoY1dpblR5cGUubmFtZSwgZmFjdG9yaWVzKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5faGNUb0pzV2luZG93VHlwZUZhY3RvcnkgPSBmdW5jdGlvbiAoaGNXaW5UeXBlRmFjdG9yeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgcHJveHlXaW5kb3dGYWN0b3J5XzEuUHJveHlXaW5kb3dGYWN0b3J5KGhjV2luVHlwZUZhY3RvcnkuZGVzY3JpcHRpb24pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLl9nZXRVUkxQYXJhbWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoKG5ldyBSZWdFeHAoJ1s/fCZdJyArIG5hbWUgKyAnPScgKyAnKFteJjtdKz8pKCZ8I3w7fCQpJykuZXhlYyhsb2NhdGlvbi5zZWFyY2gpIHx8IFssIFwiXCJdKVsxXS5yZXBsYWNlKC9cXCsvZywgJyUyMCcpKSB8fCBudWxsO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5nZXRBY3Rpdml0eVR5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuZ2V0QWN0aXZpdHlUeXBlcyhmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbmZvcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IGluZm9zW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3QWN0aXZpdHlUeXBlID0gSENCcmlkZ2UuX2hjVG9Kc0FjdGl2aXR5VHlwZShpbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdBY3Rpdml0eVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5yZWdpc3RlckFjdGl2aXR5VHlwZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVR5cGVOYW1lLCBvd25lcldpbmRvdywgaGVscGVyV2luZG93cywgbGF5b3V0Q29uZmlnLCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKGhlbHBlcldpbmRvd3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaGVscGVyV2luZG93cyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb25maWcgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBhY3Rpdml0eVR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgb3duZXJXaW5kb3dUeXBlOiBvd25lcldpbmRvdyxcclxuICAgICAgICAgICAgICAgIGhlbHBlcldpbmRvd1R5cGVzOiBoZWxwZXJXaW5kb3dzLFxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAgbGF5b3V0Q29uZmlnOiBKU09OLnN0cmluZ2lmeShsYXlvdXRDb25maWcpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnJlZ2lzdGVyQWN0aXZpdHlUeXBlKEpTT04uc3RyaW5naWZ5KGNvbmZpZyksIGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWN0aXZpdHlUeXBlID0gSENCcmlkZ2UuX2hjVG9Kc0FjdGl2aXR5VHlwZShpbmZvKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUobmV3QWN0aXZpdHlUeXBlKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUudW5yZWdpc3RlckFjdGl2aXR5VHlwZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVR5cGVOYW1lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci51bnJlZ2lzdGVyQWN0aXZpdHlUeXBlKGFjdGl2aXR5VHlwZU5hbWUsIGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5nZXRXaW5kb3dUeXBlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmdldFdpbmRvd1R5cGVzKGZ1bmN0aW9uIChpbmZvcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGluZm9zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gaW5mb3NbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdXaW5kb3dUeXBlID0gX3RoaXMuX2hjVG9Kc1dpbmRvd1R5cGUoaW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3V2luZG93VHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLnJlZ2lzdGVyV2luZG93RmFjdG9yeSA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlTmFtZSwgZmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwod2luZG93VHlwZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJ3aW5kb3dUeXBlTmFtZSBzaG91bGQgYmUgcHJvdmlkZWRcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIucmVnaXN0ZXJXaW5kb3dGYWN0b3J5KHdpbmRvd1R5cGVOYW1lLCBmYWN0b3J5LmNyZWF0ZS5iaW5kKGZhY3RvcnkpLCBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuaW5pdGlhdGVBY3Rpdml0eSA9IGZ1bmN0aW9uIChhY3Rpdml0eVR5cGUsIGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbChhY3Rpdml0eVR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJ3aW5kb3dUeXBlTmFtZSBzaG91bGQgYmUgcHJvdmlkZWRcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5pbml0aWF0ZShhY3Rpdml0eVR5cGUsIEpTT04uc3RyaW5naWZ5KGNvbnRleHQpLCBmdW5jdGlvbiAoYWN0aXZpdHlJZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhY3Rpdml0eUlkKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuZ2V0QW5ub3VuY2VtZW50SW5mbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGMgPSB3aW5kb3cuaHRtbENvbnRhaW5lcjtcclxuICAgICAgICB2YXIgY29udGV4dCA9IGhjLmdldENvbnRleHQoKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0geyBhY3Rpdml0eVdpbmRvd0lkOiBcIlwiLCBhY3Rpdml0eVdpbmRvd1R5cGU6IFwiXCIsIGFjdGl2aXR5V2luZG93SW5kZXBlbmRlbnQ6IGZhbHNlLCBhY3Rpdml0eVdpbmRvd05hbWU6IFwiXCIgfTtcclxuICAgICAgICByZXN1bHQuYWN0aXZpdHlXaW5kb3dUeXBlID0gY29udGV4dC5hY3Rpdml0eVdpbmRvd1R5cGU7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQocmVzdWx0LmFjdGl2aXR5V2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFjdGl2aXR5V2luZG93VHlwZSA9IEhDQnJpZGdlLl9nZXRVUkxQYXJhbWV0ZXIoXCJhY3Rpdml0eVdpbmRvd1R5cGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5hY3Rpdml0eVdpbmRvd0lkID0gY29udGV4dC5hY3Rpdml0eVdpbmRvd0lkO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHJlc3VsdC5hY3Rpdml0eVdpbmRvd0lkKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuYWN0aXZpdHlXaW5kb3dJZCA9IEhDQnJpZGdlLl9nZXRVUkxQYXJhbWV0ZXIoXCJhY3Rpdml0eVdpbmRvd0lkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuYWN0aXZpdHlXaW5kb3dJbmRlcGVuZGVudCA9IGNvbnRleHQuYWN0aXZpdHlXaW5kb3dJbmRlcGVuZGVudDtcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChyZXN1bHQuYWN0aXZpdHlXaW5kb3dJbmRlcGVuZGVudCkpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmFjdGl2aXR5V2luZG93TmFtZSA9IGNvbnRleHQuYWN0aXZpdHlXaW5kb3dOYW1lO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHJlc3VsdC5hY3Rpdml0eVdpbmRvd05hbWUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hY3Rpdml0eVdpbmRvd05hbWUgPSBIQ0JyaWRnZS5fZ2V0VVJMUGFyYW1ldGVyKFwiYWN0aXZpdHlXaW5kb3dOYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5hbm5vdW5jZVdpbmRvdyA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlLCBhY3Rpdml0eVdpbmRvd0lkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gbm90IGRldGVybWluZSB3aW5kb3cgdHlwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuIG5vdCBkZXRlcm1pbmUgd2luZG93IGFjdGl2aXR5V2luZG93SWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2h0bWxDb250YWluZXIuYW5ub3VuY2VXaW5kb3cod2luZG93VHlwZSwgYWN0aXZpdHlXaW5kb3dJZCwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoXCJFcnJvciBhbm5vdW5jaW5nIGFjdGl2aXR5IHdpbmRvdyB3aXRoIGlkICdcIiArIGFjdGl2aXR5V2luZG93SWQgKyBcIicuIFwiICsgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5nZXRBY3Rpdml0aWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci50cmFjZShcIkV4ZWN1dGluZyBnZXRBY3Rpdml0aWVzKClcIik7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLmdldEFjdGl2aXRpZXMoZnVuY3Rpb24gKGFjdGl2aXRpZXNTdHIpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIudHJhY2UoXCJHb3QgZ2V0QWN0aXZpdGllcygpIDpcIiArIGFjdGl2aXRpZXNTdHIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2aXRpZXMgPSBKU09OLnBhcnNlKGFjdGl2aXRpZXNTdHIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGFjdGl2aXRpZXMubWFwKGZ1bmN0aW9uIChhY3QpIHsgcmV0dXJuIF90aGlzLl9oY1RvSnNBY3Rpdml0eShhY3QpOyB9KTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLnRyYWNlKFwiRXJyb3IgaW4gZ2V0QWN0aXZpdGllcygpIDpcIiArIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS51cGRhdGVBY3Rpdml0eUNvbnRleHQgPSBmdW5jdGlvbiAoYWN0aXZpdHksIGNvbnRleHQsIGZ1bGxSZXBsYWNlLCByZW1vdmVkS2V5cykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQocmVtb3ZlZEtleXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkS2V5cyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgZnVsbFJlcGxhY2U6IGZ1bGxSZXBsYWNlLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZEtleXM6IHJlbW92ZWRLZXlzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnNldEFjdGl2aXR5Q29udGV4dChhY3Rpdml0eS5pZCwgSlNPTi5zdHJpbmdpZnkoY29udGV4dCksIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpLCBmdW5jdGlvbiAobmV3Q29udGV4dFN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0NvbnRleHQgPSBKU09OLnBhcnNlKG5ld0NvbnRleHRTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZXdDb250ZXh0KTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiByZWplY3QoZXJyb3IpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuZ2V0QWN0aXZpdHlXaW5kb3dzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuZ2V0V2luZG93cyhmdW5jdGlvbiAod2luZG93cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHdpbmRvd3MubWFwKGZ1bmN0aW9uICh3aW5kKSB7IHJldHVybiBIQ0JyaWRnZS5faGNUb0pzV2luZG93KHdpbmQpOyB9KTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuc3RvcEFjdGl2aXR5ID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5zdG9wQWN0aXZpdHkoYWN0aXZpdHkuaWQsIGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUudW5yZWdpc3RlcldpbmRvd0ZhY3RvcnkgPSBmdW5jdGlvbiAod2luZG93VHlwZU5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnJlZ2lzdGVyV2luZG93RmFjdG9yeSh3aW5kb3dUeXBlTmFtZSwgZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLmNyZWF0ZVdpbmRvdyA9IGZ1bmN0aW9uIChpZCwgd2luZG93RGVmaW5pdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuY3JlYXRlV2luZG93KGlkLCBKU09OLnN0cmluZ2lmeSh3aW5kb3dEZWZpbml0aW9uKSwgZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGlkKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUub25BY3Rpdml0eVR5cGVTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eVR5cGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLm9uV2luZG93VHlwZVN0YXR1c0NoYW5nZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1R5cGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgSENCcmlkZ2UucHJvdG90eXBlLm9uQWN0aXZpdHlTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUub25BY3Rpdml0eVdpbmRvd0NoYW5nZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuZ2V0V2luZG93Qm91bmRzID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5faHRtbENvbnRhaW5lci5nZXRXaW5kb3dCb3VuZHMoaWQsIGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoYm91bmRzKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5zZXRXaW5kb3dCb3VuZHMgPSBmdW5jdGlvbiAoaWQsIGJvdW5kcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuc2V0V2luZG93Qm91bmRzKGlkLCBKU09OLnN0cmluZ2lmeShib3VuZHMpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUucmVnaXN0ZXJXaW5kb3cgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgaW5kZXBlbmRlbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9odG1sQ29udGFpbmVyLnJlZ2lzdGVyV2luZG93KHR5cGUsIG5hbWUsIGluZGVwZW5kZW50LCBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoaWQpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5jbG9zZVdpbmRvdyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2h0bWxDb250YWluZXIuY2xvc2VXaW5kb3coaWQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5fcHVibGlzaFN0YXR1c0NoYW5nZSA9IGZ1bmN0aW9uIChlbnRpdHksIGNvbnRleHQsIGNhbGxiYWNrcykge1xyXG4gICAgICAgIHZhciBlbnRpdHlFdmVudCA9IG5ldyBlbnRpdHlFdmVudF8yLkVudGl0eUV2ZW50KGVudGl0eSwgY29udGV4dCk7XHJcbiAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVudGl0eUV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3B1Ymxpc2hBY3Rpdml0eVR5cGVTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAoYXQsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9wdWJsaXNoU3RhdHVzQ2hhbmdlKGF0LCBjb250ZXh0LCB0aGlzLl9hY3Rpdml0eVR5cGVDYWxsYmFja3MpO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5fcHVibGlzaFdpbmRvd1R5cGVTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiAod3QsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9wdWJsaXNoU3RhdHVzQ2hhbmdlKHd0LCBjb250ZXh0LCB0aGlzLl93aW5kb3dUeXBlQ2FsbGJhY2tzKTtcclxuICAgIH07XHJcbiAgICBIQ0JyaWRnZS5wcm90b3R5cGUuX3B1Ymxpc2hBY3Rpdml0eVN0YXR1c0NoYW5nZSA9IGZ1bmN0aW9uIChhY3QsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9wdWJsaXNoU3RhdHVzQ2hhbmdlKGFjdCwgY29udGV4dCwgdGhpcy5fYWN0aXZpdHlDYWxsYmFja3MpO1xyXG4gICAgfTtcclxuICAgIEhDQnJpZGdlLnByb3RvdHlwZS5fcHVibGlzaEFjdGl2aXR5V2luZG93RXZlbnQgPSBmdW5jdGlvbiAodywgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuX3B1Ymxpc2hTdGF0dXNDaGFuZ2UodywgY29udGV4dCwgdGhpcy5fd2luZG93Q2FsbGJhY2tzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSENCcmlkZ2U7XHJcbn0oKSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0c1snZGVmYXVsdCddPSBIQ0JyaWRnZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGNCcmlkZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBBY3Rpdml0eVN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eVN0YXR1cyhzdGF0ZSwgbWVzc2FnZSwgdGltZSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XHJcbiAgICB9XHJcbiAgICBBY3Rpdml0eVN0YXR1cy5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlTdGF0dXMucHJvdG90eXBlLmdldE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eVN0YXR1cy5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eVN0YXR1cztcclxufSgpKTtcclxuZXhwb3J0cy5BY3Rpdml0eVN0YXR1cyA9IEFjdGl2aXR5U3RhdHVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eVN0YXR1cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIEVudGl0eUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVudGl0eUV2ZW50KGVudGl0aXksIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmVudGl0eSA9IGVudGl0aXk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgIH1cclxuICAgIHJldHVybiBFbnRpdHlFdmVudDtcclxufSgpKTtcclxuZXhwb3J0cy5FbnRpdHlFdmVudCA9IEVudGl0eUV2ZW50O1xyXG52YXIgRW50aXR5RXZlbnRDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVudGl0eUV2ZW50Q29udGV4dChldmVudFR5cGUpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRW50aXR5RXZlbnRDb250ZXh0O1xyXG59KCkpO1xyXG5leHBvcnRzLkVudGl0eUV2ZW50Q29udGV4dCA9IEVudGl0eUV2ZW50Q29udGV4dDtcclxudmFyIEVudGl0eVN0YXR1c0NoYW5nZUV2ZW50Q29udGV4dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0KG5ld1N0YXR1cywgb2xkU3RhdHVzKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgRW50aXR5RXZlbnRUeXBlLlN0YXR1c0NoYW5nZSk7XHJcbiAgICAgICAgdGhpcy5uZXdTdGF0dXMgPSBuZXdTdGF0dXM7XHJcbiAgICAgICAgdGhpcy5vbGRTdGF0dXMgPSBvbGRTdGF0dXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRW50aXR5U3RhdHVzQ2hhbmdlRXZlbnRDb250ZXh0O1xyXG59KEVudGl0eUV2ZW50Q29udGV4dCkpO1xyXG5leHBvcnRzLkVudGl0eVN0YXR1c0NoYW5nZUV2ZW50Q29udGV4dCA9IEVudGl0eVN0YXR1c0NoYW5nZUV2ZW50Q29udGV4dDtcclxudmFyIEVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbnRpdHlBY3Rpdml0eVdpbmRvd0V2ZW50Q29udGV4dCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0KGFjdGl2aXR5LCBldmVudCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIEVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eVdpbmRvd0V2ZW50KTtcclxuICAgICAgICB0aGlzLmFjdGl2aXR5ID0gYWN0aXZpdHk7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0O1xyXG59KEVudGl0eUV2ZW50Q29udGV4dCkpO1xyXG5leHBvcnRzLkVudGl0eUFjdGl2aXR5V2luZG93RXZlbnRDb250ZXh0ID0gRW50aXR5QWN0aXZpdHlXaW5kb3dFdmVudENvbnRleHQ7XHJcbnZhciBBY3Rpdml0eUNvbnRleHRDaGFuZ2VkQ29udGV4dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWN0aXZpdHlDb250ZXh0Q2hhbmdlZENvbnRleHQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBY3Rpdml0eUNvbnRleHRDaGFuZ2VkQ29udGV4dChjb250ZXh0LCB1cGRhdGVkLCByZW1vdmVkKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5Q29udGV4dENoYW5nZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVkID0gdXBkYXRlZDtcclxuICAgICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IEpTT04ucGFyc2UoY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQWN0aXZpdHlDb250ZXh0Q2hhbmdlZENvbnRleHQ7XHJcbn0oRW50aXR5RXZlbnRDb250ZXh0KSk7XHJcbmV4cG9ydHMuQWN0aXZpdHlDb250ZXh0Q2hhbmdlZENvbnRleHQgPSBBY3Rpdml0eUNvbnRleHRDaGFuZ2VkQ29udGV4dDtcclxudmFyIEVudGl0eUV2ZW50VHlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbnRpdHlFdmVudFR5cGUoKSB7XHJcbiAgICB9XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuQWRkZWQgPSBcImFkZGVkXCI7XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuUmVtb3ZlZCA9IFwicmVtb3ZlZFwiO1xyXG4gICAgRW50aXR5RXZlbnRUeXBlLlVwZGF0ZWQgPSBcInVwZGF0ZWRcIjtcclxuICAgIEVudGl0eUV2ZW50VHlwZS5GYWN0b3J5UmVnaXN0ZXJlZCA9IFwiZmFjdG9yeVJlZ2lzdGVyZWRcIjtcclxuICAgIEVudGl0eUV2ZW50VHlwZS5GYWN0b3J5VW5yZWdpc3RlcmVkID0gXCJmYWN0b3J5VW5yZWdpc3RlcmVkXCI7XHJcbiAgICBFbnRpdHlFdmVudFR5cGUuU3RhdHVzQ2hhbmdlID0gXCJzdGF0dXNDaGFuZ2VcIjtcclxuICAgIEVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eUNvbnRleHRDaGFuZ2UgPSBcImFjdGl2aXR5Q29udGV4dFVwZGF0ZVwiO1xyXG4gICAgRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5V2luZG93RXZlbnQgPSBcImFjdGl2aXR5V2luZG93RXZlbnRcIjtcclxuICAgIHJldHVybiBFbnRpdHlFdmVudFR5cGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRW50aXR5RXZlbnRUeXBlID0gRW50aXR5RXZlbnRUeXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnRpdHlFdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgQWN0aXZpdHlBR00gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlBR00oYWN0aXZpdHkpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0eSA9IGFjdGl2aXR5O1xyXG4gICAgfVxyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVIYXNBZ20oKTtcclxuICAgICAgICBBY3Rpdml0eUFHTS5BR00ucmVnaXN0ZXIoZGVmaW5pdGlvbiwgaGFuZGxlcik7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLnNlcnZlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2aXR5LndpbmRvd3MubWFwKGZ1bmN0aW9uICh3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3Lmluc3RhbmNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5tZXRob2RzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuX2FjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3aW5kb3dzID0gdGhpcy5fYWN0aXZpdHkud2luZG93cztcclxuICAgICAgICB2YXIgbWV0aG9kTmFtZXMgPSBbXTtcclxuICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB3aW5kb3dzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgd2luZG93XzEgPSB3aW5kb3dzW2luZGV4XTtcclxuICAgICAgICAgICAgdmFyIHdpbmRvd01ldGhvZHMgPSB0aGlzLm1ldGhvZHNGb3JXaW5kb3cod2luZG93XzEpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBtZXRob2RJbmRleCA9IDA7IG1ldGhvZEluZGV4IDwgd2luZG93TWV0aG9kcy5sZW5ndGg7IG1ldGhvZEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50V2luZG93TWV0aG9kID0gd2luZG93TWV0aG9kc1ttZXRob2RJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kTmFtZXMuaW5kZXhPZihjdXJyZW50V2luZG93TWV0aG9kLm5hbWUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWVzLnB1c2goY3VycmVudFdpbmRvd01ldGhvZC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2RzLnB1c2goY3VycmVudFdpbmRvd01ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZHM7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLm1ldGhvZHNGb3JXaW5kb3cgPSBmdW5jdGlvbiAod2luZG93KSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgaWYgKCF3aW5kb3cuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQWN0aXZpdHlBR00uQUdNLm1ldGhvZHNGb3JJbnN0YW5jZSh3aW5kb3cuaW5zdGFuY2UpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgYXJnLCB0YXJnZXQsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgdmFyIGFjdGl2aXR5U2VydmVycyA9IHRoaXMuc2VydmVycygpO1xyXG4gICAgICAgIHZhciBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gW107XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBcImFjdGl2aXR5LmFsbFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXRpbC5pc1N0cmluZyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IFwiYWN0aXZpdHkuYWxsXCIpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlcnNUb0ludm9rZUFnYWluc3QgPSBhY3Rpdml0eVNlcnZlcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBcImFjdGl2aXR5LmJlc3RcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvdGVudGlhbFRhcmdldHMgPSBhY3Rpdml0eVNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kcyA9IEFjdGl2aXR5QUdNLkFHTS5tZXRob2RzRm9ySW5zdGFuY2Uoc2VydmVyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ubmFtZSA9PT0gbWV0aG9kTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocG90ZW50aWFsVGFyZ2V0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyc1RvSW52b2tlQWdhaW5zdCA9IFtwb3RlbnRpYWxUYXJnZXRzWzBdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IFwiYWxsXCIgfHwgdGFyZ2V0ID09PSBcImJlc3RcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFjdGl2aXR5QUdNLkFHTS5pbnZva2UobWV0aG9kTmFtZSwgYXJnLCB0YXJnZXQsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW52b2tlIHRhcmdldCBcIiArIHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodXRpbC5pc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0RWxlbSA9IHRhcmdldFswXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0FnbUluc3RhbmNlKGZpcnN0RWxlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9JbnZva2VBZ2FpbnN0ID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAoaW5zdGFuY2UpIHsgcmV0dXJuIGluc3RhbmNlOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQWN0aXZpdHlXaW5kb3coZmlyc3RFbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlcnNUb0ludm9rZUFnYWluc3QgPSB0YXJnZXQubWFwKGZ1bmN0aW9uICh3aW4pIHsgcmV0dXJuIHdpbi5pbnN0YW5jZTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRhcmdldCBvYmplY3RcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0FnbUluc3RhbmNlKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlcnNUb0ludm9rZUFnYWluc3QgPSBbdGFyZ2V0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0FjdGl2aXR5V2luZG93KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlcnNUb0ludm9rZUFnYWluc3QgPSBbdGFyZ2V0Lmluc3RhbmNlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdGFyZ2V0IG9iamVjdFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQWN0aXZpdHlBR00uQUdNLmludm9rZShtZXRob2ROYW1lLCBhcmcsIHNlcnZlcnNUb0ludm9rZUFnYWluc3QsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlSGFzQWdtKCk7XHJcbiAgICAgICAgcmV0dXJuIEFjdGl2aXR5QUdNLkFHTS51bnJlZ2lzdGVyKGRlZmluaXRpb24pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5jcmVhdGVTdHJlYW0gPSBmdW5jdGlvbiAobWV0aG9kRGVmaW5pdGlvbiwgc3Vic2NyaWJlckFkZGVkSGFuZGxlciwgc3Vic2NyaWJlclJlbW92ZWRGdW5jdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUhhc0FnbSgpO1xyXG4gICAgICAgIEFjdGl2aXR5QUdNLkFHTS5jcmVhdGVTdHJlYW0obWV0aG9kRGVmaW5pdGlvbiwgc3Vic2NyaWJlckFkZGVkSGFuZGxlciwgc3Vic2NyaWJlclJlbW92ZWRGdW5jdGlvbik7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlBR00ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChtZXRob2REZWZpbml0aW9uLCBwYXJhbWV0ZXJzLCB0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVIYXNBZ20oKTtcclxuICAgICAgICB2YXIgc2VydmVycyA9IHRoaXMuc2VydmVycygpO1xyXG4gICAgICAgIHJldHVybiBBY3Rpdml0eUFHTS5BR00uc3Vic2NyaWJlKG1ldGhvZERlZmluaXRpb24sIHBhcmFtZXRlcnMsIHNlcnZlcnMpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5fZW5zdXJlSGFzQWdtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKEFjdGl2aXR5QUdNLkFHTSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWdtIHNob3VsZCBiZSBjb25maWd1cmVkIHRvIGJlIHVzZWQgaW4gYWN0aXZpdHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5QUdNLnByb3RvdHlwZS5faXNBZ21JbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqLmFwcGxpY2F0aW9uICE9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUFHTS5wcm90b3R5cGUuX2lzQWN0aXZpdHlXaW5kb3cgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iai5pbnN0YW5jZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eUFHTTtcclxufSgpKTtcclxuZXhwb3J0cy5BY3Rpdml0eUFHTSA9IEFjdGl2aXR5QUdNO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eUFHTS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIGVudGl0eUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vY29udHJhY3RzL2VudGl0eUV2ZW50XCIpO1xyXG52YXIgYWN0aXZpdHlUeXBlXzEgPSByZXF1aXJlKFwiLi4vZW50aXRpZXMvYWN0aXZpdHlUeXBlXCIpO1xyXG52YXIgcHJvbWlzZUV4dGVuc2lvbnNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3Byb21pc2VFeHRlbnNpb25zXCIpO1xyXG52YXIgcmVhZHlNYXJrZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3JlYWR5TWFya2VyXCIpO1xyXG52YXIgZW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2VudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXCIpO1xyXG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIGxvY2FsV2luZG93RmFjdG9yeV8xID0gcmVxdWlyZShcIi4vbG9jYWxXaW5kb3dGYWN0b3J5XCIpO1xyXG52YXIgQWN0aXZpdHlNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFjdGl2aXR5TWFuYWdlcihicmlkZ2UsIGF1dG9Bbm5vdW5jZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyXzEuTG9nZ2VyLkdldCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9hbm5vdW5jZWRXaW5kb3dzID0gW107XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlID0gYnJpZGdlO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5VHlwZXMgPSBuZXcgZW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb25fMS5FbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbihmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX2dyYWJFbnRpdHkoZSk7IH0pO1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1R5cGVzID0gbmV3IGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9ncmFiRW50aXR5KGUpOyB9KTtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0aWVzID0gbmV3IGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9ncmFiRW50aXR5KGUpOyB9KTtcclxuICAgICAgICB0aGlzLl93aW5kb3dzID0gbmV3IGVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uXzEuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24oZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl9ncmFiRW50aXR5KGUpOyB9KTtcclxuICAgICAgICB0aGlzLl9kYXRhUmVhZHlNYXJrZXIgPSBuZXcgcmVhZHlNYXJrZXJfMS5SZWFkeU1hcmtlcihcIkFjdGl2aXR5IE1hbmFnZXIgRGF0YVwiLCBbXCJHZXRBY3Rpdml0eVR5cGVzXCIsIFwiR2V0V2luZG93VHlwZXNcIiwgXCJHZXRBY3Rpdml0aWVzXCIsIFwiR2V0V2luZG93c1wiXS5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChhdXRvQW5ub3VuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGFubm91bmNlTWFrZXIgPSBuZXcgcmVhZHlNYXJrZXJfMS5SZWFkeU1hcmtlcihcIkFjdGl2aXR5IE1hbmFnZXIgQW5ub3VuY2VcIiwgW1wiQW5ub3VuY2VtZW50XCJdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5TWFya2VyID0gYW5ub3VuY2VNYWtlcjtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YVJlYWR5TWFya2VyLnNldENhbGxiYWNrKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJBdXRvIGFubm91bmNpbmcgd2luZG93XCIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYW5ub3VuY2VXaW5kb3coKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Fubm91bmNlZFdpbmRvd3MucHVzaCh3KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVhZHlNYXJrZXIuc2lnbmFsKFwiU3VjY2Vzc2Z1bGx5IGFubm91bmNlZCB3aW5kb3cgd2l0aCBpZCAnXCIgKyB3LmlkICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJXaWxsIG5vdCBhbm5vdW5jZSB3aW5kb3cgLSBcIiArIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlYWR5TWFya2VyLnNpZ25hbCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlNYXJrZXIgPSB0aGlzLl9kYXRhUmVhZHlNYXJrZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgIC5yZWFkeSgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhdykge1xyXG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaWJlRm9yRGF0YSgpO1xyXG4gICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZSwgXCJhbm5vdW5jZWRXaW5kb3dzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fubm91bmNlZFdpbmRvd3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbGxvd2VkXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZWFkeU1hcmtlci5zZXRDYWxsYmFjayhmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF90aGlzLl9yZWFkeU1hcmtlci5nZXRFcnJvcigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRBY3Rpdml0eVR5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpdml0eVR5cGVzLmdldCgpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuZ2V0QWN0aXZpdHlUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZpdHlUeXBlcy5nZXRCeU5hbWUobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlckFjdGl2aXR5VHlwZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVR5cGVOYW1lLCBvd25lcldpbmRvd1R5cGUsIGhlbHBlcldpbmRvd1R5cGVzLCBsYXlvdXRDb25maWcsIGRlc2NyaXB0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5VHlwZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJhY3Rpdml0eVR5cGVOYW1lIGFyZ3VtZW50IGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhhY3Rpdml0eVR5cGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiYWN0aXZpdHlUeXBlTmFtZSBzaG91bGQgYmUgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhY3RUeXBlID0gX3RoaXMuZ2V0QWN0aXZpdHlUeXBlKGFjdGl2aXR5VHlwZU5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIkFjdGl2aXR5IHR5cGUgJ1wiICsgYWN0aXZpdHlUeXBlTmFtZSArIFwiJyBhbHJlYWR5IGV4aXN0c1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb3duZXJEZWZpbml0aW9uO1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChvd25lcldpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJPd25lciB3aW5kb3cgdHlwZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhvd25lcldpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBvd25lckRlZmluaXRpb24gPSB7IHR5cGU6IG93bmVyV2luZG93VHlwZSwgbmFtZTogXCJcIiwgaXNJbmRlcGVuZGVudDogZmFsc2UsIGFyZ3VtZW50czoge30gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG93bmVyRGVmaW5pdGlvbiA9IG93bmVyV2luZG93VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaGVscGVyRGVmaW5pdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGhlbHBlcldpbmRvd1R5cGVzKSAmJiB1dGlsLmlzQXJyYXkoaGVscGVyV2luZG93VHlwZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCBpbiBoZWxwZXJXaW5kb3dUeXBlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaGVscGVyV2luZG93VHlwZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0luZGVwZW5kZW50OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVEaXJlY3Rpb246IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dTdHlsZUF0dHJpYnV0ZXM6IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlckRlZmluaXRpb25zLnB1c2goZGVmaW5pdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJEZWZpbml0aW9ucy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgICAgICAucmVnaXN0ZXJBY3Rpdml0eVR5cGUoYWN0aXZpdHlUeXBlTmFtZSwgb3duZXJEZWZpbml0aW9uLCBoZWxwZXJEZWZpbml0aW9ucywgbGF5b3V0Q29uZmlnLCBkZXNjcmlwdGlvbilcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhY3Rpdml0eVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9ncmFiRW50aXR5KGFjdGl2aXR5VHlwZSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGFjdGl2aXR5VHlwZSk7XHJcbiAgICAgICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS51bnJlZ2lzdGVyQWN0aXZpdHlUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFjdFR5cGUgPSBfdGhpcy5nZXRBY3Rpdml0eVR5cGUodHlwZSk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJBY3Rpdml0eSB0eXBlICdcIiArIHR5cGUgKyBcIicgZG9lcyBub3QgZXhpc3RzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYnJpZGdlLnVucmVnaXN0ZXJBY3Rpdml0eVR5cGUodHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5pbml0aWF0ZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVR5cGUsIGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFjdFR5cGUgPSBfdGhpcy5nZXRBY3Rpdml0eVR5cGUoYWN0aXZpdHlUeXBlKTtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoYWN0VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChcIkFjdGl2aXR5IHR5cGUgJ1wiICsgYWN0aXZpdHlUeXBlICsgXCInIGRvZXMgbm90IGV4aXN0c1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgICAgICAuaW5pdGlhdGVBY3Rpdml0eShhY3Rpdml0eVR5cGUsIGNvbnRleHQpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWN0SWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9hY3Rpdml0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldE9yV2FpdChhY3RJZClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhY3QpO1xyXG4gICAgICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcmVqZWN0KGVycik7IH0pO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpdml0eVR5cGVFdmVudHMgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5VHlwZXMuc3Vic2NyaWJlKGZ1bmN0aW9uIChhdCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyKGF0LCBjb250ZXh0LnR5cGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuZ2V0V2luZG93VHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpbmRvd1R5cGVzLmdldCgpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuZ2V0V2luZG93VHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpbmRvd1R5cGVzLmdldEJ5TmFtZShuYW1lKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyV2luZG93RmFjdG9yeSA9IGZ1bmN0aW9uICh3aW5kb3dUeXBlLCBmYWN0b3J5TWV0aG9kLCBkZXNjcmlwdGlvbiwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwibm8gd2luZG93VHlwZSBzcGVjaWZpZWRcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3Qod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvd1R5cGUgPSB3aW5kb3dUeXBlLmdldE5hbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdXRpbC5pc1N0cmluZyh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwid2luZG93VHlwZSBzaG91bGQgYmUgc3RyaW5nIG9yIG9iamVjdCB0aGF0IGhhcyBnZXROYW1lIG1ldGhvZFwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZmFjdG9yeSA9IG5ldyBsb2NhbFdpbmRvd0ZhY3RvcnlfMS5Mb2NhbFdpbmRvd0ZhY3RvcnkoZmFjdG9yeU1ldGhvZCwgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgICAgICAucmVnaXN0ZXJXaW5kb3dGYWN0b3J5KHdpbmRvd1R5cGUsIGZhY3RvcnkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh2KTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUudW5yZWdpc3RlcldpbmRvd0ZhY3RvcnkgPSBmdW5jdGlvbiAod2luZG93VHlwZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3aW5kb3dUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwibm8gd2luZG93VHlwZSBzcGVjaWZpZWRcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJ3aW5kb3dUeXBlIHNob3VsZCBiZSBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlXHJcbiAgICAgICAgICAgICAgICAudW5yZWdpc3RlcldpbmRvd0ZhY3Rvcnkod2luZG93VHlwZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHYpO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRBY3Rpdml0aWVzID0gZnVuY3Rpb24gKGFjdGl2aXR5VHlwZSkge1xyXG4gICAgICAgIHZhciBhY3QgPSB0aGlzLl9hY3Rpdml0aWVzLmdldCgpO1xyXG4gICAgICAgIGlmICghYWN0aXZpdHlUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0eXBlcyA9IGFjdGl2aXR5VHlwZTtcclxuICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhhY3Rpdml0eVR5cGUpKSB7XHJcbiAgICAgICAgICAgIHR5cGVzID0gW2FjdGl2aXR5VHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGl2aXR5VHlwZSBpbnN0YW5jZW9mIGFjdGl2aXR5VHlwZV8xWydkZWZhdWx0J10pIHtcclxuICAgICAgICAgICAgdHlwZXMgPSBbYWN0aXZpdHlUeXBlLm5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpdml0eVR5cGUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBhcmd1bWVudCAnYWN0aXZpdHlUeXBlJyA9IFwiICsgYWN0aXZpdHlUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFjdC5maWx0ZXIoZnVuY3Rpb24gKGFjdCkge1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGFjdC50eXBlO1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbC5zb21lKHR5cGVzLCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUuaWQgPT0gdC5pZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5nZXRBY3Rpdml0eUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZpdGllcy5nZXRCeU5hbWUoaWQpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuYW5ub3VuY2VXaW5kb3cgPSBmdW5jdGlvbiAoYWN0aXZpdHlXaW5kb3dJZCwgd2luZG93VHlwZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhbm5vdW5jZW1lbnRJbmZvID0gX3RoaXMuX2JyaWRnZS5nZXRBbm5vdW5jZW1lbnRJbmZvKCk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdGl2aXR5V2luZG93SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpdml0eVdpbmRvd0lkID0gYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd0lkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3dUeXBlID0gYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd1R5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYW5ub3VuY2UgLSB1bmtub3duIHdpbmRvd1R5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0aXZpdHlXaW5kb3dJZCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJSZWdpc3RlcmluZyB3aW5kb3cgd2l0aCB0eXBlOidcIiArIHdpbmRvd1R5cGUgKyBcIicsIG5hbWU6J1wiICsgYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd05hbWUgKyBcIicsIGluZC46J1wiICsgYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50ICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2JyaWRnZS5yZWdpc3RlcldpbmRvdyh3aW5kb3dUeXBlLCBhbm5vdW5jZW1lbnRJbmZvLmFjdGl2aXR5V2luZG93TmFtZSwgYW5ub3VuY2VtZW50SW5mby5hY3Rpdml0eVdpbmRvd0luZGVwZW5kZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKF90aGlzLl93aW5kb3dzLmdldE9yV2FpdC5iaW5kKF90aGlzLl93aW5kb3dzKSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodyk7XHJcbiAgICAgICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmRlYnVnKFwiQW5ub3VuY2luZyB3aW5kb3cgd2l0aCBpZCAnXCIgKyBhY3Rpdml0eVdpbmRvd0lkICsgXCInIGFuZCB0eXBlICdcIiArIHdpbmRvd1R5cGUgKyBcIidcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFdpbmRvdyA9IF90aGlzLl93aW5kb3dzLmdldEJ5TmFtZShhY3Rpdml0eVdpbmRvd0lkKTtcclxuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbChjdXJyZW50V2luZG93KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJXaW5kb3cgd2l0aCBpZCAnXCIgKyBhY3Rpdml0eVdpbmRvd0lkICsgXCInIGFscmVhZHkgYW5ub3VuY2VkIC0gcmV1c2luZyB0aGUgd2luZG93XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3VycmVudFdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHdpbmRvd0V2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChhLCB3LCBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2aXR5V2luZG93SWQgPT09IHcuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgPT09IFwiam9pbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpdml0eSA9IHcuYWN0aXZpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChhY3Rpdml0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJVTkRFRklORUQgQUNUSVZJVFlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLnRyYWNlKFwiR290IGpvaW5lZCBldmVudCBmb3IgaWQgJ1wiICsgYWN0aXZpdHlXaW5kb3dJZCArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bnN1YnNjcmliZVdpbmRvd0V2ZW50cyh3aW5kb3dFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZVdpbmRvd0V2ZW50cyh3aW5kb3dFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci50cmFjZShcIldhaXRpbmcgZm9yIGpvaW5lZCBldmVudCBmb3IgaWQgJ1wiICsgYWN0aXZpdHlXaW5kb3dJZCArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9icmlkZ2UuYW5ub3VuY2VXaW5kb3cod2luZG93VHlwZSwgYWN0aXZpdHlXaW5kb3dJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnN1YnNjcmliZVdpbmRvd1R5cGVFdmVudHMgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd1R5cGVzLnN1YnNjcmliZShmdW5jdGlvbiAod3QsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaGFuZGxlcih3dCwgY29udGV4dC50eXBlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnN1YnNjcmliZUFjdGl2aXR5RXZlbnRzID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0aWVzLnN1YnNjcmliZShmdW5jdGlvbiAoYWN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLlN0YXR1c0NoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcihhY3QsIHAubmV3U3RhdHVzLCBwLm9sZFN0YXR1cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnN1YnNjcmliZVdpbmRvd0V2ZW50cyA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fd2luZG93cy5zdWJzY3JpYmUoZnVuY3Rpb24gKHdpbmRvdywgY29udGV4dCkge1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC50eXBlID09PSBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5BY3Rpdml0eVdpbmRvd0V2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKHdpbmRvdy5hY3Rpdml0eSwgd2luZG93LCBwLmV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUudW5zdWJzY3JpYmVXaW5kb3dFdmVudHMgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUuY3JlYXRlV2luZG93ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCB3aW5kb3dUeXBlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiYWN0aXZpdHkgaXMgdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd1R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJ3aW5kb3dUeXBlIGlzIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgd2luZG93RGVmaW5pdGlvbjtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcod2luZG93VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvd0RlZmluaXRpb24gPSB7IHR5cGU6IHdpbmRvd1R5cGUsIG5hbWU6IFwiXCIsIGlzSW5kZXBlbmRlbnQ6IGZhbHNlLCBhcmd1bWVudHM6IHt9IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3dEZWZpbml0aW9uID0gd2luZG93VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVUb1dpbmRvdztcclxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd0RlZmluaXRpb24ucmVsYXRpdmVUbykpIHtcclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlVG9XaW5kb3cgPSB3aW5kb3dEZWZpbml0aW9uLnJlbGF0aXZlVG87XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZVRvV2luZG93KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5kb3dzID0gX3RoaXMuZ2V0V2luZG93cyh7IHR5cGU6IHJlbGF0aXZlVG9XaW5kb3cgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd3MpICYmIHdpbmRvd3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dEZWZpbml0aW9uLnJlbGF0aXZlVG8gPSB3aW5kb3dzWzBdLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHJlbGF0aXZlVG9XaW5kb3cudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93cyA9IF90aGlzLmdldFdpbmRvd3MoeyB0eXBlOiByZWxhdGl2ZVRvV2luZG93LnR5cGUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHdpbmRvd3MpICYmIHdpbmRvd3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dEZWZpbml0aW9uLnJlbGF0aXZlVG8gPSB3aW5kb3dzWzBdLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHJlbGF0aXZlVG9XaW5kb3cud2luZG93SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93RGVmaW5pdGlvbi5yZWxhdGl2ZVRvID0gcmVsYXRpdmVUb1dpbmRvdy53aW5kb3dJZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fYnJpZGdlLmNyZWF0ZVdpbmRvdyhhY3Rpdml0eS5pZCwgd2luZG93RGVmaW5pdGlvbilcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh3aWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZGVidWcoXCJXaW5kb3cgY3JlYXRlZCwgd2FpdGluZyBmb3Igd2luZG93IGVudGl0eSB3aXRoIGlkIFwiICsgd2lkKTtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKHdpbmRvdywgY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaWQgPT09IHdpZCAmJiB3aW5kb3cuYWN0aXZpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiR290IGVudGl0eSB3aW5kb3cgd2l0aCBpZCBcIiArIHdpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUod2luZG93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2luZG93cy51bnN1YnNjcmliZShoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3dpbmRvd3Muc3Vic2NyaWJlKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5qb2luV2luZG93VG9BY3Rpdml0eSA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgd2luZG93LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5sZWF2ZVdpbmRvd0Zyb21BY3Rpdml0eSA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgd2luZG93LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zZXRBY3Rpdml0eUNvbnRleHQgPSBmdW5jdGlvbiAoYWN0aXZpdHksIGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWRPck51bGwoYWN0aXZpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoXCJhY3Rpdml0eSBjYW4gbm90IGJlIG51bGxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUFjdGl2aXR5Q29udGV4dChhY3Rpdml0eSwgY29udGV4dCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUob2JqKTtcclxuICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlRXh0ZW5zaW9uc18xLm5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5TWFuYWdlci5wcm90b3R5cGUudXBkYXRlQWN0aXZpdHlDb250ZXh0ID0gZnVuY3Rpb24gKGFjdGl2aXR5LCBjb250ZXh0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKGFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiYWN0aXZpdHkgY2FuIG5vdCBiZSBudWxsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVkS2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjb250ZXh0W2tleV0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuX2JyaWRnZVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUFjdGl2aXR5Q29udGV4dChhY3Rpdml0eSwgY29udGV4dCwgZmFsc2UsIHJlbW92ZWRLZXlzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShvYmopO1xyXG4gICAgICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2VFeHRlbnNpb25zXzEubm9kZWlmeShwcm9taXNlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdWJzY3JpYmVBY3Rpdml0eUNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpdml0aWVzLnN1YnNjcmliZShmdW5jdGlvbiAoYWN0LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFjdGl2aXR5Q29udGV4dENoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcihhY3QsIHVwZGF0ZUNvbnRleHQuY29udGV4dCwgdXBkYXRlQ29udGV4dC51cGRhdGVkLCB1cGRhdGVDb250ZXh0LnJlbW92ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wQWN0aXZpdHkgPSBmdW5jdGlvbiAoYWN0aXZpdHksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9icmlkZ2Uuc3RvcEFjdGl2aXR5KGFjdGl2aXR5KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldFdpbmRvd3MgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQoZmlsdGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2luZG93cy5nZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkKGZpbHRlci5pZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLl93aW5kb3dzLmdldEJ5TmFtZShmaWx0ZXIuaWQpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFsbFdpbmRvd3MgPSB0aGlzLl93aW5kb3dzLmdldCgpO1xyXG4gICAgICAgIHJldHVybiBhbGxXaW5kb3dzLmZpbHRlcihmdW5jdGlvbiAodykge1xyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZmlsdGVyLnR5cGUpICYmIHcudHlwZS5pZCAhPT0gZmlsdGVyLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZmlsdGVyLm5hbWUpICYmIHcubmFtZSAhPT0gZmlsdGVyLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWQoZmlsdGVyLmFjdGl2aXR5SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh3LmFjdGl2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh3LmFjdGl2aXR5LmlkICE9PSBmaWx0ZXIuYWN0aXZpdHlJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLl9ncmFiRW50aXR5ID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgIGVudGl0eS5tYW5hZ2VyID0gdGhpcztcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLl9zdWJzY3JpYmVGb3JEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiU3RhcnQgZ2V0dGluZyBpbml0aWFsIGRhdGEuLi5cIik7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlLm9uQWN0aXZpdHlUeXBlU3RhdHVzQ2hhbmdlKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdHlUeXBlcy5wcm9jZXNzKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2UuZ2V0QWN0aXZpdHlUeXBlcygpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdHlUeXBlcy5hZGQoYXQpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLnNpZ25hbChcIkdvdCBhY3QgdHlwZXNcIik7XHJcbiAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLmVycm9yKFwiQ2FuIG5vdCBpbml0aWFsaXplIEFjdGl2aXR5TWFuYWdlciAtIGVycm9yIGdldHRpbmcgYWN0aXZpdHkgdHlwZXMgLVwiICsgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5vbldpbmRvd1R5cGVTdGF0dXNDaGFuZ2UoZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl93aW5kb3dUeXBlcy5wcm9jZXNzKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2UuZ2V0V2luZG93VHlwZXMoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAod3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3dpbmRvd1R5cGVzLmFkZCh3dCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuc2lnbmFsKFwiR290IHdpbmRvdyB0eXBlc1wiKTtcclxuICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpemUgQWN0aXZpdHlNYW5hZ2VyIC0gZXJyb3IgZ2V0dGluZyB3aW5kb3cgdHlwZXMgIFwiICsgZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5vbkFjdGl2aXR5U3RhdHVzQ2hhbmdlKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdGllcy5wcm9jZXNzKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9icmlkZ2UuZ2V0QWN0aXZpdGllcygpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhYykge1xyXG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZpdGllcy5hZGQoYWMpO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGF0YVJlYWR5TWFya2VyLnNpZ25hbChcIkdvdCBhY3Rpdml0aWVzXCIpO1xyXG4gICAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgX3RoaXMuX2RhdGFSZWFkeU1hcmtlci5lcnJvcihcIkNhbiBub3QgaW5pdGlhbGl6ZSBBY3Rpdml0eU1hbmFnZXIgLSBlcnJvciBnZXR0aW5nIGFjdGl2aXR5IGluc3RhbmNlcyAtXCIgKyBlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlLm9uQWN0aXZpdHlXaW5kb3dDaGFuZ2UoZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl93aW5kb3dzLnByb2Nlc3MoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2JyaWRnZS5nZXRBY3Rpdml0eVdpbmRvd3MoKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYXcpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3dpbmRvd3MuYWRkKGF3KTtcclxuICAgICAgICAgICAgX3RoaXMuX2RhdGFSZWFkeU1hcmtlci5zaWduYWwoXCJHb3Qgd2luZG93c1wiKTtcclxuICAgICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIF90aGlzLl9kYXRhUmVhZHlNYXJrZXIuZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpemUgQWN0aXZpdHlNYW5hZ2VyIC0gZXJyb3IgZ2V0dGluZyBhY3Rpdml0eSB3aW5kb3dzIC1cIiArIGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmdldFdpbmRvd0JvdW5kcyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9icmlkZ2UuZ2V0V2luZG93Qm91bmRzKGlkKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLnNldFdpbmRvd0JvdW5kcyA9IGZ1bmN0aW9uIChpZCwgYm91bmRzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9icmlkZ2Uuc2V0V2luZG93Qm91bmRzKGlkLCBib3VuZHMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZUV4dGVuc2lvbnNfMS5ub2RlaWZ5KHByb21pc2UsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eU1hbmFnZXIucHJvdG90eXBlLmNsb3NlV2luZG93ID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JyaWRnZS5jbG9zZVdpbmRvdyhpZCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5TWFuYWdlcjtcclxufSgpKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5TWFuYWdlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZpdHlNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgTG9jYWxXaW5kb3dGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvY2FsV2luZG93RmFjdG9yeShjcmVhdGVGdW5jdGlvbiwgZGVzY3JpcHRpb24pIHtcclxuICAgICAgICB0aGlzLl9jcmVhdGVGdW5jdGlvbiA9IGNyZWF0ZUZ1bmN0aW9uO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICB9XHJcbiAgICBMb2NhbFdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVdpbmRvd0lkLCBjb250ZXh0LCBsYXlvdXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlRnVuY3Rpb24oYWN0aXZpdHlXaW5kb3dJZCwgY29udGV4dCwgbGF5b3V0KTtcclxuICAgIH07XHJcbiAgICBMb2NhbFdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTG9jYWxXaW5kb3dGYWN0b3J5O1xyXG59KCkpO1xyXG5leHBvcnRzLkxvY2FsV2luZG93RmFjdG9yeSA9IExvY2FsV2luZG93RmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxXaW5kb3dGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgUHJveHlXaW5kb3dGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3h5V2luZG93RmFjdG9yeShkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICB9XHJcbiAgICBQcm94eVdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhY3Rpdml0eVdpbmRvd0lkLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBQcm94eVdpbmRvd0ZhY3RvcnkucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJveHlXaW5kb3dGYWN0b3J5O1xyXG59KCkpO1xyXG5leHBvcnRzLlByb3h5V2luZG93RmFjdG9yeSA9IFByb3h5V2luZG93RmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJveHlXaW5kb3dGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYWN0aXZpdHlFbnRpdHlfMSA9IHJlcXVpcmUoXCIuL2FjdGl2aXR5RW50aXR5XCIpO1xyXG52YXIgYWN0aXZpdHlBR01fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2FjdGl2aXR5QUdNXCIpO1xyXG52YXIgQWN0aXZpdHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFjdGl2aXR5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHkoaWQsIGFjdFR5cGUsIHN0YXR1cywgY29udGV4dCwgb3duZXIsIGhlbHBlcldpbmRvd3MpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBpZCk7XHJcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcclxuICAgICAgICB0aGlzLl9hY3RUeXBlID0gYWN0VHlwZTtcclxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fb3duZXIgPSBvd25lcjtcclxuICAgICAgICB0aGlzLl9oZWxwZXJXaW5kb3dzID0gaGVscGVyV2luZG93cztcclxuICAgICAgICB0aGlzLl9hZ20gPSBuZXcgYWN0aXZpdHlBR01fMS5BY3Rpdml0eUFHTSh0aGlzKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0QWN0aXZpdHlUeXBlKHRoaXMuX2FjdFR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHkucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwib3duZXJcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3duZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHkucHJvdG90eXBlLCBcIndpbmRvd3NcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldFdpbmRvd3MoeyBhY3Rpdml0eUlkOiB0aGlzLl9pZCB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eS5wcm90b3R5cGUsIFwiYWdtXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FnbTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHdpbmRvdywgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmpvaW5XaW5kb3dUb0FjdGl2aXR5KHRoaXMsIHdpbmRvdywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5jcmVhdGVXaW5kb3cgPSBmdW5jdGlvbiAod2luZG93VHlwZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmNyZWF0ZVdpbmRvdyh0aGlzLCB3aW5kb3dUeXBlLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKHdpbmRvdywgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmxlYXZlV2luZG93RnJvbUFjdGl2aXR5KHRoaXMsIHdpbmRvdywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5nZXRXaW5kb3dzQnlUeXBlID0gZnVuY3Rpb24gKHdpbmRvd1R5cGUpIHtcclxuICAgICAgICB2YXIgZmlsdGVyID0geyBhY3Rpdml0eUlkOiB0aGlzLl9pZCwgdHlwZTogd2luZG93VHlwZSB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93cyhmaWx0ZXIpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5zZXRBY3Rpdml0eUNvbnRleHQodGhpcywgY29udGV4dCwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci51cGRhdGVBY3Rpdml0eUNvbnRleHQodGhpcywgY29udGV4dCwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5vblN0YXR1c0NoYW5nZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc3Vic2NyaWJlQWN0aXZpdHlFdmVudHMoZnVuY3Rpb24gKGEsIG5zLCBvcykge1xyXG4gICAgICAgICAgICBpZiAoYS5pZCA9PT0gX3RoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoYSwgbnMsIG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5vbldpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5zdWJzY3JpYmVXaW5kb3dFdmVudHMoZnVuY3Rpb24gKGEsIHcsIGUpIHtcclxuICAgICAgICAgICAgaWYgKGEuaWQgPT09IF90aGlzLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGEsIHcsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHkucHJvdG90eXBlLm9uQ29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnN1YnNjcmliZUFjdGl2aXR5Q29udGV4dENoYW5nZWQoZnVuY3Rpb24gKGFjdCwgY29udGV4dCwgZGVsdGEsIHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgaWYgKGFjdC5pZCA9PT0gX3RoaXMuaWQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoY29udGV4dCwgZGVsdGEsIHJlbW92ZWQsIGFjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBoYW5kbGVyKHRoaXMuY29udGV4dCwgdGhpcy5jb250ZXh0LCBbXSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgIH07XHJcbiAgICBBY3Rpdml0eS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm1hbmFnZXIuc3RvcEFjdGl2aXR5KHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5LnByb3RvdHlwZS51cGRhdGVDb3JlID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVDb3JlLmNhbGwodGhpcywgYWN0aXZpdHkpO1xyXG4gICAgICAgIHRoaXMuX2FjdFR5cGUgPSBhY3Rpdml0eS5fYWN0VHlwZTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gYWN0aXZpdHkuX2NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gYWN0aXZpdHkuX3N0YXR1cztcclxuICAgICAgICB0aGlzLl9oZWxwZXJXaW5kb3dzID0gYWN0aXZpdHkuX2hlbHBlcldpbmRvd3M7XHJcbiAgICAgICAgdGhpcy5fb3duZXIgPSBhY3Rpdml0eS5fb3duZXI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFjdGl2aXR5O1xyXG59KGFjdGl2aXR5RW50aXR5XzFbJ2RlZmF1bHQnXSkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHNbJ2RlZmF1bHQnXT0gQWN0aXZpdHk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2aXR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgQWN0aXZpdHlFbnRpdHkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlFbnRpdHkoaWQpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLCBcImlkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLm9uVXBkYXRlZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eUVudGl0eS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyLl9pZCAhPSB0aGlzLl9pZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbiBub3QgdXBkYXRlIGZyb20gZW50aXR5IHdpdGggZGlmZmVyZW50IGlkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVDb3JlKG90aGVyKTtcclxuICAgICAgICB0aGlzLm5vdGlmeSgpO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5RW50aXR5LnByb3RvdHlwZS51cGRhdGVDb3JlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlFbnRpdHkucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMubGlzdGVuZXJzW2luZGV4XTtcclxuICAgICAgICAgICAgbGlzdGVuZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eUVudGl0eTtcclxufSgpKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5RW50aXR5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eUVudGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFjdGl2aXR5RW50aXR5XzEgPSByZXF1aXJlKFwiLi9hY3Rpdml0eUVudGl0eVwiKTtcclxudmFyIEFjdGl2aXR5VHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWN0aXZpdHlUeXBlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlUeXBlKG5hbWUsIG93bmVyV2luZG93LCBoZWxwZXJXaW5kb3dzLCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICAgICAgdGhpcy5fb3duZXJXaW5kb3cgPSBvd25lcldpbmRvdztcclxuICAgICAgICB0aGlzLl9oZWxwZXJXaW5kb3dzID0gaGVscGVyV2luZG93cyB8fCBbXTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVR5cGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVR5cGUucHJvdG90eXBlLCBcImRlc2NyaXB0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc2NyaXB0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5VHlwZS5wcm90b3R5cGUsIFwiaGVscGVyV2luZG93c1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWxwZXJXaW5kb3dzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5VHlwZS5wcm90b3R5cGUsIFwib3duZXJXaW5kb3dcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3duZXJXaW5kb3c7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBY3Rpdml0eVR5cGUucHJvdG90eXBlLnN1YnNjcmliZUFjdGl2aXR5U3RhdHVzQ2hhbmdlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5VHlwZS5wcm90b3R5cGUuaW5pdGlhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmluaXRpYXRlKHRoaXMuX25hbWUsIGNvbnRleHQsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBBY3Rpdml0eVR5cGUucHJvdG90eXBlLnVwZGF0ZUNvcmUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlQ29yZS5jYWxsKHRoaXMsIHR5cGUpO1xyXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gdHlwZS5fZGVzY3JpcHRpb247XHJcbiAgICAgICAgdGhpcy5fb3duZXJXaW5kb3cgPSB0eXBlLl9vd25lcldpbmRvdztcclxuICAgICAgICB0aGlzLl9oZWxwZXJXaW5kb3dzID0gdHlwZS5faGVscGVyV2luZG93cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWN0aXZpdHlUeXBlO1xyXG59KGFjdGl2aXR5RW50aXR5XzFbJ2RlZmF1bHQnXSkpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHNbJ2RlZmF1bHQnXT0gQWN0aXZpdHlUeXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eVR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhY3Rpdml0eUVudGl0eV8xID0gcmVxdWlyZShcIi4vYWN0aXZpdHlFbnRpdHlcIik7XHJcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2xvZ2dlclwiKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgQWN0aXZpdHlXaW5kb3cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFjdGl2aXR5V2luZG93LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWN0aXZpdHlXaW5kb3coaWQsIG5hbWUsIHR5cGUsIGFjdGl2aXR5SWQsIGluc3RhbmNlLCBpc0luZGVwZW5kZW50KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaWQpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcl8xLkxvZ2dlci5HZXQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlJZCA9IGFjdGl2aXR5SWQ7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICB0aGlzLl9pc0luZGVwZW5kZW50ID0gaXNJbmRlcGVuZGVudDtcclxuICAgIH1cclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRXaW5kb3dCb3VuZHModGhpcy5pZCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLCBcImlzSW5kZXBlbmRlbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNJbmRlcGVuZGVudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVdpbmRvdy5wcm90b3R5cGUsIFwidHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0V2luZG93VHlwZSh0aGlzLl90eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJhY3Rpdml0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKHRoaXMuX2FjdGl2aXR5SWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0QWN0aXZpdHlCeUlkKHRoaXMuX2FjdGl2aXR5SWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJpc093bmVyXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFjdCA9IHRoaXMuYWN0aXZpdHk7XHJcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGFjdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWN0Lm93bmVyLmlkID09PSB0aGlzLmlkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoaXNWaXNpYmxlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKHRpdGxlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLnNldEJvdW5kcyA9IGZ1bmN0aW9uIChib3VuZHMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5zZXRXaW5kb3dCb3VuZHModGhpcy5pZCwgYm91bmRzLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuY2xvc2VXaW5kb3codGhpcy5pZCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2aXR5V2luZG93LnByb3RvdHlwZSwgXCJpbnN0YW5jZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS5vbkFjdGl2aXR5Sm9pbmVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlRm9yQWN0aXZpdHlXaW5kb3dFdmVudChcImpvaW5lZFwiLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLm9uQWN0aXZpdHlSZW1vdmVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlRm9yQWN0aXZpdHlXaW5kb3dFdmVudChcInJlbW92ZWRcIiwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIEFjdGl2aXR5V2luZG93LnByb3RvdHlwZS51cGRhdGVDb3JlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlJZCA9IG90aGVyLl9hY3Rpdml0eUlkO1xyXG4gICAgICAgIHRoaXMuX2lzSW5kZXBlbmRlbnQgPSBvdGhlci5faXNJbmRlcGVuZGVudDtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwob3RoZXIuX2luc3RhbmNlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG90aGVyLl9pbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWN0aXZpdHlXaW5kb3cucHJvdG90eXBlLl9zdWJzY3JpYmVGb3JBY3Rpdml0eVdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubWFuYWdlci5zdWJzY3JpYmVXaW5kb3dFdmVudHMoZnVuY3Rpb24gKGFjdGl2aXR5LCB3aW5kb3csIGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaWQgIT09IF90aGlzLmlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGFjdGl2aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBY3Rpdml0eVdpbmRvdztcclxufShhY3Rpdml0eUVudGl0eV8xWydkZWZhdWx0J10pKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzWydkZWZhdWx0J109IEFjdGl2aXR5V2luZG93O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpdml0eVdpbmRvdy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIGFjdGl2aXR5RW50aXR5XzEgPSByZXF1aXJlKFwiLi9hY3Rpdml0eUVudGl0eVwiKTtcclxudmFyIFdpbmRvd1R5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFdpbmRvd1R5cGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBXaW5kb3dUeXBlKG5hbWUsIGZhY3Rvcmllcykge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2ZhY3RvcmllcyA9IGZhY3RvcmllcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaW5kb3dUeXBlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2luZG93VHlwZS5wcm90b3R5cGUsIFwiZmFjdG9yaWVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhY3RvcmllcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaW5kb3dUeXBlLnByb3RvdHlwZSwgXCJ3aW5kb3dzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRXaW5kb3dzKHsgdHlwZTogdGhpcy5fbmFtZSB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFdpbmRvd1R5cGUucHJvdG90eXBlLnJlZ2lzdGVyRmFjdG9yeSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBmYWN0b3J5TWV0aG9kLCBkZXNjcmlwdGlvbiwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLnJlZ2lzdGVyV2luZG93RmFjdG9yeSh0aGlzLCBmYWN0b3J5TWV0aG9kLCBkZXNjcmlwdGlvbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdpbmRvd1R5cGU7XHJcbn0oYWN0aXZpdHlFbnRpdHlfMVsnZGVmYXVsdCddKSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0c1snZGVmYXVsdCddPSBXaW5kb3dUeXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgZW50aXR5RXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9jb250cmFjdHMvZW50aXR5RXZlbnRcIik7XHJcbnZhciBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbihwcm9jZXNzTmV3KSB7XHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSB7fTtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9wcm9jZXNzTmV3ID0gcHJvY2Vzc05ldztcclxuICAgIH1cclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5hZGRPbmUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHRoaXMuYWRkKFtpdGVtXSk7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtcykge1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpdGVtcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBpdGVtc1tpbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2VzcyhuZXcgZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudChlbGVtZW50LCBuZXcgZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudENvbnRleHQoZW50aXR5RXZlbnRfMS5FbnRpdHlFdmVudFR5cGUuQWRkZWQpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBldmVudC5jb250ZXh0O1xyXG4gICAgICAgIHZhciB0eXBlID0gY29udGV4dC50eXBlO1xyXG4gICAgICAgIHZhciBlbnRpdHkgPSBldmVudC5lbnRpdHk7XHJcbiAgICAgICAgdmFyIGludGVybmFsRW50aXR5ID0gdGhpcy5fdXBkYXRlSW50ZXJuYWxDb2xsZWN0aW9ucyhlbnRpdHksIHR5cGUpO1xyXG4gICAgICAgIHRoaXMuX25vdGlmeUxpc3RlbmVycyhpbnRlcm5hbEVudGl0eSwgY29udGV4dCk7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2l0ZW1zW2tleV07XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9pdGVtcykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRPcldhaXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHlBZGRlZEhhbmRsZXIgPSBmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5LmlkICE9PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudW5zdWJzY3JpYmUoZW50aXR5QWRkZWRIYW5kbGVyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlKGVudGl0eUFkZGVkSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3cgPSBfdGhpcy5nZXRCeU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUod2luZG93KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9pdGVtcykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2l0ZW1zW2tleV07XHJcbiAgICAgICAgICAgIGhhbmRsZXIoZWxlbWVudCwgbmV3IGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRDb250ZXh0KGVudGl0eUV2ZW50XzEuRW50aXR5RXZlbnRUeXBlLkFkZGVkLnRvU3RyaW5nKCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmFibGVDb2xsZWN0aW9uLnByb3RvdHlwZS5fbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gKGVudGl0eSwgY29udGV4dCkge1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuX2xpc3RlbmVyc1tpbmRleF07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihlbnRpdHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24ucHJvdG90eXBlLl91cGRhdGVJbnRlcm5hbENvbGxlY3Rpb25zID0gZnVuY3Rpb24gKGVudGl0eSwgdHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlID09PSBlbnRpdHlFdmVudF8xLkVudGl0eUV2ZW50VHlwZS5SZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pdGVtc1tlbnRpdHkuaWRdO1xyXG4gICAgICAgICAgICByZXR1cm4gZW50aXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGVudGl0eS5pZDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzTmV3KGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtc1tlbnRpdHkuaWRdID0gZW50aXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXNbZW50aXR5LmlkXS51cGRhdGUoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbZW50aXR5LmlkXTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuRW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24gPSBFbnRpdHlPYnNlcnZhYmxlQ29sbGVjdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW50aXR5T2JzZXJ2YWJsZUNvbGxlY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcclxudmFyIExvZ0xldmVsID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvZ0xldmVsKCkge1xyXG4gICAgfVxyXG4gICAgTG9nTGV2ZWwuVHJhY2UgPSBcInRyYWNlXCI7XHJcbiAgICBMb2dMZXZlbC5EZWJ1ZyA9IFwiZGVidWdcIjtcclxuICAgIExvZ0xldmVsLkluZm8gPSBcImluZm9cIjtcclxuICAgIExvZ0xldmVsLldhcm4gPSBcIndhcm5cIjtcclxuICAgIExvZ0xldmVsLkVycm9yID0gXCJlcnJvclwiO1xyXG4gICAgcmV0dXJuIExvZ0xldmVsO1xyXG59KCkpO1xyXG5leHBvcnRzLkxvZ0xldmVsID0gTG9nTGV2ZWw7XHJcbnZhciBMb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUpIHtcclxuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwoTG9nZ2VyLkdsdWVMb2dnZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsdWVMb2dnZXIgPSBMb2dnZXIuR2x1ZUxvZ2dlci5zdWJMb2dnZXIobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgTG9nZ2VyLkdldE5hbWVkID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcihuYW1lKTtcclxuICAgIH07XHJcbiAgICBMb2dnZXIuR2V0ID0gZnVuY3Rpb24gKG93bmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIoTG9nZ2VyLkdldFR5cGVOYW1lKG93bmVyKSk7XHJcbiAgICB9O1xyXG4gICAgTG9nZ2VyLnByb3RvdHlwZS50cmFjZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuX2dsdWVMb2dnZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsdWVMb2dnZXIudHJhY2UobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoTG9nZ2VyLkxldmVsID09PSBMb2dMZXZlbC5UcmFjZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKHRoaXMuX2dldE1lc3NhZ2UobWVzc2FnZSwgTG9nTGV2ZWwuVHJhY2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fZ2x1ZUxvZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2x1ZUxvZ2dlci5kZWJ1ZyhtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLkRlYnVnIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLlRyYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8odGhpcy5fZ2V0TWVzc2FnZShtZXNzYWdlLCBMb2dMZXZlbC5EZWJ1ZykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCF1dGlsLmlzVW5kZWZpbmVkT3JOdWxsKHRoaXMuX2dsdWVMb2dnZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsdWVMb2dnZXIuaW5mbyhtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLkRlYnVnIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLlRyYWNlIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLkluZm8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyh0aGlzLl9nZXRNZXNzYWdlKG1lc3NhZ2UsIExvZ0xldmVsLkluZm8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICghdXRpbC5pc1VuZGVmaW5lZE9yTnVsbCh0aGlzLl9nbHVlTG9nZ2VyKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbHVlTG9nZ2VyLndhcm4obWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoTG9nZ2VyLkxldmVsID09PSBMb2dMZXZlbC5EZWJ1ZyB8fFxyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLkxldmVsID09PSBMb2dMZXZlbC5UcmFjZSB8fFxyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLkxldmVsID09PSBMb2dMZXZlbC5JbmZvIHx8XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuTGV2ZWwgPT09IExvZ0xldmVsLldhcm4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyh0aGlzLl9nZXRNZXNzYWdlKG1lc3NhZ2UsIExvZ0xldmVsLkluZm8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMb2dnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXV0aWwuaXNVbmRlZmluZWRPck51bGwodGhpcy5fZ2x1ZUxvZ2dlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2x1ZUxvZ2dlci5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5fZ2V0TWVzc2FnZShtZXNzYWdlLCBMb2dMZXZlbC5FcnJvcikpO1xyXG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvZ2dlci5wcm90b3R5cGUuX2dldE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgbGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4gXCJbXCIgKyBsZXZlbCArIFwiXSBcIiArIHRoaXMuX25hbWUgKyBcIiAtIFwiICsgbWVzc2FnZTtcclxuICAgIH07XHJcbiAgICBMb2dnZXIuR2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIGZ1bmNOYW1lUmVnZXggPSAvZnVuY3Rpb24gKC57MSx9KVxcKC87XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSAoZnVuY05hbWVSZWdleCkuZXhlYyhvYmplY3QuY29uc3RydWN0b3IudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSkgPyByZXN1bHRzWzFdIDogXCJcIjtcclxuICAgIH07XHJcbiAgICBMb2dnZXIuTGV2ZWwgPSBMb2dMZXZlbC5JbmZvO1xyXG4gICAgcmV0dXJuIExvZ2dlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vaGVscGVycy91dGlsXCIpO1xyXG52YXIgbmV4dFRpY2sgPSBmdW5jdGlvbiAoY2IpIHsgc2V0VGltZW91dChjYiwgMCk7IH07XHJcbmZ1bmN0aW9uIG5vZGVpZnkocHJvbWlzZSwgY2FsbGJhY2spIHtcclxuICAgIGlmICghdXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XHJcbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLm5vZGVpZnkgPSBub2RlaWZ5O1xyXG47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2VFeHRlbnNpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdXRpbFwiKTtcclxudmFyIFJlYWR5TWFya2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlYWR5TWFya2VyKG5hbWUsIHNpZ25hbHNUb1dhaXQpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXJfMS5Mb2dnZXIuR2V0TmFtZWQoXCJSZWFkeU1hcmtlciBbXCIgKyBuYW1lICsgXCJdXCIpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcIkluaXRpYWxpemluZyByZWFkeSBtYXJrZXIgZm9yICdcIiArIG5hbWUgKyBcIicgd2l0aCBcIiArIHNpZ25hbHNUb1dhaXQgKyBcIiBzaWduYWxzIHRvIHdhaXRcIik7XHJcbiAgICAgICAgaWYgKHNpZ25hbHNUb1dhaXQgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hbCBudW1iZXIuIFNob3VsZCBiZSA+IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NpZ25hbHMgPSBzaWduYWxzVG9XYWl0O1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgfVxyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLnNldENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTZXQoKSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNFcnJvcigpKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuX2Vycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiU2lnbmFsZWQgLSBcIiArIG1lc3NhZ2UgKyBcIiAtIHNpZ25hbHMgbGVmdCBcIiArICh0aGlzLl9zaWduYWxzIC0gMSkpO1xyXG4gICAgICAgIHRoaXMuX3NpZ25hbHMtLTtcclxuICAgICAgICBpZiAodGhpcy5fc2lnbmFscyA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gcmVhZHkgbWFya2VyICdcIiArIHRoaXMuX25hbWUgKyBcIiAtIHNpZ25hbHMgYXJlIFwiICsgdGhpcy5fc2lnbmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzU2V0KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSZWFkeU1hcmtlci5wcm90b3R5cGUuaXNTZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFcnJvcigpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbHMgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgUmVhZHlNYXJrZXIucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF1dGlsLmlzVW5kZWZpbmVkKHRoaXMuX2Vycm9yKTtcclxuICAgIH07XHJcbiAgICBSZWFkeU1hcmtlci5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWFkeU1hcmtlcjtcclxufSgpKTtcclxuZXhwb3J0cy5SZWFkeU1hcmtlciA9IFJlYWR5TWFya2VyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkeU1hcmtlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XHJcbn1cclxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xyXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcclxufVxyXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcclxufVxyXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XHJcbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG59XHJcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XHJcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xyXG59XHJcbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcclxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwoYXJnKSB7XHJcbiAgICByZXR1cm4gIWFyZyB8fCB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcclxufVxyXG5leHBvcnRzLmlzVW5kZWZpbmVkT3JOdWxsID0gaXNVbmRlZmluZWRPck51bGw7XHJcbmZ1bmN0aW9uIGlzRW1wdHkoYXJnKSB7XHJcbiAgICBmb3IgKHZhciBwcm9wIGluIGFyZykge1xyXG4gICAgICAgIGlmIChhcmcuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XHJcbiAgICByZXR1cm4gISEoYXJnICYmIGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY2FsbCAmJiBhcmcuYXBwbHkpO1xyXG59XHJcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XHJcbjtcclxuZnVuY3Rpb24gc29tZShhcnJheSwgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5zb21lID0gc29tZTtcclxuZnVuY3Rpb24gZmlyc3QoYXJyYXksIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmV4cG9ydHMuZmlyc3QgPSBmaXJzdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJ2YXIgY29ubmVjdGlvbiA9IHJlcXVpcmUoXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCIpO1xudmFyIGNsaWVudCA9IHJlcXVpcmUoXCIuL2FnbV9jbGllbnRcIik7XG52YXIgc2VydmVyID0gcmVxdWlyZShcIi4vYWdtX3NlcnZlclwiKTtcbnZhciBpbnN0YW5jZSA9IHJlcXVpcmUoXCIuL2FnbV9pbnN0YW5jZVwiKTtcbnZhciBuYXRpdmVfYWdtID0gcmVxdWlyZShcIi4vYWdtX25hdGl2ZVwiKTtcbnZhciBkZXByZWNhdGUgPSByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpO1xudmFyIHBqc29uID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKTtcbi8vdmFyIGFkZF9zdWdhcj0gcmVxdWlyZShcIi4vYWdtX3N1Z2FyXCIpO1xuLy9Jbml0IG5hbWVzcGFjZSBpZiBub3QgYWxyZWFkeSB0aGVyZVxuXG4vL0FkZCBhIGdsb2JhbCBmdW5jdGlvbiB0aGF0IG1ha2VzIGFuIEFHTSBpbnN0YW5jZVxuYWdtID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly9XZSB3aWxsIHN0b3JlIHRoZSBsaWJyYXJ5IGhlcmVcblx0dmFyIGFnbSA9IHt9O1xuXG5cdGFnbS52ZXJzaW9uID0gcGpzb24udmVyc2lvbjtcblxuXHQvL0luaXQgZGVidWdcblx0aWYgKHR5cGVvZiBjb25maWd1cmF0aW9uICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0Y29uZmlndXJhdGlvbiA9IHt9O1xuXHR9XG5cblx0Ly9Jbml0IGNoaWxkIGNvbmZpZ3VyYXRpb24gaWYgaXQgaXMgbm90IGFscmVhZHkgcGFzc2VkIGJ5IHVzZXJcblx0dmFyIGNoaWxkX2NvbmZpZ3VyYXRpb25zID0gW1wiY29ubmVjdGlvblwiLCBcImNsaWVudFwiLCBcInNlcnZlclwiXTtcblx0Y2hpbGRfY29uZmlndXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY29uZikge1xuXHRcdGlmICh0eXBlb2YgY29uZmlndXJhdGlvbltjb25mXSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0Y29uZmlndXJhdGlvbltjb25mXSA9IHt9O1xuXHRcdH1cblx0XHQvL1NldCBkZWJ1ZyBpZiBnbG9iYWwgZGVidWcgaXMgbm90IHNldDpcblx0XHRpZiAoY29uZmlndXJhdGlvbi5kZWJ1Zykge1xuXHRcdFx0Y29uZmlndXJhdGlvbltjb25mXS5kZWJ1ZyA9IHRydWU7XG5cdFx0fVxuXHR9KTtcblxuXHQvL0luaXQgY29ubmVjdGlvblxuXHR2YXIgYyA9IGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbjtcblx0Ly9EZXRlcm1pbmUgaWYgd2UgYXJlIGdpdmVuIGEgY29ubmVjdGlvbiBvYmplY3QuIElmIG5vdCwgY3JlYXRlIGl0IG91cnNlbHZlczpcblx0YWdtLmNvbm5lY3Rpb24gPSAodHlwZW9mIGMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGMuc2VuZCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjLm9uID09PSBcImZ1bmN0aW9uXCIpID8gYyA6IGNvbm5lY3Rpb24oY29uZmlndXJhdGlvbi5jb25uZWN0aW9uKTtcblxuXHQvL0NyZWF0ZSBhIGNvbm5lY3Rpb24gcHJveHkgd2hpY2ggc2V0cyB0aGUgcHJvZHVjdCBuYW1lIGF1dG9tYXRpY2FsbHlcblx0dmFyIHByb2R1Y3RfbmFtZSA9IFwiYWdtXCI7XG5cdHZhciBhZ21fZW5hYmxlZF9jb25uZWN0aW9uID0ge1xuXHRcdHNlbmQ6IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XG5cdFx0XHRhZ20uY29ubmVjdGlvbi5zZW5kKHByb2R1Y3RfbmFtZSwgdHlwZSwgbWVzc2FnZSk7XG5cdFx0fSxcblx0XHRvbjogZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcblx0XHRcdGFnbS5jb25uZWN0aW9uLm9uKHByb2R1Y3RfbmFtZSwgdHlwZSwgaGFuZGxlcik7XG5cdFx0fVxuXG5cdH07XG5cblx0Ly9TYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSByb290IHN5c3RlbSBvYmplY3QgdGhhdCB3ZSBhcmUgZ2l2ZW5cblx0dmFyIG1ldHJpY3Nfcm9vdCA9IGNvbmZpZ3VyYXRpb24ubWV0cmljcztcblxuXHQvL0NyZWF0ZSBzdWJzeXN0ZW1zIGZvciBvdXIgbW9kdWxlcyBhbmQgc2F2ZSB0aGVtIGluIHRoZWlyIGNvbmZpZ3VyYXRpb24uXG5cdGlmIChtZXRyaWNzX3Jvb3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbmZpZ3VyYXRpb24uY2xpZW50Lm1ldHJpY3MgPSBtZXRyaWNzX3Jvb3Quc3ViU3lzdGVtKFwiQ2xpZW50XCIpO1xuXHRcdGNvbmZpZ3VyYXRpb24uc2VydmVyLm1ldHJpY3MgPSBtZXRyaWNzX3Jvb3Quc3ViU3lzdGVtKFwiU2VydmVyXCIpO1xuXHR9XG5cblx0Ly9Jbml0aWFsaXplIG91ciBtb2R1bGVzXG5cdGFnbS5pbnN0YW5jZSA9IGluc3RhbmNlKGNvbmZpZ3VyYXRpb24uaW5zdGFuY2UsIGFnbV9lbmFibGVkX2Nvbm5lY3Rpb24pO1xuXHRhZ20uY2xpZW50ID0gY2xpZW50KGFnbV9lbmFibGVkX2Nvbm5lY3Rpb24sIGFnbS5pbnN0YW5jZSwgY29uZmlndXJhdGlvbi5jbGllbnQpO1xuXHRhZ20uc2VydmVyID0gc2VydmVyKGFnbV9lbmFibGVkX2Nvbm5lY3Rpb24sIGFnbS5pbnN0YW5jZSwgY29uZmlndXJhdGlvbi5zZXJ2ZXIpO1xuXG5cdC8vQWRkIG1ldGhvZCBhbGlhc2VzXG5cdGFnbS5pbnZva2UgPSBhZ20uY2xpZW50Lmludm9rZTtcblx0YWdtLnJlZ2lzdGVyID0gYWdtLnNlcnZlci5yZWdpc3Rlcjtcblx0YWdtLnJlZ2lzdGVyQXN5bmMgPSBhZ20uc2VydmVyLnJlZ2lzdGVyQXN5bmM7XG5cdGFnbS51bnJlZ2lzdGVyID0gYWdtLnNlcnZlci51bnJlZ2lzdGVyO1xuXHRhZ20uY3JlYXRlU3RyZWFtID0gYWdtLnNlcnZlci5jcmVhdGVTdHJlYW07XG5cdGFnbS5zdWJzY3JpYmUgPSBhZ20uY2xpZW50LnN1YnNjcmliZTtcblx0YWdtLnNlcnZlcnMgPSBhZ20uY2xpZW50LnNlcnZlcnM7XG5cdGFnbS5tZXRob2RzID0gYWdtLmNsaWVudC5tZXRob2RzO1xuXHRhZ20ubWV0aG9kc19mb3JfaW5zdGFuY2UgPSBkZXByZWNhdGUoYWdtLmNsaWVudC5tZXRob2RzX2Zvcl9pbnN0YW5jZSwgJ2dsdWUuYWdtLmNsaWVudC5tZXRob2RzX2Zvcl9pbnN0YW5jZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIGdsdWUuYWdtLmNsaWVudC5tZXRob2RzRm9ySW5zdGFuY2UoKSBpbnN0ZWFkJykgO1xuXHRhZ20ubWV0aG9kc0Zvckluc3RhbmNlID0gYWdtLmNsaWVudC5tZXRob2RzX2Zvcl9pbnN0YW5jZTtcblx0YWdtLm1ldGhvZCA9IGFnbS5jbGllbnQubWV0aG9kO1xuXHRhZ20ubWV0aG9kX2FkZGVkID0gZGVwcmVjYXRlKGFnbS5jbGllbnQubWV0aG9kX2FkZGVkLCAnZ2x1ZS5hZ20ubWV0aG9kX2FkZGVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgZ2x1ZS5hZ20ubWV0aG9kQWRkZWQoKSBpbnN0ZWFkJyk7XG5cdGFnbS5tZXRob2RBZGRlZCA9IGFnbS5jbGllbnQubWV0aG9kX2FkZGVkO1xuXHRhZ20ubWV0aG9kX3JlbW92ZWQgPSBkZXByZWNhdGUoYWdtLmNsaWVudC5tZXRob2RfcmVtb3ZlZCwgJ2dsdWUuYWdtLm1ldGhvZF9yZW1vdmVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgZ2x1ZS5hZ20ubWV0aG9kUmVtb3ZlZCgpIGluc3RlYWQnKTtcblx0YWdtLm1ldGhvZFJlbW92ZWQgPSBhZ20uY2xpZW50Lm1ldGhvZF9yZW1vdmVkO1xuXG5cdGFnbS5zZXJ2ZXJfbWV0aG9kX2FkZGVkID0gZGVwcmVjYXRlKGFnbS5jbGllbnQuc2VydmVyX21ldGhvZF9hZGRlZCwgJ2dsdWUuYWdtLnNlcnZlcl9tZXRob2RfYWRkZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSBnbHVlLmFnbS5zZXJ2ZXJNZXRob2RBZGRlZCgpIGluc3RlYWQnKTtcblx0YWdtLnNlcnZlck1ldGhvZEFkZGVkID0gYWdtLmNsaWVudC5zZXJ2ZXJfbWV0aG9kX2FkZGVkO1xuXHRhZ20uc2VydmVyX21ldGhvZF9yZW1vdmVkID0gZGVwcmVjYXRlKGFnbS5jbGllbnQuc2VydmVyX21ldGhvZF9yZW1vdmVkLCAnZ2x1ZS5hZ20uc2VydmVyX21ldGhvZF9yZW1vdmVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgZ2x1ZS5hZ20uc2VydmVyTWV0aG9kUmVtb3ZlZCgpIGluc3RlYWQnKTtcblx0YWdtLnNlcnZlck1ldGhvZFJlbW92ZWQgPSBhZ20uY2xpZW50LnNlcnZlcl9tZXRob2RfcmVtb3ZlZDtcblxuXHRhZ20uc2VydmVyX2FkZGVkID0gZGVwcmVjYXRlKGFnbS5jbGllbnQuc2VydmVyX2FkZGVkLCAnZ2x1ZS5hZ20uc2VydmVyX2FkZGVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgZ2x1ZS5hZ20uc2VydmVyQWRkZWQoKSBpbnN0ZWFkJyk7XG5cdGFnbS5zZXJ2ZXJBZGRlZCA9IGFnbS5jbGllbnQuc2VydmVyX2FkZGVkO1xuXHRhZ20uc2VydmVyX3JlbW92ZWQgPSBkZXByZWNhdGUoYWdtLmNsaWVudC5zZXJ2ZXJfcmVtb3ZlZCwgJ2dsdWUuYWdtLnNlcnZlcl9yZW1vdmVkKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2UgZ2x1ZS5hZ20uc2VydmVyUmVtb3ZlZCgpIGluc3RlYWQnKTtcblx0YWdtLnNlcnZlclJlbW92ZWQgPSBhZ20uY2xpZW50LnNlcnZlcl9yZW1vdmVkO1xuXG5cdGFnbS5zdGFydCA9IGFnbS5zZXJ2ZXIuc3RhcnQ7XG5cdGFnbS5zdG9wID0gYWdtLnNlcnZlci5zdG9wO1xuXG5cdGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGFnbS5kZWJ1ZyA9PT0gdHJ1ZSkge1xuXHRcdGNvbnNvbGUubG9nKFwiQUdNIHN0YXJ0ZWQuXCIpO1xuXHR9XG5cblx0cmV0dXJuIGFnbTtcblx0Ly9yZXR1cm4gYWRkX3N1Z2FyKGFnbSk7XG5cbn07XG5cbmFnbSA9IGdsb2JhbC5odG1sQ29udGFpbmVyICE9PSB1bmRlZmluZWQgPyBuYXRpdmVfYWdtIDogYWdtO1xuXG4vL0V4cG9ydCBmb3IgYnJvd3NlcnNcbmlmIChnbG9iYWwudGljazQyID09PSB1bmRlZmluZWQpIHtcblx0Z2xvYmFsLnRpY2s0MiA9IHt9O1xufVxuZ2xvYmFsLnRpY2s0Mi5hZ20gPSBhZ207XG5cbm1vZHVsZS5leHBvcnRzID0gYWdtO1xuXG4iLCIvKlxuIFRoZSBBR00gQ2xpZW50IGFuYWx5c2VzIHNlcnZlciBwcmVzZW5jZXMsIGNvbGxlY3RzIGluZm9ybWF0aW9uIGFib3V0IHRoZWlyIG1ldGhvZHMgYW5kIGFsbG93cyB1c2VycyB0byBpbnZva2UgdGhlc2UgbWV0aG9kcy5cbiAqL1xudmFyIGNsaWVudF9zZXJ2ZXJzdGF0ZSA9IHJlcXVpcmUoJy4vYWdtX2NsaWVudF9zZXJ2ZXJzdGF0ZScpO1xudmFyIGNsaWVudF9pbnZvY2F0aW9uc3N0YXRlID0gcmVxdWlyZSgnLi9hZ21fY2xpZW50X2ludm9jYXRpb25zc3RhdGUnKTtcbnZhciBjbGllbnRfc3Vic2NyaXB0aW9uc3RhdGUgPSByZXF1aXJlKCcuL2FnbV9jbGllbnRfc3Vic2NyaXB0aW9uc3RhdGUnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9hZ21faGVscGVycycpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGluc3RhbmNlLCBjb25maWd1cmF0aW9uKSB7XG5cdC8vVmFsaWRhdGUgY29uZmlndXJhdGlvblxuXHRpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24gIT09ICdvYmplY3QnKSB7XG5cdFx0Y29uZmlndXJhdGlvbiA9IHt9O1xuXHRcdGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24uZGVidWcgPT09IHRydWUpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdDcmVhdGluZyBhbiBBR00gY2xpZW50IHdpdGggZGVmYXVsdCBjb25maWd1cmF0aW9uLicpO1xuXHRcdH1cblx0fVxuXHRpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24ucmVtb3ZlX3NlcnZlcl9vbl9uX21pc3NpbmdfaGVhcnRiZWF0cyAhPT0gJ251bWJlcicpIHtcblx0XHRjb25maWd1cmF0aW9uLnJlbW92ZV9zZXJ2ZXJfb25fbl9taXNzaW5nX2hlYXJ0YmVhdHMgPSAzO1xuXHR9XG5cdGlmICh0eXBlb2YgY29uZmlndXJhdGlvbi5tZXRob2RfcmVzcG9uc2VfdGltZW91dCAhPT0gJ251bWJlcicpIHtcblx0XHRjb25maWd1cmF0aW9uLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0ID0gMzAwMDtcblx0fVxuXHRpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24ud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQgIT09ICdudW1iZXInKSB7XG5cdFx0Y29uZmlndXJhdGlvbi53YWl0X2Zvcl9tZXRob2RfdGltZW91dCA9IDMwMDA7XG5cdH1cblx0Ly9JbnN0YW50aWF0ZSB0aGUgbW9kdWxlIHdoaWNoIGtlZXBzIHRyYWNrIG9mIGFsbCBhdmFpbGFibGUgc2VydmVycyBhbmQgbWV0aG9kc1xuXHR2YXIgc2VydmVycyA9IGNsaWVudF9zZXJ2ZXJzdGF0ZShjb25maWd1cmF0aW9uLCBpbnN0YW5jZSk7XG5cdC8vLi5hbmQgd2hlbiB5b3UgcmVjZWl2ZSBhIGhlYXJ0YmVhdC9wcmVzZW5jZSBmcm9tIGEgc2VydmVyLCBkZWxlZ2F0ZSBpdHMgcHJvY2Vzc2luZyB0byB0aGUgbW9kdWxlOlxuXHRjb25uZWN0aW9uLm9uKCdTZXJ2ZXJQcmVzZW5jZU1lc3NhZ2UnLCBmdW5jdGlvbiAobXNnKSB7XG5cdFx0c2VydmVycy5wcm9jZXNzX3ByZXNlbmNlKG1zZywgdHJ1ZSk7XG5cdH0pO1xuXHRjb25uZWN0aW9uLm9uKCdTZXJ2ZXJIZWFydGJlYXRNZXNzYWdlJywgZnVuY3Rpb24gKG1zZykge1xuXHRcdHNlcnZlcnMucHJvY2Vzc19wcmVzZW5jZShtc2csIGZhbHNlKTtcblx0fSk7XG5cdC8vSW5zdGFudGlhdGUgdGhlIG1vZHVsZSB0aGF0IGhhbmRsZXMgbWV0aG9kIGV4ZWN1dGlvbiBhbmQgcmVzcG9uc2VzXG5cdHZhciByZXNwb25zZSA9IGNsaWVudF9pbnZvY2F0aW9uc3N0YXRlKFxuXHRcdGNvbmZpZ3VyYXRpb24sXG5cdFx0aW5zdGFuY2UsXG5cdFx0ZnVuY3Rpb24gKG0pIHtcblx0XHRjb25uZWN0aW9uLnNlbmQoJ01ldGhvZEludm9jYXRpb25SZXF1ZXN0TWVzc2FnZScsIG0pO1xuXHR9KTtcblx0Ly8uLmFuZCBpbnN0YW50aWF0ZSB0aGUgbW9kdWxlIHRoYXQgaGFuZGxlcyBzdWJzY3JpcHRpb24gdG8gU3RyZWFtaW5nIG1ldGhvZHNcblx0dmFyIHN1YlN0YXRlID0gY2xpZW50X3N1YnNjcmlwdGlvbnN0YXRlKFxuXHRcdGNvbmZpZ3VyYXRpb24sXG5cdFx0aW5zdGFuY2UsXG5cdFx0ZnVuY3Rpb24gKG0pIHtcblx0XHRcdGNvbm5lY3Rpb24uc2VuZCgnTWV0aG9kSW52b2NhdGlvblJlcXVlc3RNZXNzYWdlJywgbSk7XG5cdFx0fSk7XG5cdC8vLi5hbmQgZGVsZWdhdGUgcmVzcG9uc2VzIHRvIHRoZW0uXG5cdGNvbm5lY3Rpb24ub24oJ01ldGhvZEludm9jYXRpb25SZXN1bHRNZXNzYWdlJywgZnVuY3Rpb24obXNnKXtcblx0XHRpZihtc2cgJiYgbXNnLkV2ZW50U3RyZWFtQWN0aW9uICYmIG1zZy5FdmVudFN0cmVhbUFjdGlvbiAhPT0gMCl7XG5cdFx0XHRzdWJTdGF0ZS5wcm9jZXNzUHVibGlzaGVyTXNnKG1zZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3BvbnNlLnByb2Nlc3NfbWV0aG9kX3Jlc3BvbnNlKG1zZyk7XG5cdFx0fVxuXHR9KTtcblxuXG4vLyAgIC8vQWRkcyBjbGllbnQgY2FsbGJhY2tzIHdoaWNoIGFyZSBleGVjdXRlZCB3aGVuIGEgbmV3IG1ldGhvZCBpcyBhZGRlZCBvciBzdG9wcyBiZWluZyBhdmFpbGFibGVcbi8vICAgZnVuY3Rpb24gbWV0aG9kX2FkZGVkKGNhbGxiYWNrKSB7XG4vLyAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuLy8gICAgICAgLy9BZGQgdGhlIGNhbGxiYWNrXG4vLyAgICAgICBjb25maWd1cmF0aW9uLm9uX21ldGhvZF9hZGRlZCA9IGNhbGxiYWNrO1xuLy8gICAgICAgLy9DYWxsIHRoZSBjYWxsYmFjayBmb3IgYWxsIHRoZSBtZXRob2Qgd2hpY2ggd2VyZSBhZGRlZCBiZWZvcmUgdGhlIGNhbGxiYWNrIHdhcyByZWdpc3RlcmVkLlxuLy8gICAgICAgc2VydmVycy5nZXRfbWV0aG9kcygpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuLy8gICAgICAgICBjYWxsYmFjayhtZXRob2QpO1xuLy8gICAgICAgfSk7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIHRocm93ICdcXCdtZXRob2RfYWRkZWRcXCcgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50Jztcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgZnVuY3Rpb24gbWV0aG9kX3JlbW92ZWQoY2FsbGJhY2spIHtcbi8vICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4vLyAgICAgICAvL0FkZCB0aGUgY2FsbGJhY2tcbi8vICAgICAgIGNvbmZpZ3VyYXRpb24ub25fbWV0aG9kX3JlbW92ZWQgPSBjYWxsYmFjaztcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgdGhyb3cgJ1xcJ21ldGhvZF9yZW1vdmVkXFwnIG11c3QgYmUgY2FsbGVkIHdpdGggYSBmdW5jdGlvbiBhcyBhbiBhcmd1bWVudCc7XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy9BZGRzIGNsaWVudCBjYWxsYmFja3Mgd2hpY2ggYXJlIGV4ZWN1dGVkIHdoZW4gYSBuZXcgbWV0aG9kIGlzIGFkZGVkIG9yIHN0b3BzIGJlaW5nIGF2YWlsYWJsZVxuLy8gICBmdW5jdGlvbiBzZXJ2ZXJfYWRkZWQoY2FsbGJhY2spIHtcbi8vICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4vLyAgICAgICAvL0FkZCB0aGUgY2FsbGJhY2tcbi8vICAgICAgIGNvbmZpZ3VyYXRpb24ub25fc2VydmVyX2FkZGVkID0gY2FsbGJhY2s7XG4vLyAgICAgICAvL0NhbGwgdGhlIGNhbGxiYWNrIGZvciBhbGwgdGhlIG1ldGhvZCB3aGljaCB3ZXJlIGFkZGVkIGJlZm9yZSB0aGUgY2FsbGJhY2sgd2FzIHJlZ2lzdGVyZWQuXG4vLyAgICAgICBzZXJ2ZXJzLmdldF9zZXJ2ZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VydmVyKSB7XG4vLyAgICAgICAgIGNhbGxiYWNrKHNlcnZlcik7XG4vLyAgICAgICB9KTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgdGhyb3cgJ1xcJ3NlcnZlcl9hZGRlZFxcJyBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgZnVuY3Rpb24gYXMgYW4gYXJndW1lbnQnO1xuLy8gICAgIH1cbi8vICAgfVxuLy8gICBmdW5jdGlvbiBzZXJ2ZXJfcmVtb3ZlZChjYWxsYmFjaykge1xuLy8gICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbi8vICAgICAgIC8vQWRkIHRoZSBjYWxsYmFja1xuLy8gICAgICAgY29uZmlndXJhdGlvbi5vbl9zZXJ2ZXJfcmVtb3ZlZCA9IGNhbGxiYWNrO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICB0aHJvdyAnXFwnc2VydmVyX3JlbW92ZWRcXCcgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50Jztcbi8vICAgICB9XG4vLyAgIH1cblxuXHRmdW5jdGlvbiBzdWJzY3JpYmUobmFtZSwgb3B0aW9ucywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG5cdFx0Ly9vcHRpb25zIGNhbiBoYXZlIGFyZ3VtZW50czp7fSwgdGFyZ2V0OiAnYmVzdCcvJ2FsbCcve3NlcnZlcl9pbnN0YW5jZX0sIHdhaXRUaW1lb3V0TXM6MzAwMFxuXG5cdFx0ZnVuY3Rpb24gY2FsbFN1YnN0YXRlU3Vic2NyaWJlKHRhcmdldFNlcnZlcnMsIG5hbWUsIG9wdGlvbnMsIHN1Y2Nlc3NQcm94eSwgZXJyb3JQcm94eSl7XG5cdFx0XHRpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCc+Pj4gU3Vic2NyaWJpbmcgdG8gXCInICsgbmFtZSArICdcIiBvbiAnICsgdGFyZ2V0U2VydmVycy5sZW5ndGggKyAnIHNlcnZlcnMnKTtcblx0XHRcdH1cblxuXHRcdFx0c3ViU3RhdGUuc3Vic2NyaWJlKFxuXHRcdFx0XHR7IG5hbWU6IG5hbWUgfSxcblx0XHRcdFx0b3B0aW9ucy5hcmd1bWVudHMsXG5cdFx0XHRcdHRhcmdldFNlcnZlcnMsXG5cdFx0XHRcdHsgbWV0aG9kX3Jlc3BvbnNlX3RpbWVvdXQ6IG9wdGlvbnMud2FpdFRpbWVvdXRNcyB9LFxuXHRcdFx0XHRzdWNjZXNzUHJveHksXG5cdFx0XHRcdGVycm9yUHJveHlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cblx0XHRcdHZhciBzdWNjZXNzUHJveHkgPSBmdW5jdGlvbiAoYXJncykgeyByZXNvbHZlKGFyZ3MpOyB9O1xuXHRcdFx0dmFyIGVycm9yUHJveHkgICA9IGZ1bmN0aW9uIChhcmdzKSB7IHJlamVjdChhcmdzKTsgfTtcblxuXHRcdFx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGFyZ2V0ID0gJ2Jlc3QnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIgJiYgdGFyZ2V0ICE9PSBcImFsbFwiICYmIHRhcmdldCAhPT0gXCJiZXN0XCIpIHtcblx0XHRcdFx0cmVqZWN0KHttZXNzYWdlOiAnXCInICsgdGFyZ2V0ICsgJ1wiIGlzIG5vdCBhIHZhbGlkIHRhcmdldC4gVmFsaWQgdGFyZ2V0cyBhcmUgXCJhbGxcIiwgXCJiZXN0XCIsIG9yIGFuIGluc3RhbmNlLid9KTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2Ygb3B0aW9ucy53YWl0VGltZW91dE1zICE9PSAnbnVtYmVyJyB8fCBvcHRpb25zLndhaXRUaW1lb3V0TXMgIT09IG9wdGlvbnMud2FpdFRpbWVvdXRNcyAvKk5hTiovKSB7XG5cdFx0XHRcdG9wdGlvbnMud2FpdFRpbWVvdXRNcyA9IGNvbmZpZ3VyYXRpb24ud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQ7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjdXJyZW50U2VydmVycyA9IHNlcnZlcnNfZm9yX21ldGhvZF9hbmRfdGFyZ2V0KG5hbWUsIHRhcmdldCk7XG5cblx0XHRcdC8vLi4uaW5jbHVkaW5nIHRoZSBNZXRob2RSZXF1ZXN0U3ViamVjdCBmb3IgdGhlIHN0cmVhbWluZyBtZXRob2Rcblx0XHRcdC8vZG9uJ3QgY2hlY2sgaWYgdGhlIG1ldGhvZCBpcyBzdHJlYW1pbmcgb3Igbm90LCBzdWJzY3JpYmluZyB0byBub24tc3RyZWFtaW5nIG1ldGhvZCBoYXMgdG8gaW52b2tlIGl0XG5cblx0XHRcdGlmIChjdXJyZW50U2VydmVycy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGxhdGVTZXJ2ZXJzID0gc2VydmVyc19mb3JfbWV0aG9kX2FuZF90YXJnZXQobmFtZSwgdGFyZ2V0KTtcblx0XHRcdFx0XHQvL1RPRE86IGNoYW5nZSB0byB1c2UgdGhlIG1ldGhvZEFkZGVkIGhhbmRsZXJcblx0XHRcdFx0XHQvL1RPRE86IHNldCBhZ20ubWV0aG9kQWRkZWQgYW5kIGlmKHdhaXRUaW1lb3V0Pj0wKXtzZXRUaW1lb3V0fVxuXHRcdFx0XHRcdGNhbGxTdWJzdGF0ZVN1YnNjcmliZShsYXRlU2VydmVycywgbmFtZSwgb3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KVxuXG5cdFx0XHRcdH0sIG9wdGlvbnMud2FpdFRpbWVvdXRNcylcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbFN1YnN0YXRlU3Vic2NyaWJlKGN1cnJlbnRTZXJ2ZXJzLCBuYW1lLCBvcHRpb25zLCBzdWNjZXNzUHJveHksIGVycm9yUHJveHkpXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gaGVscGVycy5wcm9taXNpZnkocHJvbWlzZSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcblx0fVxuXG5cdC8vQWJzdHJhY3QgZ2V0X21ldGhvZCBhbmQgZ2V0X3NlcnZlcnMgZnVuY3Rpb25zXG5cdC8vVGhleSByZWx5IG9uICBnZXRfbWV0aG9kIGFuZCBnZXRfc2VydmVycyBmcm9tIHRoZSBcInNlcnZlcnNcIiBtb2R1bGVcblx0Ly9JbiB0aG9zZSBvbmVzIHlvdSBkb24ndCBuZWVkIHRvIHNwZWNpZnkgYWxsIG9mIHRoZSBtZXRob2QncyBwcm9wcyB0byBmaW5kIGl0LlxuXHRmdW5jdGlvbiBnZXRfbWV0aG9kKG1ldGhvZF9maWx0ZXIpIHtcblx0XHRpZiAodHlwZW9mIG1ldGhvZF9maWx0ZXIgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRtZXRob2RfZmlsdGVyID0ge25hbWU6IG1ldGhvZF9maWx0ZXJ9O1xuXHRcdH1cblx0XHQvL0RvIG5vdCBleGVjdXRlIGZvciBlbXB0eSBmaWx0ZXJcblx0XHRpZiAobWV0aG9kX2ZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBleGFjdF9tYXRjaCA9IHNlcnZlcnMuZ2V0X21ldGhvZChtZXRob2RfZmlsdGVyKTtcblx0XHQvL1RyeSBjYWxsaW5nIHRoZSBvcmlnaW5hbCBcImdldF9tZXRob2RcIiBmdW5jdGlvbiAoaXQgd2lsbCB3b3JrIGlmIGFsbCBtZXRob2QgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkKTpcblx0XHRpZiAoZXhhY3RfbWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGV4YWN0X21hdGNoICAvL1Rha2UgYWxsIGF2YWlsYWJsZSBtZXRob2RzIGFuZCBpdGVyYXRlIHRoZW0gdW50aWwgd2UgZmluZCBhIG1hdGNoXG5cdFx0XHRcdDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRha2VXaGlsZShzZXJ2ZXJzLmdldF9tZXRob2RzKCksIGZ1bmN0aW9uIChtZXRob2QpIHtcblx0XHRcdFx0cmV0dXJuIG1ldGhvZF9tYXRjaChtZXRob2RfZmlsdGVyLCBtZXRob2QpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0X21ldGhvZHMobWV0aG9kX2ZpbHRlcikge1xuXHRcdGlmIChtZXRob2RfZmlsdGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBzZXJ2ZXJzLmdldF9tZXRob2RzKCk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbWV0aG9kX2ZpbHRlciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdG1ldGhvZF9maWx0ZXIgPSB7bmFtZTogbWV0aG9kX2ZpbHRlcn07XG5cdFx0fVxuXHRcdHJldHVybiBzZXJ2ZXJzLmdldF9tZXRob2RzKCkuZmlsdGVyKGZ1bmN0aW9uIChtZXRob2QpIHtcblx0XHRcdHJldHVybiBtZXRob2RfbWF0Y2gobWV0aG9kX2ZpbHRlciwgbWV0aG9kKTtcblx0XHR9KTtcblx0fVxuXG5cdC8vUmV0cmlldmVzIGFsbCBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBhbnkgb2Ygc2V2ZXJhbCBtZXRob2RzLCBsaXN0ZWQgYXMgYW4gYXJyYXlcblx0ZnVuY3Rpb24gZ2V0X21ldGhvZHNfZm9yX2luc3RhbmNlKGluc3RhbmNlX2ZpbHRlcikge1xuXHRcdHZhciBleGFjdF9tYXRjaCA9IHNlcnZlcnMuZ2V0X21ldGhvZHMoaW5zdGFuY2VfZmlsdGVyKTtcblx0XHQvL1RyeSBjYWxsaW5nIHRoZSBvcmlnaW5hbCBcImdldF9tZXRob2RzXCIgZnVuY3Rpb24gKGl0IHdpbGwgd29yayBpZiBhbGwgaW5zdGFuY2UgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkKTpcblx0XHRpZiAoZXhhY3RfbWF0Y2gubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRyZXR1cm4gZXhhY3RfbWF0Y2g7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBtZXRob2RfaWRzID0gZ2V0X3NlcnZlcnMoKS5maWx0ZXIoZnVuY3Rpb24gKHNlcnZlcikge1xuXHRcdFx0XHRyZXR1cm4gaW5zdGFuY2VfbWF0Y2goaW5zdGFuY2VfZmlsdGVyLCBzZXJ2ZXIpO1xuXHRcdFx0fSkucmVkdWNlKGZ1bmN0aW9uIChtZXRob2RzLCBzZXJ2ZXIpIHtcblx0XHRcdFx0c2VydmVycy5nZXRfbWV0aG9kX2lkcyhzZXJ2ZXIpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZF9pZCkge1xuXHRcdFx0XHRcdG1ldGhvZHNbbWV0aG9kX2lkXSA9IHRydWU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kcztcblx0XHRcdH0sIHt9KTtcblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhtZXRob2RfaWRzKS5tYXAoZnVuY3Rpb24gKG1ldGhvZF9pZCkge1xuXHRcdFx0XHRyZXR1cm4gc2VydmVycy5nZXRfbWV0aG9kKG1ldGhvZF9pZCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvL1JldHJpZXZlcyBhbGwgc2VydmVycyB0aGF0IHN1cHBvcnQgYSBnaXZlbiBtZXRob2Rcblx0ZnVuY3Rpb24gZ2V0X3NlcnZlcnMobWV0aG9kX2ZpbHRlcikge1xuXHRcdC8vTm8gbWV0aG9kIC0gZ2V0IGFsbCBzZXJ2ZXJzXG5cdFx0aWYgKG1ldGhvZF9maWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHNlcnZlcnMuZ2V0X3NlcnZlcnMoKTtcblx0XHR9XG5cdFx0Ly9Ob24tZXhpc3RpbmcgbWV0aG9kIC0gcmV0dXJuIGFuIGVtcHR5IGFycmF5XG5cdFx0dmFyIG1ldGhvZCA9IGdldF9tZXRob2QobWV0aG9kX2ZpbHRlcik7XG5cdFx0aWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdC8vRWxzZSwgcmV0dXJuIHNlcnZlcnMgZm9yIG1ldGhvZFxuXHRcdHJldHVybiBzZXJ2ZXJzLmdldF9zZXJ2ZXJzKG1ldGhvZCk7XG5cdH1cblxuXG5cdC8vUmV0cmlldmVzIGFsbCBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBhbnkgb2Ygc2V2ZXJhbCBtZXRob2RzLCBsaXN0ZWQgYXMgYW4gYXJyYXlcblx0ZnVuY3Rpb24gc2VydmVyc19mb3JfbWV0aG9kcyhtZXRob2RzKSB7XG5cdFx0cmV0dXJuIG1ldGhvZHMucmVkdWNlKGZ1bmN0aW9uIChzb19mYXIsIG1ldGhvZCkge1xuXHRcdFx0cmV0dXJuIHNvX2Zhci5jb25jYXQoc2VydmVycy5nZXRfc2VydmVycyhtZXRob2QsIHRydWUpKTsvLyh0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZXJlIGJlY2F1c2Ugd2UgYWxzbyBuZWVkIHRoZSByZXF1ZXN0IHN1YmplY3QpXG5cdFx0fSwgW10pLnNvcnQoc2VydmVycy5jb21wYXJlX3NlcnZlcnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VydmVyc19mb3JfbWV0aG9kX2FuZF90YXJnZXQobWV0aG9kX2ZpbHRlciwgdGFyZ2V0KSB7XG5cdFx0Ly9HZXQgdGhlIG1ldGhvZHMgd2hpY2ggbWF0Y2ggdGhlIGZpbHRlclxuXHRcdHZhciBtZXRob2RzID0gZ2V0X21ldGhvZHMobWV0aG9kX2ZpbHRlcik7XG5cdFx0Ly9EZXRlcm1pbmUgd2hlcmUgdG8gZXhlY3V0ZSB0aGUgbWV0aG9kKHMpICh0aGUgXCJ0YXJnZXRcIiBhcmd1bWVudClcblx0XHQvL0dldCBhbGwgc2VydmVycyB0aGF0IHN1cHBvcnQgdGhlIG1ldGhvZChzKSBhbmQgZ2V0IHRoZSBvbmVzIHRoYXQgbWF0Y2ggdGhlIHRhcmdldCBjcml0ZXJpYVxuXHRcdHJldHVybiBmaWx0ZXJfYnlfdGFyZ2V0KHRhcmdldCwgc2VydmVyc19mb3JfbWV0aG9kcyhtZXRob2RzKSk7XG5cdH1cblxuXG5cdC8vSW52b2tlcyBhbiBBR00gbWV0aG9kIChtb3N0bHkgaXQgZG9lcyBpbnB1dCBjaGVja2luZyksIHRoZSBhY3R1YWwgam9iIGlzIGRvbmUgYnkgXCJyZXF1ZXN0Lmludm9rZVwiXG5cdGZ1bmN0aW9uIGludm9rZShtZXRob2RfZmlsdGVyLCBhcmd1bWVudF9vYmosIHRhcmdldCwgYWRkaXRpb25hbF9vcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuXHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0dmFyIHN1Y2Nlc3NQcm94eSwgZXJyb3JQcm94eTtcblxuXHRcdFx0c3VjY2Vzc1Byb3h5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRcdFx0Ly92YXIgcGFyc2VkID0gSlNPTi5wYXJzZShhcmdzKTtcblx0XHRcdFx0cmVzb2x2ZShhcmdzKTtcblx0XHRcdH07XG5cdFx0XHRlcnJvclByb3h5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRcdFx0Ly92YXIgcGFyc2VkID0gSlNPTi5wYXJzZShhcmdzKTtcblx0XHRcdFx0cmVqZWN0KGFyZ3MpO1xuXHRcdFx0fTtcblx0XHRcdC8vQWRkIGRlZmF1bHQgcGFyYW1zXG5cdFx0XHRpZiAoYXJndW1lbnRfb2JqID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YXJndW1lbnRfb2JqID0ge307XG5cdFx0XHR9XG5cdFx0XHRpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGFyZ2V0ID0gJ2Jlc3QnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIgJiYgdGFyZ2V0ICE9PSBcImFsbFwiICYmIHRhcmdldCAhPT0gXCJiZXN0XCIpIHtcblx0XHRcdFx0cmVqZWN0KHttZXNzYWdlOiAnXCInICsgdGFyZ2V0ICsgJ1wiIGlzIG5vdCBhIHZhbGlkIHRhcmdldC4gVmFsaWQgdGFyZ2V0cyBhcmUgXCJhbGxcIiBhbmQgXCJiZXN0XCIuJ30pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFkZGl0aW9uYWxfb3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGFkZGl0aW9uYWxfb3B0aW9ucyA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWRkaXRpb25hbF9vcHRpb25zLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YWRkaXRpb25hbF9vcHRpb25zLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0ID0gY29uZmlndXJhdGlvbi5tZXRob2RfcmVzcG9uc2VfdGltZW91dDtcblx0XHRcdH1cblx0XHRcdGlmIChhZGRpdGlvbmFsX29wdGlvbnMud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRhZGRpdGlvbmFsX29wdGlvbnMud2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQgPSBjb25maWd1cmF0aW9uLndhaXRfZm9yX21ldGhvZF90aW1lb3V0O1xuXHRcdFx0fVxuXG5cblx0XHRcdC8vQ2hlY2sgaWYgdGhlIGFyZ3VtZW50cyBhcmUgYW4gb2JqZWN0XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3VtZW50X29iaiAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0cmVqZWN0KHttZXNzYWdlOiAnVGhlIG1ldGhvZCBhcmd1bWVudHMgbXVzdCBiZSBhbiBvYmplY3QuJ30pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIG1ldGhvZF9maWx0ZXIgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG1ldGhvZF9maWx0ZXIgPSB7bmFtZTogbWV0aG9kX2ZpbHRlcn07XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzZXJ2ZXJzID0gc2VydmVyc19mb3JfbWV0aG9kX2FuZF90YXJnZXQobWV0aG9kX2ZpbHRlciwgdGFyZ2V0KTtcblxuXHRcdFx0aWYgKHNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG5cblx0XHRcdFx0aW52b2tlX3VuZXhpc3RpbmcobWV0aG9kX2ZpbHRlciwgYXJndW1lbnRfb2JqLCB0YXJnZXQsIGFkZGl0aW9uYWxfb3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KTtcblxuXHRcdFx0fSBlbHNlIGlmIChzZXJ2ZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJz4+PiBJbnZva2luZyBcIicgKyBtZXRob2RfZmlsdGVyLm5hbWUgKyAnXCIgb24gMSBzZXJ2ZXInKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3BvbnNlLmludm9rZShtZXRob2RfZmlsdGVyLCBhcmd1bWVudF9vYmosIHNlcnZlcnNbMF0sIGFkZGl0aW9uYWxfb3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCc+Pj4gSW52b2tpbmcgXCInICsgbWV0aG9kX2ZpbHRlci5uYW1lICsgJ1wiIG9uICcgKyBzZXJ2ZXJzLmxlbmd0aCArICcgc2VydmVycycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW52b2tlX29uX2FsbChtZXRob2RfZmlsdGVyLCBhcmd1bWVudF9vYmosIHNlcnZlcnMsIGFkZGl0aW9uYWxfb3B0aW9ucywgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBoZWxwZXJzLnByb21pc2lmeShwcm9taXNlLCBzdWNjZXNzLCBlcnJvcik7XG5cdH1cblxuXG5cdC8vQ2FsbGVkIHdoZW4gdGhlIHVzZXIgdHJpZXMgdG8gaW52b2tlIGEgbWV0aG9kIHdoaWNoIGRvZXMgbm90IGV4aXN0XG5cdGZ1bmN0aW9uIGludm9rZV91bmV4aXN0aW5nKG1ldGhvZF9maWx0ZXIsIGFyZ3VtZW50X29iaiwgdGFyZ2V0LCBhZGRpdGlvbmFsX29wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0dmFyIHNlcnZlcl9mb3VuZCA9IGZhbHNlO1xuXG5cdFx0aWYgKGFkZGl0aW9uYWxfb3B0aW9ucy53YWl0X2Zvcl9tZXRob2RfdGltZW91dCA9PT0gMCkge1xuXHRcdFx0Y2FsbF9lcnJvcigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y29uZmlndXJhdGlvbi5zZXJ2ZXJfbWV0aG9kX2FkZGVkID0gY29uZmlndXJhdGlvbi5zZXJ2ZXJfbWV0aG9kX2FkZGVkLmZpbHRlcihmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sgIT09IG5ld19zZXJ2ZXI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoIXNlcnZlcl9mb3VuZCkge1xuXHRcdFx0XHRcdGNhbGxfZXJyb3IoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgYWRkaXRpb25hbF9vcHRpb25zLndhaXRfZm9yX21ldGhvZF90aW1lb3V0KTtcblxuXHRcdFx0cmVnaXN0ZXJfY2FsbGJhY2soXCJzZXJ2ZXJfbWV0aG9kX2FkZGVkXCIsIGlkZW50aXR5LCBuZXdfc2VydmVyKTtcblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIG5ld19zZXJ2ZXIoKSB7XG5cdFx0XHRpZiAoc2VydmVyX2ZvdW5kKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBzZXJ2ZXIgPSBzZXJ2ZXJzX2Zvcl9tZXRob2RfYW5kX3RhcmdldChtZXRob2RfZmlsdGVyLCB0YXJnZXQpWzBdO1xuXHRcdFx0aWYgKHNlcnZlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHNlcnZlcl9mb3VuZCA9IHRydWU7XG5cdFx0XHRcdHJlc3BvbnNlLmludm9rZShtZXRob2RfZmlsdGVyLCBhcmd1bWVudF9vYmosIHNlcnZlciwgYWRkaXRpb25hbF9vcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBjYWxsX2Vycm9yKCkge1xuXHRcdFx0Ly9DaGVjayBpZiB0aGUgbWV0aG9kIGV4aXN0cyBhbmQgaWYgaXQgZG9lc250JywgcmV0dXJuIGFuIGVycm9yXG5cdFx0XHRpZiAoZ2V0X21ldGhvZHMobWV0aG9kX2ZpbHRlcikubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGVycm9yKHtcblx0XHRcdFx0XHRtZXRob2Q6IG1ldGhvZF9maWx0ZXIsXG5cdFx0XHRcdFx0Y2FsbGVkX3dpdGg6IGFyZ3VtZW50X29iaixcblx0XHRcdFx0XHRtZXNzYWdlOiAnSSBjb3VsZCBub3QgZmluZCBhIG1ldGhvZCB3aXRoIHRob3NlIHByb3BlcnRpZXM6ICcgKyBKU09OLnN0cmluZ2lmeShtZXRob2RfZmlsdGVyKVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVycm9yKHtcblx0XHRcdFx0XHRtZXRob2Q6IG1ldGhvZF9maWx0ZXIsXG5cdFx0XHRcdFx0Y2FsbGVkX3dpdGg6IGFyZ3VtZW50X29iaixcblx0XHRcdFx0XHRtZXNzYWdlOiAnSSBjb3VsZCBub3QgZmluZCBzZXJ2ZXJzIHdpdGggdGhlc2UgcHJvcGVydGllczogJyArIEpTT04uc3RyaW5naWZ5KHRhcmdldClcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cblx0Ly9DYWxsZWQgd2hlbiB0aGUgaW52b2tlcyBhIG1ldGhvZCB3aXRoIG11bHRpcGxlIHRhcmdldHNcblx0Ly9DYWxscyBhIG1ldGhvZCBmb3IgYWxsIHNlcnZlcnMgYW5kIHVuaWZpZXMgdGhlIHJlc3VsdHMgdGhleSByZXR1cm4gaW50byBvbmU6XG5cdGZ1bmN0aW9uIGludm9rZV9vbl9hbGwobWV0aG9kLCBhcmd1bWVudF9vYmosIHNlcnZlcnMsIGFkZGl0aW9uYWxfb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpIHtcblx0XHQvL0hlcmUgd2Ugd2lsbCBzdG9yZSB0aGUgcmVzdWx0cyB0aGF0IHRoZSBzZXJ2ZXJzIHJldHVyblxuXHRcdHZhciBzdWNjZXNzZXMgPSBbXTtcblx0XHR2YXIgZXJyb3JzID0gW107XG5cdFx0Ly9UaGVzZSBhcmUgdGhlIGNhbGxiYWNrc1xuXHRcdHZhciBzdWNjZXNzX2NhbGxiYWNrID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0c3VjY2Vzc2VzLnB1c2gocmVzdWx0KTtcblx0XHRcdHNlbmRfcmVzcG9uc2Uoc3VjY2Vzc2VzLCBlcnJvcnMpO1xuXHRcdH07XG5cdFx0dmFyIGVycm9yX2NhbGxiYWNrID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0ZXJyb3JzLnB1c2gocmVzdWx0KTtcblx0XHRcdHNlbmRfcmVzcG9uc2Uoc3VjY2Vzc2VzLCBlcnJvcnMpO1xuXHRcdH07XG5cdFx0Ly9DYWxsIHRoZSBtZXRob2QgZm9yIGFsbCB0YXJnZXRzXG5cdFx0c2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcblx0XHRcdHJlc3BvbnNlLmludm9rZShtZXRob2QsIGFyZ3VtZW50X29iaiwgc2VydmVyLCBhZGRpdGlvbmFsX29wdGlvbnMsIHN1Y2Nlc3NfY2FsbGJhY2ssIGVycm9yX2NhbGxiYWNrKTtcblx0XHR9KTtcblxuXG5cdFx0Ly9DYWxscyB0aGUgbWFpbiBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3Mgd2l0aCB0aGUgYWdncmVnYXRlZCByZXN1bHRzXG5cdFx0ZnVuY3Rpb24gc2VuZF9yZXNwb25zZSgpIHtcblx0XHRcdC8vd2FpdCB0aWxsIGV2ZXJ5Ym9keSBpcyBmaW5pc2hlZFxuXHRcdFx0aWYgKHN1Y2Nlc3Nlcy5sZW5ndGggKyBlcnJvcnMubGVuZ3RoIDwgc2VydmVycy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly9FeGVjdXRlIHRoZSBcInN1Y2Nlc3NcIiBjYWxsYmFja1xuXHRcdFx0aWYgKHN1Y2Nlc3Nlcy5sZW5ndGggIT09IDApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHN1Y2Nlc3Nlcy5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgc3VjY2Vzcykge1xuXHRcdFx0XHRcdG9iai5tZXRob2QgPSBzdWNjZXNzLm1ldGhvZDtcblx0XHRcdFx0XHRvYmouY2FsbGVkX3dpdGggPSBzdWNjZXNzLmNhbGxlZF93aXRoO1xuXHRcdFx0XHRcdG9iai5yZXR1cm5lZCA9IHN1Y2Nlc3MucmV0dXJuZWQ7XG5cdFx0XHRcdFx0b2JqLmFsbF9yZXR1cm5fdmFsdWVzLnB1c2goe1xuXHRcdFx0XHRcdFx0ZXhlY3V0ZWRfYnk6IHN1Y2Nlc3MuZXhlY3V0ZWRfYnksXG5cdFx0XHRcdFx0XHRyZXR1cm5lZDogc3VjY2Vzcy5yZXR1cm5lZFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdG9iai5leGVjdXRlZF9ieSA9IHN1Y2Nlc3MuZXhlY3V0ZWRfYnk7XG5cdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0fSwge2FsbF9yZXR1cm5fdmFsdWVzOiBbXX0pO1xuXG5cdFx0XHRcdC8vSWYgd2UgZ2V0IGVycm9ycyBmcm9tIG9uZSBvZiB0aGUgc2VydmVycyBhZGQgdGhlbSB0byB0aGUgc3VjY2VzcyBvYmplY3QgdGhhdCB3aWxsIGJlIHJlc29sdmVkLlxuXHRcdFx0XHRpZiAoZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0XHRcdHJlc3VsdC5hbGxfZXJyb3JzID0gW107XG5cdFx0XHRcdFx0ZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRcdFx0cmVzdWx0LmFsbF9lcnJvcnMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdC8vZXhlY3V0ZWRfYnkgOiBvYmouZXhlY3V0ZWRfYnksIC8vIHdlIGRvbid0IGdldCBleGVjdXRlZF9ieSBvYmplY3QgZnJvbSB0aGUgZXJyb3IgcmVzcG9uc2Vcblx0XHRcdFx0XHRcdFx0bmFtZTogb2JqLm1ldGhvZC5uYW1lLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiBvYmoubWVzc2FnZVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdWNjZXNzKHJlc3VsdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoZXJyb3JzLmxlbmd0aCAhPT0gMCkgeyAvL0V4ZWN1dGUgdGhlIFwiZXJyb3JcIiBjYWxsYmFja1xuXHRcdFx0XHRlcnJvcihlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGVycm9yKSB7XG5cdFx0XHRcdFx0b2JqLm1ldGhvZCA9IGVycm9yLm1ldGhvZDtcblx0XHRcdFx0XHRvYmouY2FsbGVkX3dpdGggPSBlcnJvci5jYWxsZWRfd2l0aDtcblx0XHRcdFx0XHRvYmoubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG5cdFx0XHRcdFx0b2JqLmFsbF9lcnJvcnMucHVzaCh7XG5cdFx0XHRcdFx0XHRleGVjdXRlZF9ieTogZXJyb3IuZXhlY3V0ZWRfYnksXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly9vYmouZXhlY3V0ZWRfYnkgPSBzdWNjZXNzLmV4ZWN1dGVkX2J5O1xuXHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdH0sIHthbGxfZXJyb3JzOiBbXX0pKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdHZhciByZWdpc3Rlcl9jYWxsYmFjayA9IGhlbHBlcnMuc2F2ZV9jYWxsYmFja19pbi5iaW5kKHRoaXMsIGNvbmZpZ3VyYXRpb24pO1xuXG5cdHZhciBhcHBseV9vbl9zZXJ2ZXJzID0gYXBwbHlfb24uYmluZChudWxsLCBzZXJ2ZXJzLmdldF9zZXJ2ZXJzKTtcblx0dmFyIGFwcGx5X29uX21ldGhvZHMgPSBhcHBseV9vbi5iaW5kKG51bGwsIHNlcnZlcnMuZ2V0X21ldGhvZHMpO1xuXHR2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoYSkge1xuXHRcdHJldHVybiBhO1xuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0c3Vic2NyaWJlOiBzdWJzY3JpYmUsXG5cdFx0aW52b2tlOiBpbnZva2UsXG5cdFx0bWV0aG9kOiBnZXRfbWV0aG9kLFxuXHRcdHNlcnZlcnM6IGdldF9zZXJ2ZXJzLFxuXHRcdG1ldGhvZHM6IGdldF9tZXRob2RzLFxuXHRcdG1ldGhvZHNfZm9yX2luc3RhbmNlOiBnZXRfbWV0aG9kc19mb3JfaW5zdGFuY2UsXG5cdFx0bWV0aG9kX2FkZGVkOiByZWdpc3Rlcl9jYWxsYmFjay5iaW5kKG51bGwsIFwibWV0aG9kX2FkZGVkXCIsIGFwcGx5X29uX21ldGhvZHMpLFxuXHRcdG1ldGhvZF9yZW1vdmVkOiByZWdpc3Rlcl9jYWxsYmFjay5iaW5kKG51bGwsIFwibWV0aG9kX3JlbW92ZWRcIiwgaWRlbnRpdHkpLFxuXHRcdHNlcnZlcl9hZGRlZDogcmVnaXN0ZXJfY2FsbGJhY2suYmluZChudWxsLCBcInNlcnZlcl9hZGRlZFwiLCBhcHBseV9vbl9zZXJ2ZXJzKSxcblx0XHRzZXJ2ZXJfcmVtb3ZlZDogcmVnaXN0ZXJfY2FsbGJhY2suYmluZChudWxsLCBcInNlcnZlcl9yZW1vdmVkXCIsIGlkZW50aXR5KSxcblx0XHRzZXJ2ZXJfbWV0aG9kX2FkZGVkOiByZWdpc3Rlcl9jYWxsYmFjay5iaW5kKG51bGwsIFwic2VydmVyX21ldGhvZF9hZGRlZFwiLCBpZGVudGl0eSksXG5cdFx0c2VydmVyX21ldGhvZF9yZW1vdmVkOiByZWdpc3Rlcl9jYWxsYmFjay5iaW5kKG51bGwsIFwic2VydmVyX21ldGhvZF9yZW1vdmVkXCIsIGlkZW50aXR5KSxcblx0XHRwYXJzZV9zaWduYXR1cmU6IGhlbHBlcnMuc2lnbmF0dXJlX3BhcnNlX2ZyaWVuZGx5XG5cdH07XG59O1xuXG5cbi8vaW4gc2VydmVyX21ldGhvZF9hZGRlZCB3ZSB0cnkgdG8gY3VycnkgdGhlIGZvbGxvd2luZzpcbi8vXHRjb25maWd1cmF0aW9uLCBcInNlcnZlcl9tZXRob2RfYWRkZWRcIiwgZnVuY3Rpb253aGljaHJldHVybnNmaXJzdGFyZ1xuXG4vL0ZpbHRlcnMgYW4gYXJyYXkgb2Ygc2VydmVycyBhbmQgcmV0dXJucyB0aGUgb25lcyB3aGljaCBtYXRjaCB0aGUgdGFyZ2V0IGNyaXRlcmlhXG5mdW5jdGlvbiBmaWx0ZXJfYnlfdGFyZ2V0KHRhcmdldCwgc2VydmVycykge1xuXHQvL0lmIHRoZSB1c2VyIHNwZWNpZmllZCB0YXJnZXQgYXMgc3RyaW5nOlxuXHRpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcblx0XHRpZiAodGFyZ2V0ID09PSAnYWxsJykge1xuXHRcdFx0dGFyZ2V0ID0gc2VydmVycztcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gJ2Jlc3QnKSB7XG5cdFx0XHR0YXJnZXQgPSBzZXJ2ZXJzWzBdICE9PSB1bmRlZmluZWQgPyBbc2VydmVyc1swXV0gOiBbXTsgIC8vSWYgdGhlIHVzZXIgc3BlY2lmaWVkIHRoZSB0YXJnZXQgYXMgc2VydmVyIGZpbHRlclxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuXHRcdFx0dGFyZ2V0ID0gW3RhcmdldF07XG5cdFx0fVxuXHRcdHZhciB1bmV4aXN0aW5nX3NlcnZlcnMgPSBbXTtcblx0XHQvL1JldHJpZXZlIGFsbCBzZXJ2ZXJzIHRoYXQgbWF0Y2ggdGhlIGZpbHRlcnNcblx0XHR0YXJnZXQgPSB0YXJnZXQucmVkdWNlKGZ1bmN0aW9uIChtYXRjaGVzLCBmaWx0ZXIpIHtcblx0XHRcdC8vQWRkIG1hdGNoZXMgZm9yIGVhY2ggZmlsdGVyXG5cdFx0XHR2YXIgbXlfbWF0Y2hlcyA9IHNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcblx0XHRcdFx0cmV0dXJuIGluc3RhbmNlX21hdGNoKGZpbHRlciwgc2VydmVyKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIG1hdGNoZXMuY29uY2F0KG15X21hdGNoZXMpO1xuXHRcdH0sIFtdKTtcblx0fVxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG5cbi8vTWF0Y2hlcyBhIHNlcnZlciBkZWZpbml0aW9uIGFnYWluc3QgYSBzZXJ2ZXIgZmlsdGVyXG5mdW5jdGlvbiBpbnN0YW5jZV9tYXRjaChpbnN0YW5jZV9maWx0ZXIsIGluc3RhbmNlX2RlZmluaXRpb24pIHtcblx0cmV0dXJuIGNvbnRhaW5zX3Byb3BzKGluc3RhbmNlX2ZpbHRlciwgaW5zdGFuY2VfZGVmaW5pdGlvbik7XG59XG5cblxuLy9NYXRjaGVzIGEgbWV0aG9kIGRlZmluaXRpb24gYWdhaW5zdCBhIG1ldGhvZCBmaWx0ZXJcbmZ1bmN0aW9uIG1ldGhvZF9tYXRjaChtZXRob2RfZmlsdGVyLCBtZXRob2RfZGVmaW5pdGlvbikge1xuXHRyZXR1cm4gY29udGFpbnNfcHJvcHMobWV0aG9kX2ZpbHRlciwgbWV0aG9kX2RlZmluaXRpb24pO1xufVxuXG5cbi8vSGVscGVyc1xuXG5mdW5jdGlvbiBjb250YWluc19wcm9wcyhmaWx0ZXIsIG9iamVjdCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMoZmlsdGVyKS5yZWR1Y2UoZnVuY3Rpb24gKG1hdGNoLCBwcm9wKSB7XG5cdFx0aWYgKGZpbHRlcltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSB7XG5cdFx0XHRpZiAoIWZpbHRlcltwcm9wXS50ZXN0KG9iamVjdFtwcm9wXSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKFN0cmluZyhmaWx0ZXJbcHJvcF0pLnRvTG93ZXJDYXNlKCkgIT09IFN0cmluZyhvYmplY3RbcHJvcF0pLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH1cblx0XHR9XG5cdH0sIHRydWUpO1xufVxuXG5cbmZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZCkge1xuXHR2YXIgc3ogPSBhcnJheS5sZW5ndGg7XG5cdGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzejsgaW5kZXgrKykge1xuXHRcdGlmIChwcmVkKGFycmF5W2luZGV4XSkgPT09IHRydWUpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYXJyYXlbaW5kZXhdO1xufVxuXG5cbmZ1bmN0aW9uIGFwcGx5X29uKG9iamVjdHMsIGZ1bmMpIHtcblx0cmV0dXJuIG9iamVjdHMoKS5tYXAoZnVuYyk7XG59XG4iLCIvKlxuIFRoZSBJbnZjYXRpb25zc3RhdGUgbW9kdWxlIGhhbmRsZXMgQUdNIG1ldGhvZCBpbnZvY2F0aW9ucy4gdmlhIHRoZSAnaW52b2tlJyBtZXRob2RcbiBJdCBzZW5kcyBhbmQgcmVjZWl2ZXMgYWxsIGludm9jYXRpb24tcmVsYXRlZCBtZXNzYWdlcywgdmlhIHRoZSBcInByb2Nlc3NfcmVzcG9uc2VcIiBtZXRob2RcbiB0aGF0IGl0IGV4cG9zZXMgYW5kIHZpYSB0aGUgXCJzZW5kX3JlcXVlc3RcIiBjYWxsYmFja1xuXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9hZ21faGVscGVyc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgaW5zdGFuY2UsIHNlbmRfcmVxdWVzdCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvL0hlcmUgd2Ugc3RvcmUgYWxsIHBlbmRpbmcgY2FsbGJhY2tzXG5cdHZhciBwZW5kaW5nX2NhbGxiYWNrcyA9IHt9O1xuXG5cblx0Ly9JbnZva2VzIGFuIEFHTSBtZXRob2QgdG8gYSBzaW5nbGUgQUdNIHNlcnZlciwgZ2l2ZW4gdmFsaWQgaW5wdXQuXG5cdGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZ3VtZW50X29iaiwgdGFyZ2V0LCBzdHVmZiwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHQvL0dlbmVyYXRlIGEgdW5pcXVlIGludm9jYXRpb24gSUQsIGZvciB0aGlzIGludm9jYXRpb25cblx0XHR2YXIgaW52b2NhdGlvbl9pZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKTtcblxuXHRcdC8vUmVnaXN0ZXIgdGhlIHVzZXIncyBjYWxsYmFja3Ncblx0XHRyZWdpc3Rlcl9pbnZvY2F0aW9uKGludm9jYXRpb25faWQsIHtcblx0XHRcdG1ldGhvZDogbWV0aG9kLFxuXHRcdFx0Y2FsbGVkX3dpdGg6IGFyZ3VtZW50X29ialxuXHRcdH0sIHN1Y2Nlc3MsIGVycm9yLCBzdHVmZi5tZXRob2RfcmVzcG9uc2VfdGltZW91dCk7XG5cblx0XHQvL0dldCBhIHJlc3BvbnNlIHN1YmplY3QgZm9yIHRoaXMgaW52b2NhdGlvblxuXHRcdGluc3RhbmNlLnJlc3BvbnNlX3N1YmplY3QobWV0aG9kLCBmdW5jdGlvbiAocmVzcG9uc2Vfc3ViamVjdCkge1xuXG5cdFx0XHQvL0NvbnN0cnVjdCBhIG1lc3NhZ2Vcblx0XHRcdHZhciBtZXNzYWdlID0ge1xuXHRcdFx0XHRNZXRob2RSZXF1ZXN0U3ViamVjdDogdGFyZ2V0LnJlcXVlc3Rfc3ViamVjdCxcblx0XHRcdFx0TWV0aG9kUmVzcG9uc2VTdWJqZWN0OiByZXNwb25zZV9zdWJqZWN0LFxuXHRcdFx0XHRDbGllbnQ6IGluc3RhbmNlLmluZm8oKSxcblx0XHRcdFx0Q29udGV4dDoge1xuXHRcdFx0XHRcdEFyZ3VtZW50c0pzb246IGFyZ3VtZW50X29iaixcblx0XHRcdFx0XHRJbnZvY2F0aW9uSWQ6IGludm9jYXRpb25faWQsXG5cdFx0XHRcdFx0T2JqZWN0VHlwZTogc3R1ZmYub2JqZWN0X3R5cGUsXG5cdFx0XHRcdFx0RGlzcGxheUNvbnRleHQ6IHN0dWZmLmRpc3BsYXlfY29udGV4dCxcblx0XHRcdFx0XHRNZXRob2ROYW1lOiBtZXRob2QubmFtZSxcblx0XHRcdFx0XHRFeGVjdXRpb25TZXJ2ZXI6IHRhcmdldCxcblx0XHRcdFx0XHRUaW1lb3V0OiBzdHVmZi5tZXRob2RfcmVzcG9uc2VfdGltZW91dFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0Ly9TZW5kIGl0XG5cblx0XHRcdHNlbmRfcmVxdWVzdChtZXNzYWdlKTtcblx0XHRcdGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24uZGVidWcgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhcIiVjPj4+IHNlbmRpbmcgTWV0aG9kSW52b2NhdGlvblJlcXVlc3RNZXNzYWdlXCIsIFwiYmFja2dyb3VuZC1jb2xvcjpoc2xhKDE5OCwgNTElLCA3OSUsIDAuNSlcIik7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoXCIlY1wiICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIFwiYmFja2dyb3VuZC1jb2xvcjpoc2xhKDE5OCwgNTElLCA3OSUsIDAuNSlcIik7XG5cdFx0XHR9XG5cblx0XHR9KTtcblx0fVxuXG5cblx0Ly9BZGRzIGNhbGxiYWNrcyBmb3IgYSBnaXZlbiBpbnZvY2F0aW9uIElEXG5cdGZ1bmN0aW9uIHJlZ2lzdGVyX2ludm9jYXRpb24oaW52b2NhdGlvbl9pZCwgcmVzcG9uc2UsIHN1Y2Nlc3MsIGVycm9yLCB0aW1lb3V0KSB7XG5cdFx0Ly9BZGRzIHRoZSBjYWxsYmFja3Ncblx0XHRwZW5kaW5nX2NhbGxiYWNrc1tpbnZvY2F0aW9uX2lkXSA9IHtyZXNwb25zZTogcmVzcG9uc2UsIHN1Y2Nlc3M6IHN1Y2Nlc3MsIGVycm9yOiBlcnJvcn07XG5cdFx0Ly9TY2hlZHVsZXMgdG8gdGhyb3cgYSB0aW1lb3V0IGlmIG5vYm9keSBhbnN3ZXJzXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAocGVuZGluZ19jYWxsYmFja3NbaW52b2NhdGlvbl9pZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlcnJvcih7XG5cdFx0XHRcdG1ldGhvZDogcmVzcG9uc2UubWV0aG9kLCBjYWxsZWRfd2l0aDogcmVzcG9uc2UuYXJndW1lbnRfb2JqLFxuXHRcdFx0XHRtZXNzYWdlOiBcIlRpbWVvdXQgcmVhY2hlZFwiXG5cdFx0XHR9KTtcblx0XHRcdGRlbGV0ZSBwZW5kaW5nX2NhbGxiYWNrc1tpbnZvY2F0aW9uX2lkXTtcblx0XHR9LCB0aW1lb3V0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NfbWV0aG9kX3Jlc3BvbnNlKG1lc3NhZ2UpIHtcblx0XHQvL0ZpbmRzIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja1xuXHRcdHZhciBjYWxsYmFjayA9IHBlbmRpbmdfY2FsbGJhY2tzW21lc3NhZ2UuSW52b2NhdGlvbklkXTtcblx0XHRpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKFwiJWM8PDwgcmVjZWl2aW5nIE1ldGhvZEludm9jYXRpb25SZXN1bHRNZXNzYWdlXCIsIFwiYmFja2dyb3VuZC1jb2xvcjpoc2xhKDExOCwgNTElLCA3OSUsIDAuNSlcIik7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoXCIlY1wiICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIFwiYmFja2dyb3VuZC1jb2xvcjpoc2xhKDExOCwgNTElLCA3OSUsIDAuNSlcIik7XG5cdFx0XHR9XG5cdFx0XHQvL0lmIHRoZSBzZXJ2ZXIgcmV0dXJuZWQgc3VjY2VzcywgZXhlY3V0ZSB0aGUgc3VjY2VzcyBjYWxsYmFja1xuXHRcdFx0aWYgKG1lc3NhZ2UuU3RhdHVzID09PSAwICYmIHR5cGVvZiBjYWxsYmFjay5zdWNjZXNzID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0Ly9wYXJzZSB0aGUgcmVzdWx0XG5cdFx0XHRcdHZhciByZXN1bHQgPSBtZXNzYWdlLlJlc3VsdENvbnRleHRKc29uO1xuXHRcdFx0XHQvL0lmIHRoZSByZXN1bHQgaXMgYW4gZW1wdHkgb2JqZWN0LCB0aGVyZSBpcyBubyByZXN1bHRcblx0XHRcdFx0aWYgKHJlc3VsdCAmJiBPYmplY3Qua2V5cyhyZXN1bHQpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vTG9nIHRoYXQgd2UgcmVjZWl2ZWQgYSByZXN1bHRcblx0XHRcdFx0aWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCc8PDwgIFwiJyArIGNhbGxiYWNrLnJlc3BvbnNlLm1ldGhvZC5uYW1lICsgJ1wiIHdhcyBleGVjdXRlZCBieSAnICsgSlNPTi5zdHJpbmdpZnkoaGVscGVycy5wcmVwcm9jZXNzX3NlcnZlcihtZXNzYWdlLlNlcnZlcikpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL0V4ZWN1dGUgdGhlIHN1Y2Nlc3MgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2suc3VjY2Vzcyh7XG5cdFx0XHRcdFx0bWV0aG9kOiBjYWxsYmFjay5yZXNwb25zZS5tZXRob2QsXG5cdFx0XHRcdFx0Y2FsbGVkX3dpdGg6IGNhbGxiYWNrLnJlc3BvbnNlLmNhbGxlZF93aXRoLFxuXHRcdFx0XHRcdGV4ZWN1dGVkX2J5OiBoZWxwZXJzLnByZXByb2Nlc3Nfc2VydmVyKG1lc3NhZ2UuU2VydmVyKSxcblx0XHRcdFx0XHRyZXR1cm5lZDogcmVzdWx0LFxuXHRcdFx0XHRcdG1lc3NhZ2U6IG1lc3NhZ2UuUmVzdWx0TWVzc2FnZSxcblx0XHRcdFx0XHRsb2dfZGV0YWlsczogbWVzc2FnZS5SZXN1bHRMb2dEZXRhaWxzXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvL0Vsc2UsIHJldHVybiBhbiBlcnJvclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2suZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJzw8PCAgXCInICsgY2FsbGJhY2sucmVzcG9uc2UubWV0aG9kLm5hbWUgKyAnXCIgd2FzIGV4ZWN1dGVkIHdpdGggZXJyb3IgYnkgJyArIEpTT04uc3RyaW5naWZ5KGhlbHBlcnMucHJlcHJvY2Vzc19zZXJ2ZXIobWVzc2FnZS5TZXJ2ZXIpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2suZXJyb3Ioe1xuXHRcdFx0XHRcdG1ldGhvZDogY2FsbGJhY2sucmVzcG9uc2UubWV0aG9kLFxuXHRcdFx0XHRcdGNhbGxlZF93aXRoOiBjYWxsYmFjay5yZXNwb25zZS5jYWxsZWRfd2l0aCxcblx0XHRcdFx0XHRtZXNzYWdlOiBtZXNzYWdlLlJlc3VsdE1lc3NhZ2UsXG5cdFx0XHRcdFx0bG9nX2RldGFpbHM6IG1lc3NhZ2UuUmVzdWx0TG9nRGV0YWlscyxcblx0XHRcdFx0XHRzdGF0dXM6IG1lc3NhZ2Uuc3RhdHVzXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Ly9GaW5hbGx5LCByZW1vdmUgdGhlIGNhbGxiYWNrc1xuXHRcdFx0ZGVsZXRlIHBlbmRpbmdfY2FsbGJhY2tzW21lc3NhZ2UuSW52b2NhdGlvbklkXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge3Byb2Nlc3NfbWV0aG9kX3Jlc3BvbnNlOiBwcm9jZXNzX21ldGhvZF9yZXNwb25zZSwgaW52b2tlOiBpbnZva2V9O1xufTtcbiIsIi8qXG4gVGhlIE1ldGhvZHN0YXRlIG1vZHVsZSwga2VlcHMgdGhlIHN0YXRlIG9mIGF2YWlsYWJsZSBBR00gbWV0aG9kcyBpbiB0aGUgbmV0d29yay5cbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2FnbV9oZWxwZXJzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG5cdC8vQSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgQUdNIG1ldGhvZHNcblx0dmFyIG1ldGhvZHMgPSB7fTtcblxuXHQvL1NhdmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgbWV0cmljIGZ1bmN0aW9uIGlmIGl0IGV4aXN0c1xuXHR2YXIgb2JqZWN0TWV0cmljID0gKGNvbmZpZ3VyYXRpb24ubWV0cmljcyAhPT0gdW5kZWZpbmVkKSA/IGNvbmZpZ3VyYXRpb24ubWV0cmljcy5udW1iZXJNZXRyaWMuYmluZChjb25maWd1cmF0aW9uLm1ldHJpY3MpIDogZnVuY3Rpb24gKCkge1xuXHR9O1xuXG5cdC8vQWRkcyBhIG5ldyBzZXJ2ZXIgdG8gYSBtZXRob2QuIENyZWF0ZXMgdGhlIG1ldGhvZCBpZiBpdCBpcyBub3QgY3JlYXRlZCBwcmV2aW91c2x5LlxuXHRmdW5jdGlvbiBhZGRfc2VydmVyX3RvX21ldGhvZChtZXRob2RfaW5mbywgc2VydmVyX2lkLCBzZXJ2ZXJfaW5mbykge1xuXHRcdC8vR2V0IHRoZSBtZXRob2QgSURcblx0XHR2YXIgbWV0aG9kX2lkID0gZ2V0X21ldGhvZF9pZChtZXRob2RfaW5mbyk7XG5cblxuXHRcdC8vT25lIG1ldGhvZCBjYW4gaGF2ZSBzZXZlcmFsIHJlcXVlc3Qgc3ViamVjdHMgcGVyIHNlcnZlci5cblx0XHQvL1NvIHRoZSByZXF1ZXN0IHN1YmplY3QgaXMgYWN0dWFsbHkgbm90IGEgcHJvcGVydHkgb2YgdGhlIG1ldGhvZFxuXHRcdHZhciByZXF1ZXN0X3N1YmplY3QgPSBtZXRob2RfaW5mby5yZXF1ZXN0X3N1YmplY3Q7XG5cdFx0ZGVsZXRlICBtZXRob2RfaW5mby5yZXF1ZXN0X3N1YmplY3Q7XG5cblxuXHRcdC8vQ29weSB0aGUgbWV0aG9kIGFuZCBzZXJ2ZXIgb2JqZWN0cyB0byBhIGZvcm1hdCBzdWl0YWJsZSBmb3Igc2VuZGluZyB0byB1c2Vyc1xuXHRcdHZhciBtZXRob2RfaW5mb19mcmllbmRseSA9IGhlbHBlcnMuY2xvbmVfb2JqZWN0KG1ldGhvZF9pbmZvKTtcblx0XHR2YXIgc2VydmVyX2luZm9fZnJpZW5kbHkgPSBoZWxwZXJzLmNsb25lX29iamVjdChzZXJ2ZXJfaW5mbyk7XG5cblxuXHRcdHZhciBtZXRob2QgPSBtZXRob2RzW21ldGhvZF9pZF07XG5cblx0XHQvL0lmIHRoZSBtZXRob2QgZG9lcyBub3QgZXhpc3QsIGNyZWF0ZSBpdFxuXHRcdGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly9TYXZlIHRoZSBpbmZvXG5cdFx0XHRtZXRob2QgPSBtZXRob2RzW21ldGhvZF9pZF0gPSB7aW5mbzogbWV0aG9kX2luZm8sIHNlcnZlcnM6IHt9fTtcblx0XHRcdC8vQWRkIHJlcXVlc3Rfc3ViamVjdFxuXHRcdFx0bWV0aG9kID0gYWRkX3JlcXVlc3Rfc3ViamVjdChtZXRob2QsIHNlcnZlcl9pZCwgcmVxdWVzdF9zdWJqZWN0KTtcblxuXHRcdFx0Ly9FeGVjdXRlIHVzZXIgY2FsbGJhY2tzXG5cdFx0XHRoZWxwZXJzLmV4ZWN1dGVfYWxsX3dpdGgoY29uZmlndXJhdGlvbi5tZXRob2RfYWRkZWQsIG1ldGhvZF9pbmZvX2ZyaWVuZGx5KTtcblx0XHRcdC8vTG9nIGFuZCBwdWJsaXNoIG1ldHJpY3Ncblx0XHRcdGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbnNvbGUudGFibGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiPj4+Pj4+IE5ldyBtZXRob2QgZGV0ZWN0ZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkobWV0aG9kX2luZm9fZnJpZW5kbHkpKTtcblx0XHRcdFx0Y29uc29sZS50YWJsZShnZXRfbWV0aG9kcygpKTtcblx0XHRcdH1cblx0XHRcdG9iamVjdE1ldHJpYyhcIk1ldGhvZHMgdG90YWwgY291bnRcIiwgT2JqZWN0LmtleXMobWV0aG9kcykubGVuZ3RoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9FbHNlLCBqdXN0IGFkZCB0aGUgcmVxdWVzdCBzdWJqZWN0XG5cdFx0XHRtZXRob2QgPSBhZGRfcmVxdWVzdF9zdWJqZWN0KG1ldGhvZCwgc2VydmVyX2lkLCByZXF1ZXN0X3N1YmplY3QpO1xuXHRcdH1cblx0XHQvL0V4ZWN1dGUgdXNlciBjYWxsYmFja3Ncblx0XHRoZWxwZXJzLmV4ZWN1dGVfYWxsX3dpdGgoY29uZmlndXJhdGlvbi5zZXJ2ZXJfbWV0aG9kX2FkZGVkLCB7XG5cdFx0XHRtZXRob2Q6IG1ldGhvZF9pbmZvX2ZyaWVuZGx5LFxuXHRcdFx0c2VydmVyOiBzZXJ2ZXJfaW5mb19mcmllbmRseVxuXHRcdH0pO1xuXHR9XG5cblx0Ly9BZGRzIHJlcXVlc3Qgc3ViamVjdCBmb3Igc2VydmVyIGFuZCBtZXRob2Rcblx0ZnVuY3Rpb24gYWRkX3JlcXVlc3Rfc3ViamVjdChtZXRob2QsIHNlcnZlcl9pZCwgcmVxdWVzdF9zdWJqZWN0KSB7XG5cdFx0bWV0aG9kLnNlcnZlcnNbc2VydmVyX2lkXSA9IHJlcXVlc3Rfc3ViamVjdDtcblx0XHRyZXR1cm4gbWV0aG9kO1xuXHR9XG5cblxuXHQvL1JlbW92ZXMgYSBzZXJ2ZXIgZnJvbSBhIG1ldGhvZC4gRGVsZXRlcyB0aGUgbWV0aG9kIGlmIHRoZXJlIGFyZSBubyBtb3JlIHNlcnZlcnMgbGVmdC5cblx0ZnVuY3Rpb24gcmVtb3ZlX3NlcnZlcl9mcm9tX21ldGhvZChtZXRob2RfaWQsIHNlcnZlcl9pZCwgc2VydmVyX2luZm8pIHtcblx0XHQvL09idGFpbiBpbmZvIGFib3V0IHRoZSBtZXRob2QgYmVmb3JlIHJlbW92aW5nIGl0LlxuXHRcdHZhciBtZXRob2RfaW5mb19mcmllbmRseSA9IGdldF9tZXRob2QobWV0aG9kX2lkKTtcblx0XHR2YXIgc2VydmVyX2luZm9fZnJpZW5kbHkgPSBoZWxwZXJzLmNsb25lX29iamVjdChzZXJ2ZXJfaW5mbyk7XG5cblxuXHRcdC8vUmVtb3ZlIHRoZSBzZXJ2ZXIgZnJvbSB0aGUgbGlzdFxuXHRcdHZhciBzZXJ2ZXJzID0gbWV0aG9kc1ttZXRob2RfaWRdLnNlcnZlcnM7XG5cdFx0ZGVsZXRlIHNlcnZlcnNbc2VydmVyX2lkXTtcblx0XHQvL1JlbW92ZSB0aGUgbWV0aG9kIGlmIHRoZXJlIGFyZW4ndCBhbnkgc2VydmVycyBsZWZ0XG5cdFx0aWYgKE9iamVjdC5rZXlzKHNlcnZlcnMpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dmFyIGNhbGxiYWNrID0gY29uZmlndXJhdGlvbi5vbl9tZXRob2RfcmVtb3ZlZDtcblx0XHRcdGhlbHBlcnMuZXhlY3V0ZV9hbGxfd2l0aChjb25maWd1cmF0aW9uLm1ldGhvZF9yZW1vdmVkLCBtZXRob2RfaW5mb19mcmllbmRseSk7XG5cdFx0XHQvL3JlbW92ZSBtZXRob2Rcblx0XHRcdGRlbGV0ZSBtZXRob2RzW21ldGhvZF9pZF07XG5cdFx0XHQvL0xvZyBhbmQgbWV0cmljc1xuXHRcdFx0aWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uc29sZS50YWJsZSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24uZGVidWcgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCI8PDw8PDwgTWV0aG9kIHN0b3BwZWQgYmVpbmcgYXZhaWxhYmxlOiBcIiArIEpTT04uc3RyaW5naWZ5KG1ldGhvZF9pbmZvX2ZyaWVuZGx5KSk7XG5cdFx0XHRcdGNvbnNvbGUudGFibGUoZ2V0X21ldGhvZHMoKSk7XG5cdFx0XHR9XG5cdFx0XHRvYmplY3RNZXRyaWMoXCJNZXRob2RzIHRvdGFsIGNvdW50XCIsIE9iamVjdC5rZXlzKG1ldGhvZHMpLmxlbmd0aCk7XG5cdFx0fVxuXHRcdC8vRXhlY3V0ZSB1c2VyIGNhbGxiYWNrc1xuXHRcdGhlbHBlcnMuZXhlY3V0ZV9hbGxfd2l0aChjb25maWd1cmF0aW9uLnNlcnZlcl9tZXRob2RfcmVtb3ZlZCwge1xuXHRcdFx0bWV0aG9kOiBtZXRob2RfaW5mb19mcmllbmRseSxcblx0XHRcdHNlcnZlcjogc2VydmVyX2luZm9fZnJpZW5kbHlcblx0XHR9KTtcblxuXHR9XG5cblx0Ly9HZW5lcmF0ZXMgYSB1bmlxdWUgaWYgZm9yIGEgbWV0aG9kXG5cdGZ1bmN0aW9uIGdldF9tZXRob2RfaWQobSkge1xuXHRcdC8vU2V0dGluZyBwcm9wZXJpZXMgdG8gZGVmYXVsdHM6XG5cdFx0dmFyIGFjY2VwdHMgPSBtLmFjY2VwdHMgIT09IHVuZGVmaW5lZCA/IG0uYWNjZXB0cyA6IFwiXCI7XG5cdFx0dmFyIHJldHVybnMgPSBtLnJldHVybnMgIT09IHVuZGVmaW5lZCA/IG0ucmV0dXJucyA6IFwiXCI7XG5cdFx0dmFyIHZlcnNpb24gPSBtLnZlcnNpb24gIT09IHVuZGVmaW5lZCA/IG0udmVyc2lvbiA6IDA7XG5cdFx0cmV0dXJuIChtLm5hbWUgKyBhY2NlcHRzICsgcmV0dXJucyArIHZlcnNpb24pLnRvTG93ZXJDYXNlKCk7XG5cdH1cblxuXG5cdC8vUmV0cmlldmUgYWxsIG1ldGhvZHNcblx0ZnVuY3Rpb24gZ2V0X21ldGhvZHMoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKG1ldGhvZHMpLm1hcChmdW5jdGlvbiAobWV0aG9kKSB7XG5cdFx0XHRyZXR1cm4gaGVscGVycy5jbG9uZV9vYmplY3QobWV0aG9kc1ttZXRob2RdLmluZm8pO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly9SZXRyaWV2ZSBhbiBhcnJheSBvZiB0aGUgSUQncyBvZiB0aGUgc2VydmVycyBmb3IgYSBtZXRob2Rcblx0ZnVuY3Rpb24gZ2V0X3NlcnZlcnNfZm9yX21ldGhvZChtZXRob2RfaW5mbykge1xuXHRcdHZhciBtZXRob2QgPSBtZXRob2RzW2dldF9tZXRob2RfaWQobWV0aG9kX2luZm8pXTtcblx0XHRpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBtZXRob2Quc2VydmVycztcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXHR9XG5cblx0Ly9SZXRyaWV2ZXMgYSBjb3B5IG9mIHRoZSBtZXRob2QsIGJ5IGl0cyBJRFxuXHRmdW5jdGlvbiBnZXRfbWV0aG9kKG1ldGhvZF9pZCkge1xuXHRcdGlmICh0eXBlb2YgbWV0aG9kX2lkID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRtZXRob2RfaWQgPSBnZXRfbWV0aG9kX2lkKG1ldGhvZF9pZCk7XG5cdFx0fVxuXHRcdGlmIChtZXRob2RzW21ldGhvZF9pZF0gIT09IHVuZGVmaW5lZClcblx0XHQvL1dlIGNsb25lIHRoZSBtZXRob2QgZGVmaW5pdGlvbiBzbyBpdCBjYW4gYmUgbXV0YXRlZCB3aXRob3V0IGFmZmVjdGluZyB0aGUgb3JpZ2luYWxcblx0XHRcdHJldHVybiBoZWxwZXJzLmNsb25lX29iamVjdChtZXRob2RzW21ldGhvZF9pZF0uaW5mbyk7XG5cdH1cblxuXG5cdHJldHVybiB7XG5cdFx0Z2V0X21ldGhvZHM6IGdldF9tZXRob2RzLFxuXHRcdGdldF9tZXRob2Q6IGdldF9tZXRob2QsXG5cdFx0Z2V0X21ldGhvZF9pZDogZ2V0X21ldGhvZF9pZCxcblx0XHRhZGRfc2VydmVyX3RvX21ldGhvZDogYWRkX3NlcnZlcl90b19tZXRob2QsXG5cdFx0cmVtb3ZlX3NlcnZlcl9mcm9tX21ldGhvZDogcmVtb3ZlX3NlcnZlcl9mcm9tX21ldGhvZCxcblx0XHRnZXRfc2VydmVyc19mb3JfbWV0aG9kOiBnZXRfc2VydmVyc19mb3JfbWV0aG9kXG5cdH07XG5cbn07XG4iLCIvKlxuIFRoZSBTZXJ2ZXJzdGF0ZSBtb2R1bGUgcHJvY2Vzc2VzIHNlcnZlciBwcmVzZW5jZXMgYW5kIGtlZXBzIHRoZSBzdGF0ZSBvZiBhdmFpbGFibGUgQUdNIHNlcnZlcnMgaW4gdGhlIG5ldHdvcmsuXG4gKi9cbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vYWdtX2hlbHBlcnNcIik7XG5cbnZhciBnZXRfc2VydmVyX2lkID0gaGVscGVycy5nZXRfc2VydmVyX2lkO1xuXG52YXIgY2xpZW50X21ldGhvZHN0YXRlID0gcmVxdWlyZShcIi4vYWdtX2NsaWVudF9tZXRob2RzdGF0ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgaW5zdGFuY2UpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly9BIGxpc3Qgb2YgYWxsIHRoZSBzZXJ2ZXJzIGluIHRoZSBuZXR3b3JrXG5cdHZhciBzZXJ2ZXJzID0ge307XG5cblx0Ly9JbnN0YW50aWF0ZXMgdGhlIFwibWV0aG9kc3RhdGVcIiBtb2R1bGVcblx0dmFyIG1ldGhvZHMgPSBjbGllbnRfbWV0aG9kc3RhdGUoY29uZmlndXJhdGlvbik7XG5cblxuXHQvL1Byb2Nlc3NlcyBhIHByZXNlbmNlIG1lc3NhZ2UgZnJvbSBhIHNlcnZlclxuXHRmdW5jdGlvbiBwcm9jZXNzX3ByZXNlbmNlKHByZXNlbmNlLCBpc19wcmVzZW5jZSkge1xuXHRcdC8vY29uc29sZS5sb2cocHJlc2VuY2UuSW5zdGFuY2UpXG5cdFx0Ly9HZXQgc2VydmVyIGluZm8uXG5cdFx0dmFyIHNlcnZlcmluZm8gPSBoZWxwZXJzLnByZXByb2Nlc3Nfc2VydmVyKHByZXNlbmNlLkluc3RhbmNlKTtcblxuXHRcdGlmIChpc19wcmVzZW5jZSkge1xuXHRcdFx0Ly8gSWdub3JlIG1lc3NhZ2VzIGZvciBkZWFkIHNlcnZlcnNcblx0XHRcdC8vIElmIGl0IGlzIGEgbmV3IHNlcnZlciwgcmVnaXN0ZXIgaXQuXG5cdFx0XHRpZiAoIWV4aXN0cyhzZXJ2ZXJpbmZvKSkge1xuXHRcdFx0XHRhZGRfc2VydmVyKHNlcnZlcmluZm8pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJlc2VuY2UuUHVibGlzaGluZ0ludGVydmFsKSB7XG5cdFx0XHRcdHNldF90aW1lb3V0KHNlcnZlcmluZm8sIHByZXNlbmNlLlB1Ymxpc2hpbmdJbnRlcnZhbCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9GaW5hbGx5LCB1cGRhdGUgdGhlIG1ldGhvZHNcblx0XHRpZiAocHJlc2VuY2UuTWV0aG9kRGVmaW5pdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dXBkYXRlX21ldGhvZHMoc2VydmVyaW5mbywgcHJlc2VuY2UuTWV0aG9kRGVmaW5pdGlvbnMpO1xuXHRcdH1cblxuXHR9XG5cblx0Ly9UaGlzIGZ1bmN0aW9uIHNldHMgYSB0aW1lb3V0IHdoaWNoIHJlbW92ZXMgdGhlIHNlcnZlciB1bmxlc3Ncblx0Ly90aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGFnYWluIGJlZm9yZSB0aGUgdGltZW91dCBpcyBvdmVyXG5cdGZ1bmN0aW9uIHNldF90aW1lb3V0KHNlcnZlcmluZm8sIGR1cmF0aW9uKSB7XG5cblx0XHRpZiAoZHVyYXRpb24gPT09IC0xKSByZXR1cm47XG5cdFx0Ly9SZXRyaWV2ZSB0aGUgc2VydmVyXG5cdFx0dmFyIHNlcnZlcl9pZCA9IGdldF9zZXJ2ZXJfaWQoc2VydmVyaW5mbyk7XG5cdFx0dmFyIHNlcnZlciA9IHNlcnZlcnNbc2VydmVyX2lkXTtcblx0XHQvL1N0b3AgdGhlIHByZXZpb3VzIHRpbWVvdXRcblx0XHRpZiAoc2VydmVyLmJvbWIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHNlcnZlci5ib21iKTtcblx0XHR9XG5cdFx0Ly9TZXQgYSBuZXcgb25lXG5cdFx0c2VydmVyLmJvbWIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZV9zZXJ2ZXIoc2VydmVyaW5mbyk7XG5cdFx0fSwgZHVyYXRpb24gKiBjb25maWd1cmF0aW9uLnJlbW92ZV9zZXJ2ZXJfb25fbl9taXNzaW5nX2hlYXJ0YmVhdHMgKyAxKTtcblxuXHR9XG5cblx0Ly9DaGVja3MgaWYgYSBzZXJ2ZXJzIGV4aXN0c1xuXHRmdW5jdGlvbiBleGlzdHMoc2VydmVyaW5mbykge1xuXHRcdHZhciBzZXJ2ZXJfaWQgPSBnZXRfc2VydmVyX2lkKHNlcnZlcmluZm8pO1xuXHRcdHJldHVybiBzZXJ2ZXJzW3NlcnZlcl9pZF0gIT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vUmVnaXN0ZXIgYSBzZXJ2ZXJcblx0ZnVuY3Rpb24gYWRkX3NlcnZlcihzZXJ2ZXJpbmZvKSB7XG5cdFx0Ly9PYnRhaW4gYSBzZXJ2ZXIgSUQgYW5kIHN0b3JlIHRoZSBuZXcgc2VydmVyXG5cdFx0dmFyIHNlcnZlcl9pZCA9IGdldF9zZXJ2ZXJfaWQoc2VydmVyaW5mbyk7XG5cdFx0c2VydmVyc1tzZXJ2ZXJfaWRdID0ge2luZm86IHNlcnZlcmluZm8sIG1ldGhvZHM6IFtdLCBib21iOiB1bmRlZmluZWR9O1xuXG5cdFx0Ly9Mb2cgaW4gY29uc29sZVxuXHRcdGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbnNvbGUudGFibGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIj4+Pj4+PiBOZXcgc2VydmVyIGRldGVjdGVkOiBcIiArIEpTT04uc3RyaW5naWZ5KHNlcnZlcmluZm8pKTtcblx0XHRcdGNvbnNvbGUudGFibGUoZ2V0X3NlcnZlcnMoKSk7XG5cdFx0fVxuXG5cdFx0Ly9FeGVjdXRlIHVzZXIgY2FsbGJhY2tzXG5cdFx0aGVscGVycy5leGVjdXRlX2FsbF93aXRoKGNvbmZpZ3VyYXRpb24uc2VydmVyX2FkZGVkLCBzZXJ2ZXJpbmZvKTtcblxuXHRcdHJldHVybiBzZXJ2ZXJfaWQ7XG5cdH1cblxuXHQvL1VucmVnaXN0ZXJzIGEgc2VydmVyXG5cdGZ1bmN0aW9uIHJlbW92ZV9zZXJ2ZXIoc2VydmVyaW5mbykge1xuXHRcdC8vT2J0YWluIGEgc2VydmVyIElEXG5cdFx0dmFyIHNlcnZlcl9pZCA9IGdldF9zZXJ2ZXJfaWQoc2VydmVyaW5mbyk7XG5cdFx0Ly9SZW1vdmUgdGhlIHNlcnZlcidzIG1ldGhvZHNcblx0XHRzZXJ2ZXJzW3NlcnZlcl9pZF0ubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2RfaWQpIHtcblx0XHRcdG1ldGhvZHMucmVtb3ZlX3NlcnZlcl9mcm9tX21ldGhvZChtZXRob2RfaWQsIHNlcnZlcl9pZCwgc2VydmVyaW5mbyk7XG5cdFx0fSk7XG5cdFx0Ly9SZW1vdmUgdGhlIHNlcnZlciBpdHNlbGZcblx0XHRkZWxldGUgc2VydmVyc1tzZXJ2ZXJfaWRdO1xuXHRcdC8vTG9nIGluIGNvbnNvbGVcblx0XHRpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25zb2xlLnRhYmxlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuXHRcdFx0Y29uc29sZS5sb2coXCI8PDw8PDwgU2VydmVyIHN0b3BwZWQgYmVpbmcgYXZhaWxhYmxlOlwiICsgSlNPTi5zdHJpbmdpZnkoc2VydmVyaW5mbykpO1xuXHRcdFx0Y29uc29sZS50YWJsZShnZXRfc2VydmVycygpKTtcblx0XHR9XG5cblx0XHQvL0V4ZWN1dGUgdXNlciBjYWxsYmFja3Ncblx0XHRoZWxwZXJzLmV4ZWN1dGVfYWxsX3dpdGgoY29uZmlndXJhdGlvbi5zZXJ2ZXJfcmVtb3ZlZCwgc2VydmVyaW5mbyk7XG5cdH1cblxuXHQvL1VwZGF0ZXMgdGhlIG1ldGhvZHMgb2YgYSBzZXJ2ZXJcblx0ZnVuY3Rpb24gdXBkYXRlX21ldGhvZHMoc2VydmVyaW5mbywgbmV3X21ldGhvZHMpIHtcblx0XHR2YXIgc2VydmVyX2lkID0gZ2V0X3NlcnZlcl9pZChzZXJ2ZXJpbmZvKTtcblx0XHQvL0dldCBhbiBhcnJheSBvZiB0aGUgbWV0aG9kcyB0aGUgc2VydmVyIGhhZCBiZWZvcmUgd2Ugc3RhcnRlZCB0aGlzXG5cdFx0dmFyIG9sZF9tZXRob2RzX2lkcyA9IHNlcnZlcnNbc2VydmVyX2lkXS5tZXRob2RzO1xuXHRcdC8vR2V0IGFuIGFycmF5IG9mIHRoZSBtZXRob2RzIHRoYXQgdGhlIHNlcnZlciBoYXMgbm93XG5cdFx0bmV3X21ldGhvZHMgPSBuZXdfbWV0aG9kcy5tYXAoaGVscGVycy5wcmVwcm9jZXNzX21ldGhvZCkucmVkdWNlKGZ1bmN0aW9uIChvYmosIG1ldGhvZCkge1xuXHRcdFx0b2JqW21ldGhvZHMuZ2V0X21ldGhvZF9pZChtZXRob2QpXSA9IG1ldGhvZDtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSwge30pO1xuXHRcdC8vRm9yIGVhY2ggb2YgdGhlIG9sZCBtZXRob2RzXG5cdFx0b2xkX21ldGhvZHNfaWRzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZF9pZCkge1xuXHRcdFx0Ly9DaGVjayBpZiBpdCBpcyBzdGlsbCB0aGVyZVxuXHRcdFx0aWYgKG5ld19tZXRob2RzW21ldGhvZF9pZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvL0lmIGl0IGlzbid0LCByZW1vdmUgaXRcblx0XHRcdFx0bWV0aG9kcy5yZW1vdmVfc2VydmVyX2Zyb21fbWV0aG9kKG1ldGhvZF9pZCwgc2VydmVyX2lkLCBzZXJ2ZXJpbmZvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vSWYgaXQgaXMgdGhlcmUgaW4gYm90aCB0aGUgb2xkIGFycmF5IGFuZCB0aGUgbmV3IG9uZSwgd2UgZG9uJ3QgbmVlZCB0byBhZGQgaXQgYWdhaW5cblx0XHRcdFx0bmV3X21ldGhvZHNbbWV0aG9kX2lkXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHQvL05vdyBhZGQgdGhlIG5ldyBtZXRob2RzXG5cdFx0dmFyIG5ld19tZXRob2RzX2lkcyA9IE9iamVjdC5rZXlzKG5ld19tZXRob2RzKTtcblx0XHRuZXdfbWV0aG9kc19pZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcblx0XHRcdGlmIChuZXdfbWV0aG9kc1tpZF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRtZXRob2RzLmFkZF9zZXJ2ZXJfdG9fbWV0aG9kKG5ld19tZXRob2RzW2lkXSwgc2VydmVyX2lkLCBzZXJ2ZXJpbmZvKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHQvL05vdyBhbGwgd2UgaGF2ZSB0byBkbyBpcyByZXBsYWNlIHRoZSBsaXN0IG9mIG1ldGhvZHMgdGhlIHNlcnZlciBoYXNcblx0XHRzZXJ2ZXJzW3NlcnZlcl9pZF0ubWV0aG9kcyA9IG5ld19tZXRob2RzX2lkcztcblxuXHR9XG5cblx0Ly9HZXQgYWxsIHNlcnZlcnMgZm9yIGEgZ2l2ZW4gbWV0aG9kXG5cdGZ1bmN0aW9uIGdldF9zZXJ2ZXJzKG1ldGhvZCwgaW5jbHVkZV9yZXF1ZXN0X3N1YmplY3QpIHtcblx0XHR2YXIgc2VydmVyX2lkcztcblx0XHQvL0lmIHRoZXJlIGlzbid0IGEgbWV0aG9kIGdldCB0aGUgSUQncyBvZiBhbGwgc2VydmVyc1xuXHRcdGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c2VydmVyX2lkcyA9IE9iamVjdC5rZXlzKHNlcnZlcnMpO1xuXHRcdFx0Ly9FbHNlLCBnZXQgYSBsaXN0IG9mIHRoZSBzZXJ2ZXJzIHRoYXQgaGF2ZSB0aGUgbWV0aG9kXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBpZHNfdG9fcmVxdWVzdF9zdWJqZWN0cyA9IG1ldGhvZHMuZ2V0X3NlcnZlcnNfZm9yX21ldGhvZChtZXRob2QpO1xuXHRcdFx0c2VydmVyX2lkcyA9IE9iamVjdC5rZXlzKGlkc190b19yZXF1ZXN0X3N1YmplY3RzKTtcblx0XHR9XG5cdFx0Ly9Gb3JtYXQgdGhlIGxpc3Rcblx0XHRyZXR1cm4gc2VydmVyX2lkcy5tYXAoZnVuY3Rpb24gKHNlcnZlcl9pZCkge1xuXHRcdFx0dmFyIHNlcnZlciA9IGhlbHBlcnMuY2xvbmVfb2JqZWN0KHNlcnZlcnNbc2VydmVyX2lkXS5pbmZvKTtcblx0XHRcdC8vSW5jbHVkZSB0aGUgcmVxdWVzdCBzdWJqZWN0IGZvciBlYWNoIHNlcnZlciBmb3IgZWFjaCBtZXRob2Q6XG5cdFx0XHRpZiAoaW5jbHVkZV9yZXF1ZXN0X3N1YmplY3QpIHtcblx0XHRcdFx0c2VydmVyLnJlcXVlc3Rfc3ViamVjdCA9IGlkc190b19yZXF1ZXN0X3N1YmplY3RzW3NlcnZlcl9pZF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2VydmVyO1xuXHRcdH0pLnNvcnQoY29tcGFyZV9zZXJ2ZXJzKTtcblx0fVxuXG5cdC8vQSBjb21wYXJlciBmdW5jdGlvbi4gU29ydHMgdGhlIHNlcnZlcnMgYmFzZWQgb24gYXZhaWxhYmlsaXR5XG5cdGZ1bmN0aW9uIGNvbXBhcmVfc2VydmVycyhzZXJ2ZXIxLCBzZXJ2ZXIyKSB7XG5cdFx0dmFyIHMxID0gMDtcblx0XHR2YXIgczIgPSAwO1xuXHRcdC8vKzIgaWYgdGhlIHNlcnZlciBpcyBvbiB0aGUgc2FtZSBtYWNoaW5lXG5cdFx0aWYgKHNlcnZlcjEubWFjaGluZSA9PT0gaW5zdGFuY2UubWFjaGluZSkge1xuXHRcdFx0czEgPSBzMSArIDI7XG5cdFx0fVxuXHRcdGlmIChzZXJ2ZXIyLm1hY2hpbmUgPT09IGluc3RhbmNlLm1hY2hpbmUpIHtcblx0XHRcdHMyID0gczIgKyAyO1xuXHRcdH1cblx0XHQvLysxIGlmIGl0IHJ1bnMgdW5kZXIgdGhlIHNhbWUgdXNlclxuXHRcdGlmIChzZXJ2ZXIxLnVzZXIgPT09IGluc3RhbmNlLnVzZXIpIHtcblx0XHRcdHMxID0gczEgKyAxO1xuXHRcdH1cblx0XHRpZiAoc2VydmVyMi51c2VyID09PSBpbnN0YW5jZS51c2VyKSB7XG5cdFx0XHRzMiA9IHMyICsgMTtcblx0XHR9XG5cdFx0cmV0dXJuIHMyIC0gczE7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRfbWV0aG9kX2lkcyhzZXJ2ZXIpIHtcblx0XHRyZXR1cm4gc2VydmVyc1tnZXRfc2VydmVyX2lkKHNlcnZlcildLm1ldGhvZHM7XG5cdH1cblxuXG5cdC8vR2V0IGFsbCBtZXRob2RzIGZvciBhIGdpdmVuIHNlcnZlclxuXHRmdW5jdGlvbiBnZXRfbWV0aG9kcyhzZXJ2ZXIpIHtcblx0XHQvL0lmIHRoZXJlIGlzIG5vIHNlcnZlciBzcGVjaWZpZWQsIHJldHVybiBhbGxcblx0XHRpZiAoc2VydmVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBtZXRob2RzLmdldF9tZXRob2RzKCk7XG5cdFx0XHQvL0Vsc2UsIGdldCB0aGUgbWV0aG9kcyBmcm9tIHRoZSBzZXJ2ZXIgb2JqZWN0XG5cdFx0fSBlbHNlIGlmIChleGlzdHMoc2VydmVyKSkge1xuXHRcdFx0cmV0dXJuIGdldF9tZXRob2RfaWRzKHNlcnZlcikubWFwKGZ1bmN0aW9uIChtZXRob2RfaWQpIHtcblx0XHRcdFx0cmV0dXJuIG1ldGhvZHMuZ2V0X21ldGhvZChtZXRob2RfaWQpO1xuXHRcdFx0fSk7XG5cdFx0XHQvL0lmIHRoZSBzZXJ2ZXIgaXMgc3BlY2lmaWVkLCBidXQgaXQgZG9lcyBub3QgZXhpc3QsIHJldHVybiBhbiBlbXB0eSBhcnJheVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRwcm9jZXNzX3ByZXNlbmNlOiBwcm9jZXNzX3ByZXNlbmNlLFxuXHRcdGdldF9tZXRob2RzOiBnZXRfbWV0aG9kcyxcblx0XHRnZXRfbWV0aG9kX2lkczogZ2V0X21ldGhvZF9pZHMsXG5cdFx0Z2V0X3NlcnZlcnM6IGdldF9zZXJ2ZXJzLFxuXHRcdGdldF9tZXRob2Q6IG1ldGhvZHMuZ2V0X21ldGhvZCxcblx0XHRleGlzdHM6IGV4aXN0cyxcblx0XHRjb21wYXJlX3NlcnZlcnM6IGNvbXBhcmVfc2VydmVyc1xuXHR9O1xufTtcbiIsIi8qXG4gVGhlIFN1YnNjcmlwdGlvbi1zdGF0ZSBtb2R1bGUgaGFuZGxlcyBBR00gc3RyZWFtIHN1YnNjcmlwdGlvbnMgdmlhIHRoZSAnc3Vic2NyaWJlJyBtZXRob2RcbiBJdCBzZW5kcyBhbmQgcmVjZWl2ZXMgYWxsIGludm9jYXRpb24tcmVsYXRlZCBtZXNzYWdlcywgdmlhIHRoZSBcInByb2Nlc3NfcmVzcG9uc2VcIiBtZXRob2RcbiB0aGF0IGl0IGV4cG9zZXMgYW5kIHZpYSB0aGUgXCJTZW5kUmVxdWVzdFwiIGNhbGxiYWNrXG5cbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2FnbV9oZWxwZXJzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBpbnN0YW5jZSwgU2VuZFJlcXVlc3QpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIFNUQVRVU19BV0FJVElOR19BQ0NFUFQgPSAnYXdhaXRpbmdBY2NlcHQnOyAvLyBub3QgZXZlbiBvbmUgc2VydmVyIGhhcyBhY2NlcHRlZCB5ZXRcblx0dmFyIFNUQVRVU19TVUJTQ1JJQkVEID0gJ3N1YnNjcmliZWQnOyAvLyBhdCBsZWFzdCBvbmUgc2VydmVyIGhhcyByZXNwb25kZWQgYXMgJ0FjY2VwdGluZydcblx0dmFyIEVSUl9NU0dfU1VCX0ZBSUxFRCA9ICdTdWJzY3JpcHRpb24gZmFpbGVkLic7XG5cdHZhciBFUlJfTVNHX1NVQl9SRUpFQ1RFRCA9ICdTdWJzY3JpcHRpb24gcmVqZWN0ZWQuJztcblx0dmFyIE9OX0NMT1NFX01TR19TRVJWRVJfSU5JVCA9ICdTZXJ2ZXJJbml0aWF0ZWQnO1xuXHR2YXIgT05fQ0xPU0VfTVNHX0NMSUVOVF9JTklUID0gJ0NsaWVudEluaXRpYXRlZCc7XG5cblx0dmFyIHN1YnNjcmlwdGlvbnNMaXN0ID0ge307XG5cblx0Ly9QcmVwcyBhbmQgc2VuZHMgYSByZXF1ZXN0IHRvIHN1YnNjcmliZSB0byBhIHNpbmdsZSBBR00gc3RyZWFtIHB1Ymxpc2hlci5cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKHN0cmVhbWluZ01ldGhvZCwgYXJndW1lbnRfb2JqLCB0YXJnZXRTZXJ2ZXJzLCBzdHVmZiwgc3VjY2VzcywgZXJyb3IpIHtcblxuXHRcdGlmKHRhcmdldFNlcnZlcnMubGVuZ3RoID09PSAwKXtcblx0XHRcdGVycm9yKEVSUl9NU0dfU1VCX0ZBSUxFRCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9UaGlzIHNhbWUgSWQgd2lsbCBiZSBwYXNzZWQgdG8gYWxsIHRoZSBzZXJ2ZXJzIChhcyAnSW52b2NhdGlvbklkJylcblx0XHQvLyBzbyB0aGV5IGNhbiByZXNwb25kIGJhY2sgd2l0aCBpdCBkdXJpbmcgdGhlIGluaXRpYWwgaGFuZHNoYWtlXG5cdFx0dmFyIHN1YnNjcmlwdGlvbklkID0gJ3N1YnNjcmlwdGlvbklkXycgKyBoZWxwZXJzLmdlbmVyYXRlUmFuZG9tKCk7XG5cblx0XHQvL1JlZ2lzdGVyIHRoZSB1c2VyJ3MgY2FsbGJhY2tzXG5cdFx0dmFyIHBlbmRpbmdTdWIgPSByZWdpc3RlclN1YnNjcmlwdGlvbihcblx0XHRcdHN1YnNjcmlwdGlvbklkLFxuXHRcdFx0e1xuXHRcdFx0XHRtZXRob2Q6IHN0cmVhbWluZ01ldGhvZCxcblx0XHRcdFx0Y2FsbGVkX3dpdGg6IGFyZ3VtZW50X29ialxuXHRcdFx0fSxcblx0XHRcdHN1Y2Nlc3MsXG5cdFx0XHRlcnJvcixcblx0XHRcdHN0dWZmLm1ldGhvZF9yZXNwb25zZV90aW1lb3V0XG5cdFx0KTtcblxuXHRcdGlmKHR5cGVvZiBwZW5kaW5nU3ViICE9PSAnb2JqZWN0Jyl7XG5cdFx0XHRlcnJvcihFUlJfTVNHX1NVQl9GQUlMRUQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vU2VuZCBhIHN1YnNjcmlwdGlvbiByZXF1ZXN0IHRvIGVhY2ggc2VydmVyXG5cdFx0dGFyZ2V0U2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRhcmdldCl7XG5cblx0XHRcdC8vR2V0IGEgcmVzcG9uc2Ugc3ViamVjdCBmb3IgdGhpcyBpbnZvY2F0aW9uXG5cdFx0XHRpbnN0YW5jZS5yZXNwb25zZV9zdWJqZWN0KHN0cmVhbWluZ01ldGhvZCwgZnVuY3Rpb24gKHJlc3BvbnNlU3ViamVjdCkge1xuXG5cdFx0XHRcdC8vQWRkIHNlcnZlciB0byB0aGUgbGlzdCBvZiBvbmVzIHRoZSBjbGllbnQgaXMgZXhwZWN0aW5nIGEgcmVzcG9uc2UgZnJvbVxuXHRcdFx0XHRwZW5kaW5nU3ViLnRyYWNrZWRTZXJ2ZXJzLnB1c2goe1xuXHRcdFx0XHRcdHNlcnZlcjogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHN0cmVhbUlkOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0c3RyZWFtU3ViamVjdHM6IHtcblx0XHRcdFx0XHRcdGdsb2JhbDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0cHJpdmF0ZTogdW5kZWZpbmVkXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRtZXRob2RSZXF1ZXN0U3ViamVjdDogdGFyZ2V0LnJlcXVlc3Rfc3ViamVjdCxcblx0XHRcdFx0XHRtZXRob2RSZXNwb25zZVN1YmplY3Q6IHJlc3BvbnNlU3ViamVjdFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvL0NvbnN0cnVjdCBhIG1lc3NhZ2Vcblx0XHRcdFx0dmFyIG1lc3NhZ2UgPSB7XG5cdFx0XHRcdFx0RXZlbnRTdHJlYW1BY3Rpb246IDEsIC8vXCJTdWJzY3JpYmVcIiA9IGNsaWVudCB3aXNoZXMgdG8gc3Vic2NyaWJlXG5cdFx0XHRcdFx0TWV0aG9kUmVxdWVzdFN1YmplY3Q6IHRhcmdldC5yZXF1ZXN0X3N1YmplY3QsXG5cdFx0XHRcdFx0TWV0aG9kUmVzcG9uc2VTdWJqZWN0OiByZXNwb25zZVN1YmplY3QsXG5cdFx0XHRcdFx0Q2xpZW50OiBpbnN0YW5jZS5pbmZvKCksXG5cdFx0XHRcdFx0Q29udGV4dDoge1xuXHRcdFx0XHRcdFx0QXJndW1lbnRzSnNvbjogYXJndW1lbnRfb2JqLFxuXHRcdFx0XHRcdFx0SW52b2NhdGlvbklkOiBzdWJzY3JpcHRpb25JZCxcblx0XHRcdFx0XHRcdE9iamVjdFR5cGU6IHN0dWZmLm9iamVjdF90eXBlLFxuXHRcdFx0XHRcdFx0RGlzcGxheUNvbnRleHQ6IHN0dWZmLmRpc3BsYXlfY29udGV4dCxcblx0XHRcdFx0XHRcdE1ldGhvZE5hbWU6IHN0cmVhbWluZ01ldGhvZC5uYW1lLFxuXHRcdFx0XHRcdFx0RXhlY3V0aW9uU2VydmVyOiB0YXJnZXQsXG5cdFx0XHRcdFx0XHRUaW1lb3V0OiBzdHVmZi5tZXRob2RfcmVzcG9uc2VfdGltZW91dFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvL1NlbmQgaXRcblx0XHRcdFx0U2VuZFJlcXVlc3QobWVzc2FnZSk7XG5cblx0XHRcdFx0aWYgKGdsb2JhbC5jb25zb2xlICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5kZWJ1ZyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoXCIlYz4+PiBzZW5kaW5nIE1ldGhvZEludm9jYXRpb25SZXF1ZXN0TWVzc2FnZVwiLCBcImJhY2tncm91bmQtY29sb3I6aHNsYSgxOTgsIDUxJSwgNzklLCAwLjUpXCIpO1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoXCIlY1wiICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIFwiYmFja2dyb3VuZC1jb2xvcjpoc2xhKDE5OCwgNTElLCA3OSUsIDAuNSlcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fSk7XG5cblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVnaXN0ZXJTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uSWQsIHJlc3BvbnNlLCBzdWNjZXNzLCBlcnJvciwgdGltZW91dCl7XG5cblx0XHRzdWJzY3JpcHRpb25zTGlzdFtzdWJzY3JpcHRpb25JZF0gPSB7XG5cdFx0XHRzdGF0dXM6U1RBVFVTX0FXQUlUSU5HX0FDQ0VQVCxcblx0XHRcdHJlc3BvbnNlOiByZXNwb25zZSxcblx0XHRcdHN1Y2Nlc3M6IHN1Y2Nlc3MsXG5cdFx0XHRlcnJvcjogZXJyb3IsXG5cdFx0XHR0cmFja2VkU2VydmVyczogW10sXG5cdFx0XHRoYW5kbGVyczoge1xuXHRcdFx0XHRvbkRhdGE6IFtdLFxuXHRcdFx0XHRvbkNsb3NlZDogW11cblx0XHRcdFx0Ly9vbkZhaWxlZDogW11cblx0XHRcdH0sXG5cdFx0XHRxdWV1ZWQ6IHtcblx0XHRcdFx0ZGF0YTogW10sXG5cdFx0XHRcdGNsb3NlcnM6IFtdXG5cdFx0XHR9LFxuXHRcdFx0dGltZW91dElkOiB1bmRlZmluZWRcblx0XHR9O1xuXG5cblx0XHRzdWJzY3JpcHRpb25zTGlzdFtzdWJzY3JpcHRpb25JZF0udGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoc3Vic2NyaXB0aW9uc0xpc3Rbc3Vic2NyaXB0aW9uSWRdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuOyAvL25vIHN1Y2ggc3Vic2NyaXB0aW9uXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb25zTGlzdFtzdWJzY3JpcHRpb25JZF1cblxuXG5cdFx0XHRpZiAoc3Vic2NyaXB0aW9uLnN0YXR1cyA9PT0gU1RBVFVTX0FXQUlUSU5HX0FDQ0VQVCkge1xuXHRcdFx0XHRlcnJvcih7XG5cdFx0XHRcdFx0bWV0aG9kOiByZXNwb25zZS5tZXRob2QsIGNhbGxlZF93aXRoOiByZXNwb25zZS5jYWxsZWRfd2l0aCxcblx0XHRcdFx0XHRtZXNzYWdlOiBFUlJfTVNHX1NVQl9GQUlMRURcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly9Ob25lIG9mIHRoZSB0YXJnZXQgc2VydmVycyBoYXMgYW5zd2VyZWQgdGhlIHN1YnNjcmlwdGlvbiBhdHRlbXB0XG5cdFx0XHRcdGRlbGV0ZSBzdWJzY3JpcHRpb25zTGlzdFtzdWJzY3JpcHRpb25JZF07XG5cblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdHN1YnNjcmlwdGlvbi5zdGF0dXMgPT09IFNUQVRVU19TVUJTQ1JJQkVEXG5cdFx0XHRcdCYmIHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVycy5sZW5ndGggPiAwXG5cdFx0XHQpe1xuXHRcdFx0XHQvL2NsZWFuIHRoZSB0cmFja2VkU2VydmVyc1xuXHRcdFx0XHRzdWJzY3JpcHRpb24udHJhY2tlZFNlcnZlcnMgPSBzdWJzY3JpcHRpb24udHJhY2tlZFNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uKHNlcnZlcil7XG5cdFx0XHRcdFx0cmV0dXJuICh0eXBlb2Ygc2VydmVyLnN0cmVhbUlkID09PSAnc3RyaW5nJyAmJiBzZXJ2ZXIuc3RyZWFtSWQgIT09ICdzdHJpbmcnKVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzdWJzY3JpcHRpb24udGltZW91dElkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdGlmKHN1YnNjcmlwdGlvbi50cmFja2VkU2VydmVycy5sZW5ndGggPT09IDApe1xuXHRcdFx0XHRcdC8vVGhlcmUgYXJlIG5vIG9wZW4gc3RyZWFtcywgc29tZSBzZXJ2ZXJzIGFjY2VwdGVkIHRoZW4gY2xvc2VkIHZlcnkgcXVpY2tseVxuXHRcdFx0XHRcdC8vXHQodGhhdCdzIHdoeSB0aGUgc3RhdHVzIGNoYW5nZWQgYnV0IHRoZXJlJ3Mgbm8gZ29vZCBzZXJ2ZXIgd2l0aCBhIFN0cmVhbUlkKVxuXG5cdFx0XHRcdFx0Ly9jYWxsIHRoZSBvbkNsb3NlZCBoYW5kbGVyc1xuXHRcdFx0XHRcdHZhciBjbG9zZXJzQ291bnQgPSBzdWJzY3JpcHRpb24ucXVldWVkLmNsb3NlcnMubGVuZ3RoO1xuXHRcdFx0XHRcdHZhciBjbG9zaW5nU2VydmVyID0gKGNsb3NlcnNDb3VudCA+IDApID8gc3Vic2NyaXB0aW9uLnF1ZXVlZC5jbG9zZXJzW2Nsb3NlcnNDb3VudCAtIDFdIDogbnVsbDtcblxuXHRcdFx0XHRcdHN1YnNjcmlwdGlvbi5oYW5kbGVycy5vbkNsb3NlZC5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKXtcblx0XHRcdFx0XHRcdGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyl7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKHtcblx0XHRcdFx0XHRcdFx0XHRtZXNzYWdlOiBPTl9DTE9TRV9NU0dfU0VSVkVSX0lOSVQsXG5cdFx0XHRcdFx0XHRcdFx0cmVxdWVzdEFyZ3VtZW50czogc3Vic2NyaXB0aW9uLnJlc3BvbnNlLmNhbGxlZF93aXRoLFxuXHRcdFx0XHRcdFx0XHRcdHNlcnZlcjogY2xvc2luZ1NlcnZlcixcblx0XHRcdFx0XHRcdFx0XHRzdHJlYW06IHN1YnNjcmlwdGlvbi5yZXNwb25zZS5tZXRob2Rcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGRlbGV0ZSBzdWJzY3JpcHRpb25zTGlzdFtzdWJzY3JpcHRpb25JZF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LCB0aW1lb3V0KTtcblxuXHRcdHJldHVybiBzdWJzY3JpcHRpb25zTGlzdFtzdWJzY3JpcHRpb25JZF1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NQdWJsaXNoZXJNc2cobXNnKXtcblx0XHRpZiggISAobXNnICYmIG1zZy5FdmVudFN0cmVhbUFjdGlvbiAmJiBtc2cuRXZlbnRTdHJlYW1BY3Rpb24gIT09IDApICl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYobXNnLkV2ZW50U3RyZWFtQWN0aW9uID09PSAyKSB7XG5cblx0XHRcdHNlcnZlcklzS2lja2luZ0FTdWJzY3JpYmVyKG1zZyk7XG5cblx0XHR9IGVsc2UgaWYobXNnLkV2ZW50U3RyZWFtQWN0aW9uID09PSAzKSB7XG5cblx0XHRcdHNlcnZlckFja25vd2xlZGdlc0dvb2RTdWJzY3JpcHRpb24obXNnKTtcblxuXHRcdH0gZWxzZSBpZihtc2cuRXZlbnRTdHJlYW1BY3Rpb24gPT09IDUpIHtcblxuXHRcdFx0c2VydmVySGFzUHVzaGVkU29tZURhdGFJbnRvVGhlU3RyZWFtKG1zZyk7XG5cdFx0fVxuXG5cdH1cblxuXHQvKiogbXNnICdSZXNwb25zZScgQWN0aW9ucyAqL1xuXHQvL2FjdGlvbiAyXG5cdGZ1bmN0aW9uIHNlcnZlcklzS2lja2luZ0FTdWJzY3JpYmVyKG1zZyl7XG5cblx0XHQvL05vdGU6IHRoaXMgbWlnaHQgYmUgZWl0aGVyIHRoZSBzZXJ2ZXIgcmVqZWN0aW5nIGEgc3Vic2NyaXB0aW9uIHJlcXVlc3QgT1IgY2xvc2luZyBhbiBleGlzdGluZyBzdWJzY3JpcHRpb25cblxuXHRcdC8vR2V0IEFMTCBzdWJzY3JpcHRpb25zXG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdWJzY3JpcHRpb25zTGlzdCk7XG5cblx0XHQvL0lmIGl0IGlzIGEgcmVqZWN0aW9uIHRoZXJlIG1heSBiZSBhbiBJbnZvY2F0aW9uSWQsIGl0IGNhbiBuYXJyb3cgdGhlIHNlYXJjaFxuXHRcdGlmKHR5cGVvZiBtc2cuSW52b2NhdGlvbklkID09PSAnc3RyaW5nJyAmJiBtc2cuSW52b2NhdGlvbklkICE9PSAnJyl7XG5cdFx0XHRrZXlzID0ga2V5cy5maWx0ZXIoZnVuY3Rpb24oayl7XG5cdFx0XHRcdHJldHVybiBrID09PSBtc2cuSW52b2NhdGlvbklkO1xuXHRcdFx0fSlcblx0XHR9XG5cblx0XHR2YXIgZGVsZXRpb25zTGlzdCA9IFtdO1xuXG5cdFx0Ly9GaW5kIHRoZSBraWNraW5nL3JlamVjdGluZyBzZXJ2ZXIgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBzdWJzY3JpcHRpb24udHJhY2tlZFNlcnZlcnNbXVxuXHRcdGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuXHRcdFx0aWYodHlwZW9mIHN1YnNjcmlwdGlvbnNMaXN0W2tleV0gIT09ICdvYmplY3QnKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRzdWJzY3JpcHRpb25zTGlzdFtrZXldLnRyYWNrZWRTZXJ2ZXJzID0gc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS50cmFja2VkU2VydmVycy5maWx0ZXIoZnVuY3Rpb24oc2VydmVyKXtcblx0XHRcdFx0dmFyIGlzUmVqZWN0aW5nID0gKFxuXHRcdFx0XHRcdHNlcnZlci5tZXRob2RSZXF1ZXN0U3ViamVjdCA9PT0gbXNnLk1ldGhvZFJlcXVlc3RTdWJqZWN0XG5cdFx0XHRcdFx0JiYgc2VydmVyLm1ldGhvZFJlc3BvbnNlU3ViamVjdCA9PT0gbXNnLk1ldGhvZFJlc3BvbnNlU3ViamVjdFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHZhciBpc0tpY2tpbmcgPSAoXG5cdFx0XHRcdFx0c2VydmVyLnN0cmVhbUlkID09PSBtc2cuU3RyZWFtSWRcblx0XHRcdFx0XHQmJiAoXG5cdFx0XHRcdFx0XHRzZXJ2ZXIuc3RyZWFtU3ViamVjdHMuZ2xvYmFsID09PSBtc2cuRXZlbnRTdHJlYW1TdWJqZWN0XG5cdFx0XHRcdFx0XHR8fCBzZXJ2ZXIuc3RyZWFtU3ViamVjdHMucHJpdmF0ZSA9PT0gbXNnLkV2ZW50U3RyZWFtU3ViamVjdFxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblxuXHRcdFx0XHR2YXIgaXNSZWplY3RpbmdPcktpY2tpbmcgPSBpc1JlamVjdGluZyB8fCBpc0tpY2tpbmc7XG5cblx0XHRcdFx0cmV0dXJuICEgaXNSZWplY3RpbmdPcktpY2tpbmc7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYoc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS50cmFja2VkU2VydmVycy5sZW5ndGggPT09IDApe1xuXHRcdFx0XHRkZWxldGlvbnNMaXN0LnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vQ2FsbCBvbkNsb3NlZCBPUiBlcnJvcigpXG5cdFx0Ly8gYW5kIHJlbW92ZSB0aGUgc3Vic2NyaXB0aW9uXG5cdFx0ZGVsZXRpb25zTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG5cdFx0XHRpZih0eXBlb2Ygc3Vic2NyaXB0aW9uc0xpc3Rba2V5XSAhPT0gJ29iamVjdCcpe1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0c3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5zdGF0dXMgPT09IFNUQVRVU19BV0FJVElOR19BQ0NFUFRcblx0XHRcdFx0JiYgdHlwZW9mIHN1YnNjcmlwdGlvbnNMaXN0W2tleV0udGltZW91dElkID09PSAnbnVtYmVyJ1xuXHRcdFx0KXtcblxuXHRcdFx0XHRzdWJzY3JpcHRpb25zTGlzdFtrZXldLmVycm9yKEVSUl9NU0dfU1VCX1JFSkVDVEVEKTtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHN1YnNjcmlwdGlvbnNMaXN0W2tleV0udGltZW91dElkKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvL1RoZSB0aW1lb3V0IG1heSBvciBtYXkgbm90IGhhdmUgZXhwaXJlZCB5ZXQsXG5cdFx0XHRcdC8vIGJ1dCB0aGUgc3RhdHVzIGlzICdzdWJzY3JpYmVkJyBhbmQgdHJhY2tlZFNlcnZlcnMgaXMgbm93IGVtcHR5XG5cblx0XHRcdFx0c3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5oYW5kbGVycy5vbkNsb3NlZC5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKXtcblx0XHRcdFx0XHRpZih0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpe1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soe1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiBPTl9DTE9TRV9NU0dfU0VSVkVSX0lOSVQsXG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RBcmd1bWVudHM6IHN1YnNjcmlwdGlvbnNMaXN0W2tleV0ucmVzcG9uc2UuY2FsbGVkX3dpdGgsXG5cdFx0XHRcdFx0XHRcdHNlcnZlcjogbXNnLlNlcnZlcixcblx0XHRcdFx0XHRcdFx0c3RyZWFtOiBzdWJzY3JpcHRpb25zTGlzdFtrZXldLnJlc3BvbnNlLm1ldGhvZFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0fVxuXG5cdFx0XHRkZWxldGUgc3Vic2NyaXB0aW9uc0xpc3Rba2V5XTtcblxuXHRcdH0pO1xuXHR9XG5cblx0Ly9hY3Rpb24gM1xuXHRmdW5jdGlvbiBzZXJ2ZXJBY2tub3dsZWRnZXNHb29kU3Vic2NyaXB0aW9uKG1zZyl7XG5cblx0XHR2YXIgc3Vic2NyaXB0aW9uSWQgPSBtc2cuSW52b2NhdGlvbklkO1xuXG5cdFx0dmFyIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbnNMaXN0W3N1YnNjcmlwdGlvbklkXTtcblxuXHRcdGlmKHR5cGVvZiBzdWJzY3JpcHRpb24gIT09ICdvYmplY3QnKXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgYWNjZXB0aW5nU2VydmVyID0gc3Vic2NyaXB0aW9uLnRyYWNrZWRTZXJ2ZXJzLmZpbHRlciggZnVuY3Rpb24oc2VydmVyKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRzZXJ2ZXIubWV0aG9kUmVxdWVzdFN1YmplY3QgPT09IG1zZy5NZXRob2RSZXF1ZXN0U3ViamVjdFxuXHRcdFx0XHQmJiBzZXJ2ZXIubWV0aG9kUmVzcG9uc2VTdWJqZWN0ID09PSBtc2cuTWV0aG9kUmVzcG9uc2VTdWJqZWN0XG5cdFx0XHQpXG5cdFx0fSlbMF07XG5cblx0XHRpZih0eXBlb2YgYWNjZXB0aW5nU2VydmVyICE9PSAnb2JqZWN0Jyl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGlzRmlyc3RSZXNwb25zZSA9ICggc3Vic2NyaXB0aW9uLnN0YXR1cyA9PT0gU1RBVFVTX0FXQUlUSU5HX0FDQ0VQVCApO1xuXG5cdFx0c3Vic2NyaXB0aW9uLnN0YXR1cyA9IFNUQVRVU19TVUJTQ1JJQkVEO1xuXG5cdFx0dmFyIHByaXZhdGVTdHJlYW1TdWJqZWN0ID0gZ2VuZXJhdGVQcml2YXRlU3RyZWFtU3ViamVjdChzdWJzY3JpcHRpb24ucmVzcG9uc2UubWV0aG9kLm5hbWUpO1xuXG5cdFx0aWYodHlwZW9mIGFjY2VwdGluZ1NlcnZlci5zdHJlYW1JZCA9PT0gJ3N0cmluZycgJiYgYWNjZXB0aW5nU2VydmVyLnN0cmVhbUlkICE9PSAnJyl7XG5cdFx0XHRyZXR1cm47IC8vYWxyZWFkeSBhY2NlcHRlZCBwcmV2aW91c2x5XG5cdFx0fVxuXG5cdFx0YWNjZXB0aW5nU2VydmVyLnNlcnZlciA9IG1zZy5TZXJ2ZXI7XG5cdFx0YWNjZXB0aW5nU2VydmVyLnN0cmVhbUlkID0gbXNnLlN0cmVhbUlkO1xuXHRcdGFjY2VwdGluZ1NlcnZlci5zdHJlYW1TdWJqZWN0cy5nbG9iYWwgPSBtc2cuRXZlbnRTdHJlYW1TdWJqZWN0O1xuXHRcdGFjY2VwdGluZ1NlcnZlci5zdHJlYW1TdWJqZWN0cy5wcml2YXRlID0gcHJpdmF0ZVN0cmVhbVN1YmplY3Q7XG5cdFx0Ly9hY2NlcHRpbmdTZXJ2ZXIubWV0aG9kUmVzcG9uc2VTdWJqZWN0IHN0YXlzIHRoZSBzYW1lXG5cblx0XHR2YXIgY29uZmlybWF0b3J5UmVxdWVzdCA9IHtcblx0XHRcdEV2ZW50U3RyZWFtQWN0aW9uOiAzLCAvL1wiU3Vic2NyaWJlZFwiID0gY2xpZW50IGNvbmZpcm1zIGludGVudGlvbiB0byBzdWJzY3JpYmVcblx0XHRcdEV2ZW50U3RyZWFtU3ViamVjdDogcHJpdmF0ZVN0cmVhbVN1YmplY3QsXG5cdFx0XHRTdHJlYW1JZDogbXNnLlN0cmVhbUlkLFxuXHRcdFx0TWV0aG9kUmVxdWVzdFN1YmplY3Q6IG1zZy5NZXRob2RSZXF1ZXN0U3ViamVjdCxcblx0XHRcdE1ldGhvZFJlc3BvbnNlU3ViamVjdDogYWNjZXB0aW5nU2VydmVyLm1ldGhvZFJlc3BvbnNlU3ViamVjdCxcblx0XHRcdENsaWVudDogaW5zdGFuY2UuaW5mbygpLFxuXHRcdFx0Q29udGV4dDp7XG5cdFx0XHRcdEFyZ3VtZW50c0pzb246IHN1YnNjcmlwdGlvbi5yZXNwb25zZS5jYWxsZWRfd2l0aCxcblx0XHRcdFx0TWV0aG9kTmFtZTogc3Vic2NyaXB0aW9uLnJlc3BvbnNlLm1ldGhvZC5uYW1lXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFNlbmRSZXF1ZXN0KGNvbmZpcm1hdG9yeVJlcXVlc3QpO1xuXG5cdFx0aWYoaXNGaXJzdFJlc3BvbnNlKXtcblx0XHRcdC8vUGFzcyBpbiB0aGUgc3Vic2NyaXB0aW9uIG9iamVjdFxuXHRcdFx0c3Vic2NyaXB0aW9uLnN1Y2Nlc3Moe1xuXHRcdFx0XHRvbkRhdGE6IGZ1bmN0aW9uKGRhdGFDYWxsYmFjayl7XG5cdFx0XHRcdFx0aWYodHlwZW9mIGRhdGFDYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBkYXRhIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuaGFuZGxlcnMub25EYXRhLnB1c2goZGF0YUNhbGxiYWNrKVxuXHRcdFx0XHRcdGlmKHRoaXMuaGFuZGxlcnMub25EYXRhLmxlbmd0aCA9PT0gMSAmJiB0aGlzLnF1ZXVlZC5kYXRhLmxlbmd0aCA+IDApe1xuXHRcdFx0XHRcdFx0dGhpcy5xdWV1ZWQuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFJdGVtKXtcblx0XHRcdFx0XHRcdFx0ZGF0YUNhbGxiYWNrKGRhdGFJdGVtKVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0uYmluZChzdWJzY3JpcHRpb24pLFxuXHRcdFx0XHRvbkNsb3NlZDogZnVuY3Rpb24oY2xvc2VkQ2FsbGJhY2spe1xuXHRcdFx0XHRcdGlmKHR5cGVvZiBjbG9zZWRDYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKXtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uJylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5oYW5kbGVycy5vbkNsb3NlZC5wdXNoKGNsb3NlZENhbGxiYWNrKVxuXHRcdFx0XHR9LmJpbmQoc3Vic2NyaXB0aW9uKSxcblx0XHRcdFx0b25GYWlsZWQ6ZnVuY3Rpb24oZmFpbGVkQ2FsbGJhY2spe30sXG5cdFx0XHRcdGNsb3NlOiBjbG9zZVN1YnNjcmlwdGlvbi5iaW5kKHN1YnNjcmlwdGlvbiwgc3Vic2NyaXB0aW9uSWQpLFxuXHRcdFx0XHRyZXF1ZXN0QXJndW1lbnRzOiBzdWJzY3JpcHRpb24ucmVzcG9uc2UsXG5cdFx0XHRcdHNlcnZlckluc3RhbmNlOiBtc2cuU2VydmVyLFxuXHRcdFx0XHRzdHJlYW06IHN1YnNjcmlwdGlvbi5yZXNwb25zZS5tZXRob2Rcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8vYWN0aW9uIDVcblx0ZnVuY3Rpb24gc2VydmVySGFzUHVzaGVkU29tZURhdGFJbnRvVGhlU3RyZWFtKG1zZyl7XG5cblx0XHQvL0ZpbmQgdGhlIHN1YnNjcmlwdGlvbiBvZiBpbnRlcmVzdCBieSB0cmF3bGluZyB0aGUgZGljdGlvbmFyeVxuXHRcdGZvcih2YXIga2V5IGluIHN1YnNjcmlwdGlvbnNMaXN0KXtcblx0XHRcdGlmKHN1YnNjcmlwdGlvbnNMaXN0Lmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB0eXBlb2Ygc3Vic2NyaXB0aW9uc0xpc3Rba2V5XSA9PT0gJ29iamVjdCcpe1xuXG5cdFx0XHRcdHZhciBpc1ByaXZhdGVEYXRhID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdHZhciB0cmFja2VkU2VydmVyc0ZvdW5kID0gc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS50cmFja2VkU2VydmVycy5maWx0ZXIoZnVuY3Rpb24obHMpe1xuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRscy5zdHJlYW1JZCA9PT0gbXNnLlN0cmVhbUlkXG5cdFx0XHRcdFx0XHQmJiAoIGxzLnN0cmVhbVN1YmplY3RzLmdsb2JhbCA9PT0gbXNnLkV2ZW50U3RyZWFtU3ViamVjdFxuXHRcdFx0XHRcdFx0XHRcdCB8fCBscy5zdHJlYW1TdWJqZWN0cy5wcml2YXRlID09PSBtc2cuRXZlbnRTdHJlYW1TdWJqZWN0IClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZih0cmFja2VkU2VydmVyc0ZvdW5kLmxlbmd0aCA9PT0gMCl7XG5cdFx0XHRcdFx0aXNQcml2YXRlRGF0YSA9IHVuZGVmaW5lZFxuXHRcdFx0XHR9IGVsc2UgaWYodHJhY2tlZFNlcnZlcnNGb3VuZFswXS5zdHJlYW1TdWJqZWN0cy5nbG9iYWwgPT09IG1zZy5FdmVudFN0cmVhbVN1YmplY3QpIHtcblx0XHRcdFx0XHRpc1ByaXZhdGVEYXRhID0gZmFsc2Vcblx0XHRcdFx0fSBlbHNlIGlmICh0cmFja2VkU2VydmVyc0ZvdW5kWzBdLnN0cmVhbVN1YmplY3RzLnByaXZhdGUgPT09IG1zZy5FdmVudFN0cmVhbVN1YmplY3QpIHtcblx0XHRcdFx0XHRpc1ByaXZhdGVEYXRhID0gdHJ1ZVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoaXNQcml2YXRlRGF0YSAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0XHQvL2NyZWF0ZSB0aGUgYXJyaXZlZERhdGEgb2JqZWN0XG5cdFx0XHRcdFx0dmFyIHJlY2VpdmVkU3RyZWFtRGF0YSA9IHtcblx0XHRcdFx0XHRcdGRhdGE6IG1zZy5SZXN1bHRDb250ZXh0SnNvbixcblx0XHRcdFx0XHRcdHNlcnZlcjptc2cuU2VydmVyLFxuXHRcdFx0XHRcdFx0cmVxdWVzdEFyZ3VtZW50czogc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5yZXNwb25zZS5jYWxsZWRfd2l0aCB8fCAge30sXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBtc2cuUmVzdWx0TWVzc2FnZSxcblx0XHRcdFx0XHRcdHByaXZhdGU6IGlzUHJpdmF0ZURhdGFcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0dmFyIG9uRGF0YUhhbmRsZXJzID0gc3Vic2NyaXB0aW9uc0xpc3Rba2V5XS5oYW5kbGVycy5vbkRhdGE7XG5cdFx0XHRcdFx0dmFyIHF1ZXVlZERhdGEgPSBzdWJzY3JpcHRpb25zTGlzdFtrZXldLnF1ZXVlZC5kYXRhO1xuXG5cdFx0XHRcdFx0aWYoIEFycmF5LmlzQXJyYXkob25EYXRhSGFuZGxlcnMpICl7XG5cdFx0XHRcdFx0XHRpZihvbkRhdGFIYW5kbGVycy5sZW5ndGggPiAwKXtcblx0XHRcdFx0XHRcdFx0b25EYXRhSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjayl7XG5cdFx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpe1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2socmVjZWl2ZWRTdHJlYW1EYXRhKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHF1ZXVlZERhdGEucHVzaChyZWNlaXZlZFN0cmVhbURhdGEpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fS8vZW5kIGZvci1pblxuXHR9XG5cblx0LyoqIChzdWJzY3JpcHRpb24pIE1ldGhvZHMgKi9cblx0ZnVuY3Rpb24gY2xvc2VTdWJzY3JpcHRpb24oc3ViSWQpe1xuXG5cdFx0aW5zdGFuY2UucmVzcG9uc2Vfc3ViamVjdCh7fSwgZnVuY3Rpb24gKHJlc3BvbnNlU3ViamVjdCkge1xuXHRcdFx0dGhpcy50cmFja2VkU2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uKHNlcnZlcil7XG5cdFx0XHRcdFNlbmRSZXF1ZXN0KHtcblx0XHRcdFx0XHRFdmVudFN0cmVhbUFjdGlvbjogMixcblx0XHRcdFx0XHRDbGllbnQ6IGluc3RhbmNlLmluZm8oKSxcblx0XHRcdFx0XHRNZXRob2RSZXF1ZXN0U3ViamVjdDogc2VydmVyLm1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuXHRcdFx0XHRcdE1ldGhvZFJlc3BvbnNlU3ViamVjdDogcmVzcG9uc2VTdWJqZWN0LFxuXHRcdFx0XHRcdFN0cmVhbUlkOiBzZXJ2ZXIuc3RyZWFtSWQsXG5cdFx0XHRcdFx0RXZlbnRTdHJlYW1TdWJqZWN0OiBzZXJ2ZXIuc3RyZWFtU3ViamVjdHMucHJpdmF0ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHR2YXIgc3ViID0gdGhpcztcblxuXHRcdC8vQ2FsbCB0aGUgb25DbG9zZWQgaGFuZGxlcnNcblx0XHR0aGlzLmhhbmRsZXJzLm9uQ2xvc2VkLmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spe1xuXHRcdFx0aWYodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKXtcblx0XHRcdFx0Y2FsbGJhY2soe1xuXHRcdFx0XHRcdG1lc3NhZ2U6IE9OX0NMT1NFX01TR19DTElFTlRfSU5JVCxcblx0XHRcdFx0XHRyZXF1ZXN0QXJndW1lbnRzOiBzdWIucmVzcG9uc2UuY2FsbGVkX3dpdGggfHwge30sXG5cdFx0XHRcdFx0c2VydmVyOiBzdWIudHJhY2tlZFNlcnZlcnNbc3ViLnRyYWNrZWRTZXJ2ZXJzLmxlbmd0aCAtIDFdLnNlcnZlcixcblx0XHRcdFx0XHRzdHJlYW06IHN1Yi5yZXNwb25zZS5tZXRob2Rcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGRlbGV0ZSBzdWJzY3JpcHRpb25zTGlzdFtzdWJJZF07XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZVByaXZhdGVTdHJlYW1TdWJqZWN0KG1ldGhvZE5hbWUpe1xuXG5cdFx0dmFyIGFwcEluZm8gPSBpbnN0YW5jZS5pbmZvKCk7XG5cblx0XHR2YXIgcHJpdmF0ZVN0cmVhbVN1YmplY3QgPSAnRVNTcHJpdi1qc2JfJ1xuXHRcdFx0KyBhcHBJbmZvLkFwcGxpY2F0aW9uTmFtZVxuXHRcdFx0KyAnX29uXycgKyBtZXRob2ROYW1lICsgJ18nXG5cdFx0XHQrIGhlbHBlcnMuZ2VuZXJhdGVSYW5kb20oKTtcblxuXHRcdHJldHVybiBwcml2YXRlU3RyZWFtU3ViamVjdDtcblx0fVxuXG5cdHJldHVybiB7IC8vYW4gaW5zdGFuY2Ugb2YgdGhlIHN1YlN0YXRlXG5cdFx0c3Vic2NyaWJlOiBzdWJzY3JpYmUsXG5cdFx0cHJvY2Vzc1B1Ymxpc2hlck1zZzogcHJvY2Vzc1B1Ymxpc2hlck1zZ1xuXHR9O1xufTtcbiIsIi8vQ29udmVydHMgc2VydmVyIHByb3BlcnRpZXMgZnJvbSBjYW1lbCB0byBzbmFrZSBjYXNlXG5mdW5jdGlvbiBwcmVwcm9jZXNzX3NlcnZlcihtKSB7XG5cdHJldHVybiB7XG5cdFx0bWFjaGluZTogbS5NYWNoaW5lTmFtZSxcblx0XHRwaWQ6IG0uUHJvY2Vzc0lkLFxuXHRcdHN0YXJ0ZWQ6IG0uUHJvY2Vzc1N0YXJ0VGltZSxcblx0XHR1c2VyOiBtLlVzZXJOYW1lLFxuXHRcdGFwcGxpY2F0aW9uOiBtLkFwcGxpY2F0aW9uTmFtZSxcblx0XHRlbnZpcm9ubWVudDogbS5FbnZpcm9ubWVudCxcblx0XHRyZWdpb246IG0uUmVnaW9uLFxuXHRcdHNlcnZpY2VfbmFtZTogbS5TZXJ2aWNlTmFtZSxcblx0XHRtZXRyaWNzX3JlcG9zaXRvcnlfaWQ6IG0uTWV0cmljc1JlcG9zaXRvcnlJZCxcblx0XHRzdGF0ZTogbS5TdGF0ZVxuXHR9O1xufVxuXG5mdW5jdGlvbiBjbG9uZV9vYmplY3QobWV0aG9kKSB7XG5cdHZhciBuZXdfbWV0aG9kID0ge307XG5cdGZvciAodmFyIGkgaW4gbWV0aG9kKSB7XG5cdFx0Ly9SZW1vdmUgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIG9iamVjdCBiZWZvcmUgcGFzc2luZyBpdCB0byB0aGUgdXNlclxuXHRcdGlmIChtZXRob2RbaV0gIT09IHVuZGVmaW5lZCAmJiBtZXRob2RbaV0gIT09IFwiXCIgJiYgbWV0aG9kW2ldICE9PSAwKSB7XG5cdFx0XHRuZXdfbWV0aG9kW2ldID0gbWV0aG9kW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbmV3X21ldGhvZDtcbn1cblxuLy9IZWxwZXI6IHByZXByb2Nlc3NlcyB0aGUgbWV0aG9kIGRlZmluaXRpb25cbmZ1bmN0aW9uIHByZXByb2Nlc3NfbWV0aG9kKG1ldGhvZF9pbmZvKSB7XG5cdHZhciBtZXRob2QgPSBtZXRob2RfaW5mby5NZXRob2Q7XG5cdHJldHVybiB7XG5cdFx0bmFtZTogbWV0aG9kLk5hbWUsXG5cdFx0YWNjZXB0czogbWV0aG9kLklucHV0U2lnbmF0dXJlLFxuXHRcdHJldHVybnM6IG1ldGhvZC5SZXN1bHRTaWduYXR1cmUsXG5cdFx0cmVxdWVzdF9zdWJqZWN0OiBtZXRob2RfaW5mby5NZXRob2RSZXF1ZXN0U3ViamVjdCxcblx0XHRkZXNjcmlwdGlvbjogbWV0aG9kLkRlc2NyaXB0aW9uLFxuXHRcdGRpc3BsYXlfbmFtZTogbWV0aG9kLkRpc3BsYXlOYW1lLFxuXHRcdHZlcnNpb246IG1ldGhvZC5WZXJzaW9uLFxuXHRcdG9iamVjdF90eXBlczogbWV0aG9kLk9iamVjdFR5cGVSZXN0cmljdGlvbnNcblx0fTtcbn1cblxuXG5mdW5jdGlvbiBzYXZlX2NhbGxiYWNrX2luKGNhbGxiYWNrX29iaiwgZXZlbnQsIG9uX2NhbGxiYWNrX2FkZCwgY2FsbGJhY2spIHtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrX29ialtldmVudF0gPSBjYWxsYmFja19vYmpbZXZlbnRdIHx8IFtdO1xuXHRcdGNhbGxiYWNrX29ialtldmVudF0ucHVzaChjYWxsYmFjayk7XG5cdFx0b25fY2FsbGJhY2tfYWRkKGNhbGxiYWNrKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyAnXCInICsgZXZlbnQgKyAnXCIgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50Jztcblx0fVxufVxuXG5mdW5jdGlvbiBleGVjdXRlX2FsbF93aXRoKGNhbGxiYWNrcywgaW5wdXQpIHtcblx0aWYgKHR5cGVvZiBjYWxsYmFja3MgPT09IFwib2JqZWN0XCIpIHtcblx0XHRjYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrKGlucHV0KTtcblx0XHR9KTtcblx0fVxufVxuXG4vL0dlbmVyYXRlcyBhIHVuaXF1ZSBJRCBmb3IgYSBzZXJ2ZXJcbmZ1bmN0aW9uIGdldF9zZXJ2ZXJfaWQoc2VydmVyaW5mbykge1xuXHRpZiAoc2VydmVyaW5mbyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXHQvL1RoZSBtYXRjaGluZyBpcyBjYXNlLWluc2Vuc2l0aXZlXG5cdHJldHVybiAoc2VydmVyaW5mby5hcHBsaWNhdGlvbiArIHNlcnZlcmluZm8udXNlciArIHNlcnZlcmluZm8uc3RhcnRlZCArIHNlcnZlcmluZm8ucGlkKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBwcm9taXNpZnkocHJvbWlzZSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG5cdGlmICh0eXBlb2Ygc3VjY2Vzc0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlcnJvckNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH1cblxuXHRpZiAodHlwZW9mIHN1Y2Nlc3NDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0XHRpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBhZ20uZGVidWcgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJTdWNjZXNzIVwiKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBlcnJvckNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0ZXJyb3JDYWxsYmFjayA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0XHRpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBhZ20uZGVidWcgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJBbiBlcnJvciBvY2N1cnJlZC5cIik7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbSgpe1xuXHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMDApO1xufVxuXG5mdW5jdGlvbiBpc0p1c3RQbGFpblVzZXJPYmplY3QoaW5wdXQpe1xuXG5cdGlmKHR5cGVvZiBpbnB1dCAhPT0gJ29iamVjdCcgfHwgaW5wdXQgPT09IG51bGwpe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgcHJvdG87XG5cblx0aWYgKCB0eXBlb2YgT2JqZWN0LmdldFByb3RvdHlwZU9mICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdGlmICggdHlwZW9mICd0ZXN0Jy5fX3Byb3RvX18gPT09ICdvYmplY3QnICkge1xuXHRcdFx0cHJvdG8gPSBpbnB1dC5fX3Byb3RvX187XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKGlucHV0LmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBNYXkgZmFpbCBpZiB0aGUgY29uc3RydWN0b3Igd2FzIG11dGF0ZWRcblx0XHRcdHByb3RvID0gaW5wdXQuY29uc3RydWN0b3IucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnB1dCk7XG5cdH1cblxuXHRpZihwcm90byA9PT0gbnVsbCB8fCBwcm90byA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR2YXIgY29uc1RvciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cblx0cmV0dXJuIChcblx0XHR0eXBlb2YgY29uc1RvciA9PSAnZnVuY3Rpb24nXG5cdFx0JiYgY29uc1RvciBpbnN0YW5jZW9mIGNvbnNUb3IgLy9jaGVja3MgaWYgYXQgdGhlIGVuZCBvZiB0aGUgcHJvdG90eXBlIGNoYWluXG5cdFx0JiYgZnVuY1RvU3RyaW5nLmNhbGwoY29uc1RvcikgPT09IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCkgLy9jaGVja3MgaWYgdGhlIE9iamVjdCBjb25zdHJ1Y3RvciBpcyB0aGVyZVxuXHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Z2V0X3NlcnZlcl9pZDogZ2V0X3NlcnZlcl9pZCxcblx0ZXhlY3V0ZV9hbGxfd2l0aDogZXhlY3V0ZV9hbGxfd2l0aCxcblx0c2F2ZV9jYWxsYmFja19pbjogc2F2ZV9jYWxsYmFja19pbixcblx0cHJlcHJvY2Vzc19zZXJ2ZXI6IHByZXByb2Nlc3Nfc2VydmVyLFxuXHRwcmVwcm9jZXNzX21ldGhvZDogcHJlcHJvY2Vzc19tZXRob2QsXG5cdGNsb25lX29iamVjdDogY2xvbmVfb2JqZWN0LFxuXHRwcm9taXNpZnk6IHByb21pc2lmeSxcblx0Z2VuZXJhdGVSYW5kb206IGdlbmVyYXRlUmFuZG9tLFxuXHRpc0p1c3RQbGFpblVzZXJPYmplY3Q6IGlzSnVzdFBsYWluVXNlck9iamVjdFxufTtcbiIsIi8qXG4gVGhlIEFHTSBpbnN0YW5jZSBjb2xsZWN0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbWFjaGluZSB3ZSBhcmUgaW4sIFxuIGFuZCBpbnRlcmFjdHMgd2l0aCB0aGUgLk5FVCBnYXRld2F5IGluIG90aGVyIHdheXMsIFxuIHRvIGRlbGl2ZXIgZnVsbCBBR00gY29tcGF0aWJpbGl0eSB0byBBR00uSlMuXG5cbiBUbyBkbyBzbywgaXQgcmVsaWVzIG9uIHRoZSBkZWZhdWx0IEFHTSBjbGllbnQuXG4gKi9cblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50IHx8IGdsb2JhbC5wcm9jZXNzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjLCBjb25uZWN0aW9uKSB7XG5cdHZhciBpbnN0YW5jZSA9IHt9O1xuXHQvL0dlbmVyYXRlIGRlZmF1bHQgaW5zdGFuY2UgcHJvcGVydGllc1xuXHRpbnN0YW5jZS5BcHBsaWNhdGlvbk5hbWUgPSBkb2N1bWVudC50aXRsZSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDApO1xuXHRpbnN0YW5jZS5Qcm9jZXNzSWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwKTtcblx0aW5zdGFuY2UuUHJvY2Vzc1N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG5cdC8vQXBwbHkgdXNlci1zdWJtaXR0ZWQgaW5zdGFuY2UgcHJvcGVydGllcyBcblx0aWYgKHR5cGVvZiBjID09PSBcIm9iamVjdFwiKSB7XG5cdFx0aWYgKGMuYXBwbGljYXRpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aW5zdGFuY2UuQXBwbGljYXRpb25OYW1lID0gYy5hcHBsaWNhdGlvbjtcblx0XHR9XG5cdFx0aW5zdGFuY2UuTWFjaGluZU5hbWUgPSBjLm1hY2hpbmU7XG5cdFx0aW5zdGFuY2UuVXNlck5hbWUgPSBjLnVzZXI7XG5cdFx0aW5zdGFuY2UuRW52aXJvbm1lbnQgPSBjLmVudmlyb25tZW50O1xuXHRcdGluc3RhbmNlLlJlZ2lvbiA9IGMucmVnaW9uO1xuXHRcdGluc3RhbmNlLlNlcnZpY2VOYW1lID0gYy5zZXJ2aWNlX25hbWU7XG5cdFx0aW5zdGFuY2UuTWV0cmljc1JlcG9zaXRvcnlJZCA9IGMubWV0cmljc19yZXBvc2l0b3J5X2lkO1xuXHRcdGluc3RhbmNlLlN0YXRlID0gMTtcblx0fVxuXHR2YXIgaWRlbnRpdHlfdXBkYXRlZCA9IGZhbHNlO1xuXHRjb25uZWN0aW9uLm9uKFwiSW5zdGFuY2VcIiwgZnVuY3Rpb24gKGkpIHtcblx0XHRpZiAoaWRlbnRpdHlfdXBkYXRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFuY2UuTWFjaGluZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aW5zdGFuY2UuTWFjaGluZU5hbWUgPSBpLk1hY2hpbmVOYW1lO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFuY2UuVXNlck5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aW5zdGFuY2UuVXNlck5hbWUgPSBpLlVzZXJOYW1lO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFuY2UuRW52aXJvbm1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aW5zdGFuY2UuRW52aXJvbm1lbnQgPSBpLkVudmlyb25tZW50O1xuXHRcdH1cblx0XHRpZiAoaW5zdGFuY2UuUmVnaW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGluc3RhbmNlLlJlZ2lvbiA9IGkuUmVnaW9uO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFuY2UuU2VydmljZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aW5zdGFuY2UuU2VydmljZU5hbWUgPSBpLlNlcnZpY2VOYW1lO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFuY2UuTWV0cmljc1JlcG9zaXRvcnlJZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpbnN0YW5jZS5NZXRyaWNzUmVwb3NpdG9yeUlkID0gaS5NZXRyaWNzUmVwb3NpdG9yeUlkO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFuY2UuU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aW5zdGFuY2UuU3RhdGUgPSBpLlN0YXRlO1xuXHRcdH1cblx0XHRpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBnbG9iYWwuY29uc29sZS50YWJsZSAhPT0gdW5kZWZpbmVkICYmIGFnbS5kZWJ1ZyA9PT0gdHJ1ZSkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJSZWNlaXZlZCBpbnN0YW5jZSB3aXRoIGluZm8gZnJvbSBHYXRld2F5LlwiKTtcblx0XHR9XG5cdFx0aWRlbnRpdHlfdXBkYXRlZCA9IHRydWU7XG5cdH0pO1xuXHQvL0NyZWF0ZSBhIG1ldGhvZCBmb3IgYWNjZXNzaW5nIGEgcHJvcGVydHlcblx0ZnVuY3Rpb24gY3JlYXRlX2dldHRlcihwcm9wZXJ0eSkge1xuXHRcdHJldHVybiBpbnN0YW5jZVtwcm9wZXJ0eV07XG5cdH1cblxuXHQvL0dlbmVyYXRlcyBhIHJlcXVlc3Qgc3ViamVjdCBmb3IgYSBtZXRob2Rcblx0Ly9EZWxlZ2F0ZXMgaXQgdG8gdGhlIC5ORVQgZ2F0ZXdheSBpZiBpdCBpcyBvbmxpbmUsIFxuXHQvL3RvIGNyZWF0ZSBzdWJqZWN0cyB3aGljaCBhcmUgdmFsaWQgaW4gdGhlIHNjb3BlIG9mIHRoZSB0cmFuc3BvcnQgdGhhdCBpcyBiZWluZyB1c2VkLlxuXHR2YXIgcmVxX3N1YmplY3QgPSAwO1xuXG5cdGZ1bmN0aW9uIHJlcXVlc3Rfc3ViamVjdChtZXRob2RfaWRlbnRpZmllciwgY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjayhcInJlcVwiICsgKHJlcV9zdWJqZWN0KyspICsgaW5zdGFuY2UuUHJvY2Vzc0lkKTtcblx0fVxuXG5cdC8vR2VuZXJhdGVzIGEgcmVzcG9uc2Ugc3ViamVjdCBzdWJqZWN0IGZvciBhIG1ldGhvZCBpbnZvY2F0aW9uXG5cdC8vRGVsZWdhdGVzIGl0IHRvIHRoZSAuTkVUIGdhdGV3YXkgaWYgaXQgaXMgb25saW5lLCBcblx0Ly90byBjcmVhdGUgc3ViamVjdHMgd2hpY2ggYXJlIHZhbGlkIGluIHRoZSBzY29wZSBvZiB0aGUgdHJhbnNwb3J0IHRoYXQgaXMgYmVpbmcgdXNlZC5cblx0dmFyIHJlc3Bfc3ViamVjdCA9IDA7XG5cblx0ZnVuY3Rpb24gcmVzcG9uc2Vfc3ViamVjdChtZXRob2RfaWRlbnRpZmllciwgY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjayhcInJlc3BcIiArIChyZXNwX3N1YmplY3QrKykgKyBpbnN0YW5jZS5Qcm9jZXNzSWQpO1xuXHR9XG5cblx0Ly9SZXR1cm5zIGFsbCBpbnN0YW5jZSBwcm9wZXJ0aWVzXG5cdGZ1bmN0aW9uIGluZm8oKSB7XG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRyZXF1ZXN0X3N1YmplY3Q6IHJlcXVlc3Rfc3ViamVjdCxcblx0XHRyZXNwb25zZV9zdWJqZWN0OiByZXNwb25zZV9zdWJqZWN0LFxuXHRcdGluZm86IGluZm8sXG5cdFx0YXBwbGljYXRpb246IGNyZWF0ZV9nZXR0ZXIoXCJBcHBsaWNhdGlvbk5hbWVcIiksXG5cdFx0cGlkOiBjcmVhdGVfZ2V0dGVyKFwiUHJvY2Vzc0lkXCIpLFxuXHRcdHVzZXI6IGNyZWF0ZV9nZXR0ZXIoXCJVc2VyTmFtZVwiKSxcblx0XHRtYWNoaW5lOiBjcmVhdGVfZ2V0dGVyKFwiTWFjaGluZU5hbWVcIilcblxuXHR9O1xuXG59O1xuIiwidmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG52YXIgaCA9IHJlcXVpcmUoXCIuL2FnbV9oZWxwZXJzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG5cdGZ1bmN0aW9uIHN0cmluZ1RvT2JqZWN0KHBhcmFtLCBzdHJpbmdQcm9wTmFtZSkge1xuXHRcdGlmICh0eXBlb2YgcGFyYW0gPT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBvYmogPSB7fTtcblx0XHRcdG9ialtzdHJpbmdQcm9wTmFtZV0gPSBwYXJhbTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcmFtO1xuXHR9XG5cblx0Ly8gaGVscGVyIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGRhdGVzIHByb3Blcmx5XG5cdGZ1bmN0aW9uIGFnbVBhcnNlKHN0cikge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKHN0ciwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHRcdGlmICh0eXBlb2YgdiAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByZS1zZWVkIC0gdGhpcyBzaG91bGQgYmUgYSBiaXQgZmFzdGVyIHRoYW4gaW5kZXhPZlxuXHRcdFx0aWYgKHZbMF0gIT09IGRhdGVUaW1lSWRlbnRpZmllclswXSkge1xuXHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHYuaW5kZXhPZihkYXRlVGltZUlkZW50aWZpZXIpICE9PSAwKSB7XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdW5peFRpbWVzdGFtcE1zID0gdi5zdWJzdHIobGVuT2ZJZGVudGl0aWZpZXIpO1xuXHRcdFx0cmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodW5peFRpbWVzdGFtcE1zKSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSB0YXJnZXQgYXJndW1lbnQgdG8gb2JqZWN0IHJlYWR5IHRvIGJlIHBhc3NlZCB0byBBZ20gZmFjYWRlXG5cdCAqIEBwYXJhbSB0YXJnZXRcblx0ICovXG5cdGZ1bmN0aW9uIHRhcmdldEFyZ1RvT2JqZWN0KHRhcmdldCkge1xuXG5cdFx0dGFyZ2V0ID0gdGFyZ2V0IHx8ICdiZXN0JztcblxuXHRcdGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRpZiAodGFyZ2V0ICE9PSBcImFsbFwiICYmIHRhcmdldCAhPT0gXCJiZXN0XCIpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdcIicgKyB0YXJnZXQgKyAnXCIgaXMgbm90IGEgdmFsaWQgdGFyZ2V0LiBWYWxpZCB0YXJnZXRzIGFyZSBcImFsbFwiIGFuZCBcImJlc3RcIi4nKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7dGFyZ2V0OiB0YXJnZXR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuXHRcdFx0XHR0YXJnZXQgPSBbdGFyZ2V0XTtcblx0XHRcdH1cblxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRyZXR1cm4gY29udmVydEluc3RhbmNlVG9SZWdleChlKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4ge3NlcnZlckZpbHRlcjogdGFyZ2V0fTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjb252ZXJ0SW5zdGFuY2VUb1JlZ2V4KGluc3RhbmNlKSB7XG5cdFx0dmFyIGluc3RhbmNlX2NvbnZlcnRlZCA9IHt9O1xuXG5cdFx0T2JqZWN0LmtleXMoaW5zdGFuY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0dmFyIHByb3BWYWx1ZSA9IGluc3RhbmNlW2tleV07XG5cdFx0XHRpbnN0YW5jZV9jb252ZXJ0ZWRba2V5XSA9IHByb3BWYWx1ZTtcblxuXHRcdFx0aWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Ly8gZG8gZXhhY3QgbWF0Y2hpbmcgaWYgdXNlciBwYXNzZWQgYSBzdHJpbmdcblx0XHRcdFx0aW5zdGFuY2VfY29udmVydGVkW2tleV0gPSBcIl5cIiArIGluc3RhbmNlW2tleV0gKyBcIiRcIjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGluc3RhbmNlW2tleV0uY29uc3RydWN0b3IgPT09IFJlZ0V4cCkge1xuXHRcdFx0XHRpbnN0YW5jZV9jb252ZXJ0ZWRba2V5XSA9IGluc3RhbmNlW2tleV0uc291cmNlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGluc3RhbmNlX2NvbnZlcnRlZFtrZXldID0gaW5zdGFuY2Vba2V5XTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gaW5zdGFuY2VfY29udmVydGVkO1xuXHR9XG5cblx0dmFyIHJlc3VsdCA9IHtcblxuXHRcdC8vIFJlZ2lzdGVycyBhIEphdmFTY3JpcHQgZnVuY3Rpb24gYXMgYW4gQUdNIG1ldGhvZCwgdGh1cyBtYWtpbmcgaXQgYXZhaWxhYmxlIG90aGVyIEFHTSBpbnN0YW5jZXMgb24gdGhlIHNhbWUgdHJhbnNwb3J0LlxuXHRcdHJlZ2lzdGVyOiBmdW5jdGlvbiAobWV0aG9kSW5mbywgY2FsbGJhY2spIHtcblxuXHRcdFx0dmFyIHB2ID0gdGhpcy5hZ21GYWNhZGUucHJvdG9jb2xWZXJzaW9uO1xuXG5cdFx0XHRpZiAocHYgJiYgcHYgPj0gMykge1xuXHRcdFx0XHQvLyBmb3IgbmV3ZXIgSEMgdXNlIHRoZSB2ZXJzaW9uIHdoZXJlIHdlIGRvbid0IHBhc3MgYXJndW1lbnRzIGFzIEpTT04gKGJlY2F1c2Ugb2YgZGlmZmVyZW50IGlzc3Vlcylcblx0XHRcdFx0dGhpcy5hZ21GYWNhZGUucmVnaXN0ZXIoSlNPTi5zdHJpbmdpZnkoc3RyaW5nVG9PYmplY3QobWV0aG9kSW5mbywgXCJuYW1lXCIpKSxcblx0XHRcdFx0XHRjYWxsYmFjayxcblx0XHRcdFx0XHR0cnVlKTsgLy8gcmV0dXJuIGFzIG9iamVjdHNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYWdtRmFjYWRlLnJlZ2lzdGVyKEpTT04uc3RyaW5naWZ5KHN0cmluZ1RvT2JqZWN0KG1ldGhvZEluZm8sIFwibmFtZVwiKSksXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKGFyZykge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3VsdCA9IGNhbGxiYWNrKEpTT04ucGFyc2UoYXJnKSwgYXJndW1lbnRzWzFdKTtcblx0XHRcdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRyZWdpc3RlckFzeW5jOiBmdW5jdGlvbiAobWV0aG9kSW5mbywgY2FsbGJhY2spIHtcblx0XHRcdGlmICghdGhpcy5hZ21GYWNhZGUucmVnaXN0ZXJBc3luYykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0ZWQgaW4gdGhhdCB2ZXJzaW9uIG9mIEh0bWxDb250YWluZXInKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hZ21GYWNhZGUucmVnaXN0ZXJBc3luYyhzdHJpbmdUb09iamVjdChtZXRob2RJbmZvLCAnbmFtZScpLFxuXHRcdFx0XHRmdW5jdGlvbihhcmdzLCBpbnN0YW5jZSwgdHJhY2tlcikge1xuXHRcdFx0XHRcdC8vIGV4ZWN1dGUgdGhlIHVzZXIgY2FsbGJhY2tcblx0XHRcdFx0XHRjYWxsYmFjayhhcmdzLFxuXHRcdFx0XHRcdFx0aW5zdGFuY2UsXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiAoc3VjY2Vzc0FyZ3MpIHtcblx0XHRcdFx0XHRcdFx0dHJhY2tlci5zdWNjZXNzKHN1Y2Nlc3NBcmdzKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0dHJhY2tlci5lcnJvcihlcnJvcilcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0dW5yZWdpc3RlcjogZnVuY3Rpb24gKG1ldGhvZEZpbHRlcikge1xuXHRcdFx0dGhpcy5hZ21GYWNhZGUudW5yZWdpc3RlcihKU09OLnN0cmluZ2lmeShzdHJpbmdUb09iamVjdChtZXRob2RGaWx0ZXIsIFwibmFtZVwiKSkpO1xuXHRcdH0sXG5cblx0XHQvLyBJbnZva2VzIGFuIEFHTSBtZXRob2QgYXN5bmNocm9ub3VzbHkuXG5cdFx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kRmlsdGVyLCBhcmdzLCB0YXJnZXQsIG9wdGlvbnMsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuXG5cdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuXHRcdFx0XHRpZiAoIWFyZ3MpIHtcblx0XHRcdFx0XHRhcmdzID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodHlwZW9mIGFyZ3MgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0cmVqZWN0KHttZXNzYWdlOiAnVGhlIG1ldGhvZCBhcmd1bWVudHMgbXVzdCBiZSBhbiBvYmplY3QuJ30pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFvcHRpb25zKSB7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0QXJnVG9PYmplY3QodGFyZ2V0KTtcblxuXHRcdFx0XHRpZiAodGhpcy5hZ21GYWNhZGUuaW52b2tlMikge1xuXHRcdFx0XHRcdC8vIGludm9rZSB2ZXIyIC0gZG8gbm90IHN0cmluZ2lmeSBhcmd1bWVudHMgYW5kIHJlc3VsdCB2YWx1ZXNcblx0XHRcdFx0XHR0aGlzLmFnbUZhY2FkZS5pbnZva2UyKFxuXHRcdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkoc3RyaW5nVG9PYmplY3QobWV0aG9kRmlsdGVyLCBcIm5hbWVcIikpLFxuXHRcdFx0XHRcdFx0YXJncyxcblx0XHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KHRhcmdldCksXG5cdFx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeShvcHRpb25zKSxcblx0XHRcdFx0XHRcdGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoYXJncylcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdChlcnIpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgc3VjY2Vzc1Byb3h5LCBlcnJvclByb3h5O1xuXG5cdFx0XHRcdFx0c3VjY2Vzc1Byb3h5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRcdFx0XHRcdHZhciBwYXJzZWQgPSBKU09OLnBhcnNlKGFyZ3MpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShwYXJzZWQpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZXJyb3JQcm94eSA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0XHRcdFx0XHR2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShhcmdzKTtcblx0XHRcdFx0XHRcdHJlamVjdChwYXJzZWQpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dGhpcy5hZ21GYWNhZGUuaW52b2tlKFxuXHRcdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkoc3RyaW5nVG9PYmplY3QobWV0aG9kRmlsdGVyLCBcIm5hbWVcIikpLFxuXHRcdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkoYXJncyksXG5cdFx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeSh0YXJnZXQpLFxuXHRcdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkob3B0aW9ucyksXG5cdFx0XHRcdFx0XHRzdWNjZXNzUHJveHksXG5cdFx0XHRcdFx0XHRlcnJvclByb3h5XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXG5cdFx0XHRyZXR1cm4gaC5wcm9taXNpZnkocHJvbWlzZSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcblx0XHR9LFxuXG5cdFx0Ly8gUmVnaXN0ZXJzIGEgaGFuZGxlciB3aGljaCBub3RpZmllcyB5b3Ugd2hlbiBhIG5ldyBBR00gbWV0aG9kIGlzIGF2YWlsYWJsZS5cblx0XHRtZXRob2RBZGRlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLmFnbUZhY2FkZS5tZXRob2RBZGRlZChjYWxsYmFjayk7XG5cdFx0fSxcblxuXHRcdC8vIFJlZ2lzdGVycyBhIGhhbmRsZXIgd2hpY2ggbm90aWZpZXMgeW91IHdoZW4gYW4gQUdNIG1ldGhvZCBzdG9wcyBiZWluZyBhdmFpbGFibGUuXG5cdFx0bWV0aG9kUmVtb3ZlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLmFnbUZhY2FkZS5tZXRob2RSZW1vdmVkKGNhbGxiYWNrKTtcblx0XHR9LFxuXG5cdFx0c2VydmVyQWRkZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5hZ21GYWNhZGUuc2VydmVyQWRkZWQoY2FsbGJhY2spO1xuXHRcdH0sXG5cblx0XHRzZXJ2ZXJSZW1vdmVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHRoaXMuYWdtRmFjYWRlLnNlcnZlclJlbW92ZWQoY2FsbGJhY2spO1xuXHRcdH0sXG5cblx0XHRzZXJ2ZXJNZXRob2RBZGRlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLmFnbUZhY2FkZS5zZXJ2ZXJNZXRob2RBZGRlZChjYWxsYmFjayk7XG5cdFx0fSxcblxuXHRcdHNlcnZlck1ldGhvZFJlbW92ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5hZ21GYWNhZGUuc2VydmVyTWV0aG9kUmVtb3ZlZChjYWxsYmFjayk7XG5cdFx0fSxcblxuXHRcdC8vIFJldHJpZXZlcyBhIGxpc3Qgb2YgQUdNIHNlcnZlcnMgKGluc3RhbmNlcykgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBtZXRob2QuXG5cdFx0c2VydmVyczogZnVuY3Rpb24gKG1ldGhvZEZpbHRlcikge1xuXHRcdFx0dmFyIGpzb25SZXN1bHQgPSB0aGlzLmFnbUZhY2FkZS5zZXJ2ZXJzKEpTT04uc3RyaW5naWZ5KG1ldGhvZEZpbHRlcikpO1xuXHRcdFx0cmV0dXJuIGFnbVBhcnNlKGpzb25SZXN1bHQpO1xuXHRcdH0sXG5cblx0XHQvLyBSZXRyaWV2ZXMgYSBsaXN0IG9mIG1ldGhvZHMgdGhhdCBtYXRjaGVzIGEgZ2l2ZW4gZmlsdGVyLiBZb3UgY2FuIHVzZSB0aGlzIHRvIGNoZWNrIGlmIGEgZ2l2ZW4gbWV0aG9kIGV4aXN0cy5cblx0XHRtZXRob2RzOiBmdW5jdGlvbiAobWV0aG9kRmlsdGVyKSB7XG5cdFx0XHR2YXIganNvblJlc3VsdCA9IHRoaXMuYWdtRmFjYWRlLm1ldGhvZHMoSlNPTi5zdHJpbmdpZnkobWV0aG9kRmlsdGVyKSk7XG5cdFx0XHRyZXR1cm4gYWdtUGFyc2UoanNvblJlc3VsdCk7XG5cdFx0fSxcblxuXHRcdG1ldGhvZHNGb3JJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlRmlsdGVyKSB7XG5cdFx0XHR2YXIganNvblJlc3VsdCA9IHRoaXMuYWdtRmFjYWRlLm1ldGhvZHNGb3JJbnN0YW5jZShKU09OLnN0cmluZ2lmeShpbnN0YW5jZUZpbHRlcikpO1xuXHRcdFx0cmV0dXJuIGFnbVBhcnNlKGpzb25SZXN1bHQpO1xuXHRcdH0sXG5cblx0XHQvLyBzdHJlYW1pbmcgc3VwcG9ydFxuXHRcdHN1YnNjcmliZTogZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuXHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9ucy5hcmdzID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hcmd1bWVudHMgfHwge30pO1xuXHRcdFx0XHRvcHRpb25zLnRhcmdldCA9IHRhcmdldEFyZ1RvT2JqZWN0KG9wdGlvbnMudGFyZ2V0KTtcblxuXHRcdFx0XHR0aGlzLmFnbUZhY2FkZS5zdWJzY3JpYmUyKG5hbWUsXG5cdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkob3B0aW9ucyksXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKHN0cmVhbSkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShzdHJlYW0pO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHRcdHJldHVybiBoLnByb21pc2lmeShwcm9taXNlLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuXHRcdH0sXG5cblx0XHRjcmVhdGVTdHJlYW06IGZ1bmN0aW9uIChzdHJlYW1EZWYsIGNhbGxiYWNrcywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBzdHJlYW1EZWYgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRzdHJlYW1EZWYgPSB7bmFtZTogc3RyZWFtRGVmfTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghY2FsbGJhY2tzKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2tzID0ge307XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmFnbUZhY2FkZS5jcmVhdGVTdHJlYW0yKFxuXHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KHN0cmVhbURlZiksXG5cdFx0XHRcdFx0Ly8gVE9ETyAtIHdyYXAgdG8gdHJhbnNmb3JtIHBhcmFtc1xuXHRcdFx0XHRcdGNhbGxiYWNrcy5zdWJzY3JpcHRpb25SZXF1ZXN0SGFuZGxlcixcblx0XHRcdFx0XHQvLyBUT0RPIC0gd3JhcCB0byB0cmFuc2Zvcm0gcGFyYW1zXG5cdFx0XHRcdFx0Y2FsbGJhY2tzLnN1YnNjcmlwdGlvbkFkZGVkSGFuZGxlcixcblx0XHRcdFx0XHQvLyBUT0RPIC0gd3JhcCB0byB0cmFuc2Zvcm0gcGFyYW1zXG5cdFx0XHRcdFx0Y2FsbGJhY2tzLnN1YnNjcmlwdGlvblJlbW92ZWRIYW5kbGVyLFxuXHRcdFx0XHRcdC8vIHN1Y2Nlc3MgaGFuZGxlclxuXHRcdFx0XHRcdGZ1bmN0aW9uIChzdHJlYW0pIHtcblx0XHRcdFx0XHRcdHJlc29sdmUoc3RyZWFtKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8vIGVycm9yIGhhbmRsZXJcblx0XHRcdFx0XHRmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fS5iaW5kKHRoaXMpKTtcblxuXHRcdFx0cmV0dXJuIGgucHJvbWlzaWZ5KHByb21pc2UsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG5cdFx0fVxuXHR9O1xuXG5cdHJlc3VsdC52ZXJzaW9uID0gXCIyLjMuMVwiO1xuXG5cdC8vIGFkZCBtZXRyaWNzXG5cdGlmIChjb25maWd1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgY29uZmlndXJhdGlvbi5tZXRyaWNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb25maWd1cmF0aW9uLm1ldHJpY3MubWV0cmljc0lkZW50aXR5ID0gY29uZmlndXJhdGlvbi5tZXRyaWNzLmlkZW50aXR5O1xuXG5cblx0XHQvLyBxdWljayBhbmQgZGlydHkgLSB3ZSBuZWVkIHRvIHN0cmluZ2lmeSB0aGUgY29uZmlndXJhdGlvbiBzbyB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIG1ldHJpY3Mgb2JqZWN0ICh3aGljaCBoYXMgY2lyY3VsYXIgcmVmZXJlbmNlcylcblx0XHQvLyB3aXRoIGFuIG9iamVjdCB0aGF0IGhvbGRzIG9ubHkgdGhlIHByb3BlcnRpZXMgbmVlZGVkXG5cdFx0dmFyIG1ldHJpY3NDb25maWcgPSB7XG5cdFx0XHRtZXRyaWNzSWRlbnRpdHk6IGNvbmZpZ3VyYXRpb24ubWV0cmljcy5tZXRyaWNzSWRlbnRpdHksXG5cdFx0XHRwYXRoOiBjb25maWd1cmF0aW9uLm1ldHJpY3MucGF0aFxuXHRcdH07XG5cdFx0Y29uZmlndXJhdGlvbi5tZXRyaWNzID0gbWV0cmljc0NvbmZpZztcblx0fVxuXHRcblx0Ly9jcmVhdGUgbmV3IEFHTSBmYcOnYWRlIGZvciB0aGlzIGluc3RhbmNlXG5cdHZhciBmYWNhZGUgPSBnbG9iYWwuaHRtbENvbnRhaW5lci5qc0FnbUZhY2FkZTtcblx0dmFyIGNvbmZpZ0FzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoY29uZmlndXJhdGlvbiwgZnVuY3Rpb24oIGtleSwgdmFsdWUpIHtcblx0XHRpZigga2V5ID09ICdsb2dnZXInKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH0pO1xuXHRyZXN1bHQuaW5zdGFuY2UgPSBmYWNhZGUuaW5pdChjb25maWdBc1N0cmluZyk7XG5cdHJlc3VsdC5hZ21GYWNhZGUgPSBmYWNhZGU7XG5cblx0Ly8gZGF0ZSBwYXJzaW5nXG5cdHZhciBkYXRlVGltZUlkZW50aWZpZXIgPSByZXN1bHQuYWdtRmFjYWRlLmpzb25WYWx1ZURhdGVQcmVmaXg7XG5cblx0Ly8gZGVwcmVjYXRlZCBBUElcblx0cmVzdWx0LmNyZWF0ZV9zdHJlYW0gPSByZXN1bHQuY3JlYXRlU3RyZWFtO1xuXHRyZXN1bHQubWV0aG9kc19mb3JfaW5zdGFuY2UgPSByZXN1bHQubWV0aG9kc0Zvckluc3RhbmNlO1xuXHRyZXN1bHQubWV0aG9kX2FkZGVkID0gcmVzdWx0Lm1ldGhvZEFkZGVkO1xuXHRyZXN1bHQubWV0aG9kX3JlbW92ZWQgPSByZXN1bHQubWV0aG9kUmVtb3ZlZDtcblx0cmVzdWx0LnNlcnZlcl9hZGRlZCA9IHJlc3VsdC5zZXJ2ZXJBZGRlZDtcblx0cmVzdWx0LnNlcnZlcl9yZW1vdmVkID0gcmVzdWx0LnNlcnZlclJlbW92ZWQ7XG5cdHJlc3VsdC5zZXJ2ZXJfbWV0aG9kX2FkZGVkID0gcmVzdWx0LnNlcnZlck1ldGhvZEFkZGVkO1xuXHRyZXN1bHQuc2VydmVyX21ldGhvZF9yZW1vdmVkID0gcmVzdWx0LnNlcnZlck1ldGhvZFJlbW92ZWQ7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKlxuIFRoZSBBR00gU2VydmVyIGFsbG93cyB1c2VycyByZWdpc3RlciBBR00gbWV0aG9kcy5cbiBJdCBleHBvc2VzIHRoZXNlIG1ldGhvZHMgdG8gQUdNIGNsaWVudHMgKHVzaW5nIHByZXNlbmNlIG1lc3NhZ2VzKSBhbmQgbGlzdGVucyBmb3IgdGhlaXIgaW52b2NhdGlvblxuICovXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vYWdtX2hlbHBlcnNcIik7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcbnZhciBzdHJlYW1fcHVibGlzaGVyID0gcmVxdWlyZShcIi4vYWdtX3N0cmVhbV9wdWJsaXNoZXJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIGluc3RhbmNlLCBjb25maWd1cmF0aW9uKSB7XG5cblx0Ly9WYWxpZGF0ZSBjb25maWd1cmF0aW9uXG5cdGlmICh0eXBlb2YgY29uZmlndXJhdGlvbiAhPT0gXCJvYmplY3RcIikge1xuXHRcdGNvbmZpZ3VyYXRpb24gPSB7fTtcblxuXHRcdGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24uZGVidWcgPT09IHRydWUpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdDcmVhdGluZyBhbiBBR00gc2VydmVyIHdpdGggZGVmYXVsdCBjb25maWd1cmF0aW9uLicpO1xuXHRcdH1cblx0fVxuXHQvL0FkZCBkZWZhdWx0c1xuXHRpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24uaGVhcnRiZWF0X2ludGVydmFsICE9PSBcIm51bWJlclwiKSB7XG5cdFx0Y29uZmlndXJhdGlvbi5oZWFydGJlYXRfaW50ZXJ2YWwgPSA1MDAwO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBjb25maWd1cmF0aW9uLnByZXNlbmNlX2ludGVydmFsICE9PSBcIm51bWJlclwiKSB7XG5cdFx0Y29uZmlndXJhdGlvbi5wcmVzZW5jZV9pbnRlcnZhbCA9IDEwMDAwO1xuXHR9XG5cblx0Ly9TYXZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIG1ldHJpYyBmdW5jdGlvbiBpZiBpdCBleGlzdHNcblx0dmFyIG1ldHJpYyA9IChjb25maWd1cmF0aW9uLm1ldHJpY3MgIT09IHVuZGVmaW5lZCkgPyBjb25maWd1cmF0aW9uLm1ldHJpY3MubnVtYmVyTWV0cmljLmJpbmQoY29uZmlndXJhdGlvbi5tZXRyaWNzKSA6IGZ1bmN0aW9uICgpIHtcblx0fTtcblx0Ly9BbiBhcnJheSBvZiB0aGUgc2VydmVyJ3MgbWV0aG9kc1xuXHR2YXIgbWV0aG9kcyA9IFtdO1xuXG5cdHZhciBwcmVzZW5jZV90aW1lcjtcblxuXHR2YXIgaGVhcnRiZWF0X3RpbWVyO1xuXG5cdGlmIChoZWFydGJlYXRfdGltZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdGhlYXJ0YmVhdF90aW1lciA9IHNldEludGVydmFsKHNlbmRfaGVhcnRiZWF0LCBjb25maWd1cmF0aW9uLmhlYXJ0YmVhdF9pbnRlcnZhbCk7XG5cdH1cblxuXHQvL0luaXRpYWxpc2UgdGhlIHN0cmVhbSBwdWJsaXNoZXIgbW9kdWxlXG5cdHZhciBwdWJsaXNoZXIgPSBzdHJlYW1fcHVibGlzaGVyKGNvbm5lY3Rpb24sIGluc3RhbmNlLCBjb25maWd1cmF0aW9uLCBtZXRob2RzKTtcblxuXHRmdW5jdGlvbiBhbm5vdW5jZU5ld01ldGhvZChuZXdNZXRob2Qpe1xuXG5cdFx0bWV0aG9kcy5wdXNoKG5ld01ldGhvZCk7XG5cblx0XHQvL1NlbmQgcHJlc2VuY2Ugc28gdGhlIGNsaWVudHMga25vdyB3ZSBoYXZlIGl0XG5cdFx0c2VuZF9wcmVzZW5jZSgpO1xuXHRcdC8vU3RhcnQgc2VuZGluZyBwcmVzZW5jZSByZWd1bGFybHkgKGlmIHdlIGFyZW4ndCBhbHJlYWR5IGRvaW5nIGl0KVxuXHRcdGlmIChwcmVzZW5jZV90aW1lciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwcmVzZW5jZV90aW1lciA9IHNldEludGVydmFsKHNlbmRfcHJlc2VuY2UsIGNvbmZpZ3VyYXRpb24ucHJlc2VuY2VfaW50ZXJ2YWwpO1xuXHRcdH1cblx0XHRtZXRyaWMoXCJSZWdpc3RlcmVkIG1ldGhvZHNcIiwgbWV0aG9kcy5sZW5ndGgpO1xuXHR9XG5cblx0Ly8gcmVnaXN0ZXJzIGEgbmV3IGFnbSBtZXRob2Rcblx0ZnVuY3Rpb24gcmVnaXN0ZXIobWV0aG9kRGVmaW5pdGlvbiwgY2FsbGJhY2spIHtcblxuXHRcdHJlZ2lzdGVyQ29yZShtZXRob2REZWZpbml0aW9uLCBmdW5jdGlvbihjb250ZXh0LCByZXN1bHRDYWxsYmFjayl7XG5cdFx0XHQvLyBnZXQgdGhlIHJlc3VsdCBhcyBkaXJlY3QgaW52b2NhdGlvbiBvZiB0aGUgY2FsbGJhY2sgYW5kIHJldHVybiBpdCB1c2luZyByZXN1bHRDYWxsYmFja1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gY2FsbGJhY2soY29udGV4dC5hcmdzLCBjb250ZXh0Lmluc3RhbmNlKTtcblx0XHRcdFx0cmVzdWx0Q2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVzdWx0Q2FsbGJhY2soZSwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fVxuXG5cdC8vIHJlZ2lzdGVycyBhIG5ldyBhc3luIGFnbSBtZXRob2QgKHRoZSByZXN1bHQgY2FuIGJlIHJldHVybmVkIGluIGFzeW5jIHdheSlcblx0ZnVuY3Rpb24gcmVnaXN0ZXJBc3luYyhtZXRob2REZWZpbml0aW9uLCBjYWxsYmFjaykge1xuXG5cdFx0cmVnaXN0ZXJDb3JlKG1ldGhvZERlZmluaXRpb24sIGZ1bmN0aW9uKGNvbnRleHQsIHJlc3VsdENhbGxiYWNrKXtcblx0XHRcdC8vIGludm9rZSB0aGUgY2FsbGJhY2sgcGFzc2luZyBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3Ncblx0XHRcdHRyeXtcblx0XHRcdFx0Y2FsbGJhY2soY29udGV4dC5hcmdzLCBjb250ZXh0Lmluc3RhbmNlLFxuXHRcdFx0XHRcdC8vIHN1Y2Nlc3MgY2FsbGJhY2tcblx0XHRcdFx0XHRmdW5jdGlvbihyZXN1bHQpe1xuXHRcdFx0XHRcdFx0cmVzdWx0Q2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8vIGVycm9yIGNhbGxiYWNrXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHJlc3VsdENhbGxiYWNrKGUsIG51bGwpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXN1bHRDYWxsYmFjayhlLCBudWxsKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8vIGNvcmUgbWV0aG9kIGZvciByZWdpc3RlcmluZyBhZ20gbWV0aG9kXG5cdGZ1bmN0aW9uIHJlZ2lzdGVyQ29yZShtZXRob2REZWZpbml0aW9uLCB0aGVfZnVuY3Rpb24pIHtcblx0XHQvLyB0cmFuc2Zvcm0gdGhlIGRlZmluaXRpb25cblx0XHRpZiAodHlwZW9mIG1ldGhvZERlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdG1ldGhvZERlZmluaXRpb24gPSB7bmFtZTogbWV0aG9kRGVmaW5pdGlvbn07XG5cdFx0fVxuXG5cdFx0Ly9HZXQgYSByZXF1ZXN0IHN1YmplY3QgZm9yIHRoaXMgbWV0aG9kXG5cdFx0aW5zdGFuY2UucmVxdWVzdF9zdWJqZWN0KG1ldGhvZERlZmluaXRpb24sIGZ1bmN0aW9uIChyZXF1ZXN0U3ViamVjdCkge1xuXG5cdFx0XHR2YXIgbWV0aG9kID0gY29udmVydF9tZXRob2QobWV0aG9kRGVmaW5pdGlvbik7XG5cdFx0XHRtZXRob2QuTWV0aG9kUmVxdWVzdFN1YmplY3QgPSByZXF1ZXN0U3ViamVjdDtcblxuXHRcdFx0Ly9BZGQgdGhlIG1ldGhvZCAoc3RvcmUgdGhlIHVuZm9ybWF0dGVkIGRlZmluaXRpb24gaW4gb3JkZXIgdG8gZG8gY2hlY2t1cHMgaW4gdGhlIHVucmVnaXN0ZXIgbWV0aG9kKVxuXHRcdFx0YW5ub3VuY2VOZXdNZXRob2Qoe1xuXHRcdFx0XHRtZXRob2Q6IG1ldGhvZCxcblx0XHRcdFx0ZGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcblx0XHRcdFx0dGhlX2Z1bmN0aW9uOiB0aGVfZnVuY3Rpb25cblx0XHRcdH0pO1xuXG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVTdHJlYW0oc3RyZWFtRGVmLCBjYWxsYmFja3MsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayl7XG5cdFx0Ly8gaW4gY2FsbGJhY2tzIHdlIGhhdmUgc3Vic2NyaXB0aW9uUmVxdWVzdEhhbmRsZXIsIHN1YnNjcmlwdGlvbkFkZGVkSGFuZGxlciwgc3Vic2NyaXB0aW9uUmVtb3ZlZEhhbmRsZXJcblxuXHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0aWYgKHR5cGVvZiBzdHJlYW1EZWYgPT09IFwic3RyaW5nXCIpIHtcblxuXHRcdFx0XHRpZihzdHJlYW1EZWYgPT09ICcnKSB7XG5cdFx0XHRcdFx0cmVqZWN0KFwiSW52YWxpZCBzdHJlYW0gbmFtZS5cIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdHJlYW1EZWYgPSB7bmFtZTogc3RyZWFtRGVmfTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFjYWxsYmFja3MpIHtcblx0XHRcdFx0Y2FsbGJhY2tzID0ge307XG5cdFx0XHR9XG5cblx0XHRcdGlmKHR5cGVvZiBjYWxsYmFja3Muc3Vic2NyaXB0aW9uUmVxdWVzdEhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIil7XG5cdFx0XHRcdGNhbGxiYWNrcy5zdWJzY3JpcHRpb25SZXF1ZXN0SGFuZGxlciA9IGZ1bmN0aW9uKHJlcXVlc3Qpe1xuXHRcdFx0XHRcdHJlcXVlc3QuYWNjZXB0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly9HZXQgYSByZXF1ZXN0IHN1YmplY3QsIHNldCB0aGUgc3RyZWFtaW5nIGJpdCB0aGVuIHB1c2ggaW50byBtZXRob2RzW11cblx0XHRcdGluc3RhbmNlLnJlcXVlc3Rfc3ViamVjdChzdHJlYW1EZWYsIGZ1bmN0aW9uIChyZXF1ZXN0U3ViamVjdCkge1xuXHRcdFx0XHR2YXIgc3RyZWFtQ29udmVydGVkID0gY29udmVydF9tZXRob2Qoc3RyZWFtRGVmKTtcblx0XHRcdFx0c3RyZWFtQ29udmVydGVkLk1ldGhvZFJlcXVlc3RTdWJqZWN0ID0gcmVxdWVzdFN1YmplY3Q7XG5cdFx0XHRcdHN0cmVhbUNvbnZlcnRlZC5NZXRob2QuRmxhZ3MgPSAzMjsgLy8xMDAwMDAgYml0bWFzayB3aXRoIHRoZSBsYXJnZXN0IGZsYWcgKHN0cmVhbWluZzogdHJ1ZSlcblxuXHRcdFx0XHR2YXIgbmV3U3RyZWFtaW5nTWV0aG9kID0ge1xuXHRcdFx0XHRcdG1ldGhvZDogc3RyZWFtQ29udmVydGVkLFxuXHRcdFx0XHRcdGRlZmluaXRpb246IHtcblx0XHRcdFx0XHRcdGFjY2VwdHM6IHN0cmVhbURlZi5hY2NlcHRzLFxuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb246IHN0cmVhbURlZi5kZXNjcmlwdGlvbixcblx0XHRcdFx0XHRcdGRpc3BsYXlOYW1lOiBzdHJlYW1EZWYuZGlzcGxheU5hbWUsXG5cdFx0XHRcdFx0XHRuYW1lOiBzdHJlYW1EZWYubmFtZSxcblx0XHRcdFx0XHRcdG9iamVjdFR5cGVzOiBzdHJlYW1EZWYub2JqZWN0VHlwZXMsXG5cdFx0XHRcdFx0XHRyZXR1cm5zOiBzdHJlYW1EZWYucmV0dXJucyxcblx0XHRcdFx0XHRcdHN1cHBvcnRzU3RyZWFtaW5nOiB0cnVlXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHJlYW1DYWxsYmFja3M6IGNhbGxiYWNrcyxcblx0XHRcdFx0XHRnbG9iYWxFdmVudFN0cmVhbVN1YmplY3Q6IHN0cmVhbURlZi5uYW1lICsgJy5qc1N0cmVhbS4nICsgaGVscGVycy5nZW5lcmF0ZVJhbmRvbSgpLFxuXHRcdFx0XHRcdHN1YnNjcmlwdGlvbnM6IFtdLFxuXHRcdFx0XHRcdGJyYW5jaEtleVRvU3RyZWFtSWRNYXA6IFtdIC8vWyB7YnJhbmNoS2V5OiAnJywgc3RyZWFtSWQ6ICdzdHJqX25kczc4NnkyMzc4eWInfSwgey4uLn0sIC4uLl1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRhbm5vdW5jZU5ld01ldGhvZChuZXdTdHJlYW1pbmdNZXRob2QpO1xuXG5cdFx0XHRcdHJlc29sdmUoe1xuXHRcdFx0XHRcdGJyYW5jaGVzOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIHB1Ymxpc2hlci5nZXRCcmFuY2hMaXN0KG5ld1N0cmVhbWluZ01ldGhvZClcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGNsb3NlOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0cHVibGlzaGVyLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhuZXdTdHJlYW1pbmdNZXRob2QpO1xuXHRcdFx0XHRcdFx0dW5yZWdpc3RlcihuZXdTdHJlYW1pbmdNZXRob2QuZGVmaW5pdGlvbilcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGRlZmluaXRpb246IHtcblx0XHRcdFx0XHRcdGFjY2VwdHM6IHN0cmVhbURlZi5hY2NlcHRzLFxuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb246IHN0cmVhbURlZi5kZXNjcmlwdGlvbixcblx0XHRcdFx0XHRcdGRpc3BsYXlOYW1lOiBzdHJlYW1EZWYuZGlzcGxheU5hbWUsXG5cdFx0XHRcdFx0XHRuYW1lOiBzdHJlYW1EZWYubmFtZSxcblx0XHRcdFx0XHRcdG9iamVjdFR5cGVzOiBzdHJlYW1EZWYub2JqZWN0VHlwZXMsXG5cdFx0XHRcdFx0XHRyZXR1cm5zOiBzdHJlYW1EZWYucmV0dXJucyxcblx0XHRcdFx0XHRcdHN1cHBvcnRzU3RyZWFtaW5nOiB0cnVlXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRuYW1lOiBzdHJlYW1EZWYubmFtZSxcblx0XHRcdFx0XHRwdXNoOiBmdW5jdGlvbihkYXRhLCBicmFuY2hlcyl7XG5cdFx0XHRcdFx0XHRpZih0eXBlb2YgYnJhbmNoZXMgIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KGJyYW5jaGVzKSAmJiBicmFuY2hlcyAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJyYW5jaGVzIHNob3VsZCBiZSBzdHJpbmcgb3Igc3RyaW5nIGFycmF5Jyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL1RPRE8gdmFsaWRhdGUgaWYgaXMgcGxhaW4gb2JqZWN0XG5cdFx0XHRcdFx0XHRpZih0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpe1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzLiBEYXRhIG11c3QgYmUgYW4gb2JqZWN0LicpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwdWJsaXNoZXIucHVzaERhdGEobmV3U3RyZWFtaW5nTWV0aG9kLCBkYXRhLCBicmFuY2hlcylcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN1YnNjcmlwdGlvbnM6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHVibGlzaGVyLmdldFN1YnNjcmlwdGlvbkxpc3QobmV3U3RyZWFtaW5nTWV0aG9kKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHR9KTtcblxuXHRcdHJldHVybiBoZWxwZXJzLnByb21pc2lmeShwcm9taXNlLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuXHR9XG5cblx0dmFyIGludm9jYXRpb25zID0gMDtcblxuXHQvL0xpc3RlbnMgZm9yIG1ldGhvZCBpbnZvY2F0aW9uc1xuXHRjb25uZWN0aW9uLm9uKFwiTWV0aG9kSW52b2NhdGlvblJlcXVlc3RNZXNzYWdlXCIsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdFx0Ly9GaW5kIHRoZSBtZXRob2Rcblx0XHR2YXIgbWV0aG9kID0gbWV0aG9kcy5maWx0ZXIoZnVuY3Rpb24obSl7XG5cdFx0XHRyZXR1cm4gbS5tZXRob2QuTWV0aG9kUmVxdWVzdFN1YmplY3QgPT09IG1lc3NhZ2UuTWV0aG9kUmVxdWVzdFN1YmplY3Q7XG5cdFx0fSlbMF07XG5cblx0XHQvL1N0b3AgaWYgdGhlIG1lc3NhZ2UgaXNuJ3QgZm9yIHVzXG5cdFx0aWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gc29tZSBsb2dnaW5nIGlmIGVuYWJsZWRcblx0XHRpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWd1cmF0aW9uLmRlYnVnID09PSB0cnVlKSB7XG5cdFx0XHRjb25zb2xlLmRlYnVnKFwiJWM8PDwgcmVjZWl2aW5nIE1ldGhvZEludm9jYXRpb25SZXF1ZXN0TWVzc2FnZVwiLCBcImJhY2tncm91bmQtY29sb3I6aHNsYSgxOTgsIDUxJSwgNzklLCAwLjUpXCIpO1xuXHRcdFx0Y29uc29sZS5kZWJ1ZyhcIiVjXCIgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgXCJiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMTk4LCA1MSUsIDc5JSwgMC41KVwiKTtcblx0XHR9XG5cdFx0bWV0cmljKFwiSW52b2NhdGlvbnMgY291bnRcIiwgaW52b2NhdGlvbnMrKyk7XG5cblx0XHQvL1RPRE8gc2VlIGlmIGhhdmUgdG8gbW92ZSB0aGlzIGVhcmxpZXIgLSBpLmUuIGlmIHNvbWUgbWVzc2FnZXMgZnJvbSBDbGllbnQgZG9uJ3QgaGF2ZSBNZXRob2RSZXF1ZXN0U3ViamVjdFxuXHRcdC8vQ2hlY2sgaWYgbWVzc2FnZSBpcyBzdHJlYW0tcmVsYXRlZCA6IGRlZmVyIHB1Ymxpc2hlclxuXHRcdGlmIChwdWJsaXNoZXIuaXNTdHJlYW1Nc2cobWVzc2FnZSwgbWV0aG9kKSl7XG5cdFx0XHRwdWJsaXNoZXIucHJvY2Vzc1N1YnNjcmliZXJNc2cobWVzc2FnZSwgbWV0aG9kKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL0V4ZWN1dGUgaXQgYW5kIHNhdmUgdGhlIHJlc3VsdFxuXHRcdG1ldGhvZC50aGVfZnVuY3Rpb24oe2FyZ3M6bWVzc2FnZS5Db250ZXh0LkFyZ3VtZW50c0pzb24sIGluc3RhbmNlOm1lc3NhZ2UuQ2xpZW50fSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0Ly8gaGFuZGxlIGVycm9yIGNhc2Vcblx0XHRcdFx0aWYgKHR5cGVvZiBlcnIubWVzc2FnZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdGVyciA9IGVyci5tZXNzYWdlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBlcnIgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0ZXJyID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly9Eb24ndCBzZW5kIHJlc3VsdCBpZiB0aGUgY2xpZW50IGRvZXMgbm90IHJlcXVpcmUgaXRcblx0XHRcdGlmIChtZXNzYWdlLk1ldGhvZFJlc3BvbnNlU3ViamVjdCA9PT0gXCJudWxsXCIpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1RoZSBBR00gbGlicmFyeSBvbmx5IHRyYW5zZmVycyBvYmplY3RzLiBJZiB0aGUgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3QsIHB1dCBpdCBpbiBvbmVcblx0XHRcdGlmIChyZXN1bHQgJiYgKHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIgfHwgcmVzdWx0LmNvbnN0cnVjdG9yID09PSBBcnJheSkpIHtcblx0XHRcdFx0cmVzdWx0ID0ge19yZXN1bHQ6IHJlc3VsdH07XG5cdFx0XHR9XG5cblx0XHRcdHZhciByZXN1bHRNZXNzYWdlID0ge1xuXHRcdFx0XHRNZXRob2RSZXF1ZXN0U3ViamVjdDogbWVzc2FnZS5NZXRob2RSZXF1ZXN0U3ViamVjdCxcblx0XHRcdFx0TWV0aG9kUmVzcG9uc2VTdWJqZWN0OiBtZXNzYWdlLk1ldGhvZFJlc3BvbnNlU3ViamVjdCxcblx0XHRcdFx0TWV0aG9kTmFtZTogbWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSxcblx0XHRcdFx0SW52b2NhdGlvbklkOiBtZXNzYWdlLkNvbnRleHQuSW52b2NhdGlvbklkLFxuXHRcdFx0XHRSZXN1bHRDb250ZXh0SnNvbjogcmVzdWx0LFxuXHRcdFx0XHRTZXJ2ZXI6IGluc3RhbmNlLmluZm8oKSxcblx0XHRcdFx0UmVzdWx0TWVzc2FnZTogZXJyLFxuXHRcdFx0XHRTdGF0dXM6IGVyciA/IDEgOiAwXG5cdFx0XHR9O1xuXHRcdFx0Ly9TZW5kIHJlc3VsdFxuXHRcdFx0Y29ubmVjdGlvbi5zZW5kKFwiTWV0aG9kSW52b2NhdGlvblJlc3VsdE1lc3NhZ2VcIiwgcmVzdWx0TWVzc2FnZSk7XG5cblx0XHRcdGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZ3VyYXRpb24uZGVidWcgPT09IHRydWUpIHtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhcIiVjPj4+IHNlbmRpbmcgTWV0aG9kSW52b2NhdGlvblJlc3VsdE1lc3NhZ2VcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMTE4LCA1MSUsIDc5JSwgMC41KVwiKTtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhcIiVjXCIgKyBKU09OLnN0cmluZ2lmeShyZXN1bHRNZXNzYWdlKSwgXCJiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMTE4LCA1MSUsIDc5JSwgMC41KVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cblx0Ly9Db25zdHJ1Y3RzIGEgaGVhcnRiZWF0IG1lc3NhZ2Vcblx0ZnVuY3Rpb24gY29uc3RydWN0X2hlYXJ0YmVhdCgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0UHVibGlzaGluZ0ludGVydmFsOiBjb25maWd1cmF0aW9uLmhlYXJ0YmVhdF9pbnRlcnZhbCxcblx0XHRcdEluc3RhbmNlOiBpbnN0YW5jZS5pbmZvKClcblx0XHR9O1xuXHR9XG5cblx0Ly9Db25zdHJ1Y3RzIGEgcHJlc2VuY2UgbWVzc2FnZVxuXHRmdW5jdGlvbiBjb25zdHJ1Y3RfcHJlc2VuY2UoKSB7XG5cdFx0dmFyIHAgPSB7XG5cdFx0XHRQdWJsaXNoaW5nSW50ZXJ2YWw6IGNvbmZpZ3VyYXRpb24ucHJlc2VuY2VfaW50ZXJ2YWwsXG5cdFx0XHRJbnN0YW5jZTogaW5zdGFuY2UuaW5mbygpXG5cdFx0fTtcblx0XHRwLk1ldGhvZERlZmluaXRpb25zID0gbWV0aG9kcy5tYXAoZnVuY3Rpb24gKG1ldGhvZCkge1xuXHRcdFx0cmV0dXJuIG1ldGhvZC5tZXRob2Q7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHA7XG5cdH1cblxuXHQvL1RydWUgaWYgd2Ugc2hvdWxkIGJlIGJyb2FkY2FzdGluZyBwcmVzZW5jZXMgYW5kIGhlYXJ0YmVhdHMsIGZhbHNlIG90aGVyd2lzZVxuXHR2YXIgYnJvYWRjYXN0aW5nID0gdHJ1ZTtcblxuXHRmdW5jdGlvbiBzdGFydCgpIHtcblx0XHRicm9hZGNhc3RpbmcgPSB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gc3RvcCgpIHtcblx0XHRicm9hZGNhc3RpbmcgPSBmYWxzZTtcblx0fVxuXG5cdC8vU2VuZHMgYSBwcmVzZW5jZVxuXHRmdW5jdGlvbiBzZW5kX3ByZXNlbmNlKCkge1xuXHRcdGlmIChicm9hZGNhc3RpbmcpIHtcblx0XHRcdGNvbm5lY3Rpb24uc2VuZChcIlNlcnZlclByZXNlbmNlTWVzc2FnZVwiLCBjb25zdHJ1Y3RfcHJlc2VuY2UoKSk7XG5cdFx0fVxuXHR9XG5cblx0Ly9TZW5kcyBhIGhlYXJ0YmVhdFxuXHRmdW5jdGlvbiBzZW5kX2hlYXJ0YmVhdCgpIHtcblx0XHRpZiAoYnJvYWRjYXN0aW5nKSB7XG5cdFx0XHRjb25uZWN0aW9uLnNlbmQoXCJTZXJ2ZXJIZWFydGJlYXRNZXNzYWdlXCIsIGNvbnN0cnVjdF9oZWFydGJlYXQoKSk7XG5cdFx0fVxuXHR9XG5cblxuXHQvL0NvbnZlcnRzIHRoZSBtZXRob2QgZGVmaW5pdGlvbiBmcm9tIGNhbWVsIGNhc2UgdG8gc25ha2UgY2FzZVxuXHRmdW5jdGlvbiBjb252ZXJ0X21ldGhvZChtZXRob2RfaWRlbnRpZmllcikge1xuXHRcdC8vSWYgd2UgYXJlIGdpdmVuIGEgc3RyaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0LCB3ZSBwcmVzdW1lIHRoYXQgaXMgdGhlIG1ldGhvZCdzIG5hbWU6XG5cdFx0aWYgKHR5cGVvZiBtZXRob2RfaWRlbnRpZmllciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0bWV0aG9kX2lkZW50aWZpZXIgPSB7bmFtZTogbWV0aG9kX2lkZW50aWZpZXJ9O1xuXHRcdH1cblxuXHRcdC8vU2V0IGRlZmF1bHQgdmFsdWVzXG5cdFx0aWYgKHR5cGVvZiBtZXRob2RfaWRlbnRpZmllci52ZXJzaW9uICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRtZXRob2RfaWRlbnRpZmllci52ZXJzaW9uID0gMDtcblx0XHR9XG5cblxuXHRcdC8vQ29udmVydCB0aGUgbWV0aG9kIGRlZmluaXRpb24gdG8gdGhlIGZvcm1hdCB0aGF0IEFHTSByZXF1aXJlc1xuXHRcdHJldHVybiB7XG5cdFx0XHRNZXRob2Q6IHtcblx0XHRcdFx0TmFtZTogbWV0aG9kX2lkZW50aWZpZXIubmFtZSxcblx0XHRcdFx0SW5wdXRTaWduYXR1cmU6IG1ldGhvZF9pZGVudGlmaWVyLmFjY2VwdHMsXG5cdFx0XHRcdFJlc3VsdFNpZ25hdHVyZTogbWV0aG9kX2lkZW50aWZpZXIucmV0dXJucyxcblx0XHRcdFx0RGVzY3JpcHRpb246IG1ldGhvZF9pZGVudGlmaWVyLmRlc2NyaXB0aW9uLFxuXHRcdFx0XHREaXNwbGF5TmFtZTogbWV0aG9kX2lkZW50aWZpZXIuZGlzcGxheV9uYW1lLFxuXHRcdFx0XHRWZXJzaW9uOiBtZXRob2RfaWRlbnRpZmllci52ZXJzaW9uLFxuXHRcdFx0XHRPYmplY3RUeXBlUmVzdHJpY3Rpb25zOiBtZXRob2RfaWRlbnRpZmllci5vYmplY3RfdHlwZXNcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gY29udGFpbnNfcHJvcHMoZmlsdGVyLCBvYmplY3QpIHtcblx0XHR2YXIgbWF0Y2ggPSB0cnVlO1xuXHRcdE9iamVjdC5rZXlzKGZpbHRlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuXHRcdFx0aWYgKGZpbHRlcltwcm9wXSAhPT0gb2JqZWN0W3Byb3BdKSB7XG5cdFx0XHRcdG1hdGNoID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG1hdGNoO1xuXHR9XG5cblx0Ly9VbnJlZ2lzdGVycyBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBBR00gbWV0aG9kXG5cdGZ1bmN0aW9uIHVucmVnaXN0ZXIobWV0aG9kX2ZpbHRlcikge1xuXHRcdGlmICh0eXBlb2YgbWV0aG9kX2ZpbHRlciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0bWV0aG9kX2ZpbHRlciA9IHtuYW1lOiBtZXRob2RfZmlsdGVyfTtcblx0XHR9XG5cdFx0bWV0aG9kcyA9IG1ldGhvZHMuZmlsdGVyKGZ1bmN0aW9uIChtZXRob2QpIHtcblx0XHRcdHJldHVybiAhY29udGFpbnNfcHJvcHMobWV0aG9kX2ZpbHRlciwgbWV0aG9kLmRlZmluaXRpb24pO1xuXHRcdH0pO1xuXHRcdG1ldHJpYyhcIlJlZ2lzdGVyZWQgbWV0aG9kc1wiLCBtZXRob2RzLmxlbmd0aCk7XG5cdH1cblxuXHRyZXR1cm4ge3JlZ2lzdGVyOiByZWdpc3RlciwgcmVnaXN0ZXJBc3luYzogcmVnaXN0ZXJBc3luYywgdW5yZWdpc3RlcjogdW5yZWdpc3Rlciwgc3RhcnQ6IHN0YXJ0LCBzdG9wOiBzdG9wLCBjcmVhdGVTdHJlYW06IGNyZWF0ZVN0cmVhbX07XG59O1xuIiwidmFyIFByb21pc2UgPSByZXF1aXJlKCdlczYtcHJvbWlzZScpLlByb21pc2U7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2FnbV9oZWxwZXJzXCIpO1xuXG52YXIgcHVibGlzaGVyID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBpbnN0YW5jZSwgY29uZmlndXJhdGlvbiwgbWV0aG9kcyl7XG5cblx0ZnVuY3Rpb24gc2VuZFJlc3VsdChtZXNzYWdlKXtcblx0XHRpZih0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcpe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2UuJyk7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIG1lc3NhZ2UuU3RhdHVzICE9PSAnbnVtYmVyJyl7XG5cdFx0XHRtZXNzYWdlLlN0YXR1cyA9IDA7XG5cdFx0fVxuXG5cdFx0Y29ubmVjdGlvbi5zZW5kKFwiTWV0aG9kSW52b2NhdGlvblJlc3VsdE1lc3NhZ2VcIiwgbWVzc2FnZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpc1N0cmVhbU1zZ0ZvclN0cmVhbWluZ01ldGhvZChtc2csIG1ldGhvZCl7XG5cdFx0cmV0dXJuIChcblx0XHRcdG1zZ1xuXHRcdFx0JiYgbXNnLkV2ZW50U3RyZWFtQWN0aW9uXG5cdFx0XHQmJiBtc2cuRXZlbnRTdHJlYW1BY3Rpb24gIT09IDBcblx0XHRcdCYmIHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnXG5cdFx0XHQmJiBtZXRob2QuZGVmaW5pdGlvbi5zdXBwb3J0c1N0cmVhbWluZyA9PT0gdHJ1ZVxuXHRcdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzU3Vic2NyaWJlck1zZyhtc2csIHN0cmVhbWluZ01ldGhvZCl7XG5cdFx0aWYoICEgKG1zZyAmJiBtc2cuRXZlbnRTdHJlYW1BY3Rpb24gJiYgbXNnLkV2ZW50U3RyZWFtQWN0aW9uICE9PSAwKSApe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKG1zZy5FdmVudFN0cmVhbUFjdGlvbiA9PT0gMSkge1xuXHRcdFx0Y2xpZW50V2lzaGVzVG9TdWJzY3JpYmUobXNnLCBzdHJlYW1pbmdNZXRob2QpO1xuXG5cdFx0fSBlbHNlIGlmKG1zZy5FdmVudFN0cmVhbUFjdGlvbiA9PT0gMikge1xuXHRcdFx0Y2xpZW50V2lzaGVzVG9VbnN1YnNjcmliZShtc2csIHN0cmVhbWluZ01ldGhvZCk7XG5cblx0XHR9IGVsc2UgaWYobXNnLkV2ZW50U3RyZWFtQWN0aW9uID09PSAzKSB7XG5cdFx0XHRjbGllbnRBY2tub3dsZWRnZXNJdERpZFN1YnNjcmliZShtc2csIHN0cmVhbWluZ01ldGhvZCk7XG5cblx0XHR9IGVsc2UgaWYobXNnLkV2ZW50U3RyZWFtQWN0aW9uID09PSA0KSB7XG5cdFx0XHRjbGllbnRQZXJTdWJIZWFydGJlYXQobXNnKTtcblx0XHR9XG5cdH1cblxuXHQvKiogbXNnICdSZXF1ZXN0JyBBY3Rpb25zICovXG5cdC8vYWN0aW9uIDFcblx0ZnVuY3Rpb24gY2xpZW50V2lzaGVzVG9TdWJzY3JpYmUobXNnLCBzdHJlYW1pbmdNZXRob2Qpe1xuXG5cdFx0aWYoICEgKFxuXHRcdFx0c3RyZWFtaW5nTWV0aG9kXG5cdFx0XHQmJiBzdHJlYW1pbmdNZXRob2Quc3RyZWFtQ2FsbGJhY2tzXG5cdFx0XHQmJiB0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kLnN0cmVhbUNhbGxiYWNrcy5zdWJzY3JpcHRpb25SZXF1ZXN0SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykgKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL1Bhc3MtaW4gdGhlIHJlcXVlc3Qgb2JqZWN0XG5cdFx0c3RyZWFtaW5nTWV0aG9kLnN0cmVhbUNhbGxiYWNrcy5zdWJzY3JpcHRpb25SZXF1ZXN0SGFuZGxlcih7XG5cdFx0XHRhY2NlcHQ6IGFjY2VwdFJlcXVlc3RPbkJyYW5jaC5iaW5kKG51bGwsIG1zZywgc3RyZWFtaW5nTWV0aG9kLCAnJyksXG5cdFx0XHRhY2NlcHRPbkJyYW5jaDogYWNjZXB0UmVxdWVzdE9uQnJhbmNoLmJpbmQobnVsbCwgbXNnLCBzdHJlYW1pbmdNZXRob2QpLFxuXHRcdFx0YXJndW1lbnRzOiBtc2cuQ29udGV4dC5Bcmd1bWVudHNKc29uIHx8IHt9LFxuXHRcdFx0aW5zdGFuY2U6IG1zZy5DbGllbnQsXG5cdFx0XHRyZWplY3Q6IHJlamVjdFJlcXVlc3QuYmluZChudWxsLCBtc2csIHN0cmVhbWluZ01ldGhvZClcblx0XHR9KTtcblx0fVxuXG5cdC8vYWN0aW9uIDJcblx0ZnVuY3Rpb24gY2xpZW50V2lzaGVzVG9VbnN1YnNjcmliZShtc2csIHN0cmVhbWluZ01ldGhvZCl7XG5cblx0XHRpZiggISAoXG5cdFx0XHRzdHJlYW1pbmdNZXRob2Rcblx0XHRcdCYmIEFycmF5LmlzQXJyYXkoc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMpXG5cdFx0XHQmJiBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucy5sZW5ndGggPiAwKVxuXHRcdCl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2xvc2VJbmRpdmlkdWFsU3Vic2NyaXB0aW9uKHN0cmVhbWluZ01ldGhvZCwgbXNnLlN0cmVhbUlkLCBtc2cuRXZlbnRTdHJlYW1TdWJqZWN0LCBmYWxzZSlcblx0fVxuXG5cdC8vYWN0aW9uIDNcblx0ZnVuY3Rpb24gY2xpZW50QWNrbm93bGVkZ2VzSXREaWRTdWJzY3JpYmUobXNnLCBzdHJlYW1pbmdNZXRob2Qpe1xuXHRcdC8vQ2xpZW50IGluZGljYXRlcyBpdCBpcyBsaXN0ZW5pbmcgdG8gYSBzcGVjaWZpYyBTdHJlYW1JZFxuXG5cdFx0aWYodHlwZW9mIG1zZy5TdHJlYW1JZCAhPT0gJ3N0cmluZycgfHwgbXNnLlN0cmVhbUlkID09PSAnJyl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGJyYW5jaEtleSA9IGdldEJyYW5jaEtleShzdHJlYW1pbmdNZXRob2QsIG1zZy5TdHJlYW1JZCk7XG5cblx0XHRpZiggdHlwZW9mIGJyYW5jaEtleSAhPT0gJ3N0cmluZycpe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCAhIEFycmF5LmlzQXJyYXkoc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMgKSl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHN1YnNjcmlwdGlvbiA9IHtcblx0XHRcdGJyYW5jaEtleTogYnJhbmNoS2V5LFxuXHRcdFx0aW5zdGFuY2U6IG1zZy5DbGllbnQsXG5cdFx0XHRhcmd1bWVudHM6IG1zZy5Db250ZXh0LkFyZ3VtZW50c0pzb24sXG5cdFx0XHRzdHJlYW1JZDogbXNnLlN0cmVhbUlkLFxuXHRcdFx0cHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdDogbXNnLkV2ZW50U3RyZWFtU3ViamVjdCxcblx0XHRcdG1ldGhvZFJlc3BvbnNlU3ViamVjdDogbXNnLk1ldGhvZFJlc3BvbnNlU3ViamVjdFxuXHRcdH07XG5cblx0XHQvL1N1YnNjcmlwdGlvbiBiYWNrLW9iaiBpcyBzdG9yZWRcblx0XHRzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG5cblx0XHR2YXIgc3ViRnJvbnRPYmogPSBjb25qdXJlU3Vic2NyaXB0aW9uRnJvbnRPYmooc3RyZWFtaW5nTWV0aG9kLCBzdWJzY3JpcHRpb24pO1xuXHRcdHZhciBzdWJBZGRlZEhhbmRsZXIgPSBzdHJlYW1pbmdNZXRob2Quc3RyZWFtQ2FsbGJhY2tzLnN1YnNjcmlwdGlvbkFkZGVkSGFuZGxlcjtcblx0XHRpZih0eXBlb2Ygc3ViQWRkZWRIYW5kbGVyID09PSAnZnVuY3Rpb24nKXtcblx0XHRcdC8vUGFzcy1pbiB0aGUgc3Vic2NyaXB0aW9uIG9iamVjdFxuXHRcdFx0c3ViQWRkZWRIYW5kbGVyKHN1YkZyb250T2JqKTtcblx0XHR9XG5cdH1cblxuXHQvL2FjdGlvbiA0XG5cdGZ1bmN0aW9uIGNsaWVudFBlclN1YkhlYXJ0YmVhdCgpe1xuXHRcdC8vQSBjbGllbnQgbWF5IGhhdmUgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucywgZWFjaCBvbmUgaGF2aW5nIGl0cyBvd24gaGVhcnRiZWF0XG5cdFx0Ly9DdXJyZW50bHkgbm90IGltcGxlbWVudGVkIGJ5IHRoZSBHVyBvciB0aGUgY2xpZW50XG5cdH1cblxuXG5cdC8qKiAocmVxdWVzdCkgTWV0aG9kcyAqL1xuXHRmdW5jdGlvbiBhY2NlcHRSZXF1ZXN0T25CcmFuY2gobXNnLCBzdHJlYW1pbmdNZXRob2QsIGJyYW5jaCl7XG5cdFx0aWYoIHR5cGVvZiBicmFuY2ggIT09IFwic3RyaW5nXCIgKXtcblx0XHRcdGJyYW5jaCA9ICcnO1xuXHRcdH1cblxuXHRcdHZhciBzdHJlYW1JZCA9IGdldFN0cmVhbUlkKHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoKTtcblxuXHRcdHNlbmRSZXN1bHQoe1xuXHRcdFx0RXZlbnRTdHJlYW1BY3Rpb246IDMsXG5cdFx0XHRFdmVudFN0cmVhbVN1YmplY3Q6IHN0cmVhbWluZ01ldGhvZC5nbG9iYWxFdmVudFN0cmVhbVN1YmplY3QsXG5cdFx0XHRJbnZvY2F0aW9uSWQ6IG1zZy5Db250ZXh0Lkludm9jYXRpb25JZCxcblx0XHRcdE1ldGhvZE5hbWU6c3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSxcblx0XHRcdE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuXHRcdFx0TWV0aG9kUmVzcG9uc2VTdWJqZWN0OiBtc2cuTWV0aG9kUmVzcG9uc2VTdWJqZWN0LFxuXHRcdFx0TWV0aG9kVmVyc2lvbjogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuVmVyc2lvbixcblx0XHRcdFJlc3VsdE1lc3NhZ2U6IFwiQWNjZXB0ZWRcIixcblx0XHRcdFNlcnZlcjogaW5zdGFuY2UuaW5mbygpLFxuXHRcdFx0U3RyZWFtSWQ6IHN0cmVhbUlkXG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCcmFuY2hLZXkoc3RyZWFtaW5nTWV0aG9kLCBzdHJlYW1JZCl7XG5cdFx0aWYodHlwZW9mIHN0cmVhbUlkICE9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kICE9PSAnb2JqZWN0Jyl7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG5lZWRsZSA9IHN0cmVhbWluZ01ldGhvZC5icmFuY2hLZXlUb1N0cmVhbUlkTWFwLmZpbHRlcihmdW5jdGlvbihicmFuY2gpe1xuXHRcdFx0cmV0dXJuIGJyYW5jaC5zdHJlYW1JZCA9PT0gc3RyZWFtSWQ7XG5cdFx0fSlbMF07XG5cblx0XHRpZih0eXBlb2YgbmVlZGxlICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmVlZGxlLmtleSAhPT0gJ3N0cmluZycpe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZWVkbGUua2V5O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U3RyZWFtSWQoc3RyZWFtaW5nTWV0aG9kLCBicmFuY2hLZXkpe1xuXHRcdGlmKHR5cGVvZiBicmFuY2hLZXkgIT09ICdzdHJpbmcnKXtcblx0XHRcdGJyYW5jaEtleSA9ICcnO1xuXHRcdH1cblxuXHRcdHZhciBuZWVkbGVCcmFuY2ggPSBzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcC5maWx0ZXIoZnVuY3Rpb24oYnJhbmNoKXtcblx0XHRcdHJldHVybiBicmFuY2gua2V5ID09PSBicmFuY2hLZXk7XG5cdFx0fSlbMF07XG5cblx0XHR2YXIgc3RyZWFtSWQgPSAoIG5lZWRsZUJyYW5jaCA/IG5lZWRsZUJyYW5jaC5zdHJlYW1JZCA6IHVuZGVmaW5lZCApIDtcblxuXHRcdGlmKHR5cGVvZlx0c3RyZWFtSWQgIT09ICdzdHJpbmcnIHx8IHN0cmVhbUlkID09PSAnJyl7XG5cdFx0XHRzdHJlYW1JZCA9IGdlbmVyYXRlTmV3U3RyZWFtSWQoc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSk7XG5cdFx0XHRzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcC5wdXNoKHtrZXk6IGJyYW5jaEtleSwgc3RyZWFtSWQ6IHN0cmVhbUlkfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0cmVhbUlkO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVOZXdTdHJlYW1JZChzdHJlYW1pbmdNZXRob2ROYW1lKXtcblx0XHR2YXIgYXBwSW5mbyA9IGluc3RhbmNlLmluZm8oKTtcblxuXHRcdHZhciBuZXdTdHJlYW1JZCA9ICdzdHJlYW1JZC1qc2InXG5cdFx0XHQrICdfb2ZfJyArIHN0cmVhbWluZ01ldGhvZE5hbWUgKyAnXydcblx0XHRcdCsgJ19ieV8nICsgYXBwSW5mby5BcHBsaWNhdGlvbk5hbWUgKyAnXydcblx0XHRcdCsgaGVscGVycy5nZW5lcmF0ZVJhbmRvbSgpO1xuXG5cdFx0cmV0dXJuIG5ld1N0cmVhbUlkO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVqZWN0UmVxdWVzdChtc2csIHN0cmVhbWluZ01ldGhvZCwgcmVhc29uKXtcblx0XHRpZih0eXBlb2YgcmVhc29uICE9PSAnc3RyaW5nJyl7XG5cdFx0XHRyZWFzb24gPSAnJztcblx0XHR9XG5cblx0XHRzZW5kUmVzdWx0KHtcblx0XHRcdEV2ZW50U3RyZWFtQWN0aW9uOiAyLFxuXHRcdFx0RXZlbnRTdHJlYW1TdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QuZ2xvYmFsRXZlbnRTdHJlYW1TdWJqZWN0LFxuXHRcdFx0Ly9JbnZvY2F0aW9uSWQ6IG1zZy5Db250ZXh0Lkludm9jYXRpb25JZCxcblx0XHRcdE1ldGhvZE5hbWU6c3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSxcblx0XHRcdE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuXHRcdFx0TWV0aG9kUmVzcG9uc2VTdWJqZWN0OiBtc2cuTWV0aG9kUmVzcG9uc2VTdWJqZWN0LFxuXHRcdFx0TWV0aG9kVmVyc2lvbjogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuVmVyc2lvbixcblx0XHRcdFJlc3VsdE1lc3NhZ2U6IHJlYXNvbixcblx0XHRcdFNlcnZlcjogaW5zdGFuY2UuaW5mbygpLFxuXHRcdFx0U3RyZWFtSWQ6ICdkZWZhdWx0X3JlamVjdGlvbl9zdHJlYW1JZCdcblx0XHR9KTtcblx0fVxuXG5cdC8qKiAoc3Vic2NyaXB0aW9uKSBNZXRob2RzICovXG5cdGZ1bmN0aW9uIGNvbmp1cmVTdWJzY3JpcHRpb25Gcm9udE9iaihzdHJlYW1pbmdNZXRob2QsIHN1YnNjcmlwdGlvbil7XG5cdFx0Ly9leHBvc2UgYSBzdWJzY3JpcHRpb24gdG8gdGhlIHVzZXJcblx0XHRyZXR1cm4ge1xuXHRcdFx0YXJndW1lbnRzOiBzdWJzY3JpcHRpb24uYXJndW1lbnRzIHx8IHt9LFxuXHRcdFx0YnJhbmNoS2V5OiBzdWJzY3JpcHRpb24uYnJhbmNoS2V5LFxuXHRcdFx0Y2xvc2U6IGNsb3NlSW5kaXZpZHVhbFN1YnNjcmlwdGlvbi5iaW5kKFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRzdHJlYW1pbmdNZXRob2QsXG5cdFx0XHRcdHN1YnNjcmlwdGlvbi5zdHJlYW1JZCxcblx0XHRcdFx0c3Vic2NyaXB0aW9uLnByaXZhdGVFdmVudFN0cmVhbVN1YmplY3QsXG5cdFx0XHRcdHRydWVcblx0XHRcdCksXG5cdFx0XHRpbnN0YW5jZTogc3Vic2NyaXB0aW9uLmluc3RhbmNlLFxuXHRcdFx0cHVzaDogcHVzaERhdGFUb1NpbmdsZS5iaW5kKG51bGwsIHN0cmVhbWluZ01ldGhvZCwgc3Vic2NyaXB0aW9uKSxcblx0XHRcdHN0cmVhbTogc3RyZWFtaW5nTWV0aG9kLmRlZmluaXRpb25cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gY29uanVyZUJyYW5jaEZyb250T2JqKHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoS2V5KXtcblx0XHQvL2V4cG9zZSBhIGJyYW5jaCB0byB0aGUgdXNlclxuXHRcdHJldHVybiB7XG5cdFx0XHRrZXk6IGJyYW5jaEtleSxcblx0XHRcdHN1YnNjcmlwdGlvbnM6IGdldFN1YnNjcmlwdGlvbkxpc3QuYmluZChudWxsLCBzdHJlYW1pbmdNZXRob2QsIGJyYW5jaEtleSksXG5cdFx0XHRjbG9zZTogY2xvc2VNdWx0aXBsZVN1YnNjcmlwdGlvbnMuYmluZChudWxsLCBzdHJlYW1pbmdNZXRob2QsIGJyYW5jaEtleSksXG5cdFx0XHRwdXNoOiBmdW5jdGlvbihkYXRhKXsgcHVzaFRvQnJhbmNoKHN0cmVhbWluZ01ldGhvZCwgZGF0YSwgYnJhbmNoS2V5KSB9XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsb3NlSW5kaXZpZHVhbFN1YnNjcmlwdGlvbihzdHJlYW1pbmdNZXRob2QsIHN0cmVhbUlkLCBwcml2YXRlRXZlbnRTdHJlYW1TdWJqZWN0LCBzZW5kS2lja01lc3NhZ2Upe1xuXG5cdFx0dmFyIHN1YnNjcmlwdGlvbiA9IHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zLmZpbHRlciggZnVuY3Rpb24oc3ViSXRlbSkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0c3ViSXRlbS5wcml2YXRlRXZlbnRTdHJlYW1TdWJqZWN0ID09PSBwcml2YXRlRXZlbnRTdHJlYW1TdWJqZWN0XG5cdFx0XHRcdCYmIHN1Ykl0ZW0uc3RyZWFtSWQgPT09IHN0cmVhbUlkXG5cdFx0XHQpO1xuXHRcdH0pWzBdO1xuXG5cdFx0aWYgKHR5cGVvZiBzdWJzY3JpcHRpb24gIT09ICdvYmplY3QnKXtcblx0XHRcdHJldHVybjsgLy91bnJlY29nbmlzZWQgc3Vic2NyaXB0aW9uXG5cdFx0fVxuXG5cdFx0dmFyIGluaXRpYWxMZW5ndGggPSBzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG5cblx0XHRzdHJlYW1pbmdNZXRob2Quc3Vic2NyaXB0aW9ucyA9IHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zLmZpbHRlciggZnVuY3Rpb24oc3ViSXRlbSkge1xuXHRcdFx0cmV0dXJuICEoXG5cdFx0XHRcdHN1Ykl0ZW0ucHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdCA9PT0gc3Vic2NyaXB0aW9uLnByaXZhdGVFdmVudFN0cmVhbVN1YmplY3Rcblx0XHRcdFx0JiYgc3ViSXRlbS5zdHJlYW1JZCA9PT0gc3Vic2NyaXB0aW9uLnN0cmVhbUlkXG5cdFx0XHQpO1xuXHRcdH0pO1xuXG5cdFx0dmFyIGZpbHRlcmVkTGVuZ3RoID0gc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuXG5cdFx0aWYoIGZpbHRlcmVkTGVuZ3RoICE9PSAoaW5pdGlhbExlbmd0aCAtIDEpICl7XG5cdFx0XHRyZXR1cm47IC8vdGhlIHN1YnNjcmlwdGlvbiB3YXNuJ3QgcmVtb3ZlZFxuXHRcdH1cblxuXHRcdGlmKHNlbmRLaWNrTWVzc2FnZSA9PT0gdHJ1ZSl7XG5cdFx0XHRzZW5kUmVzdWx0KHtcblx0XHRcdFx0RXZlbnRTdHJlYW1BY3Rpb246IDIsXG5cdFx0XHRcdEV2ZW50U3RyZWFtU3ViamVjdDogcHJpdmF0ZUV2ZW50U3RyZWFtU3ViamVjdCxcblx0XHRcdFx0TWV0aG9kTmFtZTogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSxcblx0XHRcdFx0TWV0aG9kUmVxdWVzdFN1YmplY3Q6IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kUmVxdWVzdFN1YmplY3QsXG5cdFx0XHRcdE1ldGhvZFJlc3BvbnNlU3ViamVjdDogc3Vic2NyaXB0aW9uLm1ldGhvZFJlc3BvbnNlU3ViamVjdCxcblx0XHRcdFx0TWV0aG9kVmVyc2lvbjogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuVmVyc2lvbixcblx0XHRcdFx0UmVzcG9uc2VDb250ZXh0SnNvbjoge30sXG5cdFx0XHRcdFNlcnZlcjogaW5zdGFuY2UuaW5mbygpLFxuXHRcdFx0XHRTdHJlYW1JZDogc3Vic2NyaXB0aW9uLnN0cmVhbUlkLFxuXHRcdFx0XHRTdGF0dXM6MFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIHN1YlJlbW92ZWRIYW5kbGVyID0gc3RyZWFtaW5nTWV0aG9kLnN0cmVhbUNhbGxiYWNrcy5zdWJzY3JpcHRpb25SZW1vdmVkSGFuZGxlcjtcblx0XHRpZih0eXBlb2Ygc3ViUmVtb3ZlZEhhbmRsZXIgPT09ICdmdW5jdGlvbicpe1xuXHRcdFx0dmFyIHN1YnNjcmliZXIgPSBzdWJzY3JpcHRpb24uaW5zdGFuY2U7XG5cdFx0XHRzdWJSZW1vdmVkSGFuZGxlcihzdWJzY3JpYmVyKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNsb3NlTXVsdGlwbGVTdWJzY3JpcHRpb25zKHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoS2V5KXtcblx0XHRpZih0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kICE9PSAnb2JqZWN0JyB8fCAhQXJyYXkuaXNBcnJheShzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcCkpe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzdHJlYW1MaXN0ID0gc3RyZWFtaW5nTWV0aG9kLmJyYW5jaEtleVRvU3RyZWFtSWRNYXA7XG5cblx0XHRpZih0eXBlb2YgYnJhbmNoS2V5ID09PSAnc3RyaW5nJyl7XG5cdFx0XHRzdHJlYW1MaXN0ID0gc3RyZWFtaW5nTWV0aG9kLmJyYW5jaEtleVRvU3RyZWFtSWRNYXAuZmlsdGVyKGZ1bmN0aW9uKGJyKXtcblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGJyID09PSAnb2JqZWN0JyAmJiBici5rZXkgPT09IGJyYW5jaEtleSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly9UT0RPOiBjb25zaWRlciBnZXR0aW5nIHRoZSB1bmlxdWUgYnJhbmNoIGtleXMgZnJvbSAnbGl2ZSBzdWJzY3JpYmVycydcblxuXHRcdHN0cmVhbUxpc3QuZm9yRWFjaChmdW5jdGlvbihicil7XG5cdFx0XHR2YXIgc3RyZWFtSWQgPSBici5zdHJlYW1JZDtcblxuXHRcdFx0c2VuZFJlc3VsdCh7XG5cdFx0XHRcdEV2ZW50U3RyZWFtQWN0aW9uOiAyLFxuXHRcdFx0XHRFdmVudFN0cmVhbVN1YmplY3Q6IHN0cmVhbWluZ01ldGhvZC5nbG9iYWxFdmVudFN0cmVhbVN1YmplY3QsXG5cdFx0XHRcdE1ldGhvZE5hbWU6IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kLk5hbWUsXG5cdFx0XHRcdE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuXHRcdFx0XHRTZXJ2ZXI6IGluc3RhbmNlLmluZm8oKSxcblx0XHRcdFx0U3RyZWFtSWQ6IHN0cmVhbUlkLFxuXHRcdFx0XHRTdGF0dXM6IDBcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gcHVzaERhdGFUb1NpbmdsZShzdHJlYW1pbmdNZXRob2QsIHN1YnNjcmlwdGlvbiwgZGF0YSl7XG5cblx0XHQvL1RPRE8gdmFsaWRhdGUgZGF0YSBpcyBhIHBsYWluIG9iamVjdFxuXHRcdGlmKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jyl7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzLiBEYXRhIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuXHRcdH1cblxuXHRcdHNlbmRSZXN1bHQoe1xuXHRcdFx0RXZlbnRTdHJlYW1BY3Rpb246IDUsXG5cdFx0XHRFdmVudFN0cmVhbVN1YmplY3Q6IHN1YnNjcmlwdGlvbi5wcml2YXRlRXZlbnRTdHJlYW1TdWJqZWN0LFxuXHRcdFx0TWV0aG9kTmFtZTogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSxcblx0XHRcdE1ldGhvZFJlcXVlc3RTdWJqZWN0OiBzdHJlYW1pbmdNZXRob2QubWV0aG9kLk1ldGhvZFJlcXVlc3RTdWJqZWN0LFxuXHRcdFx0UmVzdWx0Q29udGV4dEpzb246IGRhdGEsXG5cdFx0XHRTZXJ2ZXI6IGluc3RhbmNlLmluZm8oKSxcblx0XHRcdFN0cmVhbUlkOiBzdWJzY3JpcHRpb24uc3RyZWFtSWRcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHB1c2hUb0JyYW5jaChzdHJlYW1pbmdNZXRob2QsIGRhdGEsIGJyYW5jaGVzKXtcblx0XHRpZih0eXBlb2Ygc3RyZWFtaW5nTWV0aG9kICE9PSAnb2JqZWN0JyB8fCAhQXJyYXkuaXNBcnJheShzdHJlYW1pbmdNZXRob2QuYnJhbmNoS2V5VG9TdHJlYW1JZE1hcCkpe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vVE9ETyB2YWxpZGF0ZSBkYXRhIGlzIGEgcGxhaW4gb2JqZWN0XG5cdFx0aWYodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKXtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMuIERhdGEgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIGJyYW5jaGVzID09PSAnc3RyaW5nJyl7XG5cdFx0XHRicmFuY2hlcyA9IFticmFuY2hlc107IC8vdXNlciB3YW50cyB0byBwdXNoIHRvIHNpbmdsZSBicmFuY2hcblx0XHR9IGVsc2UgaWYoIUFycmF5LmlzQXJyYXkoYnJhbmNoZXMpIHx8IGJyYW5jaGVzLmxlbmd0aCA8PSAwKXtcblx0XHRcdGJyYW5jaGVzID0gbnVsbDtcblx0XHR9XG5cblx0XHQvL2dldCB0aGUgU3RyZWFtSWQncyBmcm9tIHRoZSBtZXRob2QncyBicmFuY2ggbWFwXG5cdFx0dmFyIHN0cmVhbUlkTGlzdCA9IHN0cmVhbWluZ01ldGhvZC5icmFuY2hLZXlUb1N0cmVhbUlkTWFwXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKGJyKXtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRicmFuY2hlcyA9PT0gbnVsbFxuXHRcdFx0XHRcdHx8ICggISFiciAmJiB0eXBlb2YgYnIua2V5ID09PSAnc3RyaW5nJyAmJiBicmFuY2hlcy5pbmRleE9mKGJyLmtleSkgPj0gMCApXG5cdFx0XHRcdCk7XG5cdFx0XHR9KS5tYXAoZnVuY3Rpb24oYnIpe1xuXHRcdFx0XHRyZXR1cm4gYnIuc3RyZWFtSWQ7XG5cdFx0XHR9KTtcblxuXHRcdHN0cmVhbUlkTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW1JZCkge1xuXG5cdFx0XHRzZW5kUmVzdWx0KHtcblx0XHRcdFx0RXZlbnRTdHJlYW1BY3Rpb246IDUsXG5cdFx0XHRcdEV2ZW50U3RyZWFtU3ViamVjdDogc3RyZWFtaW5nTWV0aG9kLmdsb2JhbEV2ZW50U3RyZWFtU3ViamVjdCxcblx0XHRcdFx0TWV0aG9kTmFtZTogc3RyZWFtaW5nTWV0aG9kLm1ldGhvZC5NZXRob2QuTmFtZSxcblx0XHRcdFx0TWV0aG9kUmVxdWVzdFN1YmplY3Q6IHN0cmVhbWluZ01ldGhvZC5tZXRob2QuTWV0aG9kUmVxdWVzdFN1YmplY3QsXG5cdFx0XHRcdFJlc3VsdENvbnRleHRKc29uOiBkYXRhLFxuXHRcdFx0XHRTZXJ2ZXI6IGluc3RhbmNlLmluZm8oKSxcblx0XHRcdFx0U3RyZWFtSWQ6IHN0cmVhbUlkXG5cdFx0XHR9KTtcblxuXHRcdH0pO1xuXG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbkxpc3Qoc3RyZWFtaW5nTWV0aG9kLCBicmFuY2hLZXkpe1xuXHRcdGlmKHR5cGVvZiBzdHJlYW1pbmdNZXRob2QgIT09ICdvYmplY3QnKXtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0XHR2YXIgc3Vic2NyaXB0aW9ucyA9IFtdO1xuXG5cdFx0aWYodHlwZW9mIGJyYW5jaEtleSAhPT0gJ3N0cmluZycpe1xuXHRcdFx0c3Vic2NyaXB0aW9ucyA9IHN0cmVhbWluZ01ldGhvZC5zdWJzY3JpcHRpb25zO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdWJzY3JpcHRpb25zID0gc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMuZmlsdGVyKGZ1bmN0aW9uKHN1Yil7XG5cdFx0XHRcdHJldHVybiBzdWIuYnJhbmNoS2V5ID09PSBicmFuY2hLZXk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3Vic2NyaXB0aW9ucy5tYXAoZnVuY3Rpb24oc3ViKXtcblx0XHRcdHJldHVybiBjb25qdXJlU3Vic2NyaXB0aW9uRnJvbnRPYmooc3RyZWFtaW5nTWV0aG9kLCBzdWIpO1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0QnJhbmNoTGlzdChzdHJlYW1pbmdNZXRob2Qpe1xuXHRcdGlmKHR5cGVvZiBzdHJlYW1pbmdNZXRob2QgIT09ICdvYmplY3QnKXtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0XHR2YXIgdW5pcXVlQnJhbmNoTmFtZXMgPSBnZXRVbmlxdWVCcmFuY2hOYW1lcyhzdHJlYW1pbmdNZXRob2QpO1xuXG5cdFx0cmV0dXJuIHVuaXF1ZUJyYW5jaE5hbWVzLm1hcChmdW5jdGlvbihicmFuY2hLZXkpe1xuXG5cdFx0XHRyZXR1cm4gY29uanVyZUJyYW5jaEZyb250T2JqKHN0cmVhbWluZ01ldGhvZCwgYnJhbmNoS2V5KTtcblxuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VW5pcXVlQnJhbmNoTmFtZXMoc3RyZWFtaW5nTWV0aG9kKXtcblx0XHR2YXIga2V5c1dpdGhEdXBsaWNhdGVzID0gc3RyZWFtaW5nTWV0aG9kLnN1YnNjcmlwdGlvbnMubWFwKGZ1bmN0aW9uKHN1Yil7XG5cdFx0XHR2YXIgcmVzdWx0ID0gbnVsbDtcblx0XHRcdGlmKHR5cGVvZiBzdWIgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzdWIuYnJhbmNoS2V5ID09PSAnc3RyaW5nJyl7XG5cdFx0XHRcdHJlc3VsdCA9IHN1Yi5icmFuY2hLZXk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0pO1xuXG5cdFx0dmFyIHNlZW4gPSBbXTtcblxuXHRcdHZhciBicmFuY2hBcnJheSA9IGtleXNXaXRoRHVwbGljYXRlcy5maWx0ZXIoZnVuY3Rpb24oYktleSkge1xuXHRcdFx0aWYoYktleSA9PT0gbnVsbCB8fCBzZWVuLmluZGV4T2YoYktleSkgPj0gMCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRzZWVuLnB1c2goYktleSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBicmFuY2hBcnJheTtcblx0fVxuXG5cdHJldHVybiB7IC8vYW4gaW5zdGFuY2UgZm8gdGhlIHB1Ymxpc2hlclxuXHRcdGlzU3RyZWFtTXNnOiBpc1N0cmVhbU1zZ0ZvclN0cmVhbWluZ01ldGhvZCxcblx0XHRwcm9jZXNzU3Vic2NyaWJlck1zZzogcHJvY2Vzc1N1YnNjcmliZXJNc2csXG5cdFx0cHVzaERhdGE6IHB1c2hUb0JyYW5jaCxcblx0XHRjbG9zZUFsbFN1YnNjcmlwdGlvbnM6IGNsb3NlTXVsdGlwbGVTdWJzY3JpcHRpb25zLFxuXHRcdGdldFN1YnNjcmlwdGlvbkxpc3Q6Z2V0U3Vic2NyaXB0aW9uTGlzdCxcblx0XHRnZXRCcmFuY2hMaXN0OiBnZXRCcmFuY2hMaXN0LFxuXHRcdGdlbmVyYXRlTmV3U3RyZWFtSWQ6IGdlbmVyYXRlTmV3U3RyZWFtSWRcblx0fTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIFwidGljazQyLWFnbUAyLjMuMVwiLFxuICAgICAgXCJDOlxcXFx3b3JrXFxcXHN0YXNoXFxcXEdMVUUtZGV2XFxcXGpzLWdsdWVcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcInRpY2s0Mi1hZ21AMi4zLjFcIixcbiAgXCJfaWRcIjogXCJ0aWNrNDItYWdtQDIuMy4xXCIsXG4gIFwiX2luQ2FjaGVcIjogdHJ1ZSxcbiAgXCJfaW5zdGFsbGFibGVcIjogdHJ1ZSxcbiAgXCJfbG9jYXRpb25cIjogXCIvdGljazQyLWFnbVwiLFxuICBcIl9ub2RlVmVyc2lvblwiOiBcIjYuMy4wXCIsXG4gIFwiX25wbVVzZXJcIjoge30sXG4gIFwiX25wbVZlcnNpb25cIjogXCIzLjguNVwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwidGljazQyLWFnbVwiLFxuICAgIFwicmF3XCI6IFwidGljazQyLWFnbUAyLjMuMVwiLFxuICAgIFwicmF3U3BlY1wiOiBcIjIuMy4xXCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcIjIuMy4xXCIsXG4gICAgXCJ0eXBlXCI6IFwidmVyc2lvblwiXG4gIH0sXG4gIFwiX3JlcXVpcmVkQnlcIjogW1xuICAgIFwiL1wiXG4gIF0sXG4gIFwiX3NoYXN1bVwiOiBcIjBmOWEyZWY0MTdjZGE3Njg0YjczZGQwNTVhYmM3NzQ5MGI5ODg2NDZcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwidGljazQyLWFnbUAyLjMuMVwiLFxuICBcIl93aGVyZVwiOiBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcanMtZ2x1ZVwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiVGljazQyXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwOi8vd3d3LnRpY2s0Mi5jb21cIlxuICB9LFxuICBcImJpblwiOiB7XG4gICAgXCJhZ21cIjogXCJiaW4vYWdtXCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vamlyYS50aWNrNDIuY29tL2Jyb3dzZS9BUFBDVFJMXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiZXM2LXByb21pc2VcIjogXCJeMy4wLjJcIixcbiAgICBcImlucXVpcmVyXCI6IFwiXjAuOC41XCIsXG4gICAgXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCI6IFwiXjEuMS4yXCIsXG4gICAgXCJ1dGlsLWRlcHJlY2F0ZVwiOiBcIl4xLjAuMlwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJKYXZhU2NyaXB0IEFHTVwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJibGFua2V0XCI6IFwiXjEuMS42XCIsXG4gICAgXCJibHVlYmlyZFwiOiBcIl4yLjkuMzBcIixcbiAgICBcImJyb3dzZXJpZnktdmVyc2lvbmlmeVwiOiBcIl4xLjAuNlwiLFxuICAgIFwiZ3J1bnRcIjogXCJeMC40LjVcIixcbiAgICBcImdydW50LWJyb3dzZXJpZnlcIjogXCJeMy4zLjBcIixcbiAgICBcImdydW50LWNsaVwiOiBcIl4wLjEuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1jbGVhblwiOiBcIl4wLjYuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1jb25uZWN0XCI6IFwiXjAuOS4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIl4wLjExLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItcXVuaXRcIjogXCJeMC41LjJcIixcbiAgICBcImdydW50LWNvbnRyaWItdWdsaWZ5XCI6IFwiXjAuNi4wXCIsXG4gICAgXCJncnVudC1jb250cmliLXdhdGNoXCI6IFwiXjAuNi4xXCIsXG4gICAgXCJncnVudC1leG9yY2lzZVwiOiBcIl4xLjAuMFwiLFxuICAgIFwicGhhbnRvbWpzXCI6IFwiXjEuOS4xMlwiLFxuICAgIFwicXVuaXRqc1wiOiBcIl4xLjE1LjBcIixcbiAgICBcInVnbGlmeWlmeVwiOiBcIl4zLjAuMVwiXG4gIH0sXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCIwZjlhMmVmNDE3Y2RhNzY4NGI3M2RkMDU1YWJjNzc0OTBiOTg4NjQ2XCIsXG4gICAgXCJ0YXJiYWxsXCI6IFwiaHR0cDovLzE5Mi4xNjguMC4yMzQ6NDg3My90aWNrNDItYWdtLy0vdGljazQyLWFnbS0yLjMuMS50Z3pcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCJmMzNmYjhlZDRhNTY4MzJhN2IwY2RiOWI2NzcxNzU3MTg2OGQyN2NiXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiYWdtXCIsXG4gICAgXCJqYXZhc2NyaXB0XCIsXG4gICAgXCJsaWJyYXJ5XCJcbiAgXSxcbiAgXCJtYWluXCI6IFwibGlicmFyeS9hZ20uanNcIixcbiAgXCJuYW1lXCI6IFwidGljazQyLWFnbVwiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwibnBtIGluc3RhbGwgJiYgZ3J1bnRcIixcbiAgICBcInByZXB1Ymxpc2hcIjogXCJncnVudFwiLFxuICAgIFwic3RhcnRcIjogXCJncnVudCB3YXRjaFwiLFxuICAgIFwidGVzdFwiOiBcImdydW50IHF1bml0XCJcbiAgfSxcbiAgXCJ0aXRsZVwiOiBcIlRpY2s0MiBBR01cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMi4zLjFcIlxufVxuIiwidmFyIGFwcGxpY2F0aW9uID0gcmVxdWlyZShcIi4vYXBwbGljYXRpb25cIik7XG52YXIgaW5zdGFuY2UgPSByZXF1aXJlKFwiLi9pbnN0YW5jZVwiKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuYXBwX21hbmFnZXIgPSBmdW5jdGlvbiBhcHBfbWFuYWdlcihhZ20sIHdpbmRvd3MpIHtcblxuXHR2YXIgYXBwcyA9IGFwcGxpY2F0aW9uKGFnbSwgZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBpbnN0YW5jZXM7XG5cdH0pO1xuXHR2YXIgaW5zdGFuY2VzID0gaW5zdGFuY2UoYWdtLCBhcHBzKTtcblx0dmFyIG1hbmFnZXIgPSB7XG5cdFx0YXBwbGljYXRpb25zOiBhcHBzLmFsbCxcblx0XHRhcHBsaWNhdGlvbjogYXBwcy5nZXRfYnlfaWQsXG5cdFx0b25fYXBwX2FkZGVkOiBoZWxwZXJzLmFkZF9jYWxsYmFjayhcImFkZGVkXCIpLmJpbmQoYXBwcyksXG5cdFx0b25fYXBwX2F2YWlsYWJsZTogaGVscGVycy5hZGRfY2FsbGJhY2soXCJhdmFpbGFibGVcIikuYmluZChhcHBzKSxcblx0XHRvbl9hcHBfcmVtb3ZlZDogaGVscGVycy5hZGRfY2FsbGJhY2soXCJyZW1vdmVkXCIpLmJpbmQoYXBwcyksXG5cdFx0b25fYXBwX3VuYXZhaWxhYmxlOiBoZWxwZXJzLmFkZF9jYWxsYmFjayhcInVuYXZhaWxhYmxlXCIpLmJpbmQoYXBwcyksXG5cblx0XHRpbnN0YW5jZXM6IGluc3RhbmNlcy5hbGwsXG5cdFx0b25faW5zdGFuY2Vfc3RhcnRlZDogaGVscGVycy5hZGRfY2FsbGJhY2soXCJzdGFydGVkXCIpLmJpbmQoaW5zdGFuY2VzKSxcblx0XHRvbl9pbnN0YW5jZV9zdG9wcGVkOiBoZWxwZXJzLmFkZF9jYWxsYmFjayhcInN0b3BwZWRcIikuYmluZChpbnN0YW5jZXMpLFxuXHRcdG9uX2luc3RhbmNlX3VwZGF0ZWQ6IGhlbHBlcnMuYWRkX2NhbGxiYWNrKFwidXBkYXRlZFwiKS5iaW5kKGluc3RhbmNlcyksXG5cblx0XHRnZXRfYnJhbmNoZXM6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0QnJhbmNoZXNcIiwge30sIFwiYmVzdFwiLCB7fSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKHN1Y2Nlc3MpIHtcblx0XHRcdFx0XHRzdWNjZXNzKGhlbHBlcnMudmFscyhlLnJldHVybmVkLkJyYW5jaGVzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGVycm9yKTtcblx0XHR9LFxuXHRcdGdldF9jdXJyZW50X2JyYW5jaDogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5HZXRDdXJyZW50QnJhbmNoXCIsIHt9LCBcImJlc3RcIiwge30sIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmIChzdWNjZXNzKSB7XG5cdFx0XHRcdFx0c3VjY2VzcyhlLnJldHVybmVkLkJyYW5jaCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGVycm9yKTtcblx0XHR9LFxuXHRcdHNldF9jdXJyZW50X2JyYW5jaDogZnVuY3Rpb24gKGJyYW5jaCwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLlNldEN1cnJlbnRCcmFuY2hcIiwge0JyYW5jaDogYnJhbmNofSwgXCJiZXN0XCIsIHt9LCBzdWNjZXNzLCBlcnJvcik7XG5cdFx0fSxcblx0XHRjdXJyZW50X3VzZXI6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0VXNlclwiLCB7fSwgXCJiZXN0XCIsIHt9LCBzdWNjZXNzLCBlcnJvcik7XG5cdFx0fSxcblx0XHRnZXRfZnVuY3Rpb25hbF9lbnRpdGxlbWVudDogZnVuY3Rpb24gKGZuLCBzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0RnVuY3Rpb25hbEVudGl0bGVtZW50XCIsIHtGdW5jdGlvbjogZm59LCBcImJlc3RcIiwge30sIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmIChzdWNjZXNzKSB7XG5cdFx0XHRcdFx0c3VjY2VzcyhlLnJldHVybmVkLkVudGl0bGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgZXJyb3IpO1xuXHRcdH0sXG5cdFx0Z2V0X2Z1bmN0aW9uYWxfZW50aXRsZW1lbnRfYnJhbmNoOiBmdW5jdGlvbiAoZm4sIGJyLCBzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5BQ1MuR2V0RnVuY3Rpb25hbEVudGl0bGVtZW50XCIsIHtGdW5jdGlvbjogZm4sIEJyYW5jaDogYnJ9LCBcImJlc3RcIiwge30sIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmIChzdWNjZXNzKSB7XG5cdFx0XHRcdFx0c3VjY2VzcyhlLnJldHVybmVkLkVudGl0bGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgZXJyb3IpO1xuXHRcdH0sXG5cdFx0Y2FuX2k6IGZ1bmN0aW9uIChmbiwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkNhbklcIiwge0Z1bmN0aW9uOiBmbn0sIFwiYmVzdFwiLCB7fSwgc3VjY2VzcywgZXJyb3IpO1xuXHRcdH0sXG5cblx0XHRjYW5faV9icmFuY2g6IGZ1bmN0aW9uKGZuLCBicmFuY2gsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5DYW5JXCIsIHtGdW5jdGlvbjogZm4sIEJyYW5jaDogYnJhbmNofSwgXCJiZXN0XCIsIHt9LCBzdWNjZXNzLCBlcnJvcik7XG5cdFx0fSxcblxuXHRcdGV4aXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLlNodXRkb3duXCIsIHt9LCBcImFsbFwiLCB7fSxcblx0XHRcdFx0ZnVuY3Rpb24gKGEpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhhKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhlKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHNldF9yZWdpb246IGZ1bmN0aW9uIChyZWdpb24sIHN1Y2Nlc3MsIGVycm9yKXtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLlNldENvbmZpZ3VyYXRpb25SZWdpb25cIiwge1JlZ2lvbjogcmVnaW9ufSwgXCJiZXN0XCIsIHt9LCBzdWNjZXNzLCBlcnJvcik7XG5cdFx0fSxcblxuXHRcdGdldF9yZWdpb246IGZ1bmN0aW9uKHN1Y2Nlc3MsIGVycm9yKXtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkdldENvbmZpZ3VyYXRpb25SZWdpb25cIiwge30sIFwiYmVzdFwiLCB7fSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKHN1Y2Nlc3MpIHtcblx0XHRcdFx0XHRzdWNjZXNzKGUucmV0dXJuZWQuUmVnaW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgZXJyb3IpO1xuXHRcdH0sXG5cblx0XHRfdHJpZ2dlcl9hcHBfZXZlbnQ6IGFwcHMuX3RyaWdnZXIsXG5cdFx0X3RyaWdnZXJfaW5zdGFuY2VfZXZlbnQ6IGluc3RhbmNlcy5fdHJpZ2dlclxuXG5cdH07XG5cblx0ZnVuY3Rpb24gY2FsbF93aXRoKHByb3AsIGZ1bmMpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0ZnVuYyhyZXN1bHRbcHJvcF0pO1xuXHRcdH07XG5cblx0fVxuXHQvL0NyZWF0ZSBldmVudCBiaW5kaW5nc1xuXG5cdC8vVGVsbCB0aGUgYXBwIHdoZW4gaXRzIGluc3RhbmNlcyBhcmUgYWRkZWQvcmVtb3ZlZFxuXG5cdG1hbmFnZXIub25faW5zdGFuY2Vfc3RhcnRlZChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHRpZiAoaW5zdGFuY2UuYXBwbGljYXRpb24pIHtcblx0XHRcdC8vVHJpZ2dlciBcImluc3RhbmNlX3N0YXJ0ZWRcIiBldmVudCBvbiBhcHBsaWNhdGlvblxuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9hcHBfZXZlbnQoXCJpbnN0YW5jZV9zdGFydGVkXCIsIGluc3RhbmNlLCBpbnN0YW5jZS5hcHBsaWNhdGlvbi5uYW1lKTtcblxuXHRcdFx0Ly9UcmlnZ2VyIFwid2luZG93X29wZW5lZFwiIGV2ZW50IG9uIGluc3RhbmNlXG5cdFx0XHR2YXIgY29udGFpbmVyO1xuXHRcdFx0aWYgKHdpbmRvd3MpIHtcblx0XHRcdFx0dmFyIGlkID0gKGluc3RhbmNlLmNvbnRleHQgJiYgaW5zdGFuY2UuY29udGV4dC5ndWlkKSA/IGluc3RhbmNlLmNvbnRleHQuZ3VpZCA6IGluc3RhbmNlLmlkO1xuXHRcdFx0XHRjb250YWluZXIgPSBpbnN0YW5jZS5hcHBsaWNhdGlvbi5jb25maWd1cmF0aW9uLmNvbnRhaW5lcjtcblx0XHRcdFx0Z2x1ZS5hZ20uaW52b2tlKFwiVDQyLlduZC5GaW5kQnlJZFwiLCB7d2luZG93SWQ6IGluc3RhbmNlLmlkfSwge2FwcGxpY2F0aW9uOiBjb250YWluZXJ9LCB7fSwgd2luZG93X29wZW5lZCwgZnVuY3Rpb24oZSl7Y29uc29sZS5sb2coZSl9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3aW5kb3dfb3BlbmVkKGEpIHtcblx0XHRcdC8vV3JhcCB0aGUgd2luZG93IGluIGEgd2luZG93IG9iamVjdCwgdXNpbmcgdGhlIGdsdWUgd2luZG93cyBsaWJcblx0XHRcdHZhciB3ID0gYS5yZXR1cm5lZCBbT2JqZWN0LmtleXMoYS5yZXR1cm5lZClbMF1dO1xuXHRcdFx0dmFyIHdpbiA9IGdsdWUud2luZG93cy5fZnJvbV9ldmVudCh3LndpbmRvd05hbWUsIGNvbnRhaW5lciwgdy51cmwsIHcud2luZG93SWQsIHcud2luZG93U3R5bGVBdHRyaWJ1dGVzLCB3LndpbmRvd1RpdGxlKTtcblxuXHRcdFx0Ly9UcmlnZ2VyIHRoZSB3aW5kb3cgb3BlbmVkIGV2ZW50XG5cdFx0XHRtYW5hZ2VyLl90cmlnZ2VyX2luc3RhbmNlX2V2ZW50KFwid2luZG93X2FkZGVkXCIsIHdpbiwgaWQpO1xuXHRcdH1cblx0fSk7XG5cblx0bWFuYWdlci5vbl9pbnN0YW5jZV9zdG9wcGVkKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHRcdGlmIChpbnN0YW5jZS5hcHBsaWNhdGlvbikge1xuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9hcHBfZXZlbnQoXCJpbnN0YW5jZV9zdG9wcGVkXCIsIGluc3RhbmNlLCBpbnN0YW5jZS5hcHBsaWNhdGlvbi5uYW1lKTtcblxuXHRcdFx0dmFyIGlkID0gKGluc3RhbmNlLmNvbnRleHQgJiYgaW5zdGFuY2UuY29udGV4dC5ndWlkKSA/IGluc3RhbmNlLmNvbnRleHQuZ3VpZCA6IGluc3RhbmNlLmlkO1xuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9pbnN0YW5jZV9ldmVudChcIndpbmRvd19yZW1vdmVkXCIsIHt9LCBpZCk7XG5cblx0XHR9XG5cdH0pO1xuXG5cdG1hbmFnZXIub25faW5zdGFuY2VfdXBkYXRlZChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcblx0XHRpZiAoaW5zdGFuY2UuYXBwbGljYXRpb24pIHtcblx0XHQvLyBtYW5hZ2VyLl90cmlnZ2VyX2FwcF9ldmVudChcImluc3RhbmNlX3N0b3BwZWRcIiwgaW5zdGFuY2UsIGluc3RhbmNlLmFwcGxpY2F0aW9uLm5hbWUpO1xuXG5cdFx0Ly8gdmFyIGlkID0gKGluc3RhbmNlLmNvbnRleHQgJiYgaW5zdGFuY2UuY29udGV4dC5ndWlkKSA/IGluc3RhbmNlLmNvbnRleHQuZ3VpZCA6IGluc3RhbmNlLmlkO1xuXHRcdC8vIG1hbmFnZXIuX3RyaWdnZXJfaW5zdGFuY2VfZXZlbnQoXCJ0aXRsZV9jaGFuZ2VkXCIsIHt9LCBpZCk7XG5cdFx0fVxuXHR9KTtcblx0Ly9XaGVuIGFuIGFwcCBpcyByZW1vdmVkLCByZW1vdmUgYWxzbyBpdHMgaW5zdGFuY2VzXG5cblx0bWFuYWdlci5vbl9hcHBfcmVtb3ZlZChmdW5jdGlvbiAoYXBwKSB7XG5cdFx0YXBwLmluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXHRcdFx0dmFyIGlkID0gKGluc3RhbmNlLmNvbnRleHQgJiYgaW5zdGFuY2UuY29udGV4dC5ndWlkKSA/IGluc3RhbmNlLmNvbnRleHQuZ3VpZCA6IGluc3RhbmNlLmlkO1xuXHRcdFx0bWFuYWdlci5fdHJpZ2dlcl9pbnN0YW5jZV9ldmVudChcInN0b3BwZWRcIiwge30sIGlkKTtcblx0XHR9KTtcblx0fSk7XG5cdHZhciBicmFuY2hfY2hhbmdlZF9jYWxsYmFjaztcblx0bWFuYWdlci5vbl9icmFuY2hlc19jaGFuZ2VkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0YnJhbmNoX2NoYW5nZWRfY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0fTtcblxuXHRmdW5jdGlvbiBvbl9icmFuY2hfY2hhbmdlZChlKSB7XG5cdFx0aWYgKHR5cGVvZiBicmFuY2hfY2hhbmdlZF9jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRicmFuY2hfY2hhbmdlZF9jYWxsYmFjayhoZWxwZXJzLnZhbHMoZSkpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZV9hcHBfcmVhZHkoYXBwKSB7XG5cdFx0aWYgKGFwcC5Jc1JlYWR5KSB7XG5cdFx0XHRtYW5hZ2VyLl90cmlnZ2VyX2FwcF9ldmVudChcImF2YWlsYWJsZVwiLCBhcHApO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1hbmFnZXIuX3RyaWdnZXJfYXBwX2V2ZW50KFwidW5hdmFpbGFibGVcIiwgYXBwKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBfZmFpbGVkKGUpIHtcblx0XHRtYW5hZ2VyLl90cmlnZ2VyX2luc3RhbmNlX2V2ZW50KFwiZXJyb3JcIiwgZSwgZS5Db250ZXh0Lmd1aWQpO1xuXHR9XG5cblx0aWYgKGFnbSAmJiBhZ20uc3Vic2NyaWJlKSB7XG5cblx0XHRtYW5hZ2VyLmFnbSA9IGFnbTtcblx0XHR2YXIgaGFuZGxlcnMgPSBbXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvbkFkZGVkXCIsIHRyaWdnZXI6IFwiYWRkZWRcIiwgb246IGFwcHN9LFxuXHRcdFx0e2V2ZW50OiBcIk9uQXBwbGljYXRpb25SZW1vdmVkXCIsIHRyaWdnZXI6IFwicmVtb3ZlZFwiLCBvbjogYXBwc30sXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvbkNoYW5nZWRcIiwgdHJpZ2dlcjogXCJjaGFuZ2VkXCIsIG9uOiBhcHBzfSxcblx0XHRcdHtldmVudDogXCJPbkFwcGxpY2F0aW9uU3RhcnRlZFwiLCB0cmlnZ2VyOiBcInN0YXJ0ZWRcIiwgb246IGluc3RhbmNlc30sXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvblN0b3BwZWRcIiwgdHJpZ2dlcjogXCJzdG9wcGVkXCIsIG9uOiBpbnN0YW5jZXN9LFxuXHRcdFx0e2V2ZW50OiBcIk9uQXBwbGljYXRpb25VcGRhdGVkXCIsIHRyaWdnZXI6IFwidXBkYXRlZFwiLCBvbjogaW5zdGFuY2VzfSxcblx0XHRcdHtldmVudDogXCJPbkFwcGxpY2F0aW9uQWdtU2VydmVyUmVhZHlcIiwgdHJpZ2dlcjogXCJhZ21fcmVhZHlcIiwgb246IGluc3RhbmNlc30sXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvblJlYWR5XCIsIGZ1bmM6IGhhbmRsZV9hcHBfcmVhZHl9LFxuXHRcdFx0e2V2ZW50OiBcIk9uQnJhbmNoZXNNb2RpZmllZFwiLCBmdW5jOiBvbl9icmFuY2hfY2hhbmdlZH0sXG5cdFx0XHR7ZXZlbnQ6IFwiT25BcHBsaWNhdGlvblN0YXJ0RmFpbGVkXCIsIHJhd19mdW5jOiBhcHBfZmFpbGVkfVxuXHRcdF07XG5cbiAgICAgICAgIGFnbS5zZXJ2ZXJNZXRob2RBZGRlZChmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICAgICAgIGlmICgocmVzcC5zZXJ2ZXIuYXBwbGljYXRpb24uaW5kZXhPZignQXBwTWFuYWdlcicpICE9PSAtMSAmJiByZXNwLm1ldGhvZC5uYW1lLmluZGV4T2YoJ1Q0Mi5BQ1MuT25FdmVudCcpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBhZ20uc3Vic2NyaWJlKFwiVDQyLkFDUy5PbkV2ZW50XCIsIHt0YXJnZXQ6IFwiYWxsXCJ9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ub25EYXRhKGZ1bmN0aW9uIChzdHJlYW1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHN0cmVhbURhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RzID0gZXZlbnRzW2hhbmRsZXIuZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0cykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYXdfZnVuYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5yYXdfZnVuYyhvYmplY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcnMudmFscyhvYmplY3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5vbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIub24uX3RyaWdnZXIoaGFuZGxlci50cmlnZ2VyLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuZnVuYyhvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICB9KTtcblx0fVxuXG5cdG1hbmFnZXIudmVyc2lvbiA9IFwiMi4zLjFcIjtcblxuXHRyZXR1cm4gbWFuYWdlcjtcbn07XG5cbmdsb2JhbC50aWNrNDIgPSBnbG9iYWwudGljazQyIHx8e307XG5nbG9iYWwudGljazQyLmFwcF9tYW5hZ2VyID0gZ2xvYmFsLmFwcF9tYW5hZ2VyO1xuIiwidmFyIGV2ZW50X21hbmFnZXIgPSByZXF1aXJlKFwiLi9ldmVudF9tYW5hZ2VyXCIpO1xyXG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFnbSwgaW5zdGFuY2VzKSB7XHJcblx0dmFyIGFwcF9wcm90byA9IGhlbHBlcnMuYWRkX2NhbGxiYWNrcyh7XHJcblxyXG5cdFx0c3RhcnQ6IGZ1bmN0aW9uIChwYXJhbXMsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcblx0XHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcclxuXHRcdFx0cGFyYW1zLmd1aWQgPSBwYXJhbXMuZ3VpZCB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCk7XHJcblx0XHRcdGlmIChhZ20pIHtcclxuXHRcdFx0XHRhZ20uaW52b2tlKFwiVDQyLkFDUy5TdGFydEFwcGxpY2F0aW9uXCIsIHtOYW1lOiB0aGlzLm5hbWUsIENvbnRleHQ6IHBhcmFtc30sIFwiYmVzdFwiLCB7fSwgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHR9LCBlcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGluc3RhbmNlcygpLl90cmlnZ2VyKFwiY3JlYXRlXCIsIHtDb250ZXh0OiBwYXJhbXN9KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sIFtcImFkZGVkXCIsIFwicmVtb3ZlZFwiLCBcImF2YWlsYWJsZVwiLCBcInVuYXZhaWxhYmxlXCIsIFwiaW5zdGFuY2Vfc3RhcnRlZFwiLCBcImluc3RhbmNlX3N0b3BwZWRcIiwgXCJjaGFuZ2VkXCJdLCBcIm9uX1wiKTtcclxuXHJcbi8vY29uc3RydWN0b3IsIGluaXRfZXZlbnQsIGlkX2ZpZWxkXHJcblxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVfYXBwKHByb3BzLCBvYmopIHtcclxuXHRcdG9iai5uYW1lID0gcHJvcHMuTmFtZTtcclxuXHRcdG9iai50aXRsZSA9IHByb3BzLlRpdGxlO1xyXG5cdFx0b2JqLnZlcnNpb24gPSBwcm9wcy5WZXJzaW9uO1xyXG5cdFx0b2JqLmluc3RhbmNlcyA9IFtdO1xyXG5cdFx0b2JqLmNvbmZpZ3VyYXRpb24gPSB7fTtcclxuXHRcdG9iai5jb25maWd1cmF0aW9uLmF1dG9fc3RhcnQgPSBwcm9wcy5BdXRvU3RhcnQ7XHJcblx0XHRvYmouY29uZmlndXJhdGlvbi5jYXB0aW9uID0gcHJvcHMuQ2FwdGlvbjtcclxuXHRcdG9iai5jb25maWd1cmF0aW9uLmhpZGRlbiA9IHByb3BzLklzSGlkZGVuO1xyXG5cdFx0b2JqLmNvbmZpZ3VyYXRpb24uY29udGFpbmVyID0gcHJvcHMuQXBwbGljYXRpb25OYW1lO1xyXG5cdFx0Ly9vYmouZGlzYWJsZWQgPSBwcm9wcy5Jc0Rpc2FibGVkO1xyXG5cdFx0b2JqLmNvbmZpZ3VyYXRpb24uYWxsb3dfbXVsdGlwbGUgPSBwcm9wcy5BbGxvd011bHRpcGxlO1xyXG5cdFx0b2JqLmF2YWlsYWJsZSA9IHByb3BzLklzUmVhZHkgfHwgZmFsc2U7XHJcblx0XHRvYmouaWNvbiA9IHByb3BzLkljb247XHJcblx0XHRvYmouc29ydE9yZGVyID0gcHJvcHMuU29ydE9yZGVyO1xyXG5cdFx0b2JqLnVzZXJQcm9wZXJ0aWVzID0gcHJvcHMuVXNlclByb3BlcnRpZXM7XHJcblx0XHRyZXR1cm4gb2JqO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGV2ZW50X21hbmFnZXIoe1xyXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbiBjcmVhdGVfYXBwKHByb3BzKSB7XHJcblx0XHRcdHJldHVybiB1cGRhdGVfYXBwKHByb3BzLCBPYmplY3QuY3JlYXRlKGFwcF9wcm90bykpO1xyXG5cdFx0fSxcclxuXHRcdHVwZGF0ZTogdXBkYXRlX2FwcCxcclxuXHRcdGluaXRfZXZlbnQ6IFwiYWRkZWRcIixcclxuXHRcdGV4aXRfZXZlbnQ6IFwicmVtb3ZlZFwiLFxyXG5cdFx0aWRfZmllbGQ6IFwiTmFtZVwiLFxyXG5cdFx0Y2FsbGJhY2tzOiB7XHJcblx0XHRcdGF2YWlsYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcclxuXHRcdFx0fSxcclxuXHRcdFx0Y2hhbmdlZDogZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0XHRcdFx0dGhpcy5pY29uID0gcHJvcHMuSWNvbjtcclxuXHRcdFx0XHR0aGlzLnRpdGxlID0gcHJvcHMuVGl0bGU7XHJcblx0XHRcdFx0dGhpcy5jb25maWd1cmF0aW9uLmNhcHRpb24gPSBwcm9wcy5DYXB0aW9uO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR1bmF2YWlsYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHRoaXMuYXZhaWxhYmxlID0gZmFsc2U7XHJcblx0XHRcdH0sXHJcblx0XHRcdGluc3RhbmNlX3N0YXJ0ZWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRpbnN0YW5jZV9zdG9wcGVkOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHRcdFx0XHR0aGlzLmluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAobXlfaW5zdGFuY2UpIHtcclxuXHRcdFx0XHRcdHJldHVybiBteV9pbnN0YW5jZSAhPT0gaW5zdGFuY2U7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcbn07XHJcbiIsInZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxuXHJcbmZ1bmN0aW9uIGV4ZWNfY2FsbGJhY2tzKG9iaiwgYXJyLCB2YWwpIHtcclxuXHRpZiAoYXJyICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGFyci5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKG9iaiwgdmFsKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVfZW52aXJvbm1lbnQoc2V0dGluZ3MpIHtcclxuXHR2YXIgb2JqZWN0cyA9IHt9O1xyXG5cdHZhciBnbG9iYWxfY2FsbGJhY2tzID0ge307XHJcblx0cmV0dXJuIHtcclxuXHRcdGFsbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gaGVscGVycy52YWxzKG9iamVjdHMpO1xyXG5cdFx0fSxcclxuXHRcdGdldF9ieV9pZDogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRcdHJldHVybiBvYmplY3RzW2lkXTtcclxuXHRcdH0sXHJcblx0XHRfdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBpZCkge1xyXG5cdFx0XHRpZCA9IGlkIHx8ICggdHlwZW9mIHNldHRpbmdzLmlkX2ZpZWxkID09PSBcImZ1bmN0aW9uXCIgPyBzZXR0aW5ncy5pZF9maWVsZChwcm9wcykgOiBwcm9wc1tzZXR0aW5ncy5pZF9maWVsZF0pO1xyXG5cclxuXHRcdFx0Ly9RdWl0IGlmIHdlIHJlY2VpdmUgYW4gZXZlbnQgZm9yIGFuIG9iamVjdCBiZWZvcmUgaW5pdGlhdGluZyBpdC5cclxuXHRcdFx0aWYgKG9iamVjdHNbaWRdID09PSB1bmRlZmluZWQgJiYgKCB0eXBlICE9PSBzZXR0aW5ncy5pbml0X2V2ZW50ICYmIHR5cGUgIT09IHNldHRpbmdzLmNyZWF0ZV9ldmVudCkpIHtcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nIChcIlJlY2VpdmVkICdcIit0eXBlK1wiJyBldmVudCBiZWZvcmUgJ1wiK3NldHRpbmdzLmluaXRfZXZlbnQrXCInXCIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vQ3JlYXRlIG9yIHJldHJpZXZlIGFuIG9iamVjdCwgcmVwcmVzZW50aW5nIHRoZSBlbnRpdHlcclxuXHRcdFx0dmFyIG9iaiA9IG9iamVjdHNbaWRdID0gb2JqZWN0c1tpZF0gfHwgaW5pdF9vYmplY3Qoc2V0dGluZ3MuY3JlYXRlKHByb3BzKSk7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gc2V0dGluZ3MuaW5pdF9ldmVudCkge1xyXG5cdFx0XHRcdC8vUXVpdCBpZiB3ZSByZWNlaXZlIGEgaW5pdCBldmVudCBmb3IgYW4gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeSBhY3RpdmVcclxuXHRcdFx0XHRpZiAob2JqLmFjdGl2ZSkge1xyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyAoXCJSZWNlaXZlZCBzZWNvbmQgJ1wiK3NldHRpbmdzLmluaXRfZXZlbnQrXCInIGZvciBhcHAgXCIraWQpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0Ly9FbHNlLCBtYWtlIGl0IGFjdGl2ZVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRvYmouYWN0aXZlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHNldHRpbmdzLnVwZGF0ZShwcm9wcywgb2JqKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly9XaGVuIHRoZSBlbnRpdHkgaXMgcmVtb3ZlZCwgc2V0IGl0IHRvIG5vbi1hY3RpdmVcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBzZXR0aW5ncy5leGl0X2V2ZW50KSB7XHJcblx0XHRcdFx0b2JqLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHQvL1doZW4gYSBjcmVhdGUgZXZlbnQgaXMgcmVjZWl2ZWQsIGp1c3QgcmV0dXJuIHRoZSBvYmplY3Qgd2l0aG91dCBkb2luZyBhbnl0aGluZyBlbHNlXHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gc2V0dGluZ3MuY3JlYXRlX2V2ZW50KSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iajtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gc2V0dGluZ3MudXBkYXRlX2V2ZW50KSB7XHJcblx0XHRcdFx0c2V0dGluZ3MudXBkYXRlKHByb3BzLCBvYmopO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL0V4ZWN1dGUgc3lzdGVtIGNhbGxiYWNrc1xyXG5cdFx0XHRpZiAoc2V0dGluZ3MuY2FsbGJhY2tzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRzZXR0aW5ncy5jYWxsYmFja3NbdHlwZV0uY2FsbChvYmosIHByb3BzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgZXJyb3JzIGluIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrcyBkb2VzIG5vdFxyXG5cdFx0XHQvLyBicmVhayBvdXIgbGlicmFyeVxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdC8vRXhlY3V0ZSBnbG9iYWwgY2FsbGJhY2tzXHJcblx0XHRcdFx0ZXhlY19jYWxsYmFja3ModW5kZWZpbmVkLCBnbG9iYWxfY2FsbGJhY2tzW3R5cGVdLCBvYmopO1xyXG5cclxuXHRcdFx0XHQvL0V4ZWN1dGUgdXNlci1kZWZpbmVkIGNhbGxiYWNrcyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGUgb2JqZWN0XHJcblx0XHRcdFx0ZXhlY19jYWxsYmFja3Mob2JqLCBvYmouY2FsbGJhY2tzW3R5cGVdLCBwcm9wcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2F0Y2ggKGUpe1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly9XaGVuIHRoZSBlbnRpdHkgaXMgcmVtb3ZlZCwgcmVtb3ZlIGFsbCBjYWxsYmFja3MgKGFmdGVyIHlvdSBleGVjdXRlIHRoZW0pXHJcblx0XHRcdGlmICh0eXBlID09PSBzZXR0aW5ncy5leGl0X2V2ZW50KSB7XHJcblx0XHRcdFx0b2JqLmNhbGxiYWNrcyA9IHt9O1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBvYmo7XHJcblxyXG5cdFx0fSxcclxuXHRcdC8vRXhwb3NlIHRoZSBnbG9iYWwgY2FsbGJhY2tzIG9iamVjdCBzbyB0aGF0IHVzZXIgY2FuIHJlZ2lzdGVyIHNvbWVcclxuXHRcdGNhbGxiYWNrczogZ2xvYmFsX2NhbGxiYWNrc1xyXG5cdH07XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpbml0X29iamVjdChvYmplY3QpIHtcclxuXHRvYmplY3QuY2FsbGJhY2tzID0ge307XHJcblx0b2JqZWN0LmFjdGl2ZSA9IGZhbHNlO1xyXG5cdHJldHVybiBvYmplY3Q7XHJcbn1cclxuIiwiZnVuY3Rpb24gbm9vcCgpe31cclxuXHJcbmZ1bmN0aW9uIGV4ZWNfaWYoY29uZGl0aW9uKSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uIChhcHAsIGNhbGxiYWNrKSB7XHJcblx0XHRpZiAoY29uZGl0aW9uKGFwcCkpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChhcHApO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmV4cG9ydHMuYWRkX2NhbGxiYWNrcyA9IGZ1bmN0aW9uIGFkZF9jYWxsYmFja3Mob2JqZWN0LCBldmVudHMsIHByZWZpeCkge1xyXG5cdGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG5cdFx0aWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRldmVudCA9IHtuYW1lOiBldmVudCwgdHJpZ2dlcl93aGVuOiBub29wfTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmplY3RbcHJlZml4ICsgZXZlbnQubmFtZV0gPSBleHBvcnRzLmFkZF9jYWxsYmFjayhldmVudC5uYW1lLCBleGVjX2lmKGV2ZW50LnRyaWdnZXJfd2hlbikpO1xyXG5cdH0pO1xyXG5cdHJldHVybiBvYmplY3Q7XHJcblxyXG59O1xyXG5cclxuZXhwb3J0cy5hZGRfY2FsbGJhY2sgPSBmdW5jdGlvbiBhZGRfY2FsbGJhY2soIGtleSwgb25fYWRkICl7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuXHRcdHZhciBvYmogPSB0aGlzLmNhbGxiYWNrcztcclxuXHRcdGlmKG9ialtrZXldPT09dW5kZWZpbmVkKXtvYmpba2V5XSA9IFtjYWxsYmFja107fVxyXG5cdFx0ZWxzZSB7b2JqW2tleV0ucHVzaChjYWxsYmFjayk7fVxyXG5cdFx0aWYodHlwZW9mIG9uX2FkZCA9PT0gXCJmdW5jdGlvblwiKXtvbl9hZGQodGhpcywgY2FsbGJhY2spO31cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcbn07XHJcblxyXG5leHBvcnRzLnZhbHMgPSBmdW5jdGlvbiB2YWxzKG9iaikge1xyXG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBrZXkpIHtcclxuXHRcdGFyci5wdXNoKG9ialtrZXldKTtcclxuXHRcdHJldHVybiBhcnI7XHJcblx0fSwgW10pO1xyXG59O1xyXG4iLCJ2YXIgZXZlbnRfbWFuYWdlciA9IHJlcXVpcmUoXCIuL2V2ZW50X21hbmFnZXJcIik7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYWdtLCBhcHBzKSB7XG5cdHZhciBpbnN0YW5jZV9wcm90byA9IGhlbHBlcnMuYWRkX2NhbGxiYWNrcyh7XG5cdFx0c3RvcDogZnVuY3Rpb24gKHBhcmFtcywgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLlN0b3BBcHBsaWNhdGlvblwiLCB7TmFtZTogdGhpcy5hcHBsaWNhdGlvbi5uYW1lLCBJZDogdGhpcy5pZH0sIFwiYmVzdFwiLCB7fSwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coZSk7XG5cdFx0XHR9LCBlcnJvcik7XG5cdFx0fSxcblx0XHRhY3RpdmF0ZTogZnVuY3Rpb24gKHBhcmFtcywgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuQUNTLkFjdGl2YXRlQXBwbGljYXRpb25cIiwge05hbWU6IHRoaXMuYXBwbGljYXRpb24ubmFtZSwgSWQ6IHRoaXMuaWR9LCBcImJlc3RcIiwge30sIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGUpO1xuXHRcdFx0fSwgZXJyb3IpO1xuXHRcdH1cblx0fSwgW1xuXHRcdHtcblx0XHRcdG5hbWU6IFwid2luZG93X2FkZGVkXCIsIHRyaWdnZXJfd2hlbjogZnVuY3Rpb24gKGFwcCkgIFx0e1xuXHRcdFx0cmV0dXJuIGFwcC5hY3RpdmUgJiYgYXBwLm1haW5fd2luZG93ICE9PSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bmFtZTogXCJ3aW5kb3dfcmVtb3ZlZFwiLCB0cmlnZ2VyX3doZW46IGZ1bmN0aW9uIChhcHApIHtcblx0XHRcdHJldHVybiBhcHAubWFpbl93aW5kb3cgPT09IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRuYW1lOiBcInN0YXJ0ZWRcIiwgdHJpZ2dlcl93aGVuOiBmdW5jdGlvbiAoYXBwKSB7XG5cdFx0XHRyZXR1cm4gYXBwLmlkICE9PSB1bmRlZmluZWQgJiYgYXBwLmFjdGl2ZTtcblx0XHR9XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRuYW1lOiBcInN0b3BwZWRcIiwgdHJpZ2dlcl93aGVuOiBmdW5jdGlvbiAoYXBwKSB7XG5cdFx0XHRyZXR1cm4gYXBwLmlkICE9PSB1bmRlZmluZWQgJiYgIWFwcC5hY3RpdmU7XG5cdFx0fVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bmFtZTogXCJhZ21fcmVhZHlcIiwgdHJpZ2dlcl93aGVuOiBmdW5jdGlvbiAoYXBwKSB7XG5cdFx0XHRyZXR1cm4gYXBwLmFjdGl2ZSAmJiBhcHAuYWdtICE9PSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdH0sXG4gICAge1xuICAgICAgbmFtZTogXCJlcnJvclwiLCB0cmlnZ2VyX3doZW46IGZ1bmN0aW9uIChhcHApIHtcbiAgICAgIHJldHVybiBhcHAuZXJyb3IgIT09IHVuZGVmaW5lZDtcbiAgICB9XG5cdFx0fSxcblx0XSwgXCJvbl9cIik7XG5cblx0ZnVuY3Rpb24gdXBkYXRlX2luc3RhbmNlKHByb3BzLCBvYmopIHtcblx0XHRvYmouaWQgPSBwcm9wcy5JZDtcblx0XHRvYmouYXBwbGljYXRpb24gPSBhcHBzLmdldF9ieV9pZChwcm9wcy5OYW1lKTtcblx0XHRvYmouY29udGV4dCA9IHByb3BzLkNvbnRleHQ7XG5cdFx0b2JqLnRpdGxlID0gcHJvcHMuVGl0bGU7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cdHJldHVybiBldmVudF9tYW5hZ2VyKHtcblx0XHRjcmVhdGU6IGZ1bmN0aW9uIChwcm9wcykge1xuXHRcdFx0cmV0dXJuIHVwZGF0ZV9pbnN0YW5jZShwcm9wcywgT2JqZWN0LmNyZWF0ZShpbnN0YW5jZV9wcm90bykpO1xuXHRcdH0sXG5cdFx0dXBkYXRlOiB1cGRhdGVfaW5zdGFuY2UsXG5cdFx0Y3JlYXRlX2V2ZW50OiBcImNyZWF0ZVwiLFxuXHRcdGluaXRfZXZlbnQ6IFwic3RhcnRlZFwiLFxuXHRcdGV4aXRfZXZlbnQ6IFwic3RvcHBlZFwiLFxuICAgIHVwZGF0ZV9ldmVudDogXCJ1cGRhdGVkXCIsXG5cdFx0aWRfZmllbGQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRyZXR1cm4gZS5Db250ZXh0ICE9PSB1bmRlZmluZWQgJiYgZS5Db250ZXh0Lmd1aWQgIT09IHVuZGVmaW5lZCA/IGUuQ29udGV4dC5ndWlkIDogZS5JZDtcblx0XHR9LFxuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0YWdtX3JlYWR5OiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHQvL2dldCB0aGUgZmlyc3QgQUdNXG5cdFx0XHRcdHZhciBzZXJ2ZXJfbmFtZSA9IE9iamVjdC5rZXlzKGUuQWdtU2VydmVycylbMF07XG5cdFx0XHRcdC8vQXR0YWNoIGl0IHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0dGhpcy5hZ20gPSBjb252ZXJ0X2FnbV9pbnN0YW5jZShlLkFnbVNlcnZlcnNbc2VydmVyX25hbWVdKTtcblx0XHRcdH0sXG5cdFx0XHRlcnJvcjogZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dGhpcy5lcnJvciA9IGU7XG5cdFx0XHR9LFxuXHRcdFx0d2luZG93X2FkZGVkOiBmdW5jdGlvbiAod2luKSB7XG5cdFx0XHRcdHRoaXMubWFpbl93aW5kb3cgPSB3aW47XG5cdFx0XHRcdHRoaXMud2luZG93cyA9IHRoaXMud2luZG93cyB8fCBbXTtcblx0XHRcdFx0dGhpcy53aW5kb3dzLnB1c2god2luKTtcblx0XHRcdH0sXG5cdFx0XHR3aW5kb3dfcmVtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLm1haW5fd2luZG93ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR0aGlzLndpbmRvd3MgPSBbXTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufTtcblxuZnVuY3Rpb24gY29udmVydF9hZ21faW5zdGFuY2UoYWdtKSB7XG5cdHJldHVybiB7XG5cdFx0bWFjaGluZTogYWdtLm1hY2hpbmVOYW1lLFxuXHRcdHVzZXI6IGFnbS51c2VyTmFtZSxcblx0XHRlbnZpcm9ubWVudDogYWdtLmVudmlyb25tZW50LFxuXHRcdGFwcGxpY2F0aW9uOiBhZ20uYXBwbGljYXRpb25OYW1lXG5cblx0fTtcbn1cbiIsIi8qKlxyXG4gKiBAbW9kdWxlIGFwcGNvbmZpZ1xyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCcuL3V0aWwnKTtcclxudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbCcpO1xyXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG5cclxudmFyIGV2ZW50cyA9IHtcclxuICBjb25uZWN0OiAnY29ubmVjdCcsXHJcbiAgZGlzY29ubmVjdDogJ2Rpc2Nvbm5lY3QnLFxyXG4gIHVwZGF0ZTogJ3VwZGF0ZScsXHJcbiAgc3RhdHVzOiAnc3RhdHVzJ1xyXG59O1xyXG5cclxudmFyIEV2ZW50QnVzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzdWJzY3JpcHRpb25zQnlUeXBlO1xyXG4gIHZhciBvbiA9IGZ1bmN0aW9uICh0eXBlLCBvbmNlLCBjYWxsYmFjaywgc2NvcGUpIHtcclxuICAgIGlmICghXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHtcclxuICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgb25jZTogb25jZSxcclxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxyXG4gICAgICBzY29wZTogc2NvcGVcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zQnlUeXBlW3R5cGVdO1xyXG4gICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb25zID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9uc0J5VHlwZVt0eXBlXSA9IFtdO1xyXG4gICAgfVxyXG4gICAgc3Vic2NyaXB0aW9uLmlkID0gc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbikgLSAxO1xyXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcclxuICB9O1xyXG5cclxuICB2YXIgZW1pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgdmFyIHR5cGUgPSBhcmdzLnNwbGljZSgwLCAxKVswXTtcclxuICAgIHZhciBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9uc0J5VHlwZVt0eXBlXTtcclxuICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbdHlwZV0gPSBbXTtcclxuICAgIH1cclxuICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjay5hcHBseShzdWJzY3JpcHRpb24uc2NvcGUsIGFyZ3MpO1xyXG4gICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgXy53YXJuKCdFeGNlcHRpb24gZHVyaW5nIGV4ZWN1dGlvbiBvZiBjYWxsYmFjaycsIHN1YnNjcmlwdGlvbiwgYXJncywgeCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN1YnNjcmlwdGlvbi5vbmNlKSB7XHJcbiAgICAgICAgb2ZmKHN1YnNjcmlwdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcbiAgdmFyIG9mZiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcclxuICAgIHZhciBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9uc0J5VHlwZVtzdWJzY3JpcHRpb24udHlwZV07XHJcbiAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGRlbGV0ZSBzdWJzY3JpcHRpb25zW3N1YnNjcmlwdGlvbi5pZF07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIHJlc3VtZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcclxuICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uLmlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gb24oc3Vic2NyaXB0aW9uLnR5cGUsIHN1YnNjcmlwdGlvbi5vbmNlLCBzdWJzY3JpcHRpb24uY2FsbGJhY2ssIHN1YnNjcmlwdGlvbi5zY29wZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbc3Vic2NyaXB0aW9uLnR5cGVdO1xyXG4gICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnNCeVR5cGVbc3Vic2NyaXB0aW9uLnR5cGVdID0gW107XHJcbiAgICAgIH1cclxuICAgICAgc3Vic2NyaXB0aW9uc1tzdWJzY3JpcHRpb24uaWRdID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciByZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uc0J5VHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgT2JqZWN0LmtleXMoc3Vic2NyaXB0aW9uc0J5VHlwZSkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9uc0J5VHlwZVt0eXBlXTtcclxuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICBkZWxldGUgc3Vic2NyaXB0aW9uLmlkO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHN1YnNjcmlwdGlvbnNCeVR5cGUgPSB7fTtcclxuICB9O1xyXG4gIHJlc2V0KCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIG9uOiBvbixcclxuICAgIGVtaXQ6IGVtaXQsXHJcbiAgICBvZmY6IG9mZixcclxuICAgIHJlc3VtZTogcmVzdW1lLFxyXG4gICAgcmVzZXQ6IHJlc2V0XHJcblxyXG4gIH07XHJcbn07XHJcblxyXG52YXIgQXBwQ29uZmlnID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICB2YXIgZGVmYXVsdExpc3RlbiAgPSB0cnVlO1xyXG4gIHZhciBnYXRld2F5O1xyXG4gIHZhciBpbml0R2F0ZXdheTtcclxuICB2YXIgYnVzID0gbmV3IEV2ZW50QnVzKCk7XHJcbiAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKGJ1cyk7XHJcblxyXG4gIHZhciByb290ID0gcmVxdWlyZSgnLi9wcm9wcycpKG1vZGVsLnJvb3QpO1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgdmFyIGdhdGV3YXlDb25uZWN0aW9uO1xyXG4gIHZhciBwb2xsaW5nSW50ZXJ2YWxJZDtcclxuICB2YXIgY2xlYXJQb2xsaW5nSW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIHBvbGxpbmdJbnRlcnZhbElkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBjbGVhckludGVydmFsKHBvbGxpbmdJbnRlcnZhbElkKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBQdWJsaWMgQVBJXHJcbiAgc2VsZi5pbml0ID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xyXG4gICAgdmFyIGlzSWRlbnRpdHlWYWxpZCA9IHR5cGVvZiBzZXR0aW5ncy5pZGVudGl0eSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgT2JqZWN0LmtleXMoc2V0dGluZ3MuaWRlbnRpdHkpLmxlbmd0aCA+IDA7XHJcblxyXG4gICAgaWYgKGlzSWRlbnRpdHlWYWxpZCkge1xyXG4gICAgICBzZWxmLmlkZW50aXR5ID0gc2V0dGluZ3MuaWRlbnRpdHk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0TGlzdGVuID0gc2V0dGluZ3MuZGVmYXVsdExpc3RlbiB8fCBkZWZhdWx0TGlzdGVuO1xyXG4gICAgaWYgKCFzZWxmLmlkZW50aXR5KSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lkZW50aXR5IG11c3QgYmUgbm9uIGVtcHR5IG9iamVjdC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBtb2RlbC5zZXBhcmF0b3IgPSBzZXR0aW5ncy5kZWZhdWx0U2VwYXJhdG9yIHx8IG1vZGVsLnNlcGFyYXRvcjtcclxuXHJcbiAgICBzZWxmLnNjaGVtYSA9IHNldHRpbmdzLnNjaGVtYSB8fCBzZWxmLnNjaGVtYSB8fCAnQXBwbGljYXRpb25Db25maWd1cmF0aW9uJztcclxuXHJcbiAgICBpbml0R2F0ZXdheSA9IF8uaXNGdW5jdGlvbihzZXR0aW5ncy5nYXRld2F5KSA/XHJcbiAgICAgIHNldHRpbmdzLmdhdGV3YXkgOlxyXG4gICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5nYXRld2F5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgc2V0dGluZ3MuZ2F0ZXdheSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmdhdGV3YXkuaW5zdGFuY2UgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICBzZXR0aW5ncy5nYXRld2F5Lmluc3RhbmNlID0gXy51dWlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL2dhdGV3YXknKShzZXR0aW5ncy5nYXRld2F5KTtcclxuICAgICAgfTtcclxuICB9O1xyXG5cclxuICBzZWxmLmNvbm5lY3QgPSBmdW5jdGlvbiAobGlzdGVuLCBjYWxsYmFjaywgc2NvcGUpIHtcclxuICAgIGNsZWFyUG9sbGluZ0ludGVydmFsKCk7XHJcbiAgICB2YXIgc3Vic2NyaXB0aW9uO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24obGlzdGVuKSkge1xyXG4gICAgICAgIGNhbGxiYWNrID0gbGlzdGVuO1xyXG4gICAgICAgIHNjb3BlID0gY2FsbGJhY2s7XHJcbiAgICAgICAgbGlzdGVuID0gZGVmYXVsdExpc3RlbjtcclxuICAgICAgfVxyXG4gICAgICBzdWJzY3JpcHRpb24gPSBidXMub24oZXZlbnRzLmNvbm5lY3QsIHRydWUsIGNhbGxiYWNrLCBzY29wZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVycm9yO1xyXG4gICAgaWYgKCFzZWxmLmlkZW50aXR5KSB7XHJcbiAgICAgIGVycm9yID0gJ2lkZW50aXR5IGlzIG5vdCBzcGVjaWZpZWQuIGRpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgaW5pdCgpPyc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoIWdhdGV3YXkpIHtcclxuICAgICAgICBnYXRld2F5ID0gaW5pdEdhdGV3YXkoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWxpc3Rlbikge1xyXG4gICAgICAgIGdhdGV3YXlDb25uZWN0aW9uID1cclxuICAgICAgICAgIGdhdGV3YXkuY29ubmVjdChcclxuICAgICAgICAgICAgc2VsZi5zY2hlbWEsXHJcbiAgICAgICAgICAgIHNlbGYuaWRlbnRpdHksXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IsIHNuYXBzaG90LCB1cGRhdGVzKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG1vZGVsLmFwcGx5U25hcHNob3Qoc25hcHNob3QpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBidXMuZW1pdChldmVudHMuY29ubmVjdCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IsIHN0YXR1cykge1xyXG4gICAgICAgICAgICAgIGJ1cy5lbWl0KGV2ZW50cy5zdGF0dXMsIGVycm9yLCBzdGF0dXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgY29ubmVjdEVtaXR0ZWQgPSBmYWxzZTtcclxuICAgICAgICBnYXRld2F5Q29ubmVjdGlvbiA9IGdhdGV3YXkuY29ubmVjdChcclxuICAgICAgICAgIHNlbGYuc2NoZW1hLFxyXG4gICAgICAgICAgc2VsZi5pZGVudGl0eSxcclxuICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IsIHNuYXBzaG90LCB1cGRhdGVzKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc25hcHNob3QgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgbW9kZWwuYXBwbHlTbmFwc2hvdChzbmFwc2hvdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgIG1vZGVsLmFwcGx5VXBkYXRlcyh1cGRhdGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNvbm5lY3RFbWl0dGVkKSB7XHJcbiAgICAgICAgICAgICAgY29ubmVjdEVtaXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIGJ1cy5lbWl0KGV2ZW50cy5jb25uZWN0LCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IsIHN0YXR1cykge1xyXG4gICAgICAgICAgICB2YXIgTElTVEVOX05PVF9TVVBQT1JURUQgPSA4O1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IExJU1RFTl9OT1RfU1VQUE9SVEVEKSB7XHJcbiAgICAgICAgICAgICAgcG9sbGluZ0ludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBnYXRld2F5LmRpc2Nvbm5lY3QoZ2F0ZXdheUNvbm5lY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2F0ZXdheUNvbm5lY3Rpb24gPSBnYXRld2F5LmNvbm5lY3Qoc2VsZi5zY2hlbWEsIHNlbGYuaWRlbnRpdHksIGZhbHNlLCBmdW5jdGlvbiAoZXJyb3IsIHNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgICAgICAgIG1vZGVsLmFwcGx5U25hcHNob3Qoc25hcHNob3QsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH0sIDIwMDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICBzZXRUaW1lb3V0KGJ1cy5lbWl0LCAwLCBldmVudHMuY29ubmVjdCwgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XHJcblxyXG4gIH07XHJcblxyXG4gIHNlbGYucHJvcHMgPSBmdW5jdGlvbiAoc2VjdGlvbiwgc2VwYXJhdG9yKSB7XHJcbiAgICByZXR1cm4gcm9vdC5wcm9wcyhzZWN0aW9uLCBzZXBhcmF0b3IpO1xyXG4gIH07XHJcblxyXG4gIHNlbGYubW9kaWZ5ID0gZnVuY3Rpb24gKG1vZGlmaWNhdGlvbnMsIGNhbGxiYWNrLCBzY29wZSkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2RpZmljYXRpb25zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBtb2RpZmljYXRpb25zID0gW21vZGlmaWNhdGlvbnNdO1xyXG4gICAgfVxyXG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IGJ1cy5vbihldmVudHMudXBkYXRlLCB0cnVlLCBjYWxsYmFjaywgc2NvcGUpO1xyXG5cclxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5vbkNvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XHJcbiAgICByZXR1cm4gYnVzLm9uKGV2ZW50cy5jb25uZWN0LCBmYWxzZSwgY2FsbGJhY2ssIHNjb3BlKTtcclxuXHJcbiAgfTtcclxuXHJcbiAgc2VsZi5vbkRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XHJcbiAgICByZXR1cm4gYnVzLm9uKGV2ZW50cy5kaXNjb25uZWN0LCBmYWxzZSwgY2FsbGJhY2ssIHNjb3BlKTtcclxuICB9O1xyXG5cclxuICBzZWxmLm9mZiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcclxuICAgIGlmIChzdWJzY3JpcHRpb24pIHtcclxuICAgICAgYnVzLm9mZihzdWJzY3JpcHRpb24pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHNlbGYub24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XHJcbiAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgIGJ1cy5yZXN1bWUoc3Vic2NyaXB0aW9uKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBzZWxmLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XHJcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICBidXMub24oZXZlbnRzLmRpc2Nvbm5lY3QsIHRydWUsIGNhbGxiYWNrLCBzY29wZSk7XHJcbiAgICB9XHJcbiAgICBjbGVhclBvbGxpbmdJbnRlcnZhbCgpO1xyXG4gICAgaWYgKHR5cGVvZiBnYXRld2F5ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBnYXRld2F5LmRpc2Nvbm5lY3QoZ2F0ZXdheUNvbm5lY3Rpb24sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgIGJ1cy5lbWl0KGV2ZW50cy5kaXNjb25uZWN0LCBlcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gICAgICBnYXRld2F5ID0gdW5kZWZpbmVkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnVzLmVtaXQoZXZlbnRzLmRpc2Nvbm5lY3QsICdub3QgY29ubmVjdGVkJyk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcbkFwcENvbmZpZy5wcm90b3R5cGUuaWRlbnRpdHlFcXVhbCA9IGhlbHBlcnMuaWRlbnRpdHlFcXVhbDtcclxuQXBwQ29uZmlnLnByb3RvdHlwZS5pZGVudGl0eVRvU3RyaW5nID0gaGVscGVycy5pZGVudGl0eVRvU3RyaW5nO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIG5ldyBBcHBDb25maWcoKTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGdhdGV3YXlDb25uZWN0aW9uID0gcmVxdWlyZSgndGljazQyLWdhdGV3YXktY29ubmVjdGlvbicpO1xyXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xyXG52YXIgaWRlbnRpdHlUb1N0cmluZyA9IGhlbHBlcnMuaWRlbnRpdHlUb1N0cmluZztcclxudmFyIFBST0RVQ1QgPSAnYXBwY29uZmlnJztcclxuXHJcbnZhciBHYXRld2F5VHJhbnNwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICB2YXIgY29ubmVjdGlvbjtcclxuICB2YXIgZGF0YUhhbmRsZXJzID0ge307XHJcbiAgdmFyIHN0YXR1c0hhbmRsZXJzID0ge307XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXR1c01lc3NhZ2UobXNnKSB7XHJcbiAgICB2YXIgaGFuZGxlciA9IHN0YXR1c0hhbmRsZXJzW21zZy5pbnN0YW5jZV07XHJcbiAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICBoYW5kbGVyKG1zZy5lcnJvciwgbXNnLnN0YXR1cyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGhhbmRsZURhdGFNZXNzYWdlKG1zZykge1xyXG4gICAgdmFyIHNjaGVtYSA9IG1zZy5zY2hlbWE7XHJcbiAgICB2YXIgc2NoZW1hSGFuZGxlcnMgPSBkYXRhSGFuZGxlcnNbc2NoZW1hXTtcclxuICAgIGlmICh0eXBlb2Ygc2NoZW1hSGFuZGxlcnMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBpZGVudGl0eUtleSA9IGlkZW50aXR5VG9TdHJpbmcobXNnLmlkZW50aXR5LCB0cnVlKTtcclxuICAgIHZhciBpZGVudGl0eUhhbmRsZXJzID0gc2NoZW1hSGFuZGxlcnNbaWRlbnRpdHlLZXldO1xyXG4gICAgaWYgKHR5cGVvZiBpZGVudGl0eUhhbmRsZXJzID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZGVudGl0eUhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICBoYW5kbGVyKG1zZy5lcnJvciwgbXNnLnNuYXBzaG90LCBtc2cudXBkYXRlcyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBlbnN1cmVDb25uZWN0aW9uKCkge1xyXG4gICAgaWYgKHR5cGVvZihjb25uZWN0aW9uKSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbm5lY3Rpb24gIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICB7XHJcbiAgICAgICAgY29ubmVjdGlvbiA9IG9wdGlvbnMuY29ubmVjdGlvbjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBjb25uZWN0aW9uID0gZ2F0ZXdheUNvbm5lY3Rpb24ob3B0aW9ucy5zZXR0aW5ncywgb3B0aW9ucy5jdXN0b21fY29ubmVjdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgdmFyIGRhdGFTdWJzY3JpcHRpb247XHJcbiAgdmFyIHN0YXR1c1N1YnNjcmlwdGlvbjtcclxuICB2YXIgY29ubmVjdCA9IGZ1bmN0aW9uIChzY2hlbWEsIGlkZW50aXR5LCBsaXN0ZW4sIGhhbmRsZXIsIHN0YXR1c0hhbmRsZXIpIHtcclxuICAgIGVuc3VyZUNvbm5lY3Rpb24oKTtcclxuICAgIHZhciBzY2hlbWFIYW5kbGVycyA9IGRhdGFIYW5kbGVyc1tzY2hlbWFdO1xyXG4gICAgaWYgKHR5cGVvZiBzY2hlbWFIYW5kbGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgc2NoZW1hSGFuZGxlcnMgPSBkYXRhSGFuZGxlcnNbc2NoZW1hXSA9IHt9O1xyXG4gICAgfVxyXG4gICAgdmFyIGlkZW50aXR5S2V5ID0gaWRlbnRpdHlUb1N0cmluZyhpZGVudGl0eSwgdHJ1ZSk7XHJcbiAgICB2YXIgaWRlbnRpdHlIYW5kbGVycyA9IHNjaGVtYUhhbmRsZXJzW2lkZW50aXR5S2V5XTtcclxuICAgIGlmICh0eXBlb2YgaWRlbnRpdHlIYW5kbGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgaWRlbnRpdHlIYW5kbGVycyA9IHNjaGVtYUhhbmRsZXJzW2lkZW50aXR5S2V5XSA9IFtdO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhbmRsZXJUb1JlZ2lzdGVyO1xyXG4gICAgdmFyIGluZGV4O1xyXG4gICAgaWYgKGxpc3Rlbikge1xyXG4gICAgICBoYW5kbGVyVG9SZWdpc3RlciA9IGhhbmRsZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoYW5kbGVyVG9SZWdpc3RlciA9IGZ1bmN0aW9uIChlcnJvciwgc25hcHNob3QsIHVwZGF0ZXMpIHtcclxuICAgICAgICBoYW5kbGVyKGVycm9yLCBzbmFwc2hvdCwgdXBkYXRlcyk7XHJcbiAgICAgICAgZGVsZXRlIGlkZW50aXR5SGFuZGxlcnNbaW5kZXhdO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGluZGV4ID0gaWRlbnRpdHlIYW5kbGVycy5wdXNoKGhhbmRsZXJUb1JlZ2lzdGVyKSAtIDE7XHJcblxyXG4gICAgaWYgKHR5cGVvZiAoZGF0YVN1YnNjcmlwdGlvbikgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGRhdGFTdWJzY3JpcHRpb24gPSBjb25uZWN0aW9uLm9uKFBST0RVQ1QsIEdhdGV3YXlUcmFuc3BvcnQuTWVzc2FnZVR5cGUuREFUQSwgZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgIGhhbmRsZURhdGFNZXNzYWdlKG1zZyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIGluc3RhbmNlID0gb3B0aW9ucy5pbnN0YW5jZTtcclxuICAgIHN0YXR1c0hhbmRsZXJzW2luc3RhbmNlXSA9IHN0YXR1c0hhbmRsZXI7XHJcbiAgICBpZiAodHlwZW9mIChzdGF0dXNTdWJzY3JpcHRpb24pID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBzdGF0dXNTdWJzY3JpcHRpb24gPSBjb25uZWN0aW9uLm9uKFBST0RVQ1QsIEdhdGV3YXlUcmFuc3BvcnQuTWVzc2FnZVR5cGUuU1RBVFVTLCBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgaGFuZGxlU3RhdHVzTWVzc2FnZShtc2cpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbXNnID0ge1xyXG4gICAgICBzY2hlbWE6IHNjaGVtYSxcclxuICAgICAgaWRlbnRpdHk6IGlkZW50aXR5LFxyXG4gICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXHJcbiAgICAgIGxpc3RlbjogbGlzdGVuXHJcbiAgICB9O1xyXG4gICAgY29ubmVjdGlvbi5zZW5kKFBST0RVQ1QsIEdhdGV3YXlUcmFuc3BvcnQuTWVzc2FnZVR5cGUuQ09OTkVDVCwgbXNnKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNjaGVtYTogc2NoZW1hLFxyXG4gICAgICBpZGVudGl0eTogaWRlbnRpdHksXHJcbiAgICAgIGxpc3RlbjogbGlzdGVuLFxyXG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxyXG4gICAgICBpbmRleCA6IGluZGV4XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHZhciBtb2RpZnkgPSBmdW5jdGlvbiAoc2NoZW1hLCBpZGVudGl0eSwgbW9kaWZpY2F0aW9ucykge1xyXG4gICAgZW5zdXJlQ29ubmVjdGlvbigpO1xyXG4gICAgY29ubmVjdGlvbi5zZW5kKFBST0RVQ1QsIEdhdGV3YXlUcmFuc3BvcnQuTWVzc2FnZVR5cGUuTU9ESUZZLCBtb2RpZmljYXRpb25zKTtcclxuICB9O1xyXG4gIHZhciBkaXNjb25uZWN0ID0gZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcclxuICAgIHZhciBzY2hlbWFIYW5kbGVycyA9IGRhdGFIYW5kbGVyc1tkZXNjcmlwdG9yLnNjaGVtYV07XHJcbiAgICBpZiAodHlwZW9mIHNjaGVtYUhhbmRsZXJzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB2YXIgaWRlbnRpdHlLZXkgPSBpZGVudGl0eVRvU3RyaW5nKGRlc2NyaXB0b3IuaWRlbnRpdHksIHRydWUpO1xyXG4gICAgICB2YXIgaWRlbnRpdHlIYW5kbGVycyA9IHNjaGVtYUhhbmRsZXJzW2lkZW50aXR5S2V5XTtcclxuICAgICAgaWYgKHR5cGVvZiBpZGVudGl0eUhhbmRsZXJzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHZhciBoYW5kbGVyID0gaWRlbnRpdHlIYW5kbGVyc1tkZXNjcmlwdG9yLmluZGV4XTtcclxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICB2YXIgbXNnID0ge1xyXG4gICAgICAgICAgICBzY2hlbWE6IGRlc2NyaXB0b3Iuc2NoZW1hLFxyXG4gICAgICAgICAgICBpZGVudGl0eTogZGVzY3JpcHRvci5pZGVudGl0eSxcclxuICAgICAgICAgICAgaW5zdGFuY2U6IG9wdGlvbnMuaW5zdGFuY2VcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBjb25uZWN0aW9uLnNlbmQoR2F0ZXdheVRyYW5zcG9ydC5NZXNzYWdlVHlwZS5ESVNDT05ORUNULCBtc2cpO1xyXG4gICAgICAgICAgZGVsZXRlIGlkZW50aXR5SGFuZGxlcnNbZGVzY3JpcHRvci5pbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpZGVudGl0eUhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgZGVsZXRlIHNjaGVtYUhhbmRsZXJzW2lkZW50aXR5S2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYUhhbmRsZXJzKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBkZWxldGUgZGF0YUhhbmRsZXJzW2Rlc2NyaXB0b3Iuc2NoZW1hXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKE9iamVjdC5rZXlzKGRhdGFIYW5kbGVycykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgKGRhdGFTdWJzY3JpcHRpb24pICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGNvbm5lY3Rpb24ub2ZmKGRhdGFTdWJzY3JpcHRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWxldGUgc3RhdHVzSGFuZGxlcnNbZGVzY3JpcHRvci5pbnN0YW5jZV07XHJcbiAgICBpZiAoT2JqZWN0LmtleXMoc3RhdHVzSGFuZGxlcnMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBpZiAodHlwZW9mIHN0YXR1c1N1YnNjcmlwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBjb25uZWN0aW9uLm9mZihzdGF0dXNTdWJzY3JpcHRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgY29ubmVjdDogY29ubmVjdCxcclxuICAgIG1vZGlmeTogbW9kaWZ5LFxyXG4gICAgZGlzY29ubmVjdDogZGlzY29ubmVjdFxyXG4gIH07XHJcbn07XHJcblxyXG5HYXRld2F5VHJhbnNwb3J0Lk1lc3NhZ2VUeXBlID0ge1xyXG4gIC8vIHsgc2NoZW1hOiAnQXBwbGljYXRpb25Db25maWd1cmF0aW9uJywgaWRlbnRpdHk6IHt9LCBsaXN0ZW46IHRydWUsIGluc3RhbmNlOiAnJyB9XHJcbiAgQ09OTkVDVDogJ2Nvbm5lY3QnLFxyXG4gIC8vIHsgc2NoZW1hOiAnQXBwbGljYXRpb25Db25maWd1cmF0aW9uJywgaWRlbnRpdHk6IHt9LCBpbnN0YW5jZTogJycgfVxyXG4gIERJU0NPTk5FQ1Q6ICdkaXNjb25uZWN0JyxcclxuICAvLyB7IHNjaGVtYTogJ0FwcGxpY2F0aW9uQ29uZmlndXJhdGlvbicsIGlkZW50aXR5OiB7fSwgdXBkYXRlczogW10sIGluc3RhbmNlOiAnJyB9XHJcbiAgTU9ESUZZOiAnbW9kaWZ5JyxcclxuICAvLyB7IHNjaGVtYTogJ0FwcGxpY2F0aW9uQ29uZmlndXJhdGlvbicsIGlkZW50aXR5OiB7fSwgZXJyb3I6ICcnLCBzbmFwc2hvdDoge2RlZmF1bHRLZXlWYWx1ZTogJycsIGtleXM6IFtdLCBwcm9wczoge319LCB1cGRhdGVzOiBbXSB9XHJcbiAgREFUQTogJ2RhdGEnLFxyXG4gIC8vIHsgc2NoZW1hOiAnQXBwbGljYXRpb25Db25maWd1cmF0aW9uJywgaWRlbnRpdHk6IHt9LCBpbnN0YW5jZTogJycsIHN0YXR1czogJycsIGVycm9yOiAnJyB9XHJcbiAgU1RBVFVTOiAnc3RhdHVzJ1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYXRld2F5VHJhbnNwb3J0O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBlc2NhcGVJZGVudGl0eVRleHQodGV4dCkge1xyXG4gIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1tcXFxcXS9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9bOl0vZywgJ1xcXFw6Jyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB0ZXh0O1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaWRlbnRpdHlUb1N0cmluZyhpZGVudGl0eSwgaW5jbHVkZUtleXMsIHNlcGFyYXRvciwgb3JkZXIpIHtcclxuICBpZiAodHlwZW9mKGlkZW50aXR5KSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJy8nO1xyXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaWRlbnRpdHkpO1xyXG4gIGlmICh0eXBlb2Yob3JkZXIpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBrZXlzLnNvcnQob3JkZXIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBrZXlzLnNvcnQoKTtcclxuICB9XHJcbiAgcmV0dXJuIGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiBpbmNsdWRlS2V5cyA/IChlc2NhcGVJZGVudGl0eVRleHQoa2V5KSArICc6JyArIGVzY2FwZUlkZW50aXR5VGV4dChpZGVudGl0eVtrZXldKSkgOiBpZGVudGl0eVtrZXldO1xyXG4gIH0pLmpvaW4oc2VwYXJhdG9yKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaWRlbnRpdHlFcXVhbChpZGVudGl0eTEsIGlkZW50aXR5Mikge1xyXG4gIHJldHVybiBpZGVudGl0eVRvU3RyaW5nKGlkZW50aXR5MSwgdHJ1ZSkgPT09IGlkZW50aXR5VG9TdHJpbmcoaWRlbnRpdHkyLCB0cnVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmxhdHRlbihwcm9wcywgc2VwYXJhdG9yLCBuYW1lKSB7XHJcbiAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8ICcuJztcclxuICB2YXIgcHJlZml4ID0gbmFtZSA/IG5hbWUgKyBzZXBhcmF0b3IgOiAnJztcclxuICB2YXIgdmFsID0ge307XHJcbiAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgaWYgKGtleS5pbmRleE9mKHByZWZpeCkgIT09IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhdGggPSBrZXkuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xyXG4gICAgdmFyIHRhcmdldCA9IHZhbDtcclxuICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoc2VwYXJhdG9yKTtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICBpZiAoIXRhcmdldFtwYXJ0c1tpXV0pIHtcclxuICAgICAgICB0YXJnZXRbcGFydHNbaV1dID0ge307XHJcbiAgICAgIH1cclxuICAgICAgdGFyZ2V0ID0gdGFyZ2V0W3BhcnRzW2ldXTtcclxuICAgIH1cclxuICAgIHRhcmdldFtwYXJ0c1tpXV0gPSBwcm9wc1trZXldLnZhbHVlO1xyXG4gIH0pO1xyXG4gIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb3BFcXVhbChsaHMsIHJocykge1xyXG4gIGlmIChsaHMudmFsdWUgIT09IHJocy52YWx1ZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxocy51bmRlcmx5aW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgbGhzVW5kZXJseWluZyA9IGxocy51bmRlcmx5aW5nW2ldO1xyXG4gICAgdmFyIHJoc1VuZGVybHlpbmcgPSByaHMudW5kZXJseWluZ1tpXSB8fCB7fTtcclxuICAgIGlmIChsaHNVbmRlcmx5aW5nLnZhbHVlICE9PSByaHNVbmRlcmx5aW5nLnZhbHVlIHx8ICFpZGVudGl0eUVxdWFsKGxoc1VuZGVybHlpbmcucGFyZW50LCByaHNVbmRlcmx5aW5nLnBhcmVudCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgZmxhdHRlbjogZmxhdHRlbixcclxuICBwcm9wRXF1YWw6IHByb3BFcXVhbCxcclxuICBpZGVudGl0eVRvU3RyaW5nOiBpZGVudGl0eVRvU3RyaW5nLFxyXG4gIGlkZW50aXR5RXF1YWw6IGlkZW50aXR5RXF1YWxcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHByb3BFcXVhbCA9IHJlcXVpcmUoJy4vaGVscGVycycpLnByb3BFcXVhbDtcclxuXHJcbnZhciBVcGRhdGVUeXBlID0ge1xyXG4gIEFkZGVkOiAnQWRkZWQnLFxyXG4gIENoYW5nZWQ6ICdDaGFuZ2VkJyxcclxuICBSZW1vdmVkOiAnUmVtb3ZlZCdcclxufTtcclxuXHJcbnZhciBNb2RlbCA9IGZ1bmN0aW9uIChidXMsIHNlcGFyYXRvcikge1xyXG4gIHRoaXMuYnVzID0gYnVzO1xyXG4gIHRoaXMucm9vdCA9IG5ldyBWaWV3TW9kZWwodGhpcywgJycsIHNlcGFyYXRvciB8fCAnLicpO1xyXG4gIHRoaXMudmlld3MgPSB7fTtcclxufTtcclxuXHJcbnZhciBWaWV3TW9kZWwgPSBmdW5jdGlvbiAobW9kZWwsIHBhdGgsIHNlcGFyYXRvcikge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBzZWxmLm1vZGVsID0gbW9kZWw7XHJcbiAgc2VsZi5wcm9wcyA9IHt9O1xyXG4gIHNlbGYuc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8IG1vZGVsLnNlcGFyYXRvcjtcclxuICBzZWxmLnBhdGggPSBwYXRoO1xyXG59O1xyXG5cclxuVmlld01vZGVsLnByb3RvdHlwZS5nZXRWaWV3TW9kZWwgPSBmdW5jdGlvbiAobmFtZSwgc2VwYXJhdG9yKSB7XHJcbiAgdmFyIHBhdGggPSB0aGlzLnBhdGggKyBuYW1lICsgKHNlcGFyYXRvciA/IHNlcGFyYXRvciA6ICcuJyk7XHJcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcclxuICBpZiAocGF0aCA9PT0gJycpIHtcclxuICAgIHJldHVybiBtb2RlbC5yb290O1xyXG4gIH1cclxuICBpZiAoIW1vZGVsLnZpZXdzW3BhdGhdKSB7XHJcbiAgICB2YXIgYmVzdFBhcmVudCA9ICcnO1xyXG4gICAgLy8gZmlsbCBzdWJ2aWV3IHJlZmVyZW5jZXMgYW5kIGNob29zZSBiZXN0IHBhcmVudCBwcm9wcyB0byBjb3B5IGZyb20uXHJcbiAgICBPYmplY3Qua2V5cyhtb2RlbC52aWV3cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIGlmIChwYXRoLmluZGV4T2Yoa2V5KSA9PT0gMCkge1xyXG4gICAgICAgIGlmIChiZXN0UGFyZW50Lmxlbmd0aCA8IGtleS5sZW5ndGgpIHtcclxuICAgICAgICAgIGJlc3RQYXJlbnQgPSBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGtlZXAgc3Vidmlld3Mgc29ydGVkLlxyXG4gICAgICAgIHZhciBzdWJ2aWV3cyA9IG1vZGVsLnZpZXdzW2tleV0uc3Vidmlld3M7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ2aWV3cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKHN1YnZpZXdzW2ldLmluZGV4T2YocGF0aCkpIHtcclxuICAgICAgICAgICAgc3Vidmlld3Muc3BsaWNlKGksIDAsIHBhdGgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1YnZpZXdzLnB1c2gocGF0aCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIHZpZXdNb2RlbCA9IG5ldyBWaWV3TW9kZWwobW9kZWwsIHBhdGgsIHNlcGFyYXRvcik7XHJcblxyXG4gICAgdmFyIHBhcmVudFByb3BzID0gYmVzdFBhcmVudCA9PT0gJycgPyBtb2RlbC5yb290LnByb3BzIDogbW9kZWwudmlld3NbYmVzdFBhcmVudF0ubW9kZWwucHJvcHM7XHJcbiAgICBPYmplY3Qua2V5cyhwYXJlbnRQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIHZhciBwcm9wID0gcGFyZW50UHJvcHNba2V5XTtcclxuICAgICAgaWYgKHByb3AubmFtZS5pbmRleE9mKHBhdGgpID09PSAwKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWUuc3Vic3RyaW5nKHBhdGgubGVuZ3RoKTtcclxuICAgICAgICB2aWV3TW9kZWwucHJvcHNbbmFtZV0gPSBwcm9wO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2RlbC52aWV3c1twYXRoXSA9IHtcclxuICAgICAgc3Vidmlld3M6IFtdLFxyXG4gICAgICBtb2RlbDogdmlld01vZGVsXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gbW9kZWwudmlld3NbcGF0aF0ubW9kZWw7XHJcbn07XHJcblxyXG5WaWV3TW9kZWwucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzY29wZSkge1xyXG4gIHJldHVybiB0aGlzLm1vZGVsLm9uKHRoaXMucGF0aCwgY2FsbGJhY2ssIHNjb3BlKTtcclxufTtcclxuXHJcbk1vZGVsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChwYXRoLCBjYWxsYmFjaywgc2NvcGUpIHtcclxuICB2YXIgdHlwZSA9IHVwZGF0ZVR5cGVGb3JQYXRoKHBhdGgpO1xyXG4gIHJldHVybiB0aGlzLmJ1cy5vbih0eXBlLCBmYWxzZSwgY2FsbGJhY2ssIHNjb3BlKTtcclxufTtcclxuXHJcbk1vZGVsLnByb3RvdHlwZS5hcHBseVNuYXBzaG90ID0gZnVuY3Rpb24gKHNuYXBzaG90LCBpc1NuYXBzaG90KSB7XHJcbiAgaXNTbmFwc2hvdCA9IHR5cGVvZiBpc1NuYXBzaG90ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBpc1NuYXBzaG90O1xyXG5cclxuICB2YXIgdXBkYXRlcyA9IHRvVXBkYXRlcyhpc1NuYXBzaG90ID8ge30gOiB0aGlzLnJvb3QucHJvcHMsIHNuYXBzaG90LnByb3BzKTtcclxuICBhcHBseVVwZGF0ZXNBbmRFbWl0RXZlbnRzKHRoaXMsIHVwZGF0ZXMsIGlzU25hcHNob3QpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlVHlwZUZvclBhdGgocGF0aCkge1xyXG4gIHZhciB0eXBlID0gJ3VwZGF0ZSc7XHJcbiAgaWYgKHBhdGggIT09ICcnKSB7XHJcbiAgICB0eXBlID0gdHlwZSArICd8JyArIHBhdGg7XHJcbiAgfVxyXG4gIHJldHVybiB0eXBlO1xyXG59XHJcblxyXG4vLyBzaGFsbG93IGNvcHlcclxuZnVuY3Rpb24gY2xvbmVVcGRhdGVGb3JQYXRoKHVwZGF0ZSwgcGF0aCkge1xyXG4gIHZhciBjbG9uZSA9IHtcclxuICAgIHR5cGU6IHVwZGF0ZS50eXBlLFxyXG4gICAgbmFtZTogdXBkYXRlLm5hbWUuc3Vic3RyaW5nKHBhdGgubGVuZ3RoKVxyXG4gIH07XHJcblxyXG4gIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcclxuICAgIGNhc2UgVXBkYXRlVHlwZS5DaGFuZ2VkOlxyXG4gICAgICBjbG9uZS5vbGRWYWx1ZSA9IHVwZGF0ZS5vbGRWYWx1ZTtcclxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgY2FzZSBVcGRhdGVUeXBlLkFkZGVkOlxyXG4gICAgICBjbG9uZS52YWx1ZSA9IHVwZGF0ZS52YWx1ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFVwZGF0ZVR5cGUuUmVtb3ZlZDpcclxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiBjbG9uZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlVcGRhdGVzQW5kRW1pdEV2ZW50cyhtb2RlbCwgdXBkYXRlcywgaXNTbmFwc2hvdCkge1xyXG4gIHZhciB2aWV3cyA9IE9iamVjdC5rZXlzKG1vZGVsLnZpZXdzKTtcclxuICB2YXIgZWZmZWN0aXZlVXBkYXRlcyA9IHtcclxuICAgICcnOiB1cGRhdGVzXHJcbiAgfTtcclxuICBpZiAodmlld3MubGVuZ3RoID4gMCkge1xyXG4gICAgLy8gc29ydCB2aWV3cyBmb3IgcHJlZml4IHNlYXJjaFxyXG4gICAgaWYgKHZpZXdzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgdmlld3Muc29ydCgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3cy5sZW5ndGg7IHZpZXdzKyspIHtcclxuICAgICAgICBpZiAodXBkYXRlLm5hbWUuaW5kZXhPZih2aWV3c1tpXSkgPT09IDApIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgdmlldyA9IHZpZXdzW2ldO1xyXG4gICAgICBpZiAodHlwZW9mIHZpZXcgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGVmZmVjdGl2ZVVwZGF0ZXNbdmlld10ucHVzaChjbG9uZVVwZGF0ZUZvclBhdGgodXBkYXRlLCB2aWV3KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHZhciBhZmZlY3RlZFBhdGhzID0gT2JqZWN0LmtleXMoZWZmZWN0aXZlVXBkYXRlcyk7XHJcbiAgaWYgKGFmZmVjdGVkUGF0aHMubGVuZ3RoID4gMSkge1xyXG4gICAgYWZmZWN0ZWRQYXRocy5zb3J0KCk7XHJcbiAgfVxyXG4gIGFmZmVjdGVkUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgdmFyIHZpZXdNb2RlbCA9IHBhdGggPT09ICcnID8gbW9kZWwucm9vdCA6IG1vZGVsLnZpZXdzW3BhdGhdLm1vZGVsO1xyXG4gICAgaWYgKGlzU25hcHNob3QpIHtcclxuICAgICAgdmlld01vZGVsLnByb3BzID0ge307XHJcbiAgICB9XHJcbiAgICBlZmZlY3RpdmVVcGRhdGVzW3BhdGhdLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xyXG4gICAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBVcGRhdGVUeXBlLkFkZGVkOlxyXG4gICAgICAgICAgLy8gZmFsbC10aHJvdWdoXHJcbiAgICAgICAgY2FzZSBVcGRhdGVUeXBlLkNoYW5nZWQ6XHJcbiAgICAgICAgICAvLyBjaGFuZ2VkIHdvcmtzIGV2ZW4gZm9yIG1pc3NpbmcgcHJvcGVydGllc1xyXG4gICAgICAgICAgdmlld01vZGVsLnByb3BzW3VwZGF0ZS5uYW1lXSA9IHVwZGF0ZS52YWx1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgVXBkYXRlVHlwZS5SZW1vdmVkOlxyXG4gICAgICAgICAgZGVsZXRlIHZpZXdNb2RlbC5wcm9wc1t1cGRhdGUubmFtZV07XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIGFmZmVjdGVkUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgdmFyIHR5cGUgPSB1cGRhdGVUeXBlRm9yUGF0aChwYXRoKTtcclxuICAgIG1vZGVsLmJ1cy5lbWl0KHR5cGUsIGlzU25hcHNob3QsIHVwZGF0ZXMpO1xyXG4gIH0pO1xyXG59XHJcbk1vZGVsLnByb3RvdHlwZS5hcHBseVVwZGF0ZXMgPSBmdW5jdGlvbiAodXBkYXRlcykge1xyXG4gIGFwcGx5VXBkYXRlc0FuZEVtaXRFdmVudHModGhpcywgdXBkYXRlcywgZmFsc2UpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdG9VcGRhdGVzKGltYWdlLCBzbmFwc2hvdCkge1xyXG4gIHNuYXBzaG90ID0gc25hcHNob3QgfHwge307XHJcbiAgdmFyIHVwZGF0ZXMgPSBbXTtcclxuICB2YXIgdG9EZWxldGUgPSBPYmplY3Qua2V5cyhpbWFnZSk7XHJcbiAgT2JqZWN0LmtleXMoc25hcHNob3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgdmFyIHVwZGF0ZSA9IHt9O1xyXG4gICAgaWYgKHR5cGVvZiBpbWFnZVtrZXldID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB1cGRhdGUudHlwZSA9IFVwZGF0ZVR5cGUuQWRkZWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoIXByb3BFcXVhbChpbWFnZVtrZXldLCBzbmFwc2hvdFtrZXldKSkge1xyXG4gICAgICAgIHVwZGF0ZS50eXBlID0gVXBkYXRlVHlwZS5DaGFuZ2VkO1xyXG4gICAgICAgIHVwZGF0ZS5vbGRWYWx1ZSA9IGltYWdlW2tleV07XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0RlbGV0ZS5sZW5ndGg7IHRvRGVsZXRlKyspIHtcclxuICAgICAgICBpZiAodG9EZWxldGVbaV0gPT09IGtleSkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgdG9EZWxldGVbaV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdG9EZWxldGUuc3BsaWNlKGksIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodXBkYXRlLnR5cGUpIHtcclxuICAgICAgdXBkYXRlLnZhbHVlID0gc25hcHNob3Rba2V5XTtcclxuICAgICAgdXBkYXRlLm5hbWUgPSBrZXk7XHJcbiAgICAgIHVwZGF0ZXMucHVzaCh1cGRhdGUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHRvRGVsZXRlLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgdXBkYXRlcy5wdXNoKHtcclxuICAgICAgdHlwZTogVXBkYXRlVHlwZS5SZW1vdmVkLFxyXG4gICAgICBuYW1lOiBrZXlcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiB1cGRhdGVzO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuZmxhdHRlbjtcclxuXHJcbnZhciBQcm9wcyA9IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gIHZhciBwcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHJldHVybiBtb2RlbC5wcm9wc1tuYW1lXTtcclxuICB9O1xyXG4gIHZhciB2YWwgPSBmdW5jdGlvbiB2YWwobmFtZSkge1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgbW9kZWwucHJvcHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiBmbGF0dGVuKG1vZGVsLnByb3BzLCBtb2RlbC5zZXBhcmF0b3IsIG5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1vZGVsLnByb3BzW25hbWVdLnZhbHVlO1xyXG4gIH07XHJcblxyXG4gIHZhciBwcm9wcyA9IGZ1bmN0aW9uIChzZWN0aW9uLCBzZXBhcmF0b3IpIHtcclxuICAgIHNlY3Rpb24gPSBzZWN0aW9uIHx8ICcnO1xyXG4gICAgaWYgKHNlY3Rpb24gPT09ICcnKSB7XHJcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgc2VwYXJhdG9yIGNoYW5nZSBmb3IgJycgKHNhbWUpIHNlY3Rpb24uXHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8IG1vZGVsLnNlcGFyYXRvcjtcclxuICAgIHJldHVybiBuZXcgUHJvcHMobW9kZWwuZ2V0Vmlld01vZGVsKHNlY3Rpb24sIHNlcGFyYXRvcikpO1xyXG4gIH07XHJcbiAgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XHJcbiAgICBPYmplY3Qua2V5cyhtb2RlbC5wcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUsIG1vZGVsLnByb3BzW2tleV0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuICB2YXIgb25VcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNjb3BlKSB7XHJcbiAgICBtb2RlbC5vbihjYWxsYmFjaywgc2NvcGUpO1xyXG4gIH07XHJcbiAgdmFyIHNlbGYgPSB7XHJcbiAgICBwcm9wOiBwcm9wLFxyXG4gICAgdmFsOiB2YWwsXHJcbiAgICBwcm9wczogcHJvcHMsXHJcbiAgICBmb3JFYWNoOiBmb3JFYWNoLFxyXG4gICAgb25VcGRhdGU6IG9uVXBkYXRlXHJcbiAgfTtcclxuICByZXR1cm4gc2VsZjtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvcHM7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB1dWlkID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XHJcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XHJcbiAgICB2YXIgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XHJcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XHJcbiAgfSk7XHJcbn07XHJcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcclxufTtcclxuXHJcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xyXG59O1xyXG5cclxudmFyIGxldmVscyA9IHtcclxuICBkZWJ1ZzogJ2RlYnVnJyxcclxuICBpbmZvOiAnaW5mbycsXHJcbiAgd2FybjogJ3dhcm4nLFxyXG4gIGVycm9yOiAnZXJyb3InXHJcbn07XHJcbnZhciBsb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcclxuICBpZiAoY29uc29sZSkge1xyXG4gICAgdmFyIGxvZ2dlciA9IGNvbnNvbGVbbGV2ZWxdO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24obG9nZ2VyKSkge1xyXG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgW10uc3BsaWNlLmNhbGwoYXJncywgMCwgMCwgbm93LmdldEhvdXJzKCkgKyAnOicgKyBub3cuZ2V0TWludXRlcygpICsgJzonICsgbm93LmdldFNlY29uZHMoKSk7XHJcbiAgICAgIGxvZ2dlci5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbnZhciBpbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gIGxvZyhsZXZlbHMuaW5mbywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciB3YXJuID0gZnVuY3Rpb24gKCkge1xyXG4gIGxvZyhsZXZlbHMud2FybiwgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcclxuICBsb2cobGV2ZWxzLmRlYnVnLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgdXVpZDogdXVpZCxcclxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxyXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcclxuICBsb2c6IGxvZyxcclxuICB3YXJuOiB3YXJuLFxyXG4gIGluZm86IGluZm8sXHJcbiAgZGVidWc6IGRlYnVnXHJcbn07XHJcbiIsInZhciBjb25uZWN0aW9uID0gZnVuY3Rpb24gKHNldHRpbmdzLCBjdXN0b21fY29ubmVjdGlvbil7XHJcblx0c2V0dGluZ3MgPSBzZXR0aW5nc3x8e307XHJcblx0Ly9UaGUgbWVzc2FnZSBoYW5kbGVycyB0aGF0IGhhdmUgdG8gYmUgZXhlY3V0ZWQgZm9yIGVhY2ggcmVjZWl2ZWQgbWVzc2FnZVxyXG5cdHZhciBtZXNzYWdlX2hhbmRsZXJzID0ge307XHJcblx0XHJcblx0dmFyIGlkcyA9IDA7XHJcblx0XHJcblx0dmFyIGNvbm5lY3Rpb24gPSB7XHJcblx0XHQvL0V4ZWN1dGVzIGFwcHJvcHJpYXRlIG1lc3NhZ2UgaGFuZGxlcnMgZm9yIHRoZSBtZXNzYWdlIHR5cGUuXHJcblx0XHRfaGFuZGxlX21lc3NhZ2U6IGZ1bmN0aW9uIChtZXNzYWdlKXtcclxuXHRcdFx0IC8vUmV0cmlldmUgaGFuZGxlcnMgZm9yIHRoZSBtZXNzYWdlIHR5cGVcclxuXHRcdFx0IHZhciBoYW5kbGVycyA9IG1lc3NhZ2VfaGFuZGxlcnNbbWVzc2FnZS50eXBlXTtcclxuXHRcdFx0IGlmKGhhbmRsZXJzICE9PXVuZGVmaW5lZCl7XHJcblx0XHRcdFx0IC8vRXhlY3V0ZSB0aGVtXHJcblx0XHRcdFx0IE9iamVjdC5rZXlzKGhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXJfaWQpe1xyXG5cdFx0XHRcdFx0dmFyIGhhbmRsZXIgPSBoYW5kbGVyc1toYW5kbGVyX2lkXTtcclxuXHRcdFx0XHRcdGlmKGhhbmRsZXIhPT11bmRlZmluZWQpe2hhbmRsZXIobWVzc2FnZS5tZXNzYWdlKTt9XHJcblx0XHRcdFx0IH0pO1xyXG5cdFx0XHQgfVxyXG5cdFx0fSxcclxuXHRcdC8vQXR0YWNoZXMgYSBoYW5kbGVyXHJcblx0XHRvbjogZnVuY3Rpb24ocHJvZHVjdCwgdHlwZSwgbWVzc2FnZV9oYW5kbGVyKXtcclxuXHRcdCAgIGlmKG1lc3NhZ2VfaGFuZGxlcnNbdHlwZV0gPT09IHVuZGVmaW5lZCl7bWVzc2FnZV9oYW5kbGVyc1t0eXBlXSA9IHt9O31cclxuXHRcdCAgIHZhciBpZCA9IGlkcysrO1xyXG5cdFx0ICAgbWVzc2FnZV9oYW5kbGVyc1t0eXBlXVtpZF09IG1lc3NhZ2VfaGFuZGxlcjtcclxuXHRcdCAgIHJldHVybiB7dHlwZTp0eXBlLCBpZDppZH07XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvL1JlbW92ZSBhIGhhbmRsZXIgXHJcblx0XHRvZmY6IGZ1bmN0aW9uKGluZm8pe1xyXG5cdFx0XHRkZWxldGUgbWVzc2FnZV9oYW5kbGVyc1tpbmZvLnR5cGVdW2luZm8uaWRdO1xyXG5cdFx0fSxcclxuXHRcdC8vRHVtbXkgZnVuY3Rpb25zIGZvciB0cmFuc3BvcnRzIHRoYXQgYXJlIGFsd2F5cyBjb25uZWN0ZWRcclxuXHRcdGNvbm5lY3RlZDpmdW5jdGlvbihhKXthKCk7fSxcclxuXHRcdGRpc2Nvbm5lY3RlZDpmdW5jdGlvbigpe30sXHJcblx0XHR2ZXJzaW9uOiBcIjEuMy4xXCJcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2Nvbm5lY3Rpb24oY29ubmVjdGlvbil7XHJcblx0XHRjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbihwcm9kdWN0LCB0eXBlLCBtZXNzYWdlKXtcclxuXHRcdFx0Y3VzdG9tX2Nvbm5lY3Rpb24ucHVibGlzaCh7dHlwZTp0eXBlLCBtZXNzYWdlOm1lc3NhZ2V9KTtcclxuXHRcdH07XHJcblx0XHRjdXN0b21fY29ubmVjdGlvbi5zdWJzY3JpYmUoY29ubmVjdGlvbi5faGFuZGxlX21lc3NhZ2UpO1xyXG5cdFx0cmV0dXJuIGNvbm5lY3Rpb247XHJcblx0fVxyXG5cclxuXHRpZihzZXR0aW5ncy53ZWJzb2NrZXRfdXJsIT09dW5kZWZpbmVkKXtcclxuXHRcdHJldHVybiByZXF1aXJlKFwiLi93c1wiKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XHJcbiAgfWVsc2UgaWYoc2V0dGluZ3MuaHR0cF91cmwgIT09IHVuZGVmaW5lZCl7XHJcbiAgICByZXR1cm4gcmVxdWlyZShcIi4vaHR0cFwiKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XHJcbiAgfWVsc2UgaWYoZ2xvYmFsLmZpbiAhPT11bmRlZmluZWQpe1xyXG5cdFx0cmV0dXJuIHJlcXVpcmUoXCIuL2ZpblwiKShjb25uZWN0aW9uLCBzZXR0aW5ncyk7XHJcblx0fWVsc2UgaWYoY3VzdG9tX2Nvbm5lY3Rpb24hPT11bmRlZmluZWQpe1xyXG5cdFx0cmV0dXJuIGNyZWF0ZV9jdXN0b21fY29ubmVjdGlvbihjb25uZWN0aW9uLCBzZXR0aW5ncyk7XHJcblx0Ly9Db25uZWN0IHZpYSBIVE1MIENvbnRhaW5lciBmYWNhZGVcclxuXHR9ZWxzZSBpZiAoZ2xvYmFsLmh0bWxDb250YWluZXIhPT11bmRlZmluZWQpe1xyXG5cdFx0cmV0dXJuIHJlcXVpcmUoXCIuL2NvbnRcIikoY29ubmVjdGlvbiwgc2V0dGluZ3MpO1xyXG5cdH1lbHNlIHtcclxuXHRcdHRocm93IFwiTm8gY29ubmVjdGlvbi4gTWFrZSBzdXJlIHlvdSBhcmUgcnVubmluZyB0aGUgYXBwbGljYXRpb24gZnJvbSBPcGVuRmluLCBvciBUaWNrNDIgSFRNTCBDb250YWluZXIgb3IgZmlsbCB0aGUgJ2Nvbm5lY3Rpb24ud2Vic29ja2V0X3VybCcgcHJvcGVydHkuXCI7XHJcblx0fVxyXG59O1xyXG5cclxuaWYoZ2xvYmFsLnRpY2s0Mj09PXVuZGVmaW5lZCl7Z2xvYmFsLnRpY2s0MiA9IHt9O31cclxuZ2xvYmFsLnRpY2s0Mi5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdGlvbjtcclxuXHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29ubmVjdGlvbil7XHJcblx0dmFyIGNvbm5lY3Rpb25faWQgPSAgTWF0aC5mbG9vcigxZTEwICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKTtcclxuXHQvL1JvdXRlIG1lc3NhZ2VzIHRvIGZhY2FkZShzKVxyXG5cdGNvbm5lY3Rpb24uc2VuZCA9IGZ1bmN0aW9uIChwcm9kdWN0LCB0eXBlLCBtZXNzYWdlKXtcclxuXHRcdGlmKHByb2R1Y3QgPT09XCJtZXRyaWNzXCIpe1xyXG5cdFx0XHRnbG9iYWwuaHRtbENvbnRhaW5lci5tZXRyaWNzRmFjYWRlLnNlbmQodHlwZSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xyXG5cdFx0fWVsc2UgaWYocHJvZHVjdCA9PT1cImxvZ1wiKXtcclxuXHRcdFx0Z2xvYmFsLmh0bWxDb250YWluZXIubG9nZ2luZ0ZhY2FkZS5zZW5kKHR5cGUsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcclxuXHRcdH1lbHNlIGlmIChwcm9kdWN0ID09IFwiYXBwY29uZmlnXCIpIHtcclxuICAgICAgICAgICAgZ2xvYmFsLmh0bWxDb250YWluZXIuYXBwQ29uZmlnRmFjYWRlLnNlbmQodHlwZSwgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSksIGNvbm5lY3Rpb25faWQpO1xyXG4gICAgICAgIH1cclxuXHR9O1xyXG5cdGlmIChnbG9iYWwuaHRtbENvbnRhaW5lci5hcHBDb25maWdGYWNhZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGdsb2JhbC5odG1sQ29udGFpbmVyLmFwcENvbmZpZ0ZhY2FkZS5pbml0Q29ubmVjdGlvbihcclxuICAgICAgICAgICAgY29ubmVjdGlvbl9pZCxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKG1lc3NhZ2VBc0pzb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLl9oYW5kbGVfbWVzc2FnZShKU09OLnBhcnNlKG1lc3NhZ2VBc0pzb24pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblx0Z2xvYmFsLmNvbm5lY3Rpb25zID0gZ2xvYmFsLmNvbm5lY3Rpb25zfHx7fTsgXHJcblx0Ly9FeHBvc2UgZnVuY3Rpb24gZm9yIHNlbmRpbmcgbWVzc2FnZXM6XHJcblx0Z2xvYmFsLmNvbm5lY3Rpb25zWydjb25uZWN0aW9uJytjb25uZWN0aW9uX2lkXSA9IGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlO1xyXG5cclxuXHRyZXR1cm4gY29ubmVjdGlvbjtcclxufTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBzZXR0aW5ncyl7XHJcblx0aWYoZ2xvYmFsLmNvbnNvbGUhPT11bmRlZmluZWQmJiBzZXR0aW5ncy5kZWJ1Zz09PXRydWUpe1xyXG5cdFx0Y29uc29sZS5sb2coXCJBdHRlbXBpbmcgdG8gY29ubmVjdCB0byBHYXRld2F5IHZpYSBPcGVuRmluIEludGVyIEFwcGxpY2F0aW9uIEJ1cy5cIik7XHJcblx0fVxyXG5cclxuXHQvL0EgZnVuY3Rpb24gZm9yIHNlbmRpbmcgYSBtZXNzYWdlIFxyXG5cdGNvbm5lY3Rpb24uc2VuZCA9IGZ1bmN0aW9uKHByb2R1Y3QsIHR5cGUsIG1lc3NhZ2Upe1xyXG5cdFx0ZmluLmRlc2t0b3AuSW50ZXJBcHBsaWNhdGlvbkJ1cy5wdWJsaXNoKFwiQUdNXCIsIHt0eXBlOnR5cGUsIG1lc3NhZ2U6bWVzc2FnZX0pO1xyXG5cdH07XHJcblx0Ly9BIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgbWVzc2FnZXNcclxuXHRmaW4uZGVza3RvcC5JbnRlckFwcGxpY2F0aW9uQnVzLnN1YnNjcmliZSgnKicsJ0FHTScsIGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlKTtcclxuXHRpZihnbG9iYWwuY29uc29sZSE9PXVuZGVmaW5lZCYmIHNldHRpbmdzLmRlYnVnPT09dHJ1ZSl7XHJcblx0XHRjb25zb2xlLmxvZyhcIkNvbm5lY3RlZCB0byBPcGVuRmluIHRyYW5zcG9ydC5cIik7XHJcblx0fVxyXG5cdFxyXG5cdHJldHVybiBjb25uZWN0aW9uO1xyXG59O1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBzZXR0aW5ncykge1xyXG4gIHZhciB1cmwgPSBzZXR0aW5ncy5odHRwX3VybDtcclxuICAvLyBwb2xsaW5nIGludGVydmFsIGluIG1zLCBkZWZhdWx0IGlzIDEgc2Vjb25kXHJcbiAgdmFyIGludGVydmFsID0gc2V0dGluZ3MuaHR0cF9pbnRlcnZhbF9tcztcclxuICBpZiAoIWludGVydmFsKSBpbnRlcnZhbCA9IDEwMDA7XHJcblxyXG4gIGZ1bmN0aW9uIGxvZ19kZWJ1ZyhtZXNzYWdlKSB7XHJcbiAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgIT09IHVuZGVmaW5lZCAmJiAoc2V0dGluZ3MuZGVidWcgPT09IHRydWUgfHwgc2V0dGluZ3MudHJhY2UgPT09IHRydWUpKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbG9nX3RyYWNlKG1lc3NhZ2UpIHtcclxuICAgIGlmIChnbG9iYWwuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLnRyYWNlID09PSB0cnVlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbG9nX2RlYnVnKFwiQXR0ZW1waW5nIHRvIGNvbm5lY3QgdG8gR2F0ZXdheSB2aWEgSFRUUCB3aXRoIHVybCAnXCIgKyB1cmwgKyBcIicgYW5kIHBvbGxpbmcgaW50ZXJ2YWwgXCIgKyBpbnRlcnZhbCArIFwiIG1zXCIpO1xyXG5cclxuICBwb2xsKHVybCwgaW50ZXJ2YWwsIDAsIGZ1bmN0aW9uIChpdGVtcykge1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGl0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICBjb25uZWN0aW9uLl9oYW5kbGVfbWVzc2FnZShpdGVtc1tpbmRleF0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbiAocHJvZHVjdCwgdHlwZSwgbWVzc2FnZSwgaWQpIHtcclxuICAgIHZhciBtc2cgPSBKU09OLnN0cmluZ2lmeSh7IHR5cGU6IHR5cGUsIG1lc3NhZ2U6IG1lc3NhZ2UsIGlkOiBpZCB9KTtcclxuICAgIGh0dHBfcG9zdCh1cmwsIG1zZyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUG9sbHMgZGF0YSBmcm9tIGEgZ2l2ZW4gdXJsIG9uIHNvbWUgaW50ZXJ2YWxcclxuICAgKiBAcGFyYW0gdXJsICAgICAgIEJhc2Ugc2VydmVyIHVybC4gQSBzZXF1ZW5jZSB1cmwgcGFyYW0gbWF5IGJlIGFkZGVkIGJhc2VkIG9uIHRoZSBzZXEgcGFyYW1cclxuICAgKiBAcGFyYW0gaW50ZXJ2YWwgIEludGVydmFsIChpbiBtcykgYmV0d2VlbiBwb2xsaW5nIHJlcXVlc3R0c1xyXG4gICAqIEBwYXJhbSBzZXEgICAgICAgTmV4dCBzZXF1ZW5jZSBudW1iZXIgd2Ugc2hvdWxkIGFzayBmb3IgKGlmIDAgdGhlIHNlcnZlciB3aWxsIHJldHVybiB0aGUgbGFzdCBrbm93biBtZXNzYWdlKVxyXG4gICAqIEBwYXJhbSBvbmRhdGEgICAgRGF0YSBjYWxsYmFjayAgICBcclxuICAgKi9cclxuICBmdW5jdGlvbiBwb2xsKHVybCwgaW50ZXJ2YWwsIHNlcSwgb25kYXRhKSB7XHJcbiAgICAvLyBjb25zdHJ1Y3QgdGhlIGdldCBVcmwgLSBpZiBzZXEgIT0gMCBhZGQgYXMgdXJsIHBhcmFtIHRvIGdldCBcclxuICAgIC8vIG9ubHkgbWVzc2FnZXMgYWZ0ZXIgdGhpcyBzZXF1ZW5jZVxyXG4gICAgdmFyIGdldFVybCA9IHVybDtcclxuXHJcbiAgICBpZiAoc2VxICE9PSAwKSB7XHJcbiAgICAgIGdldFVybCA9IHVybCArIFwiP3NlcXVlbmNlPVwiICsgc2VxICsgXCImbm8tY2FjaGU9XCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIH0gICAgXHJcbiAgICAgICAgXHJcbiAgICAvLyBjcmVhdGUgYSByZXF1ZXN0ICAgIFxyXG4gICAgdmFyIHhtbGh0dHAgPSBjcmVhdGVDT1JTUmVxdWVzdChcIkdFVFwiLCBnZXRVcmwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHNlcSA9PT0gMCl7XHJcbiAgICAgICAgbG9nX2RlYnVnKFwiQ29ubmVjdGVkIHRvIEdhdGV3YXkgb24gXCIgKyB1cmwpO1xyXG4gICAgICB9XHJcbiAgICAgIGxvZ190cmFjZShcIlJlc3BvbnNlIGZyb20gJ1wiICsgZ2V0VXJsICsgXCInIGlzIFwiICsgeG1saHR0cC5yZXNwb25zZVRleHQpO1xyXG4gICAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoeG1saHR0cC5yZXNwb25zZVRleHQpO1xyXG4gICAgICAvLyB0aGUgc2VydmVyIHJldHVybnMgdGhlIG51bWJlciBvZiB0aGUgbmV4dCBzZXF1ZW5jZSB0aGF0IHdlIG11c3QgcXVlcnkgZm9yXHJcbiAgICAgIHZhciBuZXh0U2VxID0gbWVzc2FnZS5uZXh0U2VxdWVuY2U7XHJcbiAgICAgIC8vIGNhbGwgdXNlciBjYWxsYmFja2UgICAgXHJcbiAgICAgIG9uZGF0YShtZXNzYWdlLmRhdGEpO1xyXG4gICAgICAvLyByZS1zY2hlZHVsZVxyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwb2xsKHVybCwgaW50ZXJ2YWwsIG5leHRTZXEsIG9uZGF0YSk7XHJcbiAgICAgIH0sIGludGVydmFsKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHhtbGh0dHAub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIHBvbGxpbmcgZGF0YSBmcm9tIGh0dHAgc2VydmVyICdcIiArIGdldFVybCArIFwiJyAtIFwiICsgZXYpO1xyXG4gICAgICAvLyByZS1zY2hlZHVsZVxyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwb2xsKHVybCwgaW50ZXJ2YWwsIHNlcSwgb25kYXRhKTtcclxuICAgICAgfSwgaW50ZXJ2YWwpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsb2dfdHJhY2UoXCJTZW5kaW5nIEdFVCB0byAnXCIgKyBnZXRVcmwgKyBcIidcIik7XHJcbiAgICB4bWxodHRwLnNlbmQoKTtcclxuICB9XHJcblxyXG4gIC8qKiBcclxuICAgKiBQT1NUcyBhIG1lc3NhZ2UgdG8gYSBnaXZlbiB1cmwgXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaHR0cF9wb3N0KHVybCwgbWVzc2FnZSkge1xyXG4gICAgLy8gY3JlYXRlIGEgcmVxdWVzdCAgICBcclxuICAgIHZhciB4bWxodHRwID0gY3JlYXRlQ09SU1JlcXVlc3QoXCJQT1NUXCIsIHVybCk7XHJcbiAgICBsb2dfdHJhY2UoXCJTZW5kaW5nIFBPU1QgdG8gJ1wiICsgdXJsICsgXCInIDogXCIgKyBtZXNzYWdlKTtcclxuICAgIHhtbGh0dHAuc2VuZChtZXNzYWdlKTtcclxuICB9XHJcblxyXG4gIC8qKiBcclxuICAgKiBDcmVhdGVzIENPUlMgcmVxdWVzdCAoY3Jvc3MgZG9tYWluIHJlcXVlc3RzKSBmb3IgZGlmZmVyZW50IGJyb3dzZXJzIC0gWE1MSHR0cFJlcXVlc3Qgd2l0aENyZWRlbnRpYWxzXHJcbiAgICogZm9yIENocm9tZSBhbmQgRkYgYW5kIFhEb21haW5SZXF1ZXN0IGZvciBJRVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZUNPUlNSZXF1ZXN0KG1ldGhvZCwgdXJsLCByZXN1bHRfY2FsbGJhY2spIHtcclxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsgICAgXHJcbiAgICBcclxuICAgIGlmIChcIndpdGhDcmVkZW50aWFsc1wiIGluIHhocikge1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0IGhhcyBhIFwid2l0aENyZWRlbnRpYWxzXCIgcHJvcGVydHkuXHJcbiAgICAgIC8vIFwid2l0aENyZWRlbnRpYWxzXCIgb25seSBleGlzdHMgb24gWE1MSFRUUFJlcXVlc3QyIG9iamVjdHMuXHJcbiAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcclxuICAgICAgaWYgKHR5cGVvZiByZXN1bHRfY2FsbGJhY2sgIT09IFwidW5kZWZpbmVkXCIpe1xyXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCAmJiB4aHIuc3RhdHVzID09IDIwMCkge1xyXG4gICAgICAgICAgICByZXN1bHRfY2FsbGJhY2soKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgaWYgWERvbWFpblJlcXVlc3QuXHJcbiAgICAgIC8vIFhEb21haW5SZXF1ZXN0IG9ubHkgZXhpc3RzIGluIElFLCBhbmQgaXMgSUUncyB3YXkgb2YgbWFraW5nIENPUlMgcmVxdWVzdHMuXHJcbiAgICAgIHhociA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xyXG4gICAgICB4aHIub3BlbihtZXRob2QsIHVybCk7XHJcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0X2NhbGxiYWNrICE9PSBcInVuZGVmaW5lZFwiKXtcclxuICAgICAgICB4aHIub25sb2FkID0gcmVzdWx0X2NhbGxiYWNrO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBPdGhlcndpc2UsIENPUlMgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci5cclxuICAgICAgeGhyID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB4aHI7XHJcbiAgfVxyXG4gXHJcbiAgcmV0dXJuIGNvbm5lY3Rpb247XHJcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBzZXR0aW5ncyl7XHJcblx0dmFyIGNvbm5lY3RlZCA9IGZhbHNlO1xyXG5cdFxyXG5cdC8vTG9hZCB0aGUgJ3dzJyBsaWJyYXJ5LCBidXQgb25seSBpZiB3ZSBhcmUgcnVubmluZyB1bmRlciBub2RlIGpzXHJcblx0dmFyIFdlYlNvY2tldCA9IHJlcXVpcmUoXCJkZXRlY3Qtbm9kZVwiKT9yZXF1aXJlKFwid3NcIik6Z2xvYmFsLldlYlNvY2tldDtcclxuXHRcclxuXHRmdW5jdGlvbiBpbml0aWF0ZV9zb2NrZXQoKXtcclxuXHRcdGlmKGdsb2JhbC5jb25zb2xlIT09dW5kZWZpbmVkJiYgc2V0dGluZ3MuZGVidWc9PT10cnVlKXtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJBdHRlbXBpbmcgdG8gY29ubmVjdCB0byBHYXRld2F5IHZpYSBXZWJTb2NrZXQuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB3cyA9IG5ldyBXZWJTb2NrZXQoc2V0dGluZ3Mud2Vic29ja2V0X3VybCk7XHJcblx0XHQvL0FkZCB1c2VyIGNhbGxiYWNrc1xyXG5cdFx0d3Mub25jbG9zZSA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuXHRcdFx0aWYodHlwZW9mIHNldHRpbmdzLmRpc2Nvbm5lY3RlZD09PVwiZnVuY3Rpb25cIil7c2V0dGluZ3MuZGlzY29ubmVjdGVkKHNldHRpbmdzLndlYnNvY2tldF91cmwsIGV2ZW50KTt9XHJcblx0XHRcdGNvbm5lY3RlZCA9IGZhbHNlO1xyXG5cdFx0fTtcclxuXHRcdC8vTG9nIG9uIGNvbm5lY3Rpb25cclxuXHRcdHdzLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XHJcblx0XHRcdGlmKHR5cGVvZiBzZXR0aW5ncy5jb25uZWN0ZWQ9PT1cImZ1bmN0aW9uXCIpe3NldHRpbmdzLmNvbm5lY3RlZChzZXR0aW5ncy53ZWJzb2NrZXRfdXJsKTt9XHJcblx0XHRcdGlmKGdsb2JhbC5jb25zb2xlIT09dW5kZWZpbmVkICYmIHNldHRpbmdzLmRlYnVnPT09dHJ1ZSl7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gV1MgVVJMIFwiK3NldHRpbmdzLndlYnNvY2tldF91cmwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNvbm5lY3RlZCA9IHRydWU7XHJcblx0XHR9O1xyXG5cdFx0Ly9BdHRhY2ggaGFuZGxlclxyXG5cdFx0d3Mub25tZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSl7XHJcblx0XHRcdGNvbm5lY3Rpb24uX2hhbmRsZV9tZXNzYWdlKEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKSk7XHJcblx0XHR9O1xyXG5cdFx0cmV0dXJuIHdzO1xyXG5cdH1cclxuXHRcclxuXHQvL0luaXRpYXRlIGEgbmV3IHNvY2tldCAodGhpcyBnZXRzIHJlLWV4ZWN1dGVkIG9uIHJlY29ubmVjdClcclxuXHR2YXIgc29ja2V0ID0gaW5pdGlhdGVfc29ja2V0KCk7XHJcblx0XHJcblx0Ly9DcmVhdGUgYSBmdW5jdGlvbiBmb3Igc2VuZGluZyBhIG1lc3NhZ2VcclxuXHRjb25uZWN0aW9uLnNlbmQgPSBmdW5jdGlvbihwcm9kdWN0LCB0eXBlLCBtZXNzYWdlLCBpZCl7XHJcblx0XHQvL0lmIHdlIGFyZSBjb25uZWN0ZWQgc2VuZCB0aGUgbWVzc2FnZVxyXG5cdFx0aWYoc29ja2V0LnJlYWR5U3RhdGUgPT09MSl7XHJcblx0XHRcdHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHt0eXBlOnR5cGUsIG1lc3NhZ2U6bWVzc2FnZSwgaWQ6aWR9KSk7XHJcblx0XHQvL0lmIHdlIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3ZSBhcmUgbm90IGF0dGVtcHRpbmcgdG8gY29ubmVjdCByaWdodCBub3csIGF0dGVtcHQgdG8gY29ubmVjdFxyXG5cdFx0fWVsc2UgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PTApe1xyXG5cdFx0XHRzb2NrZXQgPSBpbml0aWF0ZV9zb2NrZXQoKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdGNvbm5lY3Rpb24ud2Vic29ja2V0X3VybCA9IGZ1bmN0aW9uKGEpe1xyXG5cdFx0c2V0dGluZ3Mud2Vic29ja2V0X3VybCA9IGE7XHJcblx0XHRzb2NrZXQuY2xvc2UoKTtcclxuXHRcdHNvY2tldCA9IGluaXRpYXRlX3NvY2tldCgpO1xyXG5cdH07XHJcblx0XHJcblx0Y29ubmVjdGlvbi5jb25uZWN0ZWQgPSBmdW5jdGlvbihhKXtcclxuXHRcdGlmKGNvbm5lY3RlZCl7YShzZXR0aW5ncy53ZWJzb2NrZXRfdXJsKTt9XHJcblx0XHRzZXR0aW5ncy5jb25uZWN0ZWQgPSBhO1xyXG5cdH07XHJcblx0Y29ubmVjdGlvbi5kaXNjb25uZWN0ZWQgPSBmdW5jdGlvbihhKXtcclxuXHRcdHNldHRpbmdzLmRpc2Nvbm5lY3RlZCA9IGE7XHJcblx0fTtcclxuXHRcclxuXHRyZXR1cm4gY29ubmVjdGlvbjtcclxufTtcclxuIiwidmFyIGFzY2lpVGFibGUgPSByZXF1aXJlKFwiYXNjaWktdGFibGVcIik7XG52YXIgdGljazQyQ29ubmVjdGlvbiA9IHJlcXVpcmUoXCJ0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uXCIpO1xuXG52YXIgbGV2ZWxzID0gWyAndHJhY2UnLCAnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJywgJ29mZicgXTtcblxuZnVuY3Rpb24gc2VyaWFsaXplUGF0aChwYXRoKSB7XG5cdHJldHVybiBwYXRoLmxlbmd0aCA9PT0gMCA/IFwiXCIgOiBwYXRoLmpvaW4oXCIuXCIpO1xufVxuXG52YXIgaXNDb25uZWN0aW9uID0gZnVuY3Rpb24oYykge1xuXHRyZXR1cm4gdHlwZW9mIGMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGMuc2VuZCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjLm9uID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG5mdW5jdGlvbiBnZXRMZXZlbChsb2dnZXIsIGxldmVsKSB7XG5cdC8vUmV0cmlldmVzIHRoZSBjb25zb2xlIG9yIHB1Ymxpc2ggbGV2ZWwgb2YgYSBsb2dnZXJcblx0Ly9sb2dnZXIgLSB0aGUgbG9nZ2VyIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGV2ZWxcblx0Ly9sZXZlbCAtIGEgc3RyaW5nIHdoaWNoIGNhbiBlaXRoZXIgYmUgXCJwdWJsaXNoTGV2ZWxcIiBmb3IgcmV0cmlldmluZyB0aGUgcHVibGlzaCBsZXZlbCBvciBcImNfbGV2ZWxcIiBmb3IgcmV0cmlldmluZyB0aGUgY29uc29sZSBsZXZlbC5cblx0aWYgKGxvZ2dlcltsZXZlbF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBsb2dnZXJbbGV2ZWxdO1xuXHR9IGVsc2UgaWYgKGxvZ2dlci5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBnZXRMZXZlbChsb2dnZXIucGFyZW50LCBsZXZlbCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gbWVzc2FnZVRvVGFibGUodGl0bGUsIHJvd3MpIHtcblx0Ly9EaXNwbGF5IG1lc3NhZ2UgYXMgdGFibGUgaW4gZmlsZVxuXHR2YXIga2V5cyA9IGdldEFsbEtleXMocm93cyk7XG5cdC8vZmlsbCByb3dzIHdpdGggbWVzc2FnZSBwcm9wZXJ0aWVzXG5cdHZhciB0YWJsZVJvd3MgPSByb3dzLm1hcChmdW5jdGlvbiAob2JqKSB7XG5cdFx0cmV0dXJuIGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiBvYmpba2V5XTtcblx0XHR9KTtcblx0fSk7XG5cblx0dmFyIHRhYmxlX21lc3NhZ2UgPSBhc2NpaVRhYmxlLmZhY3Rvcnkoe1xuXHRcdHRpdGxlOiB0aXRsZSxcblx0XHRoZWFkaW5nOiBrZXlzLFxuXHRcdHJvd3M6IHRhYmxlUm93c1xuXHR9KTtcblx0cmV0dXJuIHRhYmxlX21lc3NhZ2UudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxsS2V5cyhkYXRhKSB7XG5cdC8vQWNjZXB0cyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUga2V5cyBmcm9tIGFsbCBvYmplY3RzXG5cdHZhciBhbGxLZXlzID0gW107XG5cblx0ZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0XHRPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKGFsbEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuXHRcdFx0XHRhbGxLZXlzLnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdHJldHVybiBhbGxLZXlzO1xufVxuXG5mdW5jdGlvbiBsb2dnZXIoY29uZmlndXJhdGlvbikge1xuXHRpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiAhPT0gXCJvYmplY3RcIikge1xuXHRcdGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbiA9IHt9O1xuXHR9XG5cblx0Ly9TZXQgZGVidWcgZm9yIHRoZSBjb25uZWN0aW9uIG1vZHVsZSBpZiBnbG9iYWwgZGVidWcgaXMgc2V0XG5cdGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbi5kZWJ1ZyA9IGNvbmZpZ3VyYXRpb24uZGVidWc7XG5cblx0Ly9Jbml0IGNvbm5lY3Rpb25cblx0Ly9EZXRlcm1pbmUgaWYgd2UgYXJlIGdpdmVuIGEgcmVhZHkgJ2Nvbm5lY3Rpb24nIG9iamVjdCBvciBhIGNvbmZpZ3VyYXRpb24uXG5cdHZhciBjb25uZWN0aW9uID0gaXNDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbikgPyBjb25maWd1cmF0aW9uLmNvbm5lY3Rpb24gOiB0aWNrNDJDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvbik7XG5cblx0dmFyIGlkS2V5cyA9IFtcInN5c3RlbVwiLCBcInNlcnZpY2VcIiwgXCJpbnN0YW5jZVwiXTtcblxuXHQvL0NvbnZlcnQgaW5zdGFuY2UgdG8gc3RyaW5nLCB0aHJvdyBleGNlcHRpb25zIGlmIGl0IGlzIG5vdCBmdWxsXG5cdHZhciBpbnN0YW5jZV9zdHIgPSBpZEtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgcHJvcCA9IGNvbmZpZ3VyYXRpb24uaWRlbnRpdHlba2V5XTtcblx0XHRpZiAodHlwZW9mIHByb3AgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHRocm93ICdQbGVhc2Ugc3BlY2lmeSBcIicgKyBrZXkgKyAnXCIgaW4geW91ciBpZGVudGl0eSc7XG5cdFx0fVxuXHRcdHJldHVybiBwcm9wO1xuXHR9KS5qb2luKFwiL1wiKTtcblxuXHR2YXIgbG9nZ2VyUHJvdG8gPSB7XG5cdFx0c3ViTG9nZ2VyOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0Ly9DaGVjayBpZiB0aGUgc3VibG9nZ2VyIGlzIGFscmVhZHkgY3JlYXRlZFxuXHRcdFx0dmFyIGV4aXN0aW5nU3VibG9nZ2VyID0gdGhpcy5zdWJsb2dnZXJzLmZpbHRlcihmdW5jdGlvbiAoc3ViTG9nZ2VyKSB7XG5cdFx0XHRcdHJldHVybiBzdWJMb2dnZXIubmFtZSA9PT0gbmFtZTtcblx0XHRcdH0pWzBdO1xuXG5cdFx0XHRpZiAoZXhpc3RpbmdTdWJsb2dnZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdTdWJsb2dnZXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vQ2hlY2sgaWYgdGhlIG5hbWUgaXNuJ3QgdGhlIHNhbWUgYXMgb25lIG9mIHRoZSBwYXJlbnQgcHJvcGVydGllc1xuXHRcdFx0T2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGlmIChrZXkgPT09IG5hbWUpIHtcblx0XHRcdFx0XHR0aHJvdyAnVGhpcyBzdWIgbG9nZ2VyIG5hbWUgaXMgbm90IGFsbG93ZWQuJztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHQvL0NoZWNrIGlmIHRoZSBuYW1lIGlzbid0IHRoZSBzYW1lIGFzIG9uZSBvZiB0aGUgcGFyZW50IG1ldGhvZHNcblx0XHRcdE9iamVjdC5rZXlzKGxvZ2dlclByb3RvKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0aWYgKGtleSA9PT0gbmFtZSkge1xuXHRcdFx0XHRcdHRocm93ICdUaGlzIHN1YiBsb2dnZXIgbmFtZSBpcyBub3QgYWxsb3dlZC4nO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIHBhdGggPSB0aGlzLnBhdGguc2xpY2UoMCk7XG5cdFx0XHRwYXRoLnB1c2godGhpcy5uYW1lKTtcblx0XHRcdHJldHVybiBjcmVhdGVMb2dnZXIobmFtZSwgcGF0aCwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdHB1Ymxpc2hMZXZlbDogZnVuY3Rpb24gKGxldmVsKSB7XG5cdFx0XHRpZiAobGV2ZWwgIT09IG51bGwgJiYgbGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9wdWJsaXNoTGV2ZWwgPSBsZXZlbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZXRMZXZlbCh0aGlzLCBcIl9wdWJsaXNoTGV2ZWxcIik7XG5cdFx0fSxcblxuXHRcdGNvbnNvbGVMZXZlbDogZnVuY3Rpb24gKGxldmVsKSB7XG5cdFx0XHRpZiAobGV2ZWwgIT09IG51bGwgJiYgbGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9jb25zb2xlTGV2ZWwgPSBsZXZlbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZXRMZXZlbCh0aGlzLCBcIl9jb25zb2xlTGV2ZWxcIik7XG5cdFx0fSxcblxuXHRcdG1ldHJpY3NMZXZlbDogZnVuY3Rpb24gKGxldmVsLCBtZXRyaWNzU3lzdGVtKSB7XG5cdFx0XHRpZiAobGV2ZWwgIT09IG51bGwgJiYgbGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9tZXRyaWNMZXZlbCA9IGxldmVsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWV0cmljc1N5c3RlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgbWV0cmljc1N5c3RlbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbWV0cmljc1N5c3RlbS5vYmplY3RNZXRyaWMgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHRoaXMubWV0cmljU3lzdGVtID0gbWV0cmljc1N5c3RlbTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBcIlBsZWFzZSBzcGVjaWZ5IG1ldHJpYyBzeXN0ZW0gXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dGFibGU6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdFx0XHQvL21lc3NhZ2UgbXVzdCBiZSBpbiBhbiBhcnJheSwgdG8gYmUgZGlzcGxheWVkIGFzIHRhYmxlXG5cdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcblx0XHRcdFx0dGhyb3cgJ1RoZSBtZXNzYWdlIG11c3QgYmUgaW4gYW4gYXJyYXknO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1JldHJpZXZlIGxvZ2dlciBuYW1lIGFuZCBsZXZlbHNcblx0XHRcdHZhciBsb2dnZXJOYW1lID0gZ2V0TG9nZ2VyTmFtZSh0aGlzKTtcblxuXHRcdFx0Ly9QdWJsaXNoIGluIGNvbnNvbGVcblx0XHRcdGlmIChzaG91bGRQdWJsaXNoKGdldExldmVsKHRoaXMsICdfY29uc29sZUxldmVsJyksICdpbmZvJykpIHtcblx0XHRcdFx0Y29uc29sZS5pbmZvKGxvZ2dlck5hbWUgKyAnOicpO1xuXHRcdFx0XHRjb25zb2xlLnRhYmxlKG1lc3NhZ2UpO1xuXHRcdFx0fVxuXHRcdFx0Ly9QdWJsaXNoIGluIGZpbGVcblx0XHRcdGlmIChzaG91bGRQdWJsaXNoKGdldExldmVsKHRoaXMsICdfcHVibGlzaExldmVsJyksICdpbmZvJykpIHtcblx0XHRcdFx0Y29ubmVjdGlvbi5zZW5kKCdsb2cnLCAnTG9nTWVzc2FnZScsIHtcblx0XHRcdFx0XHRpbnN0YW5jZTogaW5zdGFuY2Vfc3RyLFxuXHRcdFx0XHRcdGxldmVsOiBsZXZlbHMuaW5kZXhPZignaW5mbycpLFxuXHRcdFx0XHRcdGxvZ2dlcjogbG9nZ2VyTmFtZSxcblx0XHRcdFx0XHRtZXNzYWdlOiBtZXNzYWdlVG9UYWJsZShsb2dnZXJOYW1lLCBtZXNzYWdlKVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bG9nOiBmdW5jdGlvbiAobWVzc2FnZSwgbGV2ZWwpIHtcblx0XHRcdHB1Ymxpc2hNZXNzYWdlKHRoaXMsIGxldmVsIHx8IFwiaW5mb1wiLCBtZXNzYWdlKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKG5hbWUsIHBhdGgsIHBhcmVudCkge1xuXHRcdHZhciBsb2dnZXIgPSBPYmplY3QuY3JlYXRlKGxvZ2dlclByb3RvKTtcblx0XHRsb2dnZXIubmFtZSA9IG5hbWU7XG5cdFx0bG9nZ2VyLnBhdGggPSBwYXRoO1xuXHRcdGxvZ2dlci5zdWJsb2dnZXJzID0gW107XG5cdFx0bG9nZ2VyLnBhcmVudCA9IHBhcmVudDtcblx0XHRpZiAocGFyZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vYWRkIHN1YmxvZ2dlciB0byBzdWJsb2dnZXJzIGFycmF5XG5cdFx0XHRwYXJlbnQuc3VibG9nZ2Vycy5wdXNoKGxvZ2dlcik7XG5cdFx0XHQvL2FkZCBlYXN5IGFjY2VzcyB0byBzdWJsb2dnZXJcblx0XHRcdHBhcmVudFtsb2dnZXIubmFtZV0gPSBsb2dnZXI7XG5cdFx0XHQvL2NyZWF0ZSBtZXRyaWMgc3lzdGVtXG5cdFx0XHRpZiAocGFyZW50Lm1ldHJpY1N5c3RlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGxvZ2dlci5tZXRyaWNzTGV2ZWwoJ3dhcm4nLCBwYXJlbnQubWV0cmljU3lzdGVtLnN1YlN5c3RlbShsb2dnZXIubmFtZSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcblx0XHRcdGxvZ2dlcltsZXZlbF0gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHRcdFx0XHRwdWJsaXNoTWVzc2FnZShsb2dnZXIsIGxldmVsLCBtZXNzYWdlKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRsb2dnZXIub2ZmID0gZnVuY3Rpb24oKXt9O1xuXG5cdFx0bG9nZ2VyLnZlcnNpb24gPSBcIjIuMC4zXCI7XG5cblx0XHRyZXR1cm4gbG9nZ2VyO1xuXHR9XG5cblx0ZnVuY3Rpb24gcHVibGlzaE1lc3NhZ2UobG9nZ2VyLCBsZXZlbCwgbWVzc2FnZSkge1xuXHRcdC8vUmV0cmlldmUgbG9nZ2VyIG5hbWUgYW5kIGxldmVsc1xuXHRcdHZhciBsb2dnZXJfbmFtZSA9IGdldExvZ2dlck5hbWUobG9nZ2VyKTtcblxuXHRcdC8vQWRkIHN0YWNrIHRyYWNlIGlmIHRoZSBtZXNzYWdlIGlzIGFuIGVycm9yXG5cdFx0aWYgKGxldmVsID09PSAnZXJyb3InKSB7XG5cdFx0XHR2YXIgZSA9IG5ldyBFcnJvcigpO1xuXHRcdFx0aWYgKGUuc3RhY2spIHtcblx0XHRcdFx0bWVzc2FnZSA9IG1lc3NhZ2UgKyBcIlxcblwiICsgKGUuc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMykuam9pbihcIlxcblwiKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9QdWJsaXNoIGluIGNvbnNvbGVcblx0XHRpZiAoc2hvdWxkUHVibGlzaChnZXRMZXZlbChsb2dnZXIsICdfY29uc29sZUxldmVsJyksIGxldmVsKSkge1xuXHRcdFx0Y29uc29sZVtsZXZlbF0obG9nZ2VyX25hbWUgKyBcIjogXCIgKyBtZXNzYWdlKTtcblx0XHR9XG5cdFx0Ly9QdWJsaXNoIGluIGZpbGVcblx0XHRpZiAoc2hvdWxkUHVibGlzaChnZXRMZXZlbChsb2dnZXIsICdfcHVibGlzaExldmVsJyksIGxldmVsKSkge1xuXHRcdFx0Y29ubmVjdGlvbi5zZW5kKCdsb2cnLCAnTG9nTWVzc2FnZScsIHtcblx0XHRcdFx0aW5zdGFuY2U6IGluc3RhbmNlX3N0cixcblx0XHRcdFx0bGV2ZWw6IGxldmVscy5pbmRleE9mKGxldmVsKSxcblx0XHRcdFx0bG9nZ2VyOiBsb2dnZXJfbmFtZSxcblx0XHRcdFx0bWVzc2FnZTogbWVzc2FnZVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly9QdWJsaXNoIGluIG1ldHJpY3Ncblx0XHRpZiAoc2hvdWxkUHVibGlzaChnZXRMZXZlbChsb2dnZXIsICdfbWV0cmljTGV2ZWwnKSwgbGV2ZWwpKSB7XG5cdFx0XHRpZiAobG9nZ2VyLm1ldHJpY1N5c3RlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGxvZ2dlci5tZXRyaWNTeXN0ZW0ub2JqZWN0TWV0cmljKCdMb2dNZXNzYWdlJywge1xuXHRcdFx0XHRcdFRpbWU6IG5ldyBEYXRlKCksXG5cdFx0XHRcdFx0TG9nZ2VyOiBsb2dnZXJfbmFtZSxcblx0XHRcdFx0XHRMZXZlbDogbGV2ZWwsXG5cdFx0XHRcdFx0TWVzc2FnZTogbWVzc2FnZVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAobGV2ZWwgPT0gJ2Vycm9yJyl7XG5cdFx0XHRcdFx0bG9nZ2VyLm1ldHJpY1N5c3RlbS5zZXRTdGF0ZSgxMDAsIG1lc3NhZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIHNob3VsZFB1Ymxpc2ggPSBmdW5jdGlvbiAocHVibGlzaExldmVsLCBtZXNzYWdlTGV2ZWwpIHtcblx0XHRyZXR1cm4gKCFwdWJsaXNoTGV2ZWwgfHwgbGV2ZWxzLmluZGV4T2YocHVibGlzaExldmVsKSA8PSBsZXZlbHMuaW5kZXhPZihtZXNzYWdlTGV2ZWwpKTtcblx0fTtcblxuXHR2YXIgZ2V0TG9nZ2VyTmFtZSA9IGZ1bmN0aW9uIChsb2dnZXIpIHtcblx0XHR2YXIgbG9nZ2VyUGF0aEFuZE5hbWUgPSBsb2dnZXIucGF0aC5zbGljZSgpO1xuXHRcdGxvZ2dlclBhdGhBbmROYW1lLnB1c2gobG9nZ2VyLm5hbWUpO1xuXHRcdHJldHVybiBcIltcIiArIHNlcmlhbGl6ZVBhdGgobG9nZ2VyUGF0aEFuZE5hbWUpICsgXCJdXCI7XG5cdH07XG5cblx0dmFyIG1haW5Mb2dnZXIgPSBjcmVhdGVMb2dnZXIoXCJtYWluXCIsIFtdLCB1bmRlZmluZWQpO1xuXHRtYWluTG9nZ2VyLnB1Ymxpc2hMZXZlbChcIndhcm5cIik7XG5cdG1haW5Mb2dnZXIuY29uc29sZUxldmVsKFwiaW5mb1wiKTtcblx0bWFpbkxvZ2dlci5tZXRyaWNzTGV2ZWwoXCJ3YXJuXCIpO1xuXG5cdHJldHVybiBtYWluTG9nZ2VyO1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0d2luZG93LnRpY2s0MiA9IHdpbmRvdy50aWNrNDIgfHwge307XG5cdHdpbmRvdy50aWNrNDIubG9nID0gbG9nZ2VyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2dlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgb2JqZWN0TWV0cmljXzEgPSByZXF1aXJlKFwiLi4vbWV0cmljcy9vYmplY3RNZXRyaWNcIik7XHJcbnZhciBzdHJpbmdNZXRyaWNfMSA9IHJlcXVpcmUoXCIuLi9tZXRyaWNzL3N0cmluZ01ldHJpY1wiKTtcclxudmFyIG51bWJlck1ldHJpY18xID0gcmVxdWlyZShcIi4uL21ldHJpY3MvbnVtYmVyTWV0cmljXCIpO1xyXG52YXIgdGltZXN0YW1wTWV0cmljXzEgPSByZXF1aXJlKFwiLi4vbWV0cmljcy90aW1lc3RhbXBNZXRyaWNcIik7XHJcbnZhciBNZXRyaWNTZXJpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ldHJpY1NlcmlhbGl6ZXIoKSB7XHJcbiAgICB9XHJcbiAgICBNZXRyaWNTZXJpYWxpemVyLm1ldHJpY1RvTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXRyaWMpIHtcclxuICAgICAgICB2YXIgZGVmID0gTWV0cmljU2VyaWFsaXplci5fZ2V0TWV0cmljRGVmaW5pdGlvbihtZXRyaWMubmFtZSwgbWV0cmljLnZhbHVlLCBtZXRyaWMucGF0aCwgbWV0cmljLnR5cGUsIG1ldHJpYy5kZXNjcmlwdGlvbiwgbWV0cmljLnBlcmlvZCwgbWV0cmljLnJlc29sdXRpb24pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlkOiBtZXRyaWMuaWQsXHJcbiAgICAgICAgICAgIGluc3RhbmNlOiBtZXRyaWMucmVwby5pbnN0YW5jZSxcclxuICAgICAgICAgICAgZGVmaW5pdGlvbjogZGVmLFxyXG4gICAgICAgICAgICB2YWx1ZTogTWV0cmljU2VyaWFsaXplci5fc2VyaWFsaXplVmFsdWUobWV0cmljLnZhbHVlLCBtZXRyaWMpLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgTWV0cmljU2VyaWFsaXplci5fZ2V0TWV0cmljRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcGF0aCwgdHlwZSwgZGVzY3JpcHRpb24sIHJlc29sdXRpb24sIHBlcmlvZCkge1xyXG4gICAgICAgIHZhciBkZWYgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgdHlwZTogdHlwZSA/IHR5cGUgOiBNZXRyaWNTZXJpYWxpemVyLl9nZXRUeXBlRnJvbVZhbHVlKHZhbHVlKSxcclxuICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcclxuICAgICAgICAgICAgcGVyaW9kOiBwZXJpb2RcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChkZWYudHlwZSA9PT0gb2JqZWN0TWV0cmljXzEuT2JqZWN0TWV0cmljLnR5cGUpIHtcclxuICAgICAgICAgICAgZGVmLkNvbXBvc2l0ZSA9IE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoZnVuY3Rpb24gKGFyciwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gdmFsdWVba2V5XTtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKE1ldHJpY1NlcmlhbGl6ZXIuX2dldE1ldHJpY0RlZmluaXRpb24oa2V5LCB2YWwsIHBhdGgpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgICAgIH0sIFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZjtcclxuICAgIH07XHJcbiAgICBNZXRyaWNTZXJpYWxpemVyLl9zZXJpYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWV0cmljKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBEYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuX3ZhbHVlVHlwZXMuaW5kZXhPZihcImRhdGVcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5OiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZVZhbHVlOiBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBNZXRyaWNTZXJpYWxpemVyLl9zZXJpYWxpemVWYWx1ZSh2YWx1ZVtrZXldKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWwuSW5uZXJNZXRyaWNOYW1lID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICAgICAgICAgIH0sIFtdKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlVHlwZSA9IG1ldHJpYyA/IG1ldHJpYy5nZXRWYWx1ZVR5cGUoKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdmFsdWVUeXBlID0gdmFsdWVUeXBlIHwgdGhpcy5fdmFsdWVUeXBlcy5pbmRleE9mKHR5cGVvZiB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB7IHR5cGU6IHZhbHVlVHlwZSwgdmFsdWU6IHZhbHVlLCBpc0FycmF5OiBmYWxzZSB9IH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ldHJpY1NlcmlhbGl6ZXIuX2dldFR5cGVGcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgdHlwZUFzU3RyaW5nID0gdmFsdWUuY29uc3RydWN0b3IgPT09IERhdGUgPyAndGltZXN0YW1wJyA6IHR5cGVvZiB2YWx1ZTtcclxuICAgICAgICBzd2l0Y2ggKHR5cGVBc1N0cmluZykge1xyXG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ01ldHJpY18xLlN0cmluZ01ldHJpYy50eXBlO1xyXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlck1ldHJpY18xLk51bWJlck1ldHJpYy50eXBlO1xyXG4gICAgICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcE1ldHJpY18xLlRpbWVzdGFtcE1ldHJpYy50eXBlO1xyXG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdE1ldHJpY18xLk9iamVjdE1ldHJpYy50eXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICBNZXRyaWNTZXJpYWxpemVyLl92YWx1ZVR5cGVzID0gW1xyXG4gICAgICAgIFwiYm9vbGVhblwiLFxyXG4gICAgICAgIFwiaW50XCIsXHJcbiAgICAgICAgXCJudW1iZXJcIixcclxuICAgICAgICBcImxvbmdcIixcclxuICAgICAgICBcInN0cmluZ1wiLFxyXG4gICAgICAgIFwiZGF0ZVwiLFxyXG4gICAgICAgIFwib2JqZWN0XCJdO1xyXG4gICAgcmV0dXJuIE1ldHJpY1NlcmlhbGl6ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTWV0cmljU2VyaWFsaXplciA9IE1ldHJpY1NlcmlhbGl6ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldHJpY1NlcmlhbGl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBtZXRyaWNTZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNTZXJpYWxpemVyXCIpO1xyXG52YXIgTWV0cmljc0JyaWRnZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZXRyaWNzQnJpZGdlKHJlcG8sIGNvbm5lY3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX3JlcG8gPSByZXBvO1xyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xyXG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ21ldHJpY3MnLCBcIk1ldHJpY3NTbmFwc2hvdFJlcXVlc3RcIiwgZnVuY3Rpb24gKGluc3RhbmNlSW5mbykge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VJbmZvLkluc3RhbmNlICE9PSByZXBvLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuc2VuZEZ1bGwoX3RoaXMuX3JlcG8pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgTWV0cmljc0JyaWRnZS5wcm90b3R5cGUuc2VuZEZ1bGwgPSBmdW5jdGlvbiAocmVwbykge1xyXG4gICAgICAgIHZhciByb290U3lzdGVtID0gcmVwby5yb290O1xyXG4gICAgICAgIGlmICghcm9vdFN5c3RlbSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb290U3lzdGVtLnN1YlN5c3RlbXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbmRGdWxsU3lzdGVtKHJvb3RTeXN0ZW0pO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLnNlbmRGdWxsU3lzdGVtID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlU3lzdGVtKHMpO1xyXG4gICAgICAgIHMuc3ViU3lzdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHtcclxuICAgICAgICAgICAgX3RoaXMuc2VuZEZ1bGxTeXN0ZW0oKHN1YikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHMubWV0cmljcy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNyZWF0ZU1ldHJpYyhtKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS5jcmVhdGVNZXRyaWMgPSBmdW5jdGlvbiAobWV0cmljKSB7XHJcbiAgICAgICAgdGhpcy5fc2VuZChcIkNyZWF0ZU1ldHJpY1wiLCBtZXRyaWNTZXJpYWxpemVyXzEuTWV0cmljU2VyaWFsaXplci5tZXRyaWNUb01lc3NhZ2UobWV0cmljKSk7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljc0JyaWRnZS5wcm90b3R5cGUudXBkYXRlTWV0cmljID0gZnVuY3Rpb24gKG1ldHJpYykge1xyXG4gICAgICAgIHRoaXMuX3NlbmQoXCJVcGRhdGVNZXRyaWNcIiwgbWV0cmljU2VyaWFsaXplcl8xLk1ldHJpY1NlcmlhbGl6ZXIubWV0cmljVG9NZXNzYWdlKG1ldHJpYykpO1xyXG4gICAgfTtcclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLmNyZWF0ZVN5c3RlbSA9IGZ1bmN0aW9uIChzeXN0ZW0pIHtcclxuICAgICAgICBpZiAoc3lzdGVtLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbmQoXCJDcmVhdGVNZXRyaWNTeXN0ZW1cIiwge1xyXG4gICAgICAgICAgICAgICAgaWQ6IHN5c3RlbS5pZCxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBzeXN0ZW0ucmVwby5pbnN0YW5jZSxcclxuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IHsgbmFtZTogc3lzdGVtLm5hbWUsIGRlc2NyaXB0aW9uOiBzeXN0ZW0uZGVzY3JpcHRpb24sIHBhdGg6IHN5c3RlbS5wYXRoIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ldHJpY3NCcmlkZ2UucHJvdG90eXBlLnVwZGF0ZVN5c3RlbSA9IGZ1bmN0aW9uIChzeXN0ZW0sIHN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5fc2VuZChcIlVwZGF0ZU1ldHJpY1N5c3RlbVwiLCB7XHJcbiAgICAgICAgICAgIGlkOiBzeXN0ZW0uaWQsXHJcbiAgICAgICAgICAgIGluc3RhbmNlOiBzeXN0ZW0ucmVwby5pbnN0YW5jZSxcclxuICAgICAgICAgICAgc3RhdGU6IHN0YXRlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTWV0cmljc0JyaWRnZS5wcm90b3R5cGUuaGVhcnRiZWF0ID0gZnVuY3Rpb24gKHJlcG8sIGludGVydmFsKSB7XHJcbiAgICAgICAgdGhpcy5fc2VuZChcIkhlYXJ0YmVhdE1ldHJpY3NcIiwgeyBwdWJsaXNoaW5nSW50ZXJ2YWw6IGludGVydmFsLCBpbnN0YW5jZTogcmVwby5pbnN0YW5jZSB9KTtcclxuICAgIH07XHJcbiAgICBNZXRyaWNzQnJpZGdlLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kKFwibWV0cmljc1wiLCB0eXBlLCBtZXNzYWdlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTWV0cmljc0JyaWRnZTtcclxufSgpKTtcclxuZXhwb3J0cy5NZXRyaWNzQnJpZGdlID0gTWV0cmljc0JyaWRnZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNwb3J0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBBZGRyZXNzTWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBZGRyZXNzTWV0cmljLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWRkcmVzc01ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIEFkZHJlc3NNZXRyaWMudHlwZSwgdmFsdWUgfHwgJycpO1xyXG4gICAgfVxyXG4gICAgQWRkcmVzc01ldHJpYy50eXBlID0gODtcclxuICAgIHJldHVybiBBZGRyZXNzTWV0cmljO1xyXG59KG1ldHJpY18xLk1ldHJpYykpO1xyXG5leHBvcnRzLkFkZHJlc3NNZXRyaWMgPSBBZGRyZXNzTWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzTWV0cmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBDb3VudE1ldHJpYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ291bnRNZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb3VudE1ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIENvdW50TWV0cmljLnR5cGUsIHZhbHVlIHx8IDApO1xyXG4gICAgfVxyXG4gICAgQ291bnRNZXRyaWMucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmluY3JlbWVudEJ5KDEpO1xyXG4gICAgfTtcclxuICAgIENvdW50TWV0cmljLnByb3RvdHlwZS5kZWNyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kZWNyZW1lbnRCeSgxKTtcclxuICAgIH07XHJcbiAgICBDb3VudE1ldHJpYy5wcm90b3R5cGUuaW5jcmVtZW50QnkgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCh0aGlzLnZhbHVlIHx8IDApICsgbik7XHJcbiAgICB9O1xyXG4gICAgQ291bnRNZXRyaWMucHJvdG90eXBlLmRlY3JlbWVudEJ5ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgodGhpcy52YWx1ZSB8fCAwKSAtIG4pO1xyXG4gICAgfTtcclxuICAgIENvdW50TWV0cmljLnByb3RvdHlwZS5nZXRWYWx1ZVR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDM7XHJcbiAgICB9O1xyXG4gICAgQ291bnRNZXRyaWMudHlwZSA9IDM7XHJcbiAgICByZXR1cm4gQ291bnRNZXRyaWM7XHJcbn0obWV0cmljXzEuTWV0cmljKSk7XHJcbmV4cG9ydHMuQ291bnRNZXRyaWMgPSBDb3VudE1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y291bnRNZXRyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBNZXRyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHR5cGUsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gZGVmLm5hbWU7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlZi5kZXNjcmlwdGlvbjtcclxuICAgICAgICB0aGlzLnBlcmlvZCA9IGRlZi5wZXJpb2Q7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gZGVmLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5zeXN0ZW0gPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5yZXBvID0gcGFyZW50LnJlcG87XHJcbiAgICAgICAgdGhpcy5pZCA9IHBhcmVudC5wYXRoICsgXCIvXCIgKyB0aGlzLm5hbWU7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGFyZW50LnBhdGguc2xpY2UoMCk7XHJcbiAgICAgICAgdGhpcy5wYXRoLnB1c2gocGFyZW50Lm5hbWUpO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcclxuICAgICAgICB0aGlzLl90cmFuc3BvcnQuY3JlYXRlTWV0cmljKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgTWV0cmljLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnVwZGF0ZU1ldHJpYyh0aGlzKTtcclxuICAgIH07XHJcbiAgICBNZXRyaWMucHJvdG90eXBlLmdldFZhbHVlVHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIE1ldHJpYy50eXBlID0gMDtcclxuICAgIHJldHVybiBNZXRyaWM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTWV0cmljID0gTWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIE51bWJlck1ldHJpYyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTnVtYmVyTWV0cmljLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTnVtYmVyTWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgTnVtYmVyTWV0cmljLnR5cGUsIHZhbHVlIHx8IDApO1xyXG4gICAgfVxyXG4gICAgTnVtYmVyTWV0cmljLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRCeSgxKTtcclxuICAgIH07XHJcbiAgICBOdW1iZXJNZXRyaWMucHJvdG90eXBlLmRlY3JlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRlY3JlbWVudEJ5KDEpO1xyXG4gICAgfTtcclxuICAgIE51bWJlck1ldHJpYy5wcm90b3R5cGUuaW5jcmVtZW50QnkgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCh0aGlzLnZhbHVlIHx8IDApICsgbik7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVyTWV0cmljLnByb3RvdHlwZS5kZWNyZW1lbnRCeSA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKHRoaXMudmFsdWUgfHwgMCkgLSBuKTtcclxuICAgIH07XHJcbiAgICBOdW1iZXJNZXRyaWMudHlwZSA9IDI7XHJcbiAgICByZXR1cm4gTnVtYmVyTWV0cmljO1xyXG59KG1ldHJpY18xLk1ldHJpYykpO1xyXG5leHBvcnRzLk51bWJlck1ldHJpYyA9IE51bWJlck1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyTWV0cmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBPYmplY3RNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE9iamVjdE1ldHJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE9iamVjdE1ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIE9iamVjdE1ldHJpYy50eXBlLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBPYmplY3RNZXRyaWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdE1ldHJpYy50eXBlID0gMTE7XHJcbiAgICByZXR1cm4gT2JqZWN0TWV0cmljO1xyXG59KG1ldHJpY18xLk1ldHJpYykpO1xyXG5leHBvcnRzLk9iamVjdE1ldHJpYyA9IE9iamVjdE1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0TWV0cmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgbWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNcIik7XHJcbnZhciBSYXRlTWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSYXRlTWV0cmljLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmF0ZU1ldHJpYyhkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCB2YWx1ZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIFJhdGVNZXRyaWMudHlwZSwgdmFsdWUgfHwgMCk7XHJcbiAgICB9XHJcbiAgICBSYXRlTWV0cmljLnR5cGUgPSA0O1xyXG4gICAgcmV0dXJuIFJhdGVNZXRyaWM7XHJcbn0obWV0cmljXzEuTWV0cmljKSk7XHJcbmV4cG9ydHMuUmF0ZU1ldHJpYyA9IFJhdGVNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhdGVNZXRyaWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBtZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY1wiKTtcclxudmFyIFN0YXRpc3RpY3NNZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFN0YXRpc3RpY3NNZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTdGF0aXN0aWNzTWV0cmljKGRlZiwgcGFyZW50LCB0cmFuc3BvcnQsIHZhbHVlKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgU3RhdGlzdGljc01ldHJpYy50eXBlLCB2YWx1ZSB8fCAwKTtcclxuICAgIH1cclxuICAgIFN0YXRpc3RpY3NNZXRyaWMudHlwZSA9IDY7XHJcbiAgICByZXR1cm4gU3RhdGlzdGljc01ldHJpYztcclxufShtZXRyaWNfMS5NZXRyaWMpKTtcclxuZXhwb3J0cy5TdGF0aXN0aWNzTWV0cmljID0gU3RhdGlzdGljc01ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGlzdGljc01ldHJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgU3RyaW5nTWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdHJpbmdNZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTdHJpbmdNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCBTdHJpbmdNZXRyaWMudHlwZSwgdmFsdWUgfHwgJycpO1xyXG4gICAgfVxyXG4gICAgU3RyaW5nTWV0cmljLnR5cGUgPSAxO1xyXG4gICAgcmV0dXJuIFN0cmluZ01ldHJpYztcclxufShtZXRyaWNfMS5NZXRyaWMpKTtcclxuZXhwb3J0cy5TdHJpbmdNZXRyaWMgPSBTdHJpbmdNZXRyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ01ldHJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgVGltZXNwYW5NZXRyaWMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRpbWVzcGFuTWV0cmljLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGltZXNwYW5NZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCBUaW1lc3Bhbk1ldHJpYy50eXBlLCB2YWx1ZSB8fCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBUaW1lc3Bhbk1ldHJpYy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgVGltZXNwYW5NZXRyaWMucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIFRpbWVzcGFuTWV0cmljLnR5cGUgPSAxMDtcclxuICAgIHJldHVybiBUaW1lc3Bhbk1ldHJpYztcclxufShtZXRyaWNfMS5NZXRyaWMpKTtcclxuZXhwb3J0cy5UaW1lc3Bhbk1ldHJpYyA9IFRpbWVzcGFuTWV0cmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lc3Bhbk1ldHJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIG1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljXCIpO1xyXG52YXIgVGltZXN0YW1wTWV0cmljID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhUaW1lc3RhbXBNZXRyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lc3RhbXBNZXRyaWMoZGVmLCBwYXJlbnQsIHRyYW5zcG9ydCwgdmFsdWUpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZWYsIHBhcmVudCwgdHJhbnNwb3J0LCBUaW1lc3RhbXBNZXRyaWMudHlwZSwgdmFsdWUgfHwgbmV3IERhdGUoKSk7XHJcbiAgICB9XHJcbiAgICBUaW1lc3RhbXBNZXRyaWMucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZShuZXcgRGF0ZSgpKTtcclxuICAgIH07XHJcbiAgICBUaW1lc3RhbXBNZXRyaWMudHlwZSA9IDc7XHJcbiAgICByZXR1cm4gVGltZXN0YW1wTWV0cmljO1xyXG59KG1ldHJpY18xLk1ldHJpYykpO1xyXG5leHBvcnRzLlRpbWVzdGFtcE1ldHJpYyA9IFRpbWVzdGFtcE1ldHJpYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXN0YW1wTWV0cmljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgc3lzdGVtXzEgPSByZXF1aXJlKFwiLi9zeXN0ZW1cIik7XHJcbnZhciB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL2JyaWRnZS90cmFuc3BvcnRcIik7XHJcbnZhciBSZXBvc2l0b3J5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlcG9zaXRvcnkoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRfMS5NZXRyaWNzQnJpZGdlKHRoaXMsIGNvbmZpZy5jb25uZWN0aW9uKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gY29uZmlnLmlkZW50aXR5LnN5c3RlbSArICcvJyArIGNvbmZpZy5pZGVudGl0eS5zZXJ2aWNlICsgJy8nICsgY29uZmlnLmlkZW50aXR5Lmluc3RhbmNlO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBjb25maWcuaWRlbnRpdHk7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRIZWFydGJlYXRpbmcoKTtcclxuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgc3lzdGVtXzEuU3lzdGVtKCcnLCB0aGlzLCB0aGlzLl90cmFuc3BvcnQpO1xyXG4gICAgICAgIHRoaXMuX2luaXRTeXN0ZW1NZXRyaWNzKHRoaXMucm9vdCwgY29uZmlnLmNsaWNrU3RyZWFtIHx8IGNvbmZpZy5jbGlja1N0cmVhbSA9PT0gdW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIFJlcG9zaXRvcnkucHJvdG90eXBlLl9zdGFydEhlYXJ0YmVhdGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5oZWFydGJlYXQodGhpcywgdGhpcy5fY29uZmlnLnNldHRpbmdzLmhlYXJ0YmVhdEludGVydmFsKTtcclxuICAgICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl90cmFuc3BvcnQuaGVhcnRiZWF0KF90aGlzLCBfdGhpcy5fY29uZmlnLnNldHRpbmdzLmhlYXJ0YmVhdEludGVydmFsKTtcclxuICAgICAgICB9LCB0aGlzLl9jb25maWcuc2V0dGluZ3MuaGVhcnRiZWF0SW50ZXJ2YWwpO1xyXG4gICAgfTtcclxuICAgIFJlcG9zaXRvcnkucHJvdG90eXBlLl9pbml0U3lzdGVtTWV0cmljcyA9IGZ1bmN0aW9uIChyb290U3lzdGVtLCB1c2VDbGlja1N0cmVhbSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByb290U3lzdGVtLnN0cmluZ01ldHJpYygnVXNlckFnZW50JywgbmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1c2VDbGlja1N0cmVhbSAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGlja1N0cmVhbV8xID0gcm9vdFN5c3RlbS5zdWJTeXN0ZW0oXCJDbGlja1N0cmVhbVwiKTtcclxuICAgICAgICAgICAgdmFyIGRvY3VtZW50Q2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZS50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbGlja1N0cmVhbV8xLm9iamVjdE1ldHJpYyhcIkxhc3RCcm93c2VyRXZlbnRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2xpY2tcIixcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZS50YXJnZXQgPyBlLnRhcmdldC5jbGFzc05hbWUgOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGUudGFyZ2V0LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnPCcgKyBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyAnPicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGUudGFyZ2V0LmhyZWYgfHwgXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjbGlja1N0cmVhbV8xLm9iamVjdE1ldHJpYyhcIlBhZ2VcIiwge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IGRvY3VtZW50LnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgcGFnZTogd2luZG93LmxvY2F0aW9uLmhyZWZcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGRvY3VtZW50Q2xpY2tIYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbmNsaWNrJywgZG9jdW1lbnRDbGlja0hhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXBvc2l0b3J5O1xyXG59KCkpO1xyXG5leHBvcnRzLlJlcG9zaXRvcnkgPSBSZXBvc2l0b3J5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBvc2l0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgbnVtYmVyTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL251bWJlck1ldHJpY1wiKTtcclxudmFyIHRpbWVzcGFuTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL3RpbWVzcGFuTWV0cmljXCIpO1xyXG52YXIgc3RyaW5nTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL3N0cmluZ01ldHJpY1wiKTtcclxudmFyIGFkZHJlc3NNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MvYWRkcmVzc01ldHJpY1wiKTtcclxudmFyIG9iamVjdE1ldHJpY18xID0gcmVxdWlyZShcIi4vbWV0cmljcy9vYmplY3RNZXRyaWNcIik7XHJcbnZhciB0aW1lc3RhbXBNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MvdGltZXN0YW1wTWV0cmljXCIpO1xyXG52YXIgY291bnRNZXRyaWNfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MvY291bnRNZXRyaWNcIik7XHJcbnZhciBzdGF0aXN0aWNzTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL3N0YXRpc3RpY3NNZXRyaWNcIik7XHJcbnZhciByYXRlTWV0cmljXzEgPSByZXF1aXJlKFwiLi9tZXRyaWNzL3JhdGVNZXRyaWNcIik7XHJcbnZhciBTeXN0ZW0gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3lzdGVtKG5hbWUsIHJlcG8sIHRyYW5zcG9ydCwgcGFyZW50LCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIHRoaXMubWV0cmljcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3ViU3lzdGVtcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uIHx8ICcnO1xyXG4gICAgICAgIHRoaXMucmVwbyA9IHJlcG87XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMuX2J1aWxkUGF0aCh0aGlzLnBhcmVudCk7XHJcbiAgICAgICAgdGhpcy5pZCA9ICh0aGlzLnBhdGgubGVuZ3RoID4gMCA/IHRoaXMucGF0aC5qb2luKCcvJykgKyAnLycgOiAnJykgKyB0aGlzLm5hbWU7XHJcbiAgICAgICAgdGhpcy5pZGVudGl0eSA9IHJlcG8uaWRlbnRpdHk7XHJcbiAgICAgICAgdGhpcy5yb290ID0gcmVwby5yb290O1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5jcmVhdGVTeXN0ZW0odGhpcyk7XHJcbiAgICB9XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnN1YlN5c3RlbSA9IGZ1bmN0aW9uIChuYW1lLCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIGlmICghbmFtZSB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nU3lzdGVtcyA9IHRoaXMuc3ViU3lzdGVtcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMubmFtZSA9PT0gbmFtZTsgfSk7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nU3lzdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1N5c3RlbXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzeXN0ZW0gPSBuZXcgU3lzdGVtKG5hbWUsIHRoaXMucmVwbywgdGhpcy5fdHJhbnNwb3J0LCB0aGlzLCBkZXNjcmlwdGlvbik7XHJcbiAgICAgICAgdGhpcy5zdWJTeXN0ZW1zLnB1c2goc3lzdGVtKTtcclxuICAgICAgICByZXR1cm4gc3lzdGVtO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnVwZGF0ZVN5c3RlbSh0aGlzLCB7IHN0YXRlOiBzdGF0ZSwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH0pO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuc3RyaW5nTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgc3RyaW5nTWV0cmljXzEuU3RyaW5nTWV0cmljLnR5cGUsIHZhbHVlLCBmdW5jdGlvbiAobWV0cmljRGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RyaW5nTWV0cmljXzEuU3RyaW5nTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLm51bWJlck1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIG51bWJlck1ldHJpY18xLk51bWJlck1ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG51bWJlck1ldHJpY18xLk51bWJlck1ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5jb3VudE1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIGNvdW50TWV0cmljXzEuQ291bnRNZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3VudE1ldHJpY18xLkNvdW50TWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLmFkZHJlc3NNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCBhZGRyZXNzTWV0cmljXzEuQWRkcmVzc01ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFkZHJlc3NNZXRyaWNfMS5BZGRyZXNzTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLm9iamVjdE1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIG9iamVjdE1ldHJpY18xLk9iamVjdE1ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG9iamVjdE1ldHJpY18xLk9iamVjdE1ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS50aW1lc3Bhbk1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIHRpbWVzcGFuTWV0cmljXzEuVGltZXNwYW5NZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aW1lc3Bhbk1ldHJpY18xLlRpbWVzcGFuTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnRpbWVzdGFtcE1ldHJpYyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlTWV0cmljKGRlZmluaXRpb24sIHRpbWVzdGFtcE1ldHJpY18xLlRpbWVzdGFtcE1ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRpbWVzdGFtcE1ldHJpY18xLlRpbWVzdGFtcE1ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5yYXRlTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVNZXRyaWMoZGVmaW5pdGlvbiwgcmF0ZU1ldHJpY18xLlJhdGVNZXRyaWMudHlwZSwgdmFsdWUsIGZ1bmN0aW9uIChtZXRyaWNEZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByYXRlTWV0cmljXzEuUmF0ZU1ldHJpYyhtZXRyaWNEZWYsIF90aGlzLCBfdGhpcy5fdHJhbnNwb3J0LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5zdGF0aXRpY3NNZXRyaWMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZU1ldHJpYyhkZWZpbml0aW9uLCBzdGF0aXN0aWNzTWV0cmljXzEuU3RhdGlzdGljc01ldHJpYy50eXBlLCB2YWx1ZSwgZnVuY3Rpb24gKG1ldHJpY0RlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRpc3RpY3NNZXRyaWNfMS5TdGF0aXN0aWNzTWV0cmljKG1ldHJpY0RlZiwgX3RoaXMsIF90aGlzLl90cmFuc3BvcnQsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLl91bmlvblRvTWV0cmljRGVmID0gZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcclxuICAgICAgICB2YXIgbWV0cmljRGVmO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbWV0cmljRGVmID0geyBuYW1lOiBkZWZpbml0aW9uIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXRyaWNEZWYgPSBkZWZpbml0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWV0cmljRGVmLm5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldHJpYyBuYW1lIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWV0cmljRGVmO1xyXG4gICAgfTtcclxuICAgIFN5c3RlbS5wcm90b3R5cGUuX2dldE9yQ3JlYXRlTWV0cmljID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIGV4cGVjdGVkVHlwZSwgdmFsdWUsIGNyZWF0ZUZ1bmMpIHtcclxuICAgICAgICB2YXIgbWV0cmljRGVmID0gdGhpcy5fdW5pb25Ub01ldHJpY0RlZihkZWZpbml0aW9uKTtcclxuICAgICAgICB2YXIgbWF0Y2hpbmdNZXRyaWNzID0gdGhpcy5tZXRyaWNzLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lID09PSBtZXRyaWNEZWYubmFtZTsgfSk7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nTWV0cmljcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBleGlzdGluZ01ldHJpYyA9IG1hdGNoaW5nTWV0cmljc1swXTtcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nTWV0cmljLnR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIG1ldHJpYyBuYW1lZCAnICsgbWV0cmljRGVmLm5hbWUgKyAnIGlzIGFscmVhZHkgZGVmaW5lZCB3aXRoIGRpZmZlcmVudCB0eXBlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nTWV0cmljLnVwZGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nTWV0cmljO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV3TWV0cmljID0gY3JlYXRlRnVuYyhtZXRyaWNEZWYpO1xyXG4gICAgICAgIHRoaXMubWV0cmljcy5wdXNoKG5ld01ldHJpYyk7XHJcbiAgICAgICAgcmV0dXJuIG5ld01ldHJpYztcclxuICAgIH07XHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLl9idWlsZFBhdGggPSBmdW5jdGlvbiAoc3lzdGVtKSB7XHJcbiAgICAgICAgaWYgKCFzeXN0ZW0gfHwgIXN5c3RlbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuX2J1aWxkUGF0aChzeXN0ZW0ucGFyZW50KTtcclxuICAgICAgICBwYXRoLnB1c2goc3lzdGVtLm5hbWUpO1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTeXN0ZW07XHJcbn0oKSk7XHJcbmV4cG9ydHMuU3lzdGVtID0gU3lzdGVtO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zeXN0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciByZXBvc2l0b3J5XzEgPSByZXF1aXJlKFwiLi9jb3JlL3JlcG9zaXRvcnlcIik7XHJcbnZhciB0aWNrNDJfZ2F0ZXdheV9jb25uZWN0aW9uXzEgPSByZXF1aXJlKCd0aWNrNDItZ2F0ZXdheS1jb25uZWN0aW9uJyk7XHJcbnZhciB3aW5kb3dBc0FueSA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gKG5ldyBPYmplY3QoKSkgOiB3aW5kb3c7XHJcbndpbmRvd0FzQW55LnRpY2s0MiA9IHdpbmRvd0FzQW55LnRpY2s0MiB8fCB7fTtcclxud2luZG93QXNBbnkudGljazQyLm1ldHJpY3MgPSB3aW5kb3dBc0FueS50aWNrNDIubWV0cmljcyB8fCBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICBpZiAoIWNvbmZpZy5pZGVudGl0eSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWRlbnRpdHkgbWlzc2luZyBmcm9tIG1ldHJpY3MgY29uZmlndXJhdGlvbicpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjb25maWcuaWRlbnRpdHkuc2VydmljZSB8fCB0eXBlb2YgY29uZmlnLmlkZW50aXR5LnNlcnZpY2UgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2aWNlIG1pc3Npbmcgb3IgaW52YWxpZCBpbiBtZXRyaWNzIGlkZW50aXR5IGNvbmZpZ3VyYXRpb24nKTtcclxuICAgIH1cclxuICAgIGlmICghY29uZmlnLmlkZW50aXR5LnN5c3RlbSB8fCB0eXBlb2YgY29uZmlnLmlkZW50aXR5LnN5c3RlbSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5c3RlbSBtaXNzaW5nIG9yIGludmFsaWQgaW4gbWV0cmljcyBpZGVudGl0eSBjb25maWd1cmF0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNvbmZpZy5pZGVudGl0eS5pbnN0YW5jZSB8fCB0eXBlb2YgY29uZmlnLmlkZW50aXR5Lmluc3RhbmNlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdGFuY2VtaXNzaW5nIG9yIGludmFsaWQgaW4gbWV0cmljcyBpZGVudGl0eSBjb25maWd1cmF0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBjb25maWcuc2V0dGluZ3MgPSBjb25maWcuc2V0dGluZ3MgfHwge307XHJcbiAgICBjb25maWcuc2V0dGluZ3MuaGVhcnRiZWF0SW50ZXJ2YWwgPSBjb25maWcuc2V0dGluZ3MuaGVhcnRiZWF0SW50ZXJ2YWwgfHwgMTUwMDA7XHJcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5jb25uZWN0aW9uICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgY29uZmlnLmNvbm5lY3Rpb24gPSB7fTtcclxuICAgIH1cclxuICAgIGlmICghKHR5cGVvZiBjb25maWcuY29ubmVjdGlvbiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY29uZmlnLmNvbm5lY3Rpb24uc2VuZCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBjb25maWcuY29ubmVjdGlvbi5vbiA9PT0gXCJmdW5jdGlvblwiKSkge1xyXG4gICAgICAgIGNvbmZpZy5jb25uZWN0aW9uID0gdGljazQyX2dhdGV3YXlfY29ubmVjdGlvbl8xLmNvbm5lY3Rpb24oY29uZmlnLmNvbm5lY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlcG8gPSBuZXcgcmVwb3NpdG9yeV8xLlJlcG9zaXRvcnkoY29uZmlnKTtcclxuICAgIHJlcG9bJ3ZlcnNpb24nXSA9IHJlcG8ucm9vdFsndmVyc2lvbiddID0gJzIuMC4xMyc7XHJcbiAgICByZXR1cm4gcmVwby5yb290O1xyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvd0FzQW55LnRpY2s0Mi5tZXRyaWNzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWNzTW9kdWxlLmpzLm1hcCIsInZhciB3aW5kb3dzID0gZnVuY3Rpb24gKGFnbSkge1xuXG5cdHZhciBkZXByZWNhdGUgPSByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpO1xuXHRpZiAoYWdtLnN1YnNjcmliZSkge1xuXHRcdGFnbS5zZXJ2ZXJNZXRob2RBZGRlZChmdW5jdGlvbiAocmVzcCkge1xuXHRcdFx0aWYgKChyZXNwLnNlcnZlci5hcHBsaWNhdGlvbi5pbmRleE9mKCdIdG1sQ29udGFpbmVyLicpICE9PSAtMSAmJiByZXNwLnNlcnZlci5hcHBsaWNhdGlvbi5pbmRleE9mKCcuSW50ZXJuYWwnKSAhPT0gLTEpICYmIHJlc3AubWV0aG9kLm5hbWUuaW5kZXhPZignVDQyLlduZC5XaW5kb3dTdGF0ZUNoYW5nZWQnKSAhPT0gLTEpIHtcblx0XHRcdFx0YWdtLnN1YnNjcmliZShcIlQ0Mi5XbmQuV2luZG93U3RhdGVDaGFuZ2VkXCIsIHt0YXJnZXQ6IFwiYWxsXCJ9KS50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcblx0XHRcdFx0XHRzdHJlYW0ub25EYXRhKGZ1bmN0aW9uIChzdHJlYW1EYXRhKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVfd2luZG93KHN0cmVhbURhdGEuZGF0YSwgZGV0ZXJtaW5hdGVDb3JyZWN0Q29udGFpbmVyKHN0cmVhbURhdGEuc2VydmVyLmFwcGxpY2F0aW9uKSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gYXR0YWNoIGNhbGxiYWNrc1xuXHRcdFx0XHRcdC8vc3RyZWFtLm9uKFwiZW5kXCIsIGhhbmRsZVN0cmVhbUNsb3NlZCk7XG5cdFx0XHRcdFx0Ly9zdHJlYW0ub24oXCJjbG9zZVwiLCBoYW5kbGVTdHJlYW1DbG9zZWQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXHQvL1N0b3JlIHdpbmRvd3MgdGhhdCBhcmUgdHJhY2tlZCBieSBJRCBhbmQgcmVjZWl2ZSB1cGRhdGVzXG5cdHZhciB3aW5kb3dzID0ge307XG5cblx0ZnVuY3Rpb24gdXBkYXRlX3dpbmRvdyh3aW5kb3dfaW5mbywgY29udGFpbmVyX25hbWUpIHtcblxuXHRcdHZhciB3aW5kb3dfaWQgPSBjb250YWluZXJfbmFtZSArIFwiLlwiICsgd2luZG93X2luZm8ud2luZG93TmFtZTtcblxuXHRcdHZhciB0aGVfd2luZG93ID0gd2luZG93c1t3aW5kb3dfaWRdO1xuXG5cdFx0aWYgKHRoZV93aW5kb3cgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly9JZiB0aGUgdXNlciBpcyBzdWJzY3JpYmVkIGZvciB0aGUgZ2xvYmFsIGV2ZW50cywgY3JlYXRlIHRoZSB3aW5kb3cgb2JqZWN0LlxuXHRcdFx0aWYgKGdldF9jYWxsYmFja3Mod2luZG93X2FkZGVkX2NhbGxiYWNrcywgY29udGFpbmVyX25hbWUpLmxlbmd0aCA+IDAgfHwgZ2V0X2NhbGxiYWNrcyh3aW5kb3dfcmVtb3ZlZF9jYWxsYmFja3MsIGNvbnRhaW5lcl9uYW1lKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHRoZV93aW5kb3cgPSBhX3dpbmRvd19mcm9tKHdpbmRvd19pbmZvLndpbmRvd05hbWUsIGNvbnRhaW5lcl9uYW1lLCB3aW5kb3dfaW5mby51cmwsIHdpbmRvd19pbmZvLndpbmRvd0lkLCB3aW5kb3dfaW5mby53aW5kb3dTdHlsZUF0dHJpYnV0ZXMsd2luZG93X2luZm8ud2luZG93VGl0bGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGVfd2luZG93LmlkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoZV93aW5kb3cuaWQgPSB3aW5kb3dfaW5mby53aW5kb3dJZDtcblx0XHRcdGV4ZWNfY2FsbGJhY2tzKHRoZV93aW5kb3cuY2FsbGJhY2tzLm9uX2F2YWlsYWJsZSwgdGhlX3dpbmRvdyk7XG5cdFx0fVxuXG5cdFx0aWYgKHdpbmRvd19pbmZvLnN0YXRlID09PSBcIlRpdGxlQ2hhbmdlZFwiKSB7XG5cdFx0XHR0aGVfd2luZG93LnRpdGxlID0gd2luZG93X2luZm8ud2luZG93VGl0bGU7XG5cdFx0XHRleGVjX2NhbGxiYWNrcyh0aGVfd2luZG93LmNhbGxiYWNrcy5vblRpdGxlQ2hhbmdlZCwgd2luZG93X2luZm8ud2luZG93VGl0bGUpO1xuXHRcdH1cblxuXHRcdGlmICh0aGVfd2luZG93LnVybCAhPT0gd2luZG93X2luZm8udXJsKSB7XG5cdFx0XHR0aGVfd2luZG93LnVybCA9IHdpbmRvd19pbmZvLnVybDtcblx0XHRcdGV4ZWNfY2FsbGJhY2tzKHRoZV93aW5kb3cuY2FsbGJhY2tzLm9uX3VybF9jaGFuZ2VkLCB3aW5kb3dfaW5mby51cmwpO1xuXHRcdH1cblxuXHRcdGlmICh3aW5kb3dfaW5mby5zdGF0ZSA9PT0gXCJDcmVhdGVkXCIpIHtcblx0XHRcdC8vRXhlY3V0ZSBnbG9iYWwgXCJ3aW5kb3dfYWRkZWRcIiBjYWxsYmFja3Ncblx0XHRcdGV4ZWNfY2FsbGJhY2tzKGdldF9jYWxsYmFja3Mod2luZG93X2FkZGVkX2NhbGxiYWNrcywgY29udGFpbmVyX25hbWUpLCB0aGVfd2luZG93KTtcblx0XHR9XG5cblx0XHQvL0NsZWFyIHRoZSB3aW5kb3cgb24gY2xvc2UgZXZlbnRcblx0XHRpZiAod2luZG93X2luZm8uc3RhdGUgPT09IFwiQ2xvc2VkXCIpIHtcblx0XHRcdC8vRXhlY3V0ZSBnbG9iYWwgXCJ3aW5kb3dfcmVtb3ZlZFwiIGNhbGxiYWNrc1xuXHRcdFx0ZXhlY19jYWxsYmFja3MoZ2V0X2NhbGxiYWNrcyh3aW5kb3dfcmVtb3ZlZF9jYWxsYmFja3MsIGNvbnRhaW5lcl9uYW1lKSwgdGhlX3dpbmRvdyk7XG5cdFx0XHQvL0V4ZWN1dGUgd2luZG93LXNwZWNpZmljIFwid2luZG93X3JlbW92ZWRcIiBjYWxsYmFja3Ncblx0XHRcdGV4ZWNfY2FsbGJhY2tzKHRoZV93aW5kb3cuY2FsbGJhY2tzLm9uQ2xvc2UpO1xuXHRcdFx0Ly9SZWZyZXNoIHRoZSB3aW5kb3cgb2JqZWN0IHN0YXRlXG5cdFx0XHR0aGVfd2luZG93LmlkID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhlX3dpbmRvdy5jYWxsYmFja3MgPSB7fTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vQnV0dG9uQ2xpY2tlZFxuXHRcdGlmICh3aW5kb3dfaW5mby5zdGF0ZSA9PT0gXCJCdXR0b25DbGlja2VkXCIpIHtcblx0XHRcdC8vRXhlY3V0ZSBnbG9iYWwgXCJ3aW5kb3dfYWRkZWRcIiBjYWxsYmFja3Ncblx0XHRcdGlmKHRoZV93aW5kb3cuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKHRoZV93aW5kb3cuYnV0dG9ucykubGVuZ3RoICE9PSAwKXtcblx0XHRcdFx0dGhlX3dpbmRvdy5jYWxsYmFja3Mub25UYWJCdXR0b24uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRjYWxsYmFjayh3aW5kb3dfaW5mby5idXR0b25JZCx0aGVfd2luZG93LmJ1dHRvbnNbd2luZG93X2luZm8uYnV0dG9uSWRdLmluZm8pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL0NyZWF0ZSBhIGRpY3Rpb25hcnkgdG8gc3RvcmUgdGhlIGNhbGxiYWNrcyBmb3IgdGhlIG1ldGhvZCBcIndpbmRvd19hZGRlZFwiLlxuXHR2YXIgd2luZG93X2FkZGVkX2NhbGxiYWNrcyA9IHtcblx0XHRjb250YWluZXJzX2NhbGxiYWNrczoge30sXG5cdFx0YWxsX2NvbnRhaW5lcnNfY2FsbGJhY2tzOiBbXVxuXHR9O1xuXG5cdC8vQ3JlYXRlIGEgZGljdGlvbmFyeSB0byBzdG9yZSB0aGUgY2FsbGJhY2tzIGZvciB0aGUgbWV0aG9kIFwid2luZG93X3JlbW92ZWRcIi5cblx0dmFyIHdpbmRvd19yZW1vdmVkX2NhbGxiYWNrcyA9IHtcblx0XHRjb250YWluZXJzX2NhbGxiYWNrczoge30sXG5cdFx0YWxsX2NvbnRhaW5lcnNfY2FsbGJhY2tzOiBbXVxuXHR9O1xuXG5cdC8vQ3JlYXRlcyBhIG5ldyB3aW5kb3cgb2JqZWN0IG9yIHJldHVybnMgYW4gZXhpc3Rpbmcgb25lXG5cdC8vQWNjZXB0cyB3aW5kb3cgbmFtZSwgY29udGFpbmVyIGFuZCBVUkxcblx0Ly9SZXR1cm5zIGEgd2luZG93IG9iamVjdC5cblxuXHQvL0l0IGlzIG5vdCBndWFyYW50ZWVkIHRvIHJldHVybiB0aGUgd2luZG93IHdpdGggdGhlIHNhbWUgVVJMIGFuZCBJRFxuXHRmdW5jdGlvbiBhX3dpbmRvd19mcm9tKG5hbWUsIGNvbnRhaW5lciwgdXJsLCBpZCwgd2luZG93U3R5bGVzLCB0aXRsZSkge1xuXG5cdFx0dmFyIHdpbmRvd19pZCA9IGRldGVybWluYXRlQ29ycmVjdENvbnRhaW5lcihjb250YWluZXIpICsgXCIuXCIgKyBuYW1lO1xuXG5cdFx0dmFyIGV4aXN0aW5nX3dpbmRvdyA9IHdpbmRvd3Nbd2luZG93X2lkXTtcblxuXHRcdGlmIChleGlzdGluZ193aW5kb3cgIT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHQvL0lmIHRoZSB3aW5kb3cgaXMgY2xvc2VkLCB1cGRhdGUgdGhlIFVSTCBpbiB0aGUgcmVmZXJlbmNlXG5cdFx0XHRpZiAoIWV4aXN0aW5nX3dpbmRvdy5vcGVuZWQoKSkge1xuXHRcdFx0XHRleGlzdGluZ193aW5kb3cudXJsID0gdXJsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4aXN0aW5nX3dpbmRvdztcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvL0luaXQgb2JqZWN0XG5cdFx0XHR2YXIgd2luZG93X29iaiA9IE9iamVjdC5jcmVhdGUod2luZG93X3Byb3RvKTtcblx0XHRcdHdpbmRvd19vYmoubmFtZSA9IG5hbWU7XG5cdFx0XHR3aW5kb3dfb2JqLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblx0XHRcdHdpbmRvd19vYmoudXJsID0gdXJsO1xuXHRcdFx0d2luZG93X29iai5pZCA9IGlkO1xuXHRcdFx0d2luZG93X29iai5jYWxsYmFja3MgPSB7fTtcblxuXHRcdFx0Ly9JbnNlcnQgQUdNIHNlcnZlciBwcm9wZXJ0aWVzXG5cdFx0XHR3aW5kb3dfb2JqLmFwcGxpY2F0aW9uID0gd2luZG93X2lkO1xuXG5cdFx0XHQvL3NldHRpbmcgd2luZG93IHRpdGxlXG5cdFx0XHR3aW5kb3dfb2JqLnRpdGxlID0gdGl0bGU7XG5cblx0XHRcdC8vQWRkaW5nIHdpbmRvd1N0eWxlQXR0cmlidXRlc1xuXHRcdFx0aWYgKHdpbmRvd1N0eWxlcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB3aW5kb3dTdHlsZXMgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHdpbmRvd19vYmoud2luZG93U3R5bGVBdHRyaWJ1dGVzID0gSlNPTi5wYXJzZSh3aW5kb3dTdHlsZXMpO1xuXHRcdFx0fSBlbHNlIGlmICh3aW5kb3dTdHlsZXMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93U3R5bGVzID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR3aW5kb3dfb2JqLndpbmRvd1N0eWxlQXR0cmlidXRlcyA9IHdpbmRvd1N0eWxlcztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dfb2JqLndpbmRvd1N0eWxlQXR0cmlidXRlcyA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvL0luaXQgZW1wdHkgYXJyYXkgZm9yIGJ1dHRvbnNcblx0XHRcdHdpbmRvd19vYmouYnV0dG9ucyA9IHt9O1xuXG5cdFx0XHR3aW5kb3dzW3dpbmRvd19pZF0gPSB3aW5kb3dfb2JqO1xuXG5cdFx0XHRyZXR1cm4gd2luZG93X29iajtcblx0XHR9XG5cdH1cblxuXHQvL0JpbmRzIGEgZ2l2ZW4gd2luZG93IG9iamVjdCB0byBhbiBhY3R1YWwgd2luZG93XG5cdGZ1bmN0aW9uIGJpbmRfd2luZG93KHRoZV93aW5kb3csIHN1Y2Nlc3MsIGVycm9yKSB7XG5cblx0XHQvL1R5cGljYWxseSB0aGUgYmluZGluZyBvY2N1cnMgd2hlbiB3ZSByZWNlaXZlIGFuIGV2ZW50LCBzbyB3ZSB3aWxsIHJldHJpZXZlIHNvbWUgaW5mbyBhYm91dCB0aGUgd2luZG93XG5cdFx0Ly9hbmQgaWYgaXQgZXhpc3RzIHdlIHdpbGwgdHJpZ2dlciBhbiBhcnRpZmljaWFsIGV2ZW50IHdpdGggaXQuXG5cblx0XHQvL0NoZWNrIGlmIHRoZSB3aW5kb3cgaXNuJ3QgYWxyZWFkeSBib3VuZFxuXHRcdGlmICh0aGVfd2luZG93LmlkID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0Ly9jaGVja2luZyBmb3IgY29udGFpbmVyXG5cdFx0XHR2YXIgdGFyZ2V0ID0gY29udGFpbmVyX2ZpbHRlcih0aGVfd2luZG93LmNvbnRhaW5lcik7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0ZXJyb3IoXCJObyBzdWNoIGNvbnRhaW5lclwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL1JldHJpZXZlIHdpbmRvdyBwYXJhbWV0ZXJzXG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLlduZC5GaW5kQnlOYW1lXCIsIHt3aW5kb3dOYW1lOiB0aGVfd2luZG93Lm5hbWV9LCB0YXJnZXQsIHt9LCBiaW5kX2Zyb21faW5mbywgZXJyb3IpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGludm9rZV9hZ21fc3VjY2Vzc19jYWxsYmFjayhzdWNjZXNzLCB0aGVfd2luZG93KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoZV93aW5kb3c7XG5cblx0XHRmdW5jdGlvbiBiaW5kX2Zyb21faW5mbyhlKSB7XG5cdFx0XHQvL1JldHJpZXZlIHdpbmRvdyBpbmZvIChhIGJpdCBoYWNreSBiZWNhdXNlIHRoZSByZXNwb25zZSBmb3JtYXQgaXMgd2VpcmQpXG5cdFx0XHR2YXIgd2luZG93X2luZm8gPSB2YWxzKGUucmV0dXJuZWQpWzBdO1xuXG5cdFx0XHRpZiAod2luZG93X2luZm8gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRlcnJvcihcIndlIGNvdW5kIG5vdCBvcGVuL2ZpbmQgdGhpcyB3aW5kb3dcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vVHJpZ2dlciBhbiBldmVudFxuXHRcdFx0XHR3aW5kb3dfaW5mby5zdGF0ZSA9IFwiQXR0YWNoZWRcIjtcblx0XHRcdFx0dXBkYXRlX3dpbmRvdyh3aW5kb3dfaW5mbywgdGhlX3dpbmRvdy5jb250YWluZXIpO1xuXG5cdFx0XHRcdC8vRXhlYyB1c2VyIGNhbGxiYWNrXG5cdFx0XHRcdGludm9rZV9hZ21fc3VjY2Vzc19jYWxsYmFjayhzdWNjZXNzLCB0aGVfd2luZG93KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL0Z1bmN0aW9ucyBmb3Igb3BlbmluZywgY2xvc2luZywgcmVzaXppbmcgd2luZG93c1xuXHR2YXIgd2luZG93X3Byb3RvID0ge1xuXG5cdFx0b3BlbjogZnVuY3Rpb24gKGRpbWVuc2lvbnMsIHN0eWxlLCBzdWNjZXNzLCBlcnJvcikge1xuXG5cdFx0XHQvL0Egd3JhcHBlciBmb3IgdGhlIHN0YW5kYXJkIEFHTSBcIm9wZW5cIiBmdW5jdGlvblxuXG5cdFx0XHR2YXIgdGhlX3dpbmRvdyA9IHRoaXM7XG5cblx0XHRcdC8vSW5pdCBzdHlsZSBvYmplY3RzIGlmIHRoZXkgYXJlIG51bGxcblx0XHRcdGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zIHx8IHt9O1xuXHRcdFx0c3R5bGUgPSBzdHlsZSB8fCB7fTtcblxuXHRcdFx0Ly9UYWtlIG91dCB0aGUgc3RpY2t5LXdpbmRvd3MgcmVsYXRlZCBwcm9wZXJ0aWVzIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXG5cdFx0XHR2YXIgaXNTdGlja3kgPSBzdHlsZS5pc1N0aWNreTtcblx0XHRcdGRlbGV0ZSBzdHlsZS5pc1N0aWNreTtcblxuXHRcdFx0dmFyIHN0aWNreUdyb3VwID0gc3R5bGUuc3RpY2t5R3JvdXA7XG5cdFx0XHRkZWxldGUgc3R5bGUuc3RpY2t5R3JvdXA7XG5cdFx0XHRkZWxldGUgc3R5bGUuaGFzTW92ZUFyZWFUaGlja25lc3M7XG5cdFx0XHRkZWxldGUgc3R5bGUuaGFzU2l6ZUFyZWFUaGlja25lc3M7XG5cblx0XHRcdC8vY2hlY2tpbmcgZm9yIGNvbnRhaW5lclxuXHRcdFx0dmFyIHRhcmdldCA9IGNvbnRhaW5lcl9maWx0ZXIodGhlX3dpbmRvdy5jb250YWluZXIpO1xuXHRcdFx0aWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGVycm9yKFwiTm8gc3VjaCBjb250YWluZXJcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5IdG1sLkNyZWF0ZVdpbmRvd1wiLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly9XaW5kb3cgbmFtZSBhbmQgdXJsXG5cdFx0XHRcdFx0d2luZG93TmFtZTogdGhlX3dpbmRvdy5uYW1lLCB1cmw6IHRoZV93aW5kb3cudXJsLFxuXHRcdFx0XHRcdC8vZGltZW5zaW9uc1xuXHRcdFx0XHRcdHRvcDogZGltZW5zaW9ucy50b3AsIGxlZnQ6IGRpbWVuc2lvbnMubGVmdCwgd2lkdGg6IGRpbWVuc2lvbnMud2lkdGgsIGhlaWdodDogZGltZW5zaW9ucy5oZWlnaHQsXG5cdFx0XHRcdFx0Ly9TdGlja3l3aW5kb3dzIC0gcmVsYXRlZCBwcm9wc1xuXHRcdFx0XHRcdGlzU3RpY2t5OiBpc1N0aWNreSwgc3RpY2t5R3JvdXA6IHN0aWNreUdyb3VwLFxuXHRcdFx0XHRcdC8vU3R5bGUgYXR0cmlidXRlc1xuXHRcdFx0XHRcdHdpbmRvd1N0eWxlQXR0cmlidXRlczogSlNPTi5zdHJpbmdpZnkoc3R5bGUpXG5cblx0XHRcdFx0fSxcblx0XHRcdFx0dGFyZ2V0LFxuXHRcdFx0XHR7fSxcblx0XHRcdFx0b3BlbmVkLFxuXHRcdFx0XHRjYW5ub3Rfb3Blbik7XG5cblx0XHRcdGZ1bmN0aW9uIG9wZW5lZChtZXNzYWdlKSB7XG5cdFx0XHRcdC8vQWRkIGlkIHRvIHRoZSBjdXJyZW50IHdpbmRvd3MgYmVjYXVzZSB0aGUgY3VycmVudCBIVE1MIENvbnRhaW5lclxuXHRcdFx0XHQvL2RvZXNuJ3Qgc3VwcG9ydCB0cmFja2luZyB0aGUgdXBkYXRlcyBvZiB0aGUgd2luZG93XG5cdFx0XHRcdGlmIChtZXNzYWdlLnJldHVybmVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGVfd2luZG93LmlkID0gbWVzc2FnZS5yZXR1cm5lZC5pZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbnZva2VfYWdtX3N1Y2Nlc3NfY2FsbGJhY2soc3VjY2VzcywgdGhlX3dpbmRvdyk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNhbm5vdF9vcGVuKGUpIHtcblx0XHRcdFx0Ly9DYWxsIHRoZSBlcnJvciBjYWxsYmFja1xuXHRcdFx0XHRpZiAodHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRlcnJvcihlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vVHJ5IHRvIGJpbmQgdGhlIHJldHVybmVkIG9iamVjdCBpbiBjYXNlLi4uXG5cdFx0XHRcdGJpbmRfd2luZG93KHRoZV93aW5kb3cpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhlX3dpbmRvdztcblx0XHR9LFxuXG5cdFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdHJldHVybiBhZ21fYWN0aW9uKFwiVDQyLlduZC5TZXRXaW5kb3dTdHlsZVwiKS5jYWxsKHRoaXMsIHN1Y2Nlc3MsIGVycm9yLCB7d2luZG93U3R5bGVBdHRyaWJ1dGVzOiBKU09OLnN0cmluZ2lmeShzdHlsZSl9KTtcblx0XHR9LFxuXG5cdFx0b3BlbmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pZCAhPT0gdW5kZWZpbmVkO1xuXHRcdH0sXG5cblx0XHRvbkF2YWlsYWJsZTogYWRkX2NhbGxiYWNrKFwib25fYXZhaWxhYmxlXCIsIGZ1bmN0aW9uICh0aGVfd2luZG93LCBjYWxsYmFjaykge1xuXHRcdFx0aWYgKHRoZV93aW5kb3cub3BlbmVkKCkpIHtcblx0XHRcdFx0Y2FsbGJhY2sodGhlX3dpbmRvdyk7XG5cdFx0XHR9XG5cdFx0fSksXG5cblx0XHRjbG9zZTogYWdtX2FjdGlvbihcIlQ0Mi5XbmQuQ2xvc2VcIiksXG5cblx0XHRjb2xsYXBzZTogYWdtX2FjdGlvbihcIlQ0Mi5XbmQuQ29sbGFwc2VcIiksXG5cblx0XHRvbkNsb3NlOiBhZGRfY2FsbGJhY2soXCJvbkNsb3NlXCIpLFxuXG5cdFx0bmF2aWdhdGU6IGZ1bmN0aW9uICh1cmwsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRyZXR1cm4gYWdtX2FjdGlvbihcIlQ0Mi5IdG1sLk9wZW5VcmxcIikuY2FsbCh0aGlzLCBzdWNjZXNzLCBlcnJvciwge3VybDogdXJsfSk7XG5cdFx0fSxcblxuXHRcdG9uVXJsQ2hhbmdlZDogYWRkX2NhbGxiYWNrKFwib25VcmxDaGFuZ2VkXCIpLFxuXG5cdFx0b25UaXRsZUNoYW5nZWQ6IGFkZF9jYWxsYmFjayhcIm9uVGl0bGVDaGFuZ2VkXCIsIGZ1bmN0aW9uKHRoZV93aW5kb3csY2FsbGJhY2spe1xuXHRcdFx0Y2FsbGJhY2sodGhlX3dpbmRvdy50aXRsZSk7XG5cdFx0fSksXG5cblx0XHRmb2N1czogYWdtX2FjdGlvbihcIlQ0Mi5XbmQuQWN0aXZhdGVcIiksXG5cblx0XHRzZXRUaXRsZTogZnVuY3Rpb24gKHRpdGxlLCBzdWNjZXNzLCBlcnJvcikge1xuXG5cdFx0XHR2YXIgdGFyZ2V0ID0gY29udGFpbmVyX2ZpbHRlcih0aGlzLmNvbnRhaW5lcik7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlcnJvcihcIk5vIGNvbnRhaW5lclwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL0ludm9rZSB0aGUgQUdNIG1ldGhvZFxuXHRcdFx0YWdtLmludm9rZShcIlQ0Mi5XbmQuU2V0V2luZG93VGl0bGVcIiwge1xuXHRcdFx0XHR3aW5kb3dJZDogdGhpcy5pZCxcblx0XHRcdFx0dGl0bGU6IHRpdGxlXG5cdFx0XHR9LCB0YXJnZXQsIHt9LCB0aXRsZV9pc19zZXQuYmluZCh0aGlzKSwgdGl0bGVfY2Fubm90X2JlX3NldCk7XG5cblx0XHRcdGZ1bmN0aW9uIHRpdGxlX2lzX3NldCgpIHtcblx0XHRcdFx0aW52b2tlX2FnbV9zdWNjZXNzX2NhbGxiYWNrKHN1Y2Nlc3MsIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB0aXRsZV9jYW5ub3RfYmVfc2V0KGUpIHtcblx0XHRcdFx0aW52b2tlX2FnbV9lcnJvcl9jYWxsYmFjayhlcnJvciwgZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldERldGFpbHM6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0dmFyIHdpbmRvd19pZCA9IHRoaXMuaWQ7XG5cblx0XHRcdHZhciB0YXJnZXQgPSBjb250YWluZXJfZmlsdGVyKHRoaXMuY29udGFpbmVyKTtcblx0XHRcdGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVycm9yKFwiTm8gY29udGFpbmVyXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuV25kLkZpbmRCeUlkXCIsIHt3aW5kb3dJZDogdGhpcy5pZH0sIHRhcmdldCwge30sIHJldHVybmVkX2RpbWVuc2lvbnMsIGNhbm5vdF9yZXR1cm5fZGltZW5zaW9ucyk7XG5cblx0XHRcdGZ1bmN0aW9uIHJldHVybmVkX2RpbWVuc2lvbnModmFsdWUpIHtcblx0XHRcdFx0aW52b2tlX2FnbV9zdWNjZXNzX2NhbGxiYWNrKHN1Y2Nlc3MsIHZhbHVlLnJldHVybmVkW3dpbmRvd19pZF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjYW5ub3RfcmV0dXJuX2RpbWVuc2lvbnMoZSkge1xuXHRcdFx0XHRpbnZva2VfYWdtX2Vycm9yX2NhbGxiYWNrKGVycm9yLCBlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bW92ZVJlc2l6ZTogZnVuY3Rpb24gKGRpbWVuc2lvbnMsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRyZXR1cm4gYWdtX2FjdGlvbihcIlQ0Mi5XbmQucmVzaXplQW5kTW92ZVwiKS5jYWxsKHRoaXMsIHN1Y2Nlc3MsIGVycm9yLCBkaW1lbnNpb25zKTtcblx0XHR9LFxuXG5cdFx0bWF4aW1pemU6IGFnbV9hY3Rpb24oXCJUNDIuV25kLk1heGltaXplXCIpLFxuXG5cdFx0cmVzdG9yZTogYWdtX2FjdGlvbihcIlQ0Mi5XbmQuUmVzdG9yZVwiKSxcblxuXHRcdG1pbmltaXplOiBhZ21fYWN0aW9uKFwiVDQyLlduZC5NaW5pbWl6ZVwiKSxcblxuXHRcdG1heGltaXplUmVzdG9yZTogYWdtX2FjdGlvbihcIlQ0Mi5XbmQuTWF4aW1pemVPclJlc3RvcmVEb3duXCIpLFxuXG5cdFx0b25UYWJCdXR0b246IGFkZF9jYWxsYmFjayhcIm9uVGFiQnV0dG9uXCIpLFxuXG5cdFx0YWRkVGFiQnV0dG9uOiAgZnVuY3Rpb24gKGJ1dHRvbkluZm8sIHN1Y2Nlc3MsIGVycm9yKSB7XG5cblx0XHRcdHZhciB0YXJnZXQgPSBjb250YWluZXJfZmlsdGVyKHRoaXMuY29udGFpbmVyKTtcblx0XHRcdGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkgIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlcnJvcihcIk5vIGNvbnRhaW5lclwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYodHlwZW9mIGJ1dHRvbkluZm8gPT09ICd1bmRlZmluZWQnKXtcblx0XHRcdFx0aWYgKHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlcnJvcihcIk5vIGJ1dHRvbiBpbmZvXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKGJ1dHRvbkluZm8uYnV0dG9uSWQgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdGlmICh0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXJyb3IoXCJObyBidXR0b25JZFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihidXR0b25JbmZvLmltYWdlQmFzZTY0ID09PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRpZiAodHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVycm9yKFwiTm8gaW1hZ2VCYXNlNjRcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGJ1dHRvbkluZm8gPSB7XG5cdFx0XHRcdGJ1dHRvbklkOiBidXR0b25JbmZvLmJ1dHRvbklkLFxuXHRcdFx0XHR0b29sdGlwOiBidXR0b25JbmZvLnRvb2x0aXAsXG5cdFx0XHRcdG9yZGVyOiBidXR0b25JbmZvLm9yZGVyLFxuXHRcdFx0XHRpbWFnZUJhc2U2NDogYnV0dG9uSW5mby5pbWFnZUJhc2U2NCxcblx0XHRcdFx0aG92ZXJJbWFnZUJhc2U2NDogIGJ1dHRvbkluZm8uaG92ZXJJbWFnZUJhc2U2NCxcblx0XHRcdFx0Y2xpY2tJbWFnZUJhc2U2NDogYnV0dG9uSW5mby5jbGlja0ltYWdlQmFzZTY0LFxuXHRcdFx0fTtcblxuXHRcdFx0Ly9JbnZva2UgdGhlIEFHTSBtZXRob2Rcblx0XHRcdGFnbS5pbnZva2UoXCJUNDIuV25kLkFkZEJ1dHRvblwiLCB7XG5cdFx0XHRcdHdpbmRvd0lkOiB0aGlzLmlkLFxuXHRcdFx0XHRidXR0b25JbmZvOmJ1dHRvbkluZm9cblx0XHRcdH0sIHRhcmdldCwge30sIGJ1dHRvbklzQWRkZWQuYmluZCh0aGlzKSwgYnV0dG9uQ2Fubm90QmVBZGRlZC5iaW5kKHRoaXMpKTtcblxuXHRcdFx0ZnVuY3Rpb24gYnV0dG9uSXNBZGRlZCgpIHtcblx0XHRcdFx0dmFyIF9idXR0b25JZCA9IGJ1dHRvbkluZm8uYnV0dG9uSWQ7XG5cdFx0XHRcdHRoaXMuYnV0dG9uc1tfYnV0dG9uSWRdID0ge1xuXHRcdFx0XHRcdGlkOiBfYnV0dG9uSWQsXG5cdFx0XHRcdFx0aW5mbzpidXR0b25JbmZvXG5cdFx0XHRcdH07XG5cdFx0XHRcdGludm9rZV9hZ21fc3VjY2Vzc19jYWxsYmFjayhzdWNjZXNzLCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnV0dG9uQ2Fubm90QmVBZGRlZChlKSB7XG5cdFx0XHRcdGludm9rZV9hZ21fZXJyb3JfY2FsbGJhY2soZXJyb3IsIGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyBkZXByZWNhdGVzXG5cdHdpbmRvd19wcm90by5zZXRfc3R5bGUgPSBkZXByZWNhdGUod2luZG93X3Byb3RvLnNldFN0eWxlLCAnd2luZG93LnNldF9zdHlsZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIHdpbmRvdy5zZXRTdHlsZSgpIGluc3RlYWQnKTtcblx0d2luZG93X3Byb3RvLm9uX2F2YWlsYWJsZSA9IGRlcHJlY2F0ZSh3aW5kb3dfcHJvdG8ub25BdmFpbGFibGUsICd3aW5kb3cub25fYXZhaWxhYmxlKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93Lm9uQXZhaWxhYmxlKCkgaW5zdGVhZCcpO1xuXHR3aW5kb3dfcHJvdG8ub25fY2xvc2UgPSBkZXByZWNhdGUod2luZG93X3Byb3RvLm9uQ2xvc2UsICd3aW5kb3cub25fY2xvc2UoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cub25DbG9zZSgpIGluc3RlYWQnKTtcblx0d2luZG93X3Byb3RvLm9uX3VybF9jaGFuZ2VkID0gZGVwcmVjYXRlKHdpbmRvd19wcm90by5vblVybENoYW5nZWQsICd3aW5kb3cub25fdXJsX2NoYW5nZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cub25VcmxDaGFuZ2VkKCkgaW5zdGVhZCcpO1xuXHR3aW5kb3dfcHJvdG8uc2V0X3RpdGxlID0gZGVwcmVjYXRlKHdpbmRvd19wcm90by5zZXRUaXRsZSwgJ3dpbmRvdy5zZXRfdGl0bGUoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cuc2V0VGl0bGUoKSBpbnN0ZWFkJyk7XG5cdHdpbmRvd19wcm90by5nZXRfZGV0YWlscyA9IGRlcHJlY2F0ZSh3aW5kb3dfcHJvdG8uZ2V0RGV0YWlscywgJ3dpbmRvdy5nZXRfZGV0YWlscygpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIHdpbmRvdy5nZXREZXRhaWxzKCkgaW5zdGVhZCcpO1xuXHR3aW5kb3dfcHJvdG8ubW92ZV9yZXNpemUgPSBkZXByZWNhdGUod2luZG93X3Byb3RvLm1vdmVSZXNpemUsICd3aW5kb3cubW92ZV9yZXNpemUoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cubW92ZVJlc2l6ZSgpIGluc3RlYWQnKTtcblx0d2luZG93X3Byb3RvLm1heGltaXplX3Jlc3RvcmUgPSBkZXByZWNhdGUod2luZG93X3Byb3RvLm1heGltaXplUmVzdG9yZSwgJ3dpbmRvdy5tYXhpbWl6ZV9yZXN0b3JlKCkgaXMgZGVwcmVjYXRlZCBhbmQgbWlnaHQgYmUgcmVtb3ZlZCBmcm9tIGZ1dHVyZSB2ZXJzaW9ucyBvZiBnbHVlLiBVc2Ugd2luZG93Lm1heGltaXplUmVzdG9yZSgpIGluc3RlYWQnKTtcblxuXHQvL0FkZHMgYW4gYWxpYXMgb2YgYW4gQUdNIG1ldGhvZCBpbiB0aGUgV2luZG93IHByb3RvdHlwZVxuXHRmdW5jdGlvbiBhZ21fYWN0aW9uKGFjdGlvbikge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IsIGFyZ3MpIHtcblxuXHRcdFx0Ly9TdG9wIGlmIHRoZSB3aW5kb3cgaXMgY2xvc2VkXG5cdFx0XHRpZiAodGhpcy51cmwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRlcnJvcihcIkNhbm5vdCBleGVjdXRlIGEgY29tbWFuZCBvbiBhIGNsb3NlZCB3aW5kb3cuXCIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvL0FkZCB0aGUgd2luZG93IElEIHRvIHRoZSBhcmd1bWVudHNcblx0XHRcdGFyZ3MgPSBhcmdzIHx8IHt9O1xuXHRcdFx0YXJncy53aW5kb3dJZCA9IHRoaXMuaWQ7XG5cblx0XHRcdC8vSW52b2tlIHRoZSBBR00gbWV0aG9kXG5cdFx0XHRhZ20uaW52b2tlKGFjdGlvbiwgYXJncywgY29udGFpbmVyX2ZpbHRlcih0aGlzLmNvbnRhaW5lciksIHt9LCBmdWxmaWxsZWQsIGVycm9yKTtcblxuXHRcdFx0dmFyIHRoZV93aW5kb3cgPSB0aGlzO1xuXG5cdFx0XHRmdW5jdGlvbiBmdWxmaWxsZWQoKSB7XG5cdFx0XHRcdGludm9rZV9hZ21fc3VjY2Vzc19jYWxsYmFjayhzdWNjZXNzLCB0aGVfd2luZG93KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRldGVybWluYXRlQ29ycmVjdENvbnRhaW5lcihjb250YWluZXJOYW1lKSB7XG5cdFx0Ly8gZGV0ZXJtaW5hdGUgSEMgb3IgQnJvd3NlclxuXHRcdHZhciBpc0h0bWxDb250YWluZXIgPSB0eXBlb2YgaHRtbENvbnRhaW5lciAhPT0gJ3VuZGVmaW5lZCc7XG5cdFx0dmFyIGNvbnRhaW5lckZ1bGxOYW1lID0gXCJIdG1sQ29udGFpbmVyLlwiO1xuXG5cdFx0Ly9Db250YWluZXIgbmFtZSBpcyBvcHRpb25hbC4gaWYgaXMgdW5kZWZpbmVkXG5cdFx0aWYgKGNvbnRhaW5lck5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGlzSHRtbENvbnRhaW5lcikge1xuXHRcdFx0XHRjb250YWluZXJGdWxsTmFtZSArPSBodG1sQ29udGFpbmVyLmNvbnRhaW5lck5hbWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc2VsZWN0ZWRDb250YWluZXJzID0gZ2V0QXZhaWxhYmxlU2VydmVycygpO1xuXHRcdFx0XHRpZiAoc2VsZWN0ZWRDb250YWluZXJzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGNvbnRhaW5lckZ1bGxOYW1lID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRhaW5lckZ1bGxOYW1lID0gc2VsZWN0ZWRDb250YWluZXJzWzBdLmFwcGxpY2F0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBmaXJzdERvdEluZGV4ID0gY29udGFpbmVyTmFtZS5pbmRleE9mKCcuJyk7XG5cdFx0XHR2YXIgZGFzaEluZGV4ID0gY29udGFpbmVyTmFtZS5pbmRleE9mKCctJyk7XG5cdFx0XHR2YXIgbGFzdERvdEluZGV4ID0gY29udGFpbmVyTmFtZS5pbmRleE9mKCcuJywgZGFzaEluZGV4KTtcblx0XHRcdC8vaGVyZSBpcyBhIGZ1bGwgcGF0dGVybiAtIGp1c3QgcGFzcyBpdFxuXHRcdFx0aWYgKGZpcnN0RG90SW5kZXggIT09IC0xICYmIGRhc2hJbmRleCA+IGZpcnN0RG90SW5kZXggJiYgbGFzdERvdEluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRjb250YWluZXJGdWxsTmFtZSA9IGNvbnRhaW5lck5hbWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaXNIdG1sQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0aWYgKGh0bWxDb250YWluZXIuZW52LmVudiAhPT0gdW5kZWZpbmVkIHx8IGh0bWxDb250YWluZXIuZW52LnJlZ2lvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHQvLyBIZXJlIHdlIGhhdmUgcGFydGlhbCBuYW1lIG9mIENvbnRhaW5lciBpbiBIQ1xuXHRcdFx0XHRcdFx0aWYgKGNvbnRhaW5lck5hbWUuaW5kZXhPZihodG1sQ29udGFpbmVyLmVudi5lbnYpID09PSAtMSAmJiBjb250YWluZXJOYW1lLmluZGV4T2YoaHRtbENvbnRhaW5lci5lbnYucmVnaW9uKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0Y29udGFpbmVyRnVsbE5hbWUgKz0gaHRtbENvbnRhaW5lci5lbnYuZW52ICsgJy0nICsgaHRtbENvbnRhaW5lci5lbnYucmVnaW9uICsgJy4nO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29udGFpbmVyRnVsbE5hbWUgKz0gY29udGFpbmVyTmFtZTtcblx0XHRcdFx0XHRcdC8vQmV0dGVyIHRvIGNoZWNrIGlmIGV4aXN0IHNlcnZlciB3aXRoIHNpbWlsYXIgY29udGFpbmVyPyBhbmQgaWYgaXQgcGFzc2VkIHdyb25nIGNvbnRhaW5lciB0byB0aHJvdyBhbiBleGNlcHRpb24/XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBtYXRjaGluZ1NlcnZlcnMgPSBnZXRBdmFpbGFibGVTZXJ2ZXJzQnlOYW1lKGNvbnRhaW5lck5hbWUpO1xuXHRcdFx0XHRcdGlmIChtYXRjaGluZ1NlcnZlcnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0Y29udGFpbmVyRnVsbE5hbWUgPSBtYXRjaGluZ1NlcnZlcnNbMF0uYXBwbGljYXRpb247XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRhaW5lckZ1bGxOYW1lID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29udGFpbmVyRnVsbE5hbWU7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRBdmFpbGFibGVTZXJ2ZXJzKCkge1xuXHRcdHJldHVybiBhZ20uc2VydmVycygpLnJlZHVjZShmdW5jdGlvbiAobWVtbywgc2VydmVyKSB7XG5cdFx0XHRpZiAoc2VydmVyLmFwcGxpY2F0aW9uLmluZGV4T2YoJ0h0bWxDb250YWluZXIuJykgIT09IC0xKSB7XG5cdFx0XHRcdGlmIChzZXJ2ZXIuYXBwbGljYXRpb24uaW5kZXhPZignLkludGVybmFsJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0bWVtby51bnNoaWZ0KHNlcnZlcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWVtby5wdXNoKHNlcnZlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBtZW1vO1xuXHRcdH0sIFtdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEF2YWlsYWJsZVNlcnZlcnNCeU5hbWUobmFtZVNlcnZlcikge1xuXHRcdHJldHVybiBhZ20uc2VydmVycygpLmZpbHRlcihmdW5jdGlvbiAoc2VydmVyKSB7XG5cdFx0XHR2YXIgc3BsaXR0ZWRTZXJ2ZXJOYW1lID0gc2VydmVyLmFwcGxpY2F0aW9uLnNwbGl0KCcuJylbMl07XG5cdFx0XHRyZXR1cm4gc3BsaXR0ZWRTZXJ2ZXJOYW1lID09PSBuYW1lU2VydmVyO1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29udGFpbmVyX2ZpbHRlcihuYW1lKSB7XG5cdFx0aWYgKGRldGVybWluYXRlQ29ycmVjdENvbnRhaW5lcihuYW1lKSkge1xuXHRcdFx0cmV0dXJuIHthcHBsaWNhdGlvbjogZGV0ZXJtaW5hdGVDb3JyZWN0Q29udGFpbmVyKG5hbWUpfTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0fVxuXG5cdC8vVGhlIEFQSSBpdHNlbGZcblx0dmFyIGFwaSA9IHtcblxuXHRcdG15OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaDtcblx0XHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRoID0gd2luZG93Lmh0bWxDb250YWluZXI7XG5cdFx0XHR9XG5cdFx0XHQvL1JldHJpZXZlIHRoZSBjdXJyZW50IHdpbmRvdyAodGhlIG9udyBpbiB3aGljaCB5b3VyIGFwcGxpY2F0aW9uIGN1cnJlbnRseSByZXNpZGVzKS5cblx0XHRcdHJldHVybiBoID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBhX3dpbmRvd19mcm9tKGguYnJvd3NlcldpbmRvd05hbWUsIGguY29udGFpbmVyTmFtZSwgd2luZG93LmxvY2F0aW9uLmhyZWYsIGgud2luZG93SWQpO1xuXHRcdH0sXG5cblx0XHRvcGVuOiBmdW5jdGlvbiAobmFtZSwgdXJsLCBjb250YWluZXIsIGRpbWVuc2lvbnMsIHN0eWxlLCBzdWNjZXNzLCBlcnJvcikge1xuXHRcdFx0dmFyIHRhcmdldCA9IGRldGVybWluYXRlQ29ycmVjdENvbnRhaW5lcihjb250YWluZXIpO1xuXHRcdFx0aWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXJyb3IoXCJObyBjb250YWluZXJcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhX3dpbmRvd19mcm9tKG5hbWUsIHRhcmdldCwgdXJsLCB1bmRlZmluZWQsIHN0eWxlKS5vcGVuKGRpbWVuc2lvbnMsIHN0eWxlLCBzdWNjZXNzLCBlcnJvcik7XG5cdFx0fSxcblxuXHRcdGZpbmQ6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0XHRyZXR1cm4gYmluZF93aW5kb3coYV93aW5kb3dfZnJvbShuYW1lLCBkZXRlcm1pbmF0ZUNvcnJlY3RDb250YWluZXIoY29udGFpbmVyKSksIHN1Y2Nlc3MsIGVycm9yKTtcblx0XHR9LFxuXHRcdF9mcm9tX2V2ZW50OiBhX3dpbmRvd19mcm9tLFxuXG5cdFx0bGlzdDogZnVuY3Rpb24gKGNvbnRhaW5lciwgc3VjY2VzcywgZXJyb3IpIHtcblx0XHRcdGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0YXJnZXQgPSBjb250YWluZXJfZmlsdGVyKGNvbnRhaW5lcik7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlcnJvcihcIk5vIGNvbnRhaW5lclwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRhZ20uaW52b2tlKFwiVDQyLlduZC5MaXN0V2luZG93c1wiLCB7fSwgdGFyZ2V0LCB7d2FpdF9mb3JfbWV0aG9kX3RpbWVvdXQ6IDE1MDAwfSwgbGlzdGVkLCBjYW5ub3RfbGlzdCk7XG5cblx0XHRcdGZ1bmN0aW9uIGxpc3RlZCh2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWUucmV0dXJuZWQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHN1Y2Nlc3MoW10pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gdmFscyh2YWx1ZS5yZXR1cm5lZCkubWFwKGZ1bmN0aW9uIChvcGVuZWRfd2luZG93KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFfd2luZG93X2Zyb20ob3BlbmVkX3dpbmRvdy53aW5kb3dOYW1lLCBkZXRlcm1pbmF0ZUNvcnJlY3RDb250YWluZXIoY29udGFpbmVyKSwgb3BlbmVkX3dpbmRvdy51cmwsIG9wZW5lZF93aW5kb3cud2luZG93SWQsIG9wZW5lZF93aW5kb3cud2luZG93U3R5bGVBdHRyaWJ1dGVzLCBvcGVuZWRfd2luZG93LndpbmRvd1RpdGxlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHN1Y2Nlc3MocmVzdWx0KTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2Fubm90X2xpc3QoZSkge1xuXHRcdFx0XHRpbnZva2VfYWdtX2Vycm9yX2NhbGxiYWNrKGVycm9yLCBlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly9BZGQgY2FsbGJhY2sgZm9yIHdpbmRvdyBhZGRlZCBmb3IgdGhlIGxpc3Qgb2YgY29udGFpbmVycy5cblx0XHR3aW5kb3dBZGRlZDogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250YWluZXIpIHtcblx0XHRcdC8vQWRkIHRoZSBjdXJyZW50IGNhbGxiYWNrIHRvIHRoZSBjYWxsYmFjayBkaWN0aW9uYXJ5LlxuXHRcdFx0cHV0X2NhbGxiYWNrcyh3aW5kb3dfYWRkZWRfY2FsbGJhY2tzLCBjYWxsYmFjaywgY29udGFpbmVyKTtcblxuXHRcdFx0Ly9FeGVjdXRlIGFsbCB0aGUgY2FsbGJhY2tzIGZvciBhbHJlYWR5IGV4aXN0aW5nIHdpbmRvd3MuXG5cblx0XHRcdC8vR2V0IGFsbCBleGlzdGluZyBodG1sIGNvbnRhaW5lcnMuXG5cdFx0XHRhcGkuY29udGFpbmVyQWRkZWQoZnVuY3Rpb24gKHNlcnZlcikge1xuXHRcdFx0XHQvL0lmIHRoZSB1c2VyIGlzIHN1YnNjcmliZWQgdG8gdGhlIGNvbnRhaW5lclxuXHRcdFx0XHRpZiAoY29udGFpbmVyID09PSB1bmRlZmluZWQgfHwgY29udGFpbmVyID09PSBzZXJ2ZXIpIHtcblx0XHRcdFx0XHQvL2xpc3QgYWxsIHRoZSB3aW5kb3dzIGluIHRoZSBjb250YWluZXIuXG5cdFx0XHRcdFx0YXBpLmxpc3Qoc2VydmVyLFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24gKGxpc3Rfb2Zfd2luZG93cykge1xuXHRcdFx0XHRcdFx0XHQvL2V4ZWN1dGUgdGhlIGNhbGxiYWNrIGZvciBlYWNoIHdpbmRvdy5cblx0XHRcdFx0XHRcdFx0bGlzdF9vZl93aW5kb3dzLmZvckVhY2goZnVuY3Rpb24gKGV4aXN0aW5nX3dpbmRvdykge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGV4aXN0aW5nX3dpbmRvdyk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdC8vRXJyb3IgY2FsbGJhY2sgaWYgdGhlIHdpbmRvd3MgY2Fubm90IGJlIGxpc3RlZC5cblx0XHRcdFx0XHRcdGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdVbmFibGUgdG8gbG9hZCBleGlzdGluZyB3aW5kb3dzLiAnICsgZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHdpbmRvd1JlbW92ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGFpbmVyKSB7XG5cdFx0XHQvL0FkZCB0aGUgY3VycmVudCBjYWxsYmFjayB0byB0aGUgY2FsbGJhY2sgZGljdGlvbmFyeS5cblx0XHRcdHB1dF9jYWxsYmFja3Mod2luZG93X3JlbW92ZWRfY2FsbGJhY2tzLCBjYWxsYmFjaywgY29udGFpbmVyKTtcblx0XHR9LFxuXG5cdFx0Y29udGFpbmVyQWRkZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0YWdtLnNlcnZlckFkZGVkKGZ1bmN0aW9uIChzZXJ2ZXIpIHtcblx0XHRcdFx0aWYgKHNlcnZlci5hcHBsaWNhdGlvbi5pbmRleE9mKCdIdG1sQ29udGFpbmVyLicpICE9PSAtMSkge1xuXHRcdFx0XHRcdGludm9rZV9hZ21fc3VjY2Vzc19jYWxsYmFjayhjYWxsYmFjaywgc2VydmVyLmFwcGxpY2F0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGNvbnRhaW5lclJlbW92ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0YWdtLnNlcnZlclJlbW92ZWQoZnVuY3Rpb24gKHNlcnZlcikge1xuXHRcdFx0XHRpZiAoc2VydmVyLmFwcGxpY2F0aW9uLmluZGV4T2YoJ0h0bWxDb250YWluZXIuJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0aW52b2tlX2FnbV9zdWNjZXNzX2NhbGxiYWNrKGNhbGxiYWNrLCBzZXJ2ZXIuYXBwbGljYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0Ly8gZGVwcmVjYXRlc1xuXHRhcGkud2luZG93X2FkZGVkID0gZGVwcmVjYXRlKGFwaS53aW5kb3dBZGRlZCwgJ3dpbmRvdy53aW5kb3dfYWRkZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cud2luZG93QWRkZWQoKSBpbnN0ZWFkJyk7XG5cdGFwaS53aW5kb3dfcmVtb3ZlZCA9IGRlcHJlY2F0ZShhcGkud2luZG93UmVtb3ZlZCwgJ3dpbmRvdy53aW5kb3dfcmVtb3ZlZCgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIHdpbmRvdy53aW5kb3dSZW1vdmVkKCkgaW5zdGVhZCcpO1xuXHRhcGkuY29udGFpbmVyX2FkZGVkID0gZGVwcmVjYXRlKGFwaS5jb250YWluZXJBZGRlZCwgJ3dpbmRvdy5jb250YWluZXJfYWRkZWQoKSBpcyBkZXByZWNhdGVkIGFuZCBtaWdodCBiZSByZW1vdmVkIGZyb20gZnV0dXJlIHZlcnNpb25zIG9mIGdsdWUuIFVzZSB3aW5kb3cuY29udGFpbmVyQWRkZWQoKSBpbnN0ZWFkJyk7XG5cdGFwaS5jb250YWluZXJfcmVtb3ZlZCA9IGRlcHJlY2F0ZShhcGkuY29udGFpbmVyUmVtb3ZlZCwgJ3dpbmRvdy5jb250YWluZXJfcmVtb3ZlZCgpIGlzIGRlcHJlY2F0ZWQgYW5kIG1pZ2h0IGJlIHJlbW92ZWQgZnJvbSBmdXR1cmUgdmVyc2lvbnMgb2YgZ2x1ZS4gVXNlIHdpbmRvdy5jb250YWluZXJSZW1vdmVkKCkgaW5zdGVhZCcpO1xuXG5cblx0dmFyIFBhY2thZ2VKc29uID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKTtcblx0YXBpLnZlcnNpb24gPSBQYWNrYWdlSnNvbi52ZXJzaW9uO1xuXG5cdHJldHVybiBhcGk7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0d2luZG93LnRpY2s0MiA9IHdpbmRvdy50aWNrNDIgfHwge307XG5cdHdpbmRvdy50aWNrNDIud2luZG93cyA9IHdpbmRvd3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luZG93cztcblxuXG5mdW5jdGlvbiBhZGRfY2FsbGJhY2soa2V5LCBvbl9hZGQpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdHZhciBvYmogPSB0aGlzLmNhbGxiYWNrcztcblx0XHRpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0b2JqW2tleV0gPSBbY2FsbGJhY2tdO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG9ialtrZXldLnB1c2goY2FsbGJhY2spO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIG9uX2FkZCA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRvbl9hZGQodGhpcywgY2FsbGJhY2spO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gZXhlY19jYWxsYmFja3MoYXJyLCB2YWwpIHtcblx0aWYgKGFyciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0YXJyLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayh2YWwpO1xuXHRcdH0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHZhbHMob2JqKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBrZXkpIHtcblx0XHRhcnIucHVzaChvYmpba2V5XSk7XG5cdFx0cmV0dXJuIGFycjtcblx0fSwgW10pO1xufVxuXG5mdW5jdGlvbiBjb250YWluZXJfZnJvbV9maWx0ZXIoZmlsdGVyKSB7XG5cdHJldHVybiBmaWx0ZXIuYXBwbGljYXRpb24ubWF0Y2goL0h0bWxDb250YWluZXJcXC4oLio/KSQvKVsxXTtcbn1cblxuZnVuY3Rpb24gaW52b2tlX2FnbV9zdWNjZXNzX2NhbGxiYWNrKGNhbGxiYWNrLCBjYWxsYmFja19hcmd1bWVudCkge1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRjYWxsYmFjayhjYWxsYmFja19hcmd1bWVudCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gaW52b2tlX2FnbV9lcnJvcl9jYWxsYmFjayhjYWxsYmFjaywgZXJyb3IpIHtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0Y2FsbGJhY2soZXJyb3IubWVzc2FnZSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0X2NhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRhaW5lcl9uYW1lKSB7XG5cdGlmIChjYWxsYmFja3MuY29udGFpbmVyc19jYWxsYmFja3NbY29udGFpbmVyX25hbWVdICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FsbGJhY2tzLmFsbF9jb250YWluZXJzX2NhbGxiYWNrcy5jb25jYXQoY2FsbGJhY2tzLmNvbnRhaW5lcnNfY2FsbGJhY2tzW2NvbnRhaW5lcl9uYW1lXSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGNhbGxiYWNrcy5hbGxfY29udGFpbmVyc19jYWxsYmFja3M7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHV0X2NhbGxiYWNrcyhnbG9iYWxfY2FsbGJhY2tzLCBjYWxsYmFjaywgY29udGFpbmVyKSB7XG5cdGlmIChjb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdGdsb2JhbF9jYWxsYmFja3MuYWxsX2NvbnRhaW5lcnNfY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChnbG9iYWxfY2FsbGJhY2tzLmNvbnRhaW5lcnNfY2FsbGJhY2tzW2NvbnRhaW5lcl0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Z2xvYmFsX2NhbGxiYWNrcy5jb250YWluZXJzX2NhbGxiYWNrc1tjb250YWluZXJdID0gW2NhbGxiYWNrXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2xvYmFsX2NhbGxiYWNrcy5jb250YWluZXJzX2NhbGxiYWNrc1tjb250YWluZXJdLnB1c2goY2FsbGJhY2spO1xuXHRcdH1cblx0fVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcInRpY2s0Mi13aW5kb3dzQDIuMi4wXCIsXG4gICAgICBcIkM6XFxcXHdvcmtcXFxcc3Rhc2hcXFxcR0xVRS1kZXZcXFxcanMtZ2x1ZVwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwidGljazQyLXdpbmRvd3NAMi4yLjBcIixcbiAgXCJfaWRcIjogXCJ0aWNrNDItd2luZG93c0AyLjIuMFwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2luc3RhbGxhYmxlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL3RpY2s0Mi13aW5kb3dzXCIsXG4gIFwiX25vZGVWZXJzaW9uXCI6IFwiNS4zLjBcIixcbiAgXCJfbnBtVXNlclwiOiB7fSxcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjMuMy4xMlwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwidGljazQyLXdpbmRvd3NcIixcbiAgICBcInJhd1wiOiBcInRpY2s0Mi13aW5kb3dzQDIuMi4wXCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiMi4yLjBcIixcbiAgICBcInNjb3BlXCI6IG51bGwsXG4gICAgXCJzcGVjXCI6IFwiMi4yLjBcIixcbiAgICBcInR5cGVcIjogXCJ2ZXJzaW9uXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwOi8vMTkyLjE2OC4wLjIzNDo0ODczL3RpY2s0Mi13aW5kb3dzLy0vdGljazQyLXdpbmRvd3MtMi4yLjAudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcIjQ4ZmE4ZDQ2OGU1N2RlMjE0NTZkZWIxMzNmZmNmZGI1Nzg3Yzc4NTFcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwidGljazQyLXdpbmRvd3NAMi4yLjBcIixcbiAgXCJfd2hlcmVcIjogXCJDOlxcXFx3b3JrXFxcXHN0YXNoXFxcXEdMVUUtZGV2XFxcXGpzLWdsdWVcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIlRpY2s0MlwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcInV0aWwtZGVwcmVjYXRlXCI6IFwiXjEuMC4yXCJcbiAgfSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgd2luZG93aW5nIEFQSSBmb3IgdGhlIFRpY2s0MiBIVE1MIENvbnRhaW5lclwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJibGFua2V0XCI6IFwiXjEuMS42XCIsXG4gICAgXCJicm93c2VyaWZ5LXZlcnNpb25pZnlcIjogXCJeMS4wLjRcIixcbiAgICBcImdydW50XCI6IFwiXjAuNC41XCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwiXjMuMy4wXCIsXG4gICAgXCJncnVudC1jbGlcIjogXCJeMC4xLjEzXCIsXG4gICAgXCJncnVudC1jb250cmliLWNsZWFuXCI6IFwiXjAuNi4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWNvbm5lY3RcIjogXCJeMC45LjBcIixcbiAgICBcImdydW50LWNvbnRyaWItanNoaW50XCI6IFwiXjAuMTEuMlwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1xdW5pdFwiOiBcIl4wLjUuMlwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeMC42LjBcIixcbiAgICBcImdydW50LWNvbnRyaWItd2F0Y2hcIjogXCJeMC42LjFcIixcbiAgICBcImdydW50LWV4b3JjaXNlXCI6IFwiXjEuMC4xXCIsXG4gICAgXCJwaGFudG9tanNcIjogXCJeMS45LjEyXCIsXG4gICAgXCJxdW5pdGpzXCI6IFwiXjEuMTUuMFwiLFxuICAgIFwidWdsaWZ5aWZ5XCI6IFwiXjMuMC4xXCJcbiAgfSxcbiAgXCJkaXJlY3Rvcmllc1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwidGVzdHNcIlxuICB9LFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiNDhmYThkNDY4ZTU3ZGUyMTQ1NmRlYjEzM2ZmY2ZkYjU3ODdjNzg1MVwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHA6Ly8xOTIuMTY4LjAuMjM0OjQ4NzMvdGljazQyLXdpbmRvd3MvLS90aWNrNDItd2luZG93cy0yLjIuMC50Z3pcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCJiNTIyYjMzOGVhNGI3M2U3M2Q0NjZiZTFiMmRlNTRkZDRlMTI1ZWFiXCIsXG4gIFwibGljZW5zZVwiOiBcIklTQ1wiLFxuICBcIm1haW5cIjogXCJsaWJyYXJ5L3dpbmRvd3MuanNcIixcbiAgXCJuYW1lXCI6IFwidGljazQyLXdpbmRvd3NcIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2JtYXJpbm92QHN0YXNoLnRpY2s0Mi5jb206ODQ0My9zY20vb2Zndy9qcy13aW5kb3dzLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJwcmVwdWJsaXNoXCI6IFwibnBtIHVwZGF0ZSAmIGdydW50XCIsXG4gICAgXCJ0ZXN0XCI6IFwiZWNobyBcXFwiRXJyb3I6IG5vIHRlc3Qgc3BlY2lmaWVkXFxcIiAmJiBleGl0IDFcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIyLjIuMFwiXG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcblxuLyoqXG4gKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldCA/IHdzIDogbnVsbDtcblxuLyoqXG4gKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogVGhlIHRoaXJkIGBvcHRzYCBvcHRpb25zIG9iamVjdCBnZXRzIGlnbm9yZWQgaW4gd2ViIGJyb3dzZXJzLCBzaW5jZSBpdCdzXG4gKiBub24tc3RhbmRhcmQsIGFuZCB0aHJvd3MgYSBUeXBlRXJyb3IgaWYgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2VpbmFyb3Mvd3MvaXNzdWVzLzIyN1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3RvY29scyAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge09iamVjdCkgb3B0cyAob3B0aW9uYWwpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHdzKHVyaSwgcHJvdG9jb2xzLCBvcHRzKSB7XG4gIHZhciBpbnN0YW5jZTtcbiAgaWYgKHByb3RvY29scykge1xuICAgIGluc3RhbmNlID0gbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scyk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgV2ViU29ja2V0KHVyaSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5pZiAoV2ViU29ja2V0KSB3cy5wcm90b3R5cGUgPSBXZWJTb2NrZXQucHJvdG90eXBlO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJ0aWNrNDItZ2x1ZVwiLFxuICBcInZlcnNpb25cIjogXCIyLjkuMVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBKYXZhU2NyaXB0IGxpYnJhcnkgd2hpY2ggcHJvdmlkZXMgc3VwcG9ydCBmb3IgVGljazQyIEdMVUUuXCIsXG4gIFwibWFpblwiOiBcImxpYnJhcnkvZ2x1ZS5qc1wiLFxuICBcImJpblwiOiB7XG4gICAgXCJpbml0LWRldi1tb2RlXCI6IFwiYmluL2luaXQtZGV2LW1vZGUuanNcIixcbiAgICBcInJlbW92ZS1pbnN0YWxsZWQtZGVwZW5kZW5jaWVzXCI6IFwiYmluL3JlbW92ZS1pbnN0YWxsZWQtZGVwZW5kZW5jaWVzLmpzXCIsXG4gICAgXCJyZW1vdmUtZGV2ZWxvcG1lbnQtZGVwZW5kZW5jaWVzXCI6IFwiYmluL3JlbW92ZS1kZXZlbG9wbWVudC1kZXBlbmRlbmNpZXMuanNcIixcbiAgICBcImJ1aWxkXCI6IFwiLi9iaW4vYnVpbGQuanNcIixcbiAgICBcImNsZWFuXCI6IFwiLi9iaW4vY2xlYW4uanNcIixcbiAgICBcImZpbGUtdmVyc2lvbmlmeVwiOiBcImJpbi9maWxlLXZlcnNpb25pZnkuanNcIixcbiAgICBcIm1pbmlmeVwiOiBcIi4vYmluL21pbmlmeS5qc1wiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJsaW50XCI6IFwianNoaW50IGxpYnJhcnlcIixcbiAgICBcInRlc3RcIjogXCJucG0gcnVuIGxpbnQgJiBtb2NoYSAtLXJlcXVpcmUgLi90ZXN0L3Rlc3RfaGVscGVyIFxcXCJ0ZXN0LyoqLyouanNcXFwiXCIsXG4gICAgXCJidWlsZFwiOiBcIm5vZGUgYmluL2NsZWFuLmpzICYgbm9kZSBiaW4vYnVpbGQuanMgJiBub2RlIGJpbi9taW5pZnkgJiBub2RlIGJpbi9maWxlLXZlcnNpb25pZnlcIixcbiAgICBcImJ1aWxkOmRldlwiOiBcIm5vZGUgYmluL2NsZWFuICYgbm9kZSBiaW4vYnVpbGRcIixcbiAgICBcInByZXB1Ymxpc2hcIjogXCJucG0gdXBkYXRlICYgbnBtIHJ1biBidWlsZFwiLFxuICAgIFwiaW5pdDpkZXZlbG9wXCI6IFwibm9kZSBiaW4vaW5pdC1kZXYtbW9kZVwiLFxuICAgIFwiY2xlYXI6ZGV2ZWxvcFwiOiBcIm5vZGUgYmluL3JlbW92ZS1kZXZlbG9wbWVudC1kZXBlbmRlbmNpZXNcIixcbiAgICBcIndhdGNoXCI6IFwib25jaGFuZ2UgXFxcIi4vbGlicmFyeS8qLmpzXFxcIiBcXFwiLi9ub2RlX21vZHVsZXMvdGljazQyLSovbGlicmFyeS8qLmpzXFxcIiAgXFxcIi4vbm9kZV9tb2R1bGVzL3RpY2s0Mi0qL2xpYnJhcnlfanMvKi5qc1xcXCIgXFxcIi4uL25vZGVfbW9kdWxlcy90aWNrNDItKi9saWJyYXJ5LyouanNcXFwiICBcXFwiLi4vbm9kZV9tb2R1bGVzL3RpY2s0Mi0qL2xpYnJhcnlfanMvKi5qc1xcXCIgLWl2IC1lIFxcXCIuL2JpblxcXCIgLS0gbnBtIHJ1biBidWlsZDpkZXZcIixcbiAgICBcIndhdGNoOmRldmVsb3BcIjogXCJub2RlIGJpbi9yZW1vdmUtaW5zdGFsbGVkLWRlcGVuZGVuY2llcyAmIG5wbSBydW4gd2F0Y2hcIixcbiAgICBcIndhdGNoOnByb2RcIjogXCJucG0gaW5zdGFsbCAmIG5wbSBydW4gd2F0Y2hcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9ibWFyaW5vdkBzdGFzaC50aWNrNDIuY29tOjg0NDMvc2NtL29mZ3cvanMtZ2x1ZS5naXRcIlxuICB9LFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiVGljazQyXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwOi8vd3d3LnRpY2s0Mi5jb21cIlxuICB9LFxuICBcImxpY2Vuc2VcIjogXCJJU0NcIixcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiY3VpZFwiOiBcIl4xLjMuOFwiLFxuICAgIFwiZGV0ZWN0LW5vZGVcIjogXCJeMi4wLjNcIixcbiAgICBcImVzNS1zaGltXCI6IFwiXjQuMS4xNFwiLFxuICAgIFwidGljazQyLWFjdGl2aXR5XCI6IFwiXjIuMC4wXCIsXG4gICAgXCJ0aWNrNDItYWdtXCI6IFwiXjIuMS42XCIsXG4gICAgXCJ0aWNrNDItYXBwLW1hbmFnZXJcIjogXCJeMi4wLjBcIixcbiAgICBcInRpY2s0Mi1hcHBjb25maWdcIjogXCJeMC4wLjBcIixcbiAgICBcInRpY2s0Mi1nYXRld2F5LWNvbm5lY3Rpb25cIjogXCJeMS4xLjZcIixcbiAgICBcInRpY2s0Mi1sb2dnZXJcIjogXCJeMi4wLjNcIixcbiAgICBcInRpY2s0Mi1tZXRyaWNzXCI6IFwiXjIuMC4xM1wiLFxuICAgIFwidGljazQyLXdpbmRvd3NcIjogXCJeMi4wLjJcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjEzLjAuMFwiLFxuICAgIFwiYnJvd3NlcmlmeS1yZXBsYWNpZnlcIjogXCJeMC4wLjRcIixcbiAgICBcImJyb3dzZXJpZnktdmVyc2lvbmlmeVwiOiBcIl4xLjAuNFwiLFxuICAgIFwiY2hhaVwiOiBcIl4zLjUuMFwiLFxuICAgIFwiZnNcIjogXCIwLjAuMlwiLFxuICAgIFwianNkb21cIjogXCJeOC4xLjBcIixcbiAgICBcImpzaGludFwiOiBcIl4yLjkuMVwiLFxuICAgIFwibWluaWZ5aWZ5XCI6IFwiXjcuMy4yXCIsXG4gICAgXCJtb2NoYVwiOiBcIl4yLjQuNVwiLFxuICAgIFwib25jaGFuZ2VcIjogXCJeMi4xLjJcIixcbiAgICBcInNoZWxsanNcIjogXCJeMC42LjBcIlxuICB9XG59XG4iXX0=
